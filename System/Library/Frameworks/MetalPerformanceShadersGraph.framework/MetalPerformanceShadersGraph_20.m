uint64_t mlir::mps::ExponentOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FastFourierTransformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Flatten2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FloorDivideOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::FloorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GRUGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GRUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GatherOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GeluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GetCoordOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GreaterThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::GreaterThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::HammingDistanceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IdentityOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ImToColOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ImaginaryPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::InitRandomPhiloxStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::InstanceNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsFiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsInfiniteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::IsNaNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LPNormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LSTMGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LSTMOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LeakyReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LessThanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LessThanOrEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LocalConvolutionWeightGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmBase10Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmBase2Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::LogarithmOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatMulOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixDecompositionLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixInverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MatrixSolverLUOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MaximumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MinimumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ModuloOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::MultiplyOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NandOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NegativeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NonMaximumSuppressionOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NonZeroOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NormalizationOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NotEqualToOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::NotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::OneHotOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::OrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PadGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PadOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PermuteOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PlaceholderOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolAvgGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolAvgOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolL2NormGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolL2NormOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolMaxGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PoolMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PowerOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PruningGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::PruningOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::QuantizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomTruncatedNormalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RandomUniformOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RankOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReadVariableOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RealPartOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RealToHermiteanFFTOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReciprocalOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReciprocalSquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionAndOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionArgMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionArgMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionLogSumExpOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMeanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionMinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionOrOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionProdOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionSumOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReductionVarianceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReinterpretCastOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::Relu6Op::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReluGradOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReluOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReshapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ResizeGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ResizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ReverseOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::RoundOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SampleGridDataGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SampleGridOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterAlongAxisOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterNDOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ScatterOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SelectOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::ShapeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidGradientWithSigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidHardOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SigmoidOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SignbitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SinOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SingleGateRNNGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SingleGateRNNOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SinhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SizeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftmaxOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftplusOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftplusParametricOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SoftsignOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SortOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SpaceToBatchOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SpaceToDepth2DOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SplitOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SquareOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SquareRootOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SqueezeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StencilOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::StridedSliceUpdateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SubtractOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::SwishOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TanOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TanhOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TileGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TileOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TopKGradientOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TopKOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TransposeOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TruncateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::TypeConstraintOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::UnrealizedFoldOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::UpdateRandomStateOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::VariableFromTensorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::XnorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::XorOp::canonicalize(uint64_t a1, uint64_t a2)
{
  uint64_t v5;
  uint64_t InterfaceFor;

  if (mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    if (a1)
    {
      v5 = a1;
      InterfaceFor = mlir::OpInterface<mlir::ExternalCanonicalizeInterface,mlir::detail::ExternalCanonicalizeInterfaceInterfaceTraits>::getInterfaceFor(a1);
      return mlir::anec::VerifyAttributesWithFamilyInterface::verifyAttributesWithFamily((uint64_t)&v5, a2);
    }
    v5 = 0;
    InterfaceFor = 0;
  }
  else
  {
    v5 = 0;
    InterfaceFor = 0;
  }
  return 0;
}

uint64_t mlir::mps::symbolizeMetalPixelFormat(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v6;

  switch(a2)
  {
    case 7:
      if (*(_DWORD *)a1 != 1851078738 || *(_DWORD *)(a1 + 3) != 1836216174)
        goto LABEL_40;
      result = 0x100000000;
      break;
    case 8:
      switch(*(_QWORD *)a1)
      {
        case 0x6D726F6E55384752:
          result = 0x100000001;
          break;
        case 0x74616F6C46363152:
          result = 0x100000004;
          break;
        case 0x74616F6C46323352:
          result = 0x100000007;
          break;
        default:
          goto LABEL_40;
      }
      break;
    case 9:
      if (*(_QWORD *)a1 == 0x616F6C4636314752 && *(_BYTE *)(a1 + 8) == 116)
      {
        result = 0x100000005;
      }
      else
      {
        if (*(_QWORD *)a1 != 0x616F6C4632334752 || *(_BYTE *)(a1 + 8) != 116)
          goto LABEL_40;
        result = 0x100000008;
      }
      break;
    case 10:
      v6 = 0x100000002;
      if (*(_QWORD *)a1 == 0x6F6E553841424752 && *(_WORD *)(a1 + 8) == 28018)
        goto LABEL_41;
      if (*(_QWORD *)a1 != 0x6F6E553841524742 || *(_WORD *)(a1 + 8) != 28018)
        goto LABEL_40;
      result = 0x100000003;
      break;
    case 11:
      if (*(_QWORD *)a1 == 0x6C46363141424752 && *(_QWORD *)(a1 + 3) == 0x74616F6C46363141)
      {
        result = 0x100000006;
      }
      else
      {
        if (*(_QWORD *)a1 != 0x6C46323341424752 || *(_QWORD *)(a1 + 3) != 0x74616F6C46323341)
          goto LABEL_40;
        result = 0x100000009;
      }
      break;
    default:
LABEL_40:
      v6 = 0;
LABEL_41:
      result = v6;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizeNearestRoundingMode(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  switch(a2)
  {
    case 4:
      if (*(_DWORD *)a1 != 1818846563)
        goto LABEL_38;
      result = 0x100000002;
      break;
    case 5:
      if (*(_DWORD *)a1 != 1869573222 || *(_BYTE *)(a1 + 4) != 114)
        goto LABEL_38;
      result = 0x100000003;
      break;
    case 12:
      if (*(_QWORD *)a1 != 0x6F745F646E756F72 || *(_DWORD *)(a1 + 8) != 1684303711)
        goto LABEL_38;
      result = 0x100000005;
      break;
    case 13:
      if (*(_QWORD *)a1 != 0x6F745F646E756F72 || *(_QWORD *)(a1 + 5) != 0x6E6576655F6F745FLL)
        goto LABEL_38;
      result = 0x100000004;
      break;
    case 17:
      if (*(_QWORD *)a1 != 0x72705F646E756F72
        || *(_QWORD *)(a1 + 8) != 0x6965635F72656665
        || *(_BYTE *)(a1 + 16) != 108)
      {
        goto LABEL_38;
      }
      result = 0x100000000;
      break;
    case 18:
      if (*(_QWORD *)a1 != 0x72705F646E756F72
        || *(_QWORD *)(a1 + 8) != 0x6F6C665F72656665
        || *(_WORD *)(a1 + 16) != 29295)
      {
        goto LABEL_38;
      }
      result = 0x100000001;
      break;
    default:
LABEL_38:
      result = 0;
      break;
  }
  return result;
}

uint64_t mlir::mps::symbolizePaddingStyle(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1398752852 && *(_DWORD *)(a1 + 3) == 1162690899)
      return 0x100000002;
    return 0;
  }
  if (a2 == 15)
  {
    if (*(_QWORD *)a1 == 0x544943494C505845 && *(_QWORD *)(a1 + 7) == 0x54455346464F5F54)
      return 0x100000003;
    if (*(_QWORD *)a1 == 0x4D41535F584E4E4FLL && *(_QWORD *)(a1 + 7) == 0x5245574F4C5F454DLL)
      return 0x100000004;
    return 0;
  }
  if (a2 != 8)
    return 0;
  if (*(_QWORD *)a1 != 0x544943494C505845)
  {
    if (*(_QWORD *)a1 == 0x44494C41565F4654)
      return 0x100000001;
    return 0;
  }
  return 0x100000000;
}

uint64_t mlir::mps::symbolizePoolIndicesMode(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;

  if (a2 == 15)
  {
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44316E657474616CLL)
      return 0x100000004;
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44326E657474616CLL)
      return 0x100000005;
    if (*a1 == 0x6C465F6C61636F4CLL && *(_QWORD *)((char *)a1 + 7) == 0x44336E657474616CLL)
      return 0x100000006;
    v4 = 0x100000007;
    if (*a1 ^ 0x6C465F6C61636F4CLL | *(_QWORD *)((char *)a1 + 7) ^ 0x44346E657474616CLL)
      return 0;
    return v4;
  }
  if (a2 != 16)
    return 0;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44316E657474616CLL)
    return 0x100000000;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44326E657474616CLL)
    return 0x100000001;
  v4 = 0x100000002;
  if (*a1 == 0x465F6C61626F6C47 && a1[1] == 0x44336E657474616CLL)
    return v4;
  if (*a1 != 0x465F6C61626F6C47 || a1[1] != 0x44346E657474616CLL)
    return 0;
  return 0x100000003;
}

uint64_t mlir::mps::symbolizeRNNActivation(int *a1, uint64_t a2)
{
  uint64_t result;
  int v4;
  int v5;
  uint64_t v7;
  int v8;

  result = 0;
  switch(a2)
  {
    case 4:
      switch(*a1)
      {
        case 1701736302:
          result = 0x100000000;
          break;
        case 1970038130:
          result = 0x100000001;
          break;
        case 1752064372:
          result = 0x100000002;
          break;
        default:
          goto LABEL_19;
      }
      break;
    case 7:
      v4 = *a1;
      v5 = *(int *)((char *)a1 + 3);
      if (v4 != 1835493747 || v5 != 1684631405)
        goto LABEL_19;
      result = 0x100000003;
      break;
    case 11:
      if (*(_QWORD *)a1 ^ 0x745F64656C616373 | *(_QWORD *)((char *)a1 + 3) ^ 0x686E61745F64656CLL)
        result = 0;
      else
        result = 0x100000005;
      break;
    case 12:
      v7 = *(_QWORD *)a1;
      v8 = a1[2];
      if (v7 == 0x6769735F64726168 && v8 == 1684631405)
        result = 0x100000004;
      else
LABEL_19:
        result = 0;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::symbolizeReductionMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 7)
  {
    if (*(_DWORD *)a1 == 1685025392 && *(_DWORD *)(a1 + 3) == 1952675172)
      return 0x100000003;
    if (*(_DWORD *)a1 == 1298625121 && *(_DWORD *)(a1 + 3) == 544106829)
      return 0x100000004;
    return 0;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 ^ 0x4D677261 | *(unsigned __int16 *)(a1 + 4) ^ 0x7861)
      return 0;
    else
      return 0x100000005;
  }
  if (a2 != 3)
    return 0;
  if (*(_WORD *)a1 == 26989 && *(_BYTE *)(a1 + 2) == 110)
    return 0x100000000;
  if (*(_WORD *)a1 != 24941 || *(_BYTE *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 30067 && *(_BYTE *)(a1 + 2) == 109)
      return 0x100000002;
    return 0;
  }
  return 0x100000001;
}

uint64_t mlir::mps::symbolizeScatterMode(uint64_t a1, uint64_t a2)
{
  if (a2 == 8)
  {
    if (*(_QWORD *)a1 != 0x7463617274627573)
    {
      if (*(_QWORD *)a1 == 0x796C7069746C756DLL)
        return 0x100000002;
      return 0;
    }
    return 0x100000001;
  }
  if (a2 == 6)
  {
    if (*(_DWORD *)a1 == 1769367908 && *(_WORD *)(a1 + 4) == 25956)
      return 0x100000003;
    return 0;
  }
  if (a2 != 3)
    return 0;
  if (*(_WORD *)a1 == 25697 && *(_BYTE *)(a1 + 2) == 100)
    return 0x100000000;
  if (*(_WORD *)a1 == 26989 && *(_BYTE *)(a1 + 2) == 110)
    return 0x100000004;
  if (*(_WORD *)a1 != 24941 || *(_BYTE *)(a1 + 2) != 120)
  {
    if (*(_WORD *)a1 == 25971 && *(_BYTE *)(a1 + 2) == 116)
      return 0x100000006;
    return 0;
  }
  return 0x100000005;
}

uint64_t mlir::mps::symbolizeStencilPaddingMode(int *a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  BOOL v5;
  int v6;
  int v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;

  result = 0;
  switch(a2)
  {
    case 4:
      v4 = 0x100000004;
      v5 = *a1 == 1869768058;
      goto LABEL_18;
    case 6:
      v6 = *a1;
      v7 = *((unsigned __int16 *)a1 + 2);
      if (v6 != 1920100717 || v7 != 29295)
        return 0;
      return 0x100000001;
    case 8:
      if (*(_QWORD *)a1 == 0x746E6174736E6F63)
      {
        result = 0x100000000;
      }
      else if (*(_QWORD *)a1 == 0x6369646F69726570)
      {
        result = 0x100000005;
      }
      else
      {
LABEL_25:
        result = 0;
      }
      break;
    case 11:
      v9 = *(_QWORD *)a1;
      v10 = *(_QWORD *)((char *)a1 + 3);
      if (v9 == 0x456F54706D616C63 && v10 == 0x656764456F54706DLL)
        return 0x100000003;
      else
        return 0;
    case 12:
      v4 = 0x100000006;
      v5 = (*(_QWORD *)a1 ^ 0x6972655069746E61 | a1[2] ^ 0x6369646FLL) == 0;
LABEL_18:
      if (v5)
        return v4;
      else
        return 0;
    case 14:
      v12 = *(_QWORD *)a1;
      v13 = *(_QWORD *)((char *)a1 + 6);
      if (v12 != 0x6957726F7272696DLL || v13 != 0x6567644568746957)
        goto LABEL_25;
      result = 0x100000002;
      break;
    default:
      return result;
  }
  return result;
}

const char *mlir::mps::stringifyTensorDataLayout(unsigned int a1)
{
  if (a1 > 0xA)
    return "";
  else
    return off_1E0E55838[a1];
}

uint64_t mlir::mps::symbolizeTensorDataLayout(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;

  switch(a2)
  {
    case 2:
      if (*(_WORD *)a1 != 22344)
        goto LABEL_18;
      result = 0x100000006;
      break;
    case 3:
      if (*(_WORD *)a1 == 18499 && *(_BYTE *)(a1 + 2) == 87)
      {
        result = 0x100000004;
      }
      else
      {
        if (*(_WORD *)a1 != 22344 || *(_BYTE *)(a1 + 2) != 67)
          goto LABEL_18;
        result = 0x100000005;
      }
      break;
    case 4:
      if (*(_DWORD *)a1 == 1464353614)
      {
        result = 0x100000000;
      }
      else if (*(_DWORD *)a1 == 1129793614)
      {
        result = 0x100000001;
      }
      else
      {
        v5 = 0x100000002;
        if (*(_DWORD *)a1 == 1464355151)
          goto LABEL_33;
        if (*(_DWORD *)a1 != 1330206536)
          goto LABEL_18;
        result = 0x100000003;
      }
      break;
    case 5:
      if (*(_DWORD *)a1 == 1212433230 && *(_BYTE *)(a1 + 4) == 87)
      {
        result = 0x100000007;
      }
      else if (*(_DWORD *)a1 == 1464353870 && *(_BYTE *)(a1 + 4) == 67)
      {
        result = 0x100000008;
      }
      else if (*(_DWORD *)a1 == 1212434767 && *(_BYTE *)(a1 + 4) == 87)
      {
        result = 0x100000009;
      }
      else
      {
        v5 = 0x10000000ALL;
        if (*(_DWORD *)a1 ^ 0x49574844 | *(unsigned __int8 *)(a1 + 4) ^ 0x4F)
          v5 = 0;
LABEL_33:
        result = v5;
      }
      break;
    default:
LABEL_18:
      result = 0;
      break;
  }
  return result;
}

mlir::mps::MPSDialect *mlir::mps::MPSDialect::MPSDialect(mlir::mps::MPSDialect *this, mlir::MLIRContext *a2)
{
  mlir::mps::MPSDialect *v3;

  v3 = (mlir::mps::MPSDialect *)mlir::Dialect::Dialect((uint64_t)this, (uint64_t)"mps", 3, (uint64_t)a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id);
  *(_QWORD *)v3 = off_1E0E48050;
  mlir::mps::MPSDialect::initialize(v3);
  return this;
}

void mlir::mps::MPSDialect::~MPSDialect(llvm **this)
{
  mlir::Dialect::~Dialect(this);
}

void sub_180935438(void *__p)
{
  operator delete(__p);
}

uint64_t mlir::mps::TensorDataLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::TensorDataLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  uint64_t v97;
  int *v98;
  int *v99;
  int *v100;
  __int128 v101;
  uint64_t v102;
  int *v103;
  int *v104;
  int *v105;
  __int128 v106;
  uint64_t v107;
  int *v108;
  int *v109;
  int *v110;
  __int128 v111;
  uint64_t v112;
  int *v113;
  int *v114;
  int *v115;
  __int128 v116;
  uint64_t v117;
  int *v118;
  int *v119;
  int *v120;
  __int128 v121;
  uint64_t v122;
  int *v123;
  int *v124;
  int *v125;
  __int128 v126;
  _QWORD **v127;
  _QWORD **v128;
  void *v129;
  _QWORD *v130;
  _QWORD *v131;
  void *v132;
  void *v133;
  void *v134;
  uint64_t v135;
  _QWORD **v136;
  _QWORD **v137;
  void *v138;
  _QWORD *v139;
  _QWORD *v140;
  void *v141;
  void *v142;
  void *v143;
  unint64_t v144;
  unint64_t v145;
  BOOL v146;
  unint64_t v147;
  BOOL v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  BOOL v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  BOOL v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  BOOL v164;
  unint64_t v165;
  BOOL v166;
  unint64_t v167;
  BOOL v168;
  unint64_t v169;
  BOOL v170;
  unint64_t v171;
  BOOL v172;
  unint64_t v173;
  BOOL v174;
  unint64_t v175;
  BOOL v176;
  int64_t v177;
  unint64_t v178;
  BOOL v179;
  int64_t v180;
  unint64_t v181;
  BOOL v182;
  int64_t v183;
  unint64_t v184;
  BOOL v185;
  int64_t v186;
  unint64_t v187;
  BOOL v188;
  int64_t v189;
  unint64_t v190;
  BOOL v191;
  int64_t v192;
  unint64_t v193;
  BOOL v194;
  int64_t v195;
  unint64_t v196;
  BOOL v197;
  int64_t v198;
  int64_t v199;
  int64_t v200;
  int64_t v201;
  int64_t v202;
  int64_t v203;
  int64_t v204;
  int64_t v205;
  int64_t v206;
  int64_t v207;
  int64_t v208;
  int64_t v209;
  int64_t v210;
  int64_t v211;
  int64_t v212;
  int64_t v213;
  int64_t v214;
  unsigned int v215[8];
  __int16 v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  const char *v220;
  uint64_t v221;
  _QWORD v222[3];
  void *v223;
  uint64_t v224;
  void *v225;
  _QWORD *v226;
  void *__p;
  _QWORD **v228;
  char v229;
  _QWORD v230[3];
  int *v231;
  unsigned int v232;
  unsigned int v233;
  _BYTE v234[96];
  _QWORD *v235;
  _QWORD *v236;
  _QWORD **v237;
  _QWORD **v238;
  char v239;
  uint64_t v240;

  v240 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v217 = 0;
  v218 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v217))
  {
LABEL_73:
    v135 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v232) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v222, a1, v135, v230);
    if (v222[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v222);
    if (v229)
    {
      v136 = (_QWORD **)__p;
      if (__p)
      {
        v137 = v228;
        v138 = __p;
        if (v228 != __p)
        {
          do
            v137 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v137 - 1);
          while (v137 != v136);
          v138 = __p;
        }
        v228 = v136;
        operator delete(v138);
      }
      v139 = v225;
      if (v225)
      {
        v140 = v226;
        v141 = v225;
        if (v226 != v225)
        {
          do
          {
            v143 = (void *)*--v140;
            v142 = v143;
            *v140 = 0;
            if (v143)
              operator delete[](v142);
          }
          while (v140 != v139);
          v141 = v225;
        }
        v226 = v139;
        operator delete(v141);
      }
      if (v223 != &v224)
        free(v223);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeTensorDataLayout(v217, v218);
  if ((v3 & 0xFF00000000) == 0)
  {
    v216 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v230, a1, v2, v215);
    if (v230[0])
    {
      v219 = 3;
      v220 = "expected ";
      v221 = 9;
      v8 = &v219;
      v9 = v231;
      if (v232 >= v233)
      {
        v144 = v232 + 1;
        if (v231 <= &v219 && &v231[6 * v232] > &v219)
        {
          v177 = (char *)&v219 - (char *)v231;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          v9 = v231;
          v8 = (int *)((char *)v231 + v177);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v144, 24);
          v8 = &v219;
          v9 = v231;
        }
      }
      v10 = &v9[6 * v232];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v232;
      if (v230[0])
      {
        v219 = 3;
        v220 = "::mlir::mps::TensorDataLayout";
        v221 = 29;
        v13 = &v219;
        v14 = v231;
        if (v12 >= v233)
        {
          v145 = v12 + 1;
          v146 = &v231[6 * v12] > &v219;
          if (v231 <= &v219 && v146)
          {
            v180 = (char *)&v219 - (char *)v231;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            v14 = v231;
            v13 = (int *)((char *)v231 + v180);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v145, 24);
            v13 = &v219;
            v14 = v231;
          }
        }
        v15 = &v14[6 * v232];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v232;
        if (v230[0])
        {
          v219 = 3;
          v220 = " to be one of: ";
          v221 = 15;
          v18 = &v219;
          v19 = v231;
          if (v17 >= v233)
          {
            v147 = v17 + 1;
            v148 = &v231[6 * v17] > &v219;
            if (v231 <= &v219 && v148)
            {
              v183 = (char *)&v219 - (char *)v231;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              v19 = v231;
              v18 = (int *)((char *)v231 + v183);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v147, 24);
              v18 = &v219;
              v19 = v231;
            }
          }
          v20 = &v19[6 * v232];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v232;
          if (v230[0])
          {
            v219 = 3;
            v220 = "NCHW";
            v221 = 4;
            v23 = &v219;
            v24 = v231;
            if (v22 >= v233)
            {
              v149 = v22 + 1;
              v150 = &v231[6 * v22] > &v219;
              if (v231 <= &v219 && v150)
              {
                v186 = (char *)&v219 - (char *)v231;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                v24 = v231;
                v23 = (int *)((char *)v231 + v186);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v149, 24);
                v23 = &v219;
                v24 = v231;
              }
            }
            v25 = &v24[6 * v232];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v232;
            if (v230[0])
            {
              v219 = 3;
              v220 = ", ";
              v221 = 2;
              v28 = &v219;
              v29 = v231;
              if (v27 >= v233)
              {
                v151 = v27 + 1;
                v152 = &v231[6 * v27] > &v219;
                if (v231 <= &v219 && v152)
                {
                  v189 = (char *)&v219 - (char *)v231;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  v29 = v231;
                  v28 = (int *)((char *)v231 + v189);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v151, 24);
                  v28 = &v219;
                  v29 = v231;
                }
              }
              v30 = &v29[6 * v232];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v232;
              if (v230[0])
              {
                v219 = 3;
                v220 = "NHWC";
                v221 = 4;
                v33 = &v219;
                v34 = v231;
                if (v32 >= v233)
                {
                  v153 = v32 + 1;
                  v154 = &v231[6 * v32] > &v219;
                  if (v231 <= &v219 && v154)
                  {
                    v192 = (char *)&v219 - (char *)v231;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    v34 = v231;
                    v33 = (int *)((char *)v231 + v192);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v153, 24);
                    v33 = &v219;
                    v34 = v231;
                  }
                }
                v35 = &v34[6 * v232];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v232;
                if (v230[0])
                {
                  v219 = 3;
                  v220 = ", ";
                  v221 = 2;
                  v38 = &v219;
                  v39 = v231;
                  if (v37 >= v233)
                  {
                    v155 = v37 + 1;
                    v156 = &v231[6 * v37] > &v219;
                    if (v231 <= &v219 && v156)
                    {
                      v195 = (char *)&v219 - (char *)v231;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      v39 = v231;
                      v38 = (int *)((char *)v231 + v195);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v155, 24);
                      v38 = &v219;
                      v39 = v231;
                    }
                  }
                  v40 = &v39[6 * v232];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v232;
                  if (v230[0])
                  {
                    v219 = 3;
                    v220 = "OIHW";
                    v221 = 4;
                    v43 = &v219;
                    v44 = v231;
                    if (v42 >= v233)
                    {
                      v157 = v42 + 1;
                      v158 = &v231[6 * v42] > &v219;
                      if (v231 <= &v219 && v158)
                      {
                        v198 = (char *)&v219 - (char *)v231;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        v44 = v231;
                        v43 = (int *)((char *)v231 + v198);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v157, 24);
                        v43 = &v219;
                        v44 = v231;
                      }
                    }
                    v45 = &v44[6 * v232];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v232;
                    if (v230[0])
                    {
                      v219 = 3;
                      v220 = ", ";
                      v221 = 2;
                      v48 = &v219;
                      v49 = v231;
                      if (v47 >= v233)
                      {
                        v159 = v47 + 1;
                        v160 = &v231[6 * v47] > &v219;
                        if (v231 <= &v219 && v160)
                        {
                          v199 = (char *)&v219 - (char *)v231;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          v49 = v231;
                          v48 = (int *)((char *)v231 + v199);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v159, 24);
                          v48 = &v219;
                          v49 = v231;
                        }
                      }
                      v50 = &v49[6 * v232];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v232;
                      if (v230[0])
                      {
                        v219 = 3;
                        v220 = "HWIO";
                        v221 = 4;
                        v53 = &v219;
                        v54 = v231;
                        if (v52 >= v233)
                        {
                          v161 = v52 + 1;
                          v162 = &v231[6 * v52] > &v219;
                          if (v231 <= &v219 && v162)
                          {
                            v200 = (char *)&v219 - (char *)v231;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            v54 = v231;
                            v53 = (int *)((char *)v231 + v200);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v161, 24);
                            v53 = &v219;
                            v54 = v231;
                          }
                        }
                        v55 = &v54[6 * v232];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v232;
                        if (v230[0])
                        {
                          v219 = 3;
                          v220 = ", ";
                          v221 = 2;
                          v58 = &v219;
                          v59 = v231;
                          if (v57 >= v233)
                          {
                            v163 = v57 + 1;
                            v164 = &v231[6 * v57] > &v219;
                            if (v231 <= &v219 && v164)
                            {
                              v201 = (char *)&v219 - (char *)v231;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              v59 = v231;
                              v58 = (int *)((char *)v231 + v201);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v163, 24);
                              v58 = &v219;
                              v59 = v231;
                            }
                          }
                          v60 = &v59[6 * v232];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v232;
                          if (v230[0])
                          {
                            v219 = 3;
                            v220 = "CHW";
                            v221 = 3;
                            v63 = &v219;
                            v64 = v231;
                            if (v62 >= v233)
                            {
                              v165 = v62 + 1;
                              v166 = &v231[6 * v62] > &v219;
                              if (v231 <= &v219 && v166)
                              {
                                v202 = (char *)&v219 - (char *)v231;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                v64 = v231;
                                v63 = (int *)((char *)v231 + v202);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v165, 24);
                                v63 = &v219;
                                v64 = v231;
                              }
                            }
                            v65 = &v64[6 * v232];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v232;
                            if (v230[0])
                            {
                              v219 = 3;
                              v220 = ", ";
                              v221 = 2;
                              v68 = &v219;
                              v69 = v231;
                              if (v67 >= v233)
                              {
                                v167 = v67 + 1;
                                v168 = &v231[6 * v67] > &v219;
                                if (v231 <= &v219 && v168)
                                {
                                  v203 = (char *)&v219 - (char *)v231;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  v69 = v231;
                                  v68 = (int *)((char *)v231 + v203);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v167, 24);
                                  v68 = &v219;
                                  v69 = v231;
                                }
                              }
                              v70 = &v69[6 * v232];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v232;
                              if (v230[0])
                              {
                                v219 = 3;
                                v220 = "HWC";
                                v221 = 3;
                                v73 = &v219;
                                v74 = v231;
                                if (v72 >= v233)
                                {
                                  v169 = v72 + 1;
                                  v170 = &v231[6 * v72] > &v219;
                                  if (v231 <= &v219 && v170)
                                  {
                                    v204 = (char *)&v219 - (char *)v231;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    v74 = v231;
                                    v73 = (int *)((char *)v231 + v204);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v169, 24);
                                    v73 = &v219;
                                    v74 = v231;
                                  }
                                }
                                v75 = &v74[6 * v232];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v232;
                                if (v230[0])
                                {
                                  v219 = 3;
                                  v220 = ", ";
                                  v221 = 2;
                                  v78 = &v219;
                                  v79 = v231;
                                  if (v77 >= v233)
                                  {
                                    v171 = v77 + 1;
                                    v172 = &v231[6 * v77] > &v219;
                                    if (v231 <= &v219 && v172)
                                    {
                                      v205 = (char *)&v219 - (char *)v231;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      v79 = v231;
                                      v78 = (int *)((char *)v231 + v205);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v171, 24);
                                      v78 = &v219;
                                      v79 = v231;
                                    }
                                  }
                                  v80 = &v79[6 * v232];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v232;
                                  if (v230[0])
                                  {
                                    v219 = 3;
                                    v220 = "HW";
                                    v221 = 2;
                                    v83 = &v219;
                                    v84 = v231;
                                    if (v82 >= v233)
                                    {
                                      v173 = v82 + 1;
                                      v174 = &v231[6 * v82] > &v219;
                                      if (v231 <= &v219 && v174)
                                      {
                                        v206 = (char *)&v219 - (char *)v231;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        v84 = v231;
                                        v83 = (int *)((char *)v231 + v206);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v173, 24);
                                        v83 = &v219;
                                        v84 = v231;
                                      }
                                    }
                                    v85 = &v84[6 * v232];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v232;
                                    if (v230[0])
                                    {
                                      v219 = 3;
                                      v220 = ", ";
                                      v221 = 2;
                                      v88 = &v219;
                                      v89 = v231;
                                      if (v87 >= v233)
                                      {
                                        v175 = v87 + 1;
                                        v176 = &v231[6 * v87] > &v219;
                                        if (v231 <= &v219 && v176)
                                        {
                                          v207 = (char *)&v219 - (char *)v231;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          v89 = v231;
                                          v88 = (int *)((char *)v231 + v207);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v175, 24);
                                          v88 = &v219;
                                          v89 = v231;
                                        }
                                      }
                                      v90 = &v89[6 * v232];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v232;
                                      if (v230[0])
                                      {
                                        v219 = 3;
                                        v220 = "NCDHW";
                                        v221 = 5;
                                        v93 = &v219;
                                        v94 = v231;
                                        if (v92 >= v233)
                                        {
                                          v178 = v92 + 1;
                                          v179 = &v231[6 * v92] > &v219;
                                          if (v231 <= &v219 && v179)
                                          {
                                            v208 = (char *)&v219 - (char *)v231;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            v94 = v231;
                                            v93 = (int *)((char *)v231 + v208);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v178, 24);
                                            v93 = &v219;
                                            v94 = v231;
                                          }
                                        }
                                        v95 = &v94[6 * v232];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        v97 = ++v232;
                                        if (v230[0])
                                        {
                                          v219 = 3;
                                          v220 = ", ";
                                          v221 = 2;
                                          v98 = &v219;
                                          v99 = v231;
                                          if (v97 >= v233)
                                          {
                                            v181 = v97 + 1;
                                            v182 = &v231[6 * v97] > &v219;
                                            if (v231 <= &v219 && v182)
                                            {
                                              v209 = (char *)&v219 - (char *)v231;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              v99 = v231;
                                              v98 = (int *)((char *)v231 + v209);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v181, 24);
                                              v98 = &v219;
                                              v99 = v231;
                                            }
                                          }
                                          v100 = &v99[6 * v232];
                                          v101 = *(_OWORD *)v98;
                                          *((_QWORD *)v100 + 2) = *((_QWORD *)v98 + 2);
                                          *(_OWORD *)v100 = v101;
                                          v102 = ++v232;
                                          if (v230[0])
                                          {
                                            v219 = 3;
                                            v220 = "NDHWC";
                                            v221 = 5;
                                            v103 = &v219;
                                            v104 = v231;
                                            if (v102 >= v233)
                                            {
                                              v184 = v102 + 1;
                                              v185 = &v231[6 * v102] > &v219;
                                              if (v231 <= &v219 && v185)
                                              {
                                                v210 = (char *)&v219 - (char *)v231;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                v104 = v231;
                                                v103 = (int *)((char *)v231 + v210);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v184, 24);
                                                v103 = &v219;
                                                v104 = v231;
                                              }
                                            }
                                            v105 = &v104[6 * v232];
                                            v106 = *(_OWORD *)v103;
                                            *((_QWORD *)v105 + 2) = *((_QWORD *)v103 + 2);
                                            *(_OWORD *)v105 = v106;
                                            v107 = ++v232;
                                            if (v230[0])
                                            {
                                              v219 = 3;
                                              v220 = ", ";
                                              v221 = 2;
                                              v108 = &v219;
                                              v109 = v231;
                                              if (v107 >= v233)
                                              {
                                                v187 = v107 + 1;
                                                v188 = &v231[6 * v107] > &v219;
                                                if (v231 <= &v219 && v188)
                                                {
                                                  v211 = (char *)&v219 - (char *)v231;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v109 = v231;
                                                  v108 = (int *)((char *)v231 + v211);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v187, 24);
                                                  v108 = &v219;
                                                  v109 = v231;
                                                }
                                              }
                                              v110 = &v109[6 * v232];
                                              v111 = *(_OWORD *)v108;
                                              *((_QWORD *)v110 + 2) = *((_QWORD *)v108 + 2);
                                              *(_OWORD *)v110 = v111;
                                              v112 = ++v232;
                                              if (v230[0])
                                              {
                                                v219 = 3;
                                                v220 = "OIDHW";
                                                v221 = 5;
                                                v113 = &v219;
                                                v114 = v231;
                                                if (v112 >= v233)
                                                {
                                                  v190 = v112 + 1;
                                                  v191 = &v231[6 * v112] > &v219;
                                                  if (v231 <= &v219 && v191)
                                                  {
                                                    v212 = (char *)&v219 - (char *)v231;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v114 = v231;
                                                    v113 = (int *)((char *)v231 + v212);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v190, 24);
                                                    v113 = &v219;
                                                    v114 = v231;
                                                  }
                                                }
                                                v115 = &v114[6 * v232];
                                                v116 = *(_OWORD *)v113;
                                                *((_QWORD *)v115 + 2) = *((_QWORD *)v113 + 2);
                                                *(_OWORD *)v115 = v116;
                                                v117 = ++v232;
                                                if (v230[0])
                                                {
                                                  v219 = 3;
                                                  v220 = ", ";
                                                  v221 = 2;
                                                  v118 = &v219;
                                                  v119 = v231;
                                                  if (v117 >= v233)
                                                  {
                                                    v193 = v117 + 1;
                                                    v194 = &v231[6 * v117] > &v219;
                                                    if (v231 <= &v219 && v194)
                                                    {
                                                      v213 = (char *)&v219 - (char *)v231;
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v119 = v231;
                                                      v118 = (int *)((char *)v231 + v213);
                                                    }
                                                    else
                                                    {
                                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v193, 24);
                                                      v118 = &v219;
                                                      v119 = v231;
                                                    }
                                                  }
                                                  v120 = &v119[6 * v232];
                                                  v121 = *(_OWORD *)v118;
                                                  *((_QWORD *)v120 + 2) = *((_QWORD *)v118 + 2);
                                                  *(_OWORD *)v120 = v121;
                                                  v122 = ++v232;
                                                  if (v230[0])
                                                  {
                                                    v219 = 3;
                                                    v220 = "DHWIO";
                                                    v221 = 5;
                                                    v123 = &v219;
                                                    v124 = v231;
                                                    if (v122 >= v233)
                                                    {
                                                      v196 = v122 + 1;
                                                      v197 = &v231[6 * v122] > &v219;
                                                      if (v231 <= &v219 && v197)
                                                      {
                                                        v214 = (char *)&v219 - (char *)v231;
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v124 = v231;
                                                        v123 = (int *)((char *)v231 + v214);
                                                      }
                                                      else
                                                      {
                                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v231, v234, v196, 24);
                                                        v123 = &v219;
                                                        v124 = v231;
                                                      }
                                                    }
                                                    v125 = &v124[6 * v232];
                                                    v126 = *(_OWORD *)v123;
                                                    *((_QWORD *)v125 + 2) = *((_QWORD *)v123 + 2);
                                                    *(_OWORD *)v125 = v126;
                                                    ++v232;
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v230);
    if (v230[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v230);
    if (v239)
    {
      v127 = v237;
      if (v237)
      {
        v128 = v238;
        v129 = v237;
        if (v238 != v237)
        {
          do
            v128 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v128 - 1);
          while (v128 != v127);
          v129 = v237;
        }
        v238 = v127;
        operator delete(v129);
      }
      v130 = v235;
      if (v235)
      {
        v131 = v236;
        v132 = v235;
        if (v236 != v235)
        {
          do
          {
            v134 = (void *)*--v131;
            v133 = v134;
            *v131 = 0;
            if (v134)
              operator delete[](v133);
          }
          while (v131 != v130);
          v132 = v235;
        }
        v236 = v130;
        operator delete(v132);
      }
      if (v231 != (int *)v234)
        free(v231);
    }
    goto LABEL_73;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v215[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v230[0] = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    v230[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v230, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, v215);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::TensorDataLayoutAttr::print(mlir::mps::TensorDataLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 0xA)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_17;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "NCHW";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "NHWC";
      v9 = 4;
      break;
    case 2u:
      v7 = 0;
      v8 = "OIHW";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "HWIO";
      v9 = 4;
      break;
    case 4u:
      v7 = 0;
      v8 = "CHW";
      v9 = 3;
      break;
    case 5u:
      v7 = 0;
      v8 = "HWC";
      v9 = 3;
      break;
    case 6u:
      v7 = 0;
      v8 = "HW";
      v9 = 2;
      break;
    case 7u:
      v7 = 0;
      v8 = "NCDHW";
      goto LABEL_16;
    case 8u:
      v7 = 0;
      v8 = "NDHWC";
      goto LABEL_16;
    case 9u:
      v7 = 0;
      v8 = "OIDHW";
      goto LABEL_16;
    case 0xAu:
      v7 = 0;
      v8 = "DHWIO";
LABEL_16:
      v9 = 5;
      break;
    default:
      goto LABEL_6;
  }
LABEL_17:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::ReductionModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ReductionModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD **v77;
  _QWORD **v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  void *v83;
  void *v84;
  uint64_t v85;
  _QWORD **v86;
  _QWORD **v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  void *v92;
  void *v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD **v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD **v157;
  _QWORD **v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = (_QWORD **)__p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = (void *)*--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              operator delete[](v92);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeReductionMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "::mlir::mps::ReductionMode";
        v141 = 26;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "min";
            v141 = 3;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "max";
                v141 = 3;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "sum";
                    v141 = 3;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "product";
                        v141 = 7;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "argMin ";
                            v141 = 7;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "argMax";
                                v141 = 6;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = (void *)*--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              operator delete[](v83);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ReductionModeAttrStorage,mlir::mps::ReductionMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24ReductionModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17ReductionModeAttrEJNS2_13ReductionModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ReductionModeAttr::print(mlir::mps::ReductionModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "min";
  v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "max";
      v9 = 3;
      break;
    case 2u:
      v7 = 0;
      v8 = "sum";
      v9 = 3;
      break;
    case 3u:
      v7 = 0;
      v8 = "product";
      v9 = 7;
      break;
    case 4u:
      v7 = 0;
      v8 = "argMin ";
      v9 = 7;
      break;
    case 5u:
      v7 = 0;
      v8 = "argMax";
      v9 = 6;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::DeviceHintAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, &v5);
}

uint64_t mlir::mps::DeviceHintAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD **v45;
  _QWORD **v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  void *v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD **v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD **v109;
  _QWORD **v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = (_QWORD **)__p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = (void *)*--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                operator delete[](v61);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::DeviceHint";
          v93 = 23;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "ANE";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "GPU";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "CPU";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = (void *)*--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                operator delete[](v51);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 20033 && *(_BYTE *)(v89 + 2) == 69)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 20551 && *(_BYTE *)(v89 + 2) == 85)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 20547 || *(_BYTE *)(v89 + 2) != 85)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::DeviceHintAttrStorage,mlir::mps::DeviceHint>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail21DeviceHintAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_14DeviceHintAttrEJNS2_10DeviceHintEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::DeviceHintAttr::print(mlir::mps::DeviceHintAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "ANE";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "CPU";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "GPU";
  else
    v9 = "";
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::ScatterModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::ScatterModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  _QWORD **v87;
  _QWORD **v88;
  void *v89;
  _QWORD *v90;
  _QWORD *v91;
  void *v92;
  void *v93;
  void *v94;
  uint64_t v95;
  _QWORD **v96;
  _QWORD **v97;
  void *v98;
  _QWORD *v99;
  _QWORD *v100;
  void *v101;
  void *v102;
  void *v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  int64_t v135;
  int64_t v136;
  int64_t v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  int64_t v147;
  int64_t v148;
  int64_t v149;
  int64_t v150;
  unsigned int v151[8];
  __int16 v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  const char *v156;
  uint64_t v157;
  _QWORD v158[3];
  void *v159;
  uint64_t v160;
  void *v161;
  _QWORD *v162;
  void *__p;
  _QWORD **v164;
  char v165;
  _QWORD v166[3];
  int *v167;
  unsigned int v168;
  unsigned int v169;
  _BYTE v170[96];
  _QWORD *v171;
  _QWORD *v172;
  _QWORD **v173;
  _QWORD **v174;
  char v175;
  uint64_t v176;

  v176 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v153 = 0;
  v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    if (v165)
    {
      v96 = (_QWORD **)__p;
      if (__p)
      {
        v97 = v164;
        v98 = __p;
        if (v164 != __p)
        {
          do
            v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          v98 = __p;
        }
        v164 = v96;
        operator delete(v98);
      }
      v99 = v161;
      if (v161)
      {
        v100 = v162;
        v101 = v161;
        if (v162 != v161)
        {
          do
          {
            v103 = (void *)*--v100;
            v102 = v103;
            *v100 = 0;
            if (v103)
              operator delete[](v102);
          }
          while (v100 != v99);
          v101 = v161;
        }
        v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160)
        free(v159);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeScatterMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    v152 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      v155 = 3;
      v156 = "expected ";
      v157 = 9;
      v8 = &v155;
      v9 = v167;
      if (v168 >= v169)
      {
        v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v9 = v167;
          v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v8 = &v155;
          v9 = v167;
        }
      }
      v10 = &v9[6 * v168];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v168;
      if (v166[0])
      {
        v155 = 3;
        v156 = "::mlir::mps::ScatterMode";
        v157 = 24;
        v13 = &v155;
        v14 = v167;
        if (v12 >= v169)
        {
          v105 = v12 + 1;
          v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v14 = v167;
            v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v13 = &v155;
            v14 = v167;
          }
        }
        v15 = &v14[6 * v168];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v168;
        if (v166[0])
        {
          v155 = 3;
          v156 = " to be one of: ";
          v157 = 15;
          v18 = &v155;
          v19 = v167;
          if (v17 >= v169)
          {
            v107 = v17 + 1;
            v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v19 = v167;
              v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v18 = &v155;
              v19 = v167;
            }
          }
          v20 = &v19[6 * v168];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v168;
          if (v166[0])
          {
            v155 = 3;
            v156 = "add";
            v157 = 3;
            v23 = &v155;
            v24 = v167;
            if (v22 >= v169)
            {
              v109 = v22 + 1;
              v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v24 = v167;
                v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v23 = &v155;
                v24 = v167;
              }
            }
            v25 = &v24[6 * v168];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v168;
            if (v166[0])
            {
              v155 = 3;
              v156 = ", ";
              v157 = 2;
              v28 = &v155;
              v29 = v167;
              if (v27 >= v169)
              {
                v111 = v27 + 1;
                v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v29 = v167;
                  v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v28 = &v155;
                  v29 = v167;
                }
              }
              v30 = &v29[6 * v168];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v168;
              if (v166[0])
              {
                v155 = 3;
                v156 = "subtract";
                v157 = 8;
                v33 = &v155;
                v34 = v167;
                if (v32 >= v169)
                {
                  v113 = v32 + 1;
                  v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v34 = v167;
                    v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v33 = &v155;
                    v34 = v167;
                  }
                }
                v35 = &v34[6 * v168];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v168;
                if (v166[0])
                {
                  v155 = 3;
                  v156 = ", ";
                  v157 = 2;
                  v38 = &v155;
                  v39 = v167;
                  if (v37 >= v169)
                  {
                    v115 = v37 + 1;
                    v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v39 = v167;
                      v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v38 = &v155;
                      v39 = v167;
                    }
                  }
                  v40 = &v39[6 * v168];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v168;
                  if (v166[0])
                  {
                    v155 = 3;
                    v156 = "multiply";
                    v157 = 8;
                    v43 = &v155;
                    v44 = v167;
                    if (v42 >= v169)
                    {
                      v117 = v42 + 1;
                      v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v44 = v167;
                        v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v43 = &v155;
                        v44 = v167;
                      }
                    }
                    v45 = &v44[6 * v168];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v168;
                    if (v166[0])
                    {
                      v155 = 3;
                      v156 = ", ";
                      v157 = 2;
                      v48 = &v155;
                      v49 = v167;
                      if (v47 >= v169)
                      {
                        v119 = v47 + 1;
                        v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v49 = v167;
                          v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v48 = &v155;
                          v49 = v167;
                        }
                      }
                      v50 = &v49[6 * v168];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v168;
                      if (v166[0])
                      {
                        v155 = 3;
                        v156 = "divide";
                        v157 = 6;
                        v53 = &v155;
                        v54 = v167;
                        if (v52 >= v169)
                        {
                          v121 = v52 + 1;
                          v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v54 = v167;
                            v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v53 = &v155;
                            v54 = v167;
                          }
                        }
                        v55 = &v54[6 * v168];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v168;
                        if (v166[0])
                        {
                          v155 = 3;
                          v156 = ", ";
                          v157 = 2;
                          v58 = &v155;
                          v59 = v167;
                          if (v57 >= v169)
                          {
                            v123 = v57 + 1;
                            v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v59 = v167;
                              v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v58 = &v155;
                              v59 = v167;
                            }
                          }
                          v60 = &v59[6 * v168];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v168;
                          if (v166[0])
                          {
                            v155 = 3;
                            v156 = "min";
                            v157 = 3;
                            v63 = &v155;
                            v64 = v167;
                            if (v62 >= v169)
                            {
                              v125 = v62 + 1;
                              v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v64 = v167;
                                v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v63 = &v155;
                                v64 = v167;
                              }
                            }
                            v65 = &v64[6 * v168];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v168;
                            if (v166[0])
                            {
                              v155 = 3;
                              v156 = ", ";
                              v157 = 2;
                              v68 = &v155;
                              v69 = v167;
                              if (v67 >= v169)
                              {
                                v127 = v67 + 1;
                                v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v69 = v167;
                                  v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v68 = &v155;
                                  v69 = v167;
                                }
                              }
                              v70 = &v69[6 * v168];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v168;
                              if (v166[0])
                              {
                                v155 = 3;
                                v156 = "max";
                                v157 = 3;
                                v73 = &v155;
                                v74 = v167;
                                if (v72 >= v169)
                                {
                                  v129 = v72 + 1;
                                  v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v74 = v167;
                                    v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v73 = &v155;
                                    v74 = v167;
                                  }
                                }
                                v75 = &v74[6 * v168];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v168;
                                if (v166[0])
                                {
                                  v155 = 3;
                                  v156 = ", ";
                                  v157 = 2;
                                  v78 = &v155;
                                  v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    v131 = v77 + 1;
                                    v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v79 = v167;
                                      v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v78 = &v155;
                                      v79 = v167;
                                    }
                                  }
                                  v80 = &v79[6 * v168];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v168;
                                  if (v166[0])
                                  {
                                    v155 = 3;
                                    v156 = "set";
                                    v157 = 3;
                                    v83 = &v155;
                                    v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      v133 = v82 + 1;
                                      v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v84 = v167;
                                        v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v83 = &v155;
                                        v84 = v167;
                                      }
                                    }
                                    v85 = &v84[6 * v168];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    if (v175)
    {
      v87 = v173;
      if (v173)
      {
        v88 = v174;
        v89 = v173;
        if (v174 != v173)
        {
          do
            v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          v89 = v173;
        }
        v174 = v87;
        operator delete(v89);
      }
      v90 = v171;
      if (v171)
      {
        v91 = v172;
        v92 = v171;
        if (v172 != v171)
        {
          do
          {
            v94 = (void *)*--v91;
            v93 = v94;
            *v91 = 0;
            if (v94)
              operator delete[](v93);
          }
          while (v91 != v90);
          v92 = v171;
        }
        v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170)
        free(v167);
    }
    goto LABEL_57;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::ScatterModeAttrStorage,mlir::mps::ScatterMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22ScatterModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15ScatterModeAttrEJNS2_11ScatterModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::ScatterModeAttr::print(mlir::mps::ScatterModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_13;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "add";
  v9 = 3;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "subtract";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "multiply";
      v9 = 8;
      break;
    case 3u:
      v7 = 0;
      v8 = "divide";
      v9 = 6;
      break;
    case 4u:
      v7 = 0;
      v8 = "min";
      goto LABEL_12;
    case 5u:
      v7 = 0;
      v8 = "max";
      goto LABEL_12;
    case 6u:
      v7 = 0;
      v8 = "set";
LABEL_12:
      v9 = 3;
      break;
    default:
      goto LABEL_6;
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  int *v48;
  int *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  int *v53;
  int *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  _QWORD *v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  _QWORD **v65;
  _QWORD **v66;
  void *v67;
  _QWORD *v68;
  _QWORD *v69;
  void *v70;
  void *v71;
  void *v72;
  uint64_t result;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v76;
  unint64_t v77;
  BOOL v78;
  unint64_t v79;
  BOOL v80;
  unint64_t v81;
  BOOL v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  BOOL v88;
  unint64_t v89;
  BOOL v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  unsigned int v101[8];
  __int16 v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  const char *v106;
  uint64_t v107;
  _QWORD v108[3];
  void *v109;
  uint64_t v110;
  void *v111;
  _QWORD *v112;
  void *__p;
  _QWORD **v114;
  char v115;
  _QWORD v116[3];
  int *v117;
  unsigned int v118;
  unsigned int v119;
  _BYTE v120[96];
  _QWORD *v121;
  _QWORD *v122;
  _QWORD **v123;
  _QWORD **v124;
  char v125;
  uint64_t v126;

  v126 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v103 = 0;
  v104 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v103))
  {
LABEL_64:
    v64 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v118) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v108, a1, v64, v116);
    if (v108[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v108);
    if (v115)
    {
      v65 = (_QWORD **)__p;
      if (__p)
      {
        v66 = v114;
        v67 = __p;
        if (v114 != __p)
        {
          do
            v66 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v66 - 1);
          while (v66 != v65);
          v67 = __p;
        }
        v114 = v65;
        operator delete(v67);
      }
      v68 = v111;
      if (v111)
      {
        v69 = v112;
        v70 = v111;
        if (v112 != v111)
        {
          do
          {
            v72 = (void *)*--v69;
            v71 = v72;
            *v69 = 0;
            if (v72)
              operator delete[](v71);
          }
          while (v69 != v68);
          v70 = v111;
        }
        v112 = v68;
        operator delete(v70);
      }
      if (v109 != &v110)
        free(v109);
    }
    return 0;
  }
  switch(v104)
  {
    case 7:
      if (*(_DWORD *)v103 != 1818649970 || *(_DWORD *)(v103 + 3) != 1952671084)
        goto LABEL_25;
      v4 = 1;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 8:
      if (*(_QWORD *)v103 != 0x746E6174736E6F63)
        goto LABEL_25;
      v4 = 0;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 9:
      if (*(_QWORD *)v103 != 0x697274656D6D7973 || *(_BYTE *)(v103 + 8) != 99)
        goto LABEL_25;
      v4 = 2;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
      goto LABEL_85;
    case 11:
      if (*(_QWORD *)v103 != 0x456F54706D616C63 || *(_QWORD *)(v103 + 3) != 0x656764456F54706DLL)
        goto LABEL_25;
      v4 = 3;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
LABEL_85:
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v101[0] = v4;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v116[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id;
      v116[1] = Context;
      result = mlir::StorageUniquer::get<mlir::mps::detail::PaddingModeAttrStorage,mlir::mps::PaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail22PaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_15PaddingModeAttrEJNS2_11PaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v116, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id, v101);
      break;
    default:
LABEL_25:
      v102 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v116, a1, v2, v101);
      if (v116[0])
      {
        v105 = 3;
        v106 = "expected ";
        v107 = 9;
        v7 = &v105;
        v8 = v117;
        if (v118 >= v119)
        {
          v76 = v118 + 1;
          if (v117 <= &v105 && &v117[6 * v118] > &v105)
          {
            v91 = (char *)&v105 - (char *)v117;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            v8 = v117;
            v7 = (int *)((char *)v117 + v91);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v76, 24);
            v7 = &v105;
            v8 = v117;
          }
        }
        v9 = &v8[6 * v118];
        v10 = *(_OWORD *)v7;
        *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
        *(_OWORD *)v9 = v10;
        v11 = ++v118;
        if (v116[0])
        {
          v105 = 3;
          v106 = "::mlir::mps::PaddingMode";
          v107 = 24;
          v12 = &v105;
          v13 = v117;
          if (v11 >= v119)
          {
            v77 = v11 + 1;
            v78 = &v117[6 * v11] > &v105;
            if (v117 <= &v105 && v78)
            {
              v92 = (char *)&v105 - (char *)v117;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              v13 = v117;
              v12 = (int *)((char *)v117 + v92);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v77, 24);
              v12 = &v105;
              v13 = v117;
            }
          }
          v14 = &v13[6 * v118];
          v15 = *(_OWORD *)v12;
          *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
          *(_OWORD *)v14 = v15;
          v16 = ++v118;
          if (v116[0])
          {
            v105 = 3;
            v106 = " to be one of: ";
            v107 = 15;
            v17 = &v105;
            v18 = v117;
            if (v16 >= v119)
            {
              v79 = v16 + 1;
              v80 = &v117[6 * v16] > &v105;
              if (v117 <= &v105 && v80)
              {
                v93 = (char *)&v105 - (char *)v117;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                v18 = v117;
                v17 = (int *)((char *)v117 + v93);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v79, 24);
                v17 = &v105;
                v18 = v117;
              }
            }
            v19 = &v18[6 * v118];
            v20 = *(_OWORD *)v17;
            *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
            *(_OWORD *)v19 = v20;
            v21 = ++v118;
            if (v116[0])
            {
              v105 = 3;
              v106 = "constant";
              v107 = 8;
              v22 = &v105;
              v23 = v117;
              if (v21 >= v119)
              {
                v81 = v21 + 1;
                v82 = &v117[6 * v21] > &v105;
                if (v117 <= &v105 && v82)
                {
                  v94 = (char *)&v105 - (char *)v117;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  v23 = v117;
                  v22 = (int *)((char *)v117 + v94);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v81, 24);
                  v22 = &v105;
                  v23 = v117;
                }
              }
              v24 = &v23[6 * v118];
              v25 = *(_OWORD *)v22;
              *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
              *(_OWORD *)v24 = v25;
              v26 = ++v118;
              if (v116[0])
              {
                v105 = 3;
                v106 = ", ";
                v107 = 2;
                v27 = &v105;
                v28 = v117;
                if (v26 >= v119)
                {
                  v83 = v26 + 1;
                  if (v117 <= &v105 && &v117[6 * v26] > &v105)
                  {
                    v95 = (char *)&v105 - (char *)v117;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    v28 = v117;
                    v27 = (int *)((char *)v117 + v95);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v83, 24);
                    v27 = &v105;
                    v28 = v117;
                  }
                }
                v29 = &v28[6 * v118];
                v30 = *(_OWORD *)v27;
                *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
                *(_OWORD *)v29 = v30;
                v31 = ++v118;
                if (v116[0])
                {
                  v105 = 3;
                  v106 = "reflect";
                  v107 = 7;
                  v32 = &v105;
                  v33 = v117;
                  if (v31 >= v119)
                  {
                    v84 = v31 + 1;
                    if (v117 <= &v105 && &v117[6 * v31] > &v105)
                    {
                      v96 = (char *)&v105 - (char *)v117;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      v33 = v117;
                      v32 = (int *)((char *)v117 + v96);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v84, 24);
                      v32 = &v105;
                      v33 = v117;
                    }
                  }
                  v34 = &v33[6 * v118];
                  v35 = *(_OWORD *)v32;
                  *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                  *(_OWORD *)v34 = v35;
                  v36 = ++v118;
                  if (v116[0])
                  {
                    v105 = 3;
                    v106 = ", ";
                    v107 = 2;
                    v37 = &v105;
                    v38 = v117;
                    if (v36 >= v119)
                    {
                      v85 = v36 + 1;
                      if (v117 <= &v105 && &v117[6 * v36] > &v105)
                      {
                        v97 = (char *)&v105 - (char *)v117;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        v38 = v117;
                        v37 = (int *)((char *)v117 + v97);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v85, 24);
                        v37 = &v105;
                        v38 = v117;
                      }
                    }
                    v39 = &v38[6 * v118];
                    v40 = *(_OWORD *)v37;
                    *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                    *(_OWORD *)v39 = v40;
                    v41 = ++v118;
                    if (v116[0])
                    {
                      v105 = 3;
                      v106 = "symmetric";
                      v107 = 9;
                      v42 = &v105;
                      v43 = v117;
                      if (v41 >= v119)
                      {
                        v86 = v41 + 1;
                        if (v117 <= &v105 && &v117[6 * v41] > &v105)
                        {
                          v98 = (char *)&v105 - (char *)v117;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          v43 = v117;
                          v42 = (int *)((char *)v117 + v98);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v86, 24);
                          v42 = &v105;
                          v43 = v117;
                        }
                      }
                      v44 = &v43[6 * v118];
                      v45 = *(_OWORD *)v42;
                      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                      *(_OWORD *)v44 = v45;
                      v46 = ++v118;
                      if (v116[0])
                      {
                        v105 = 3;
                        v106 = ", ";
                        v107 = 2;
                        v47 = &v105;
                        v48 = v117;
                        if (v46 >= v119)
                        {
                          v87 = v46 + 1;
                          v88 = &v117[6 * v46] > &v105;
                          if (v117 <= &v105 && v88)
                          {
                            v99 = (char *)&v105 - (char *)v117;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            v48 = v117;
                            v47 = (int *)((char *)v117 + v99);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v87, 24);
                            v47 = &v105;
                            v48 = v117;
                          }
                        }
                        v49 = &v48[6 * v118];
                        v50 = *(_OWORD *)v47;
                        *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
                        *(_OWORD *)v49 = v50;
                        v51 = ++v118;
                        if (v116[0])
                        {
                          v105 = 3;
                          v106 = "clampToEdge";
                          v107 = 11;
                          v52 = &v105;
                          v53 = v117;
                          if (v51 >= v119)
                          {
                            v89 = v51 + 1;
                            v90 = &v117[6 * v51] > &v105;
                            if (v117 <= &v105 && v90)
                            {
                              v100 = (char *)&v105 - (char *)v117;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              v53 = v117;
                              v52 = (int *)((char *)v117 + v100);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v117, v120, v89, 24);
                              v52 = &v105;
                              v53 = v117;
                            }
                          }
                          v54 = &v53[6 * v118];
                          v55 = *(_OWORD *)v52;
                          *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
                          *(_OWORD *)v54 = v55;
                          ++v118;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v116);
      if (v116[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v116);
      if (v125)
      {
        v56 = v123;
        if (v123)
        {
          v57 = v124;
          v58 = v123;
          if (v124 != v123)
          {
            do
              v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
            while (v57 != v56);
            v58 = v123;
          }
          v124 = v56;
          operator delete(v58);
        }
        v59 = v121;
        if (v121)
        {
          v60 = v122;
          v61 = v121;
          if (v122 != v121)
          {
            do
            {
              v63 = (void *)*--v60;
              v62 = v63;
              *v60 = 0;
              if (v63)
                operator delete[](v62);
            }
            while (v60 != v59);
            v61 = v121;
          }
          v122 = v59;
          operator delete(v61);
        }
        if (v117 != (int *)v120)
          free(v117);
      }
      goto LABEL_64;
  }
  return result;
}

llvm::raw_ostream *mlir::mps::PaddingModeAttr::print(mlir::mps::PaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_9;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "constant";
  v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "reflect";
      v9 = 7;
      break;
    case 2u:
      v7 = 0;
      v8 = "symmetric";
      v9 = 9;
      break;
    case 3u:
      v7 = 0;
      v8 = "clampToEdge";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_9:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SamplingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SamplingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  _QWORD **v43;
  _QWORD **v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  void *v50;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  unsigned int v71[8];
  __int16 v72;
  _DWORD *v73;
  uint64_t v74;
  int v75;
  const char *v76;
  uint64_t v77;
  _QWORD v78[3];
  void *v79;
  uint64_t v80;
  void *v81;
  _QWORD *v82;
  void *__p;
  _QWORD **v84;
  char v85;
  _QWORD v86[3];
  int *v87;
  unsigned int v88;
  unsigned int v89;
  _BYTE v90[96];
  _QWORD *v91;
  _QWORD *v92;
  _QWORD **v93;
  _QWORD **v94;
  char v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v73 = 0;
  v74 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
  {
LABEL_44:
    v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v88) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v78, a1, v42, v86);
    if (v78[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
    if (v85)
    {
      v43 = (_QWORD **)__p;
      if (__p)
      {
        v44 = v84;
        v45 = __p;
        if (v84 != __p)
        {
          do
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
          while (v44 != v43);
          v45 = __p;
        }
        v84 = v43;
        operator delete(v45);
      }
      v46 = v81;
      if (v81)
      {
        v47 = v82;
        v48 = v81;
        if (v82 != v81)
        {
          do
          {
            v50 = (void *)*--v47;
            v49 = v50;
            *v47 = 0;
            if (v50)
              operator delete[](v49);
          }
          while (v47 != v46);
          v48 = v81;
        }
        v82 = v46;
        operator delete(v48);
      }
      if (v79 != &v80)
        free(v79);
    }
    return 0;
  }
  if (v74 != 8)
  {
    if (v74 != 7)
      goto LABEL_13;
    if (*v73 != 1918985582 || *(_DWORD *)((char *)v73 + 3) != 1953719666)
      goto LABEL_13;
    v4 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_65:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v71[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
    v86[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, v71);
  }
  if (*(_QWORD *)v73 != 0x7261656E696C6962)
  {
LABEL_13:
    v72 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v86, a1, v2, v71);
    if (v86[0])
    {
      v75 = 3;
      v76 = "expected ";
      v77 = 9;
      v5 = &v75;
      v6 = v87;
      if (v88 >= v89)
      {
        v54 = v88 + 1;
        if (v87 <= &v75 && &v87[6 * v88] > &v75)
        {
          v65 = (char *)&v75 - (char *)v87;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v6 = v87;
          v5 = (int *)((char *)v87 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v5 = &v75;
          v6 = v87;
        }
      }
      v7 = &v6[6 * v88];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v88;
      if (v86[0])
      {
        v75 = 3;
        v76 = "::mlir::mps::SamplingMode";
        v77 = 25;
        v10 = &v75;
        v11 = v87;
        if (v9 >= v89)
        {
          v55 = v9 + 1;
          v56 = &v87[6 * v9] > &v75;
          if (v87 <= &v75 && v56)
          {
            v66 = (char *)&v75 - (char *)v87;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v11 = v87;
            v10 = (int *)((char *)v87 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v10 = &v75;
            v11 = v87;
          }
        }
        v12 = &v11[6 * v88];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v88;
        if (v86[0])
        {
          v75 = 3;
          v76 = " to be one of: ";
          v77 = 15;
          v15 = &v75;
          v16 = v87;
          if (v14 >= v89)
          {
            v57 = v14 + 1;
            v58 = &v87[6 * v14] > &v75;
            if (v87 <= &v75 && v58)
            {
              v67 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v16 = v87;
              v15 = (int *)((char *)v87 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v15 = &v75;
              v16 = v87;
            }
          }
          v17 = &v16[6 * v88];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v88;
          if (v86[0])
          {
            v75 = 3;
            v76 = "nearest";
            v77 = 7;
            v20 = &v75;
            v21 = v87;
            if (v19 >= v89)
            {
              v59 = v19 + 1;
              v60 = &v87[6 * v19] > &v75;
              if (v87 <= &v75 && v60)
              {
                v68 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v21 = v87;
                v20 = (int *)((char *)v87 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v20 = &v75;
                v21 = v87;
              }
            }
            v22 = &v21[6 * v88];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v88;
            if (v86[0])
            {
              v75 = 3;
              v76 = ", ";
              v77 = 2;
              v25 = &v75;
              v26 = v87;
              if (v24 >= v89)
              {
                v61 = v24 + 1;
                v62 = &v87[6 * v24] > &v75;
                if (v87 <= &v75 && v62)
                {
                  v69 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v26 = v87;
                  v25 = (int *)((char *)v87 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v25 = &v75;
                  v26 = v87;
                }
              }
              v27 = &v26[6 * v88];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v88;
              if (v86[0])
              {
                v75 = 3;
                v76 = "bilinear";
                v77 = 8;
                v30 = &v75;
                v31 = v87;
                if (v29 >= v89)
                {
                  v63 = v29 + 1;
                  v64 = &v87[6 * v29] > &v75;
                  if (v87 <= &v75 && v64)
                  {
                    v70 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v31 = v87;
                    v30 = (int *)((char *)v87 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v30 = &v75;
                    v31 = v87;
                  }
                }
                v32 = &v31[6 * v88];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                ++v88;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
    if (v86[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
    if (v95)
    {
      v34 = v93;
      if (v93)
      {
        v35 = v94;
        v36 = v93;
        if (v94 != v93)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = v93;
        }
        v94 = v34;
        operator delete(v36);
      }
      v37 = v91;
      if (v91)
      {
        v38 = v92;
        v39 = v91;
        if (v92 != v91)
        {
          do
          {
            v41 = (void *)*--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
              operator delete[](v40);
          }
          while (v38 != v37);
          v39 = v91;
        }
        v92 = v37;
        operator delete(v39);
      }
      if (v87 != (int *)v90)
        free(v87);
    }
    goto LABEL_44;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_65;
  return 0;
}

llvm::raw_ostream *mlir::mps::SamplingModeAttr::print(mlir::mps::SamplingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  const char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = "";
  v8 = 8;
  if (v6 == 1)
    v7 = "bilinear";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 7;
  if (v6)
    v11 = v7;
  else
    v11 = "nearest";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::NearestRoundingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::NearestRoundingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD **v77;
  _QWORD **v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  void *v83;
  void *v84;
  uint64_t v85;
  _QWORD **v86;
  _QWORD **v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  void *v92;
  void *v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  uint64_t v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD **v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD **v157;
  _QWORD **v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = (_QWORD **)__p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = (void *)*--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              operator delete[](v92);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeNearestRoundingMode(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "mlir::mps::NearestRoundingMode";
        v141 = 30;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "round_prefer_ceil";
            v141 = 17;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "round_prefer_floor";
                v141 = 18;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "ceil";
                    v141 = 4;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "floor";
                        v141 = 5;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "round_to_even";
                            v141 = 13;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "round_to_odd";
                                v141 = 12;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = (void *)*--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              operator delete[](v83);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NearestRoundingModeAttrStorage,mlir::mps::NearestRoundingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30NearestRoundingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23NearestRoundingModeAttrEJNS2_19NearestRoundingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::NearestRoundingModeAttr::print(mlir::mps::NearestRoundingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "round_prefer_ceil";
  v9 = 17;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "round_prefer_floor";
      v9 = 18;
      break;
    case 2u:
      v7 = 0;
      v8 = "ceil";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "floor";
      v9 = 5;
      break;
    case 4u:
      v7 = 0;
      v8 = "round_to_even";
      v9 = 13;
      break;
    case 5u:
      v7 = 0;
      v8 = "round_to_odd";
      v9 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SparseTensorStorageAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, &v5);
}

uint64_t mlir::mps::SparseTensorStorageAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD **v45;
  _QWORD **v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  void *v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD **v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD **v109;
  _QWORD **v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = (_QWORD **)__p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = (void *)*--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                operator delete[](v61);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::SparseTensorStorage";
          v93 = 32;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "COO";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "CSC";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "CSR";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = (void *)*--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                operator delete[](v51);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 20291 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 21315 && *(_BYTE *)(v89 + 2) == 67)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 21315 || *(_BYTE *)(v89 + 2) != 82)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::SparseTensorStorageAttr::print(mlir::mps::SparseTensorStorageAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "COO";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "CSR";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "CSC";
  else
    v9 = "";
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MetalPixelFormatAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, &v5);
}

uint64_t mlir::mps::MetalPixelFormatAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  uint64_t v97;
  int *v98;
  int *v99;
  int *v100;
  __int128 v101;
  uint64_t v102;
  int *v103;
  int *v104;
  int *v105;
  __int128 v106;
  uint64_t v107;
  int *v108;
  int *v109;
  int *v110;
  __int128 v111;
  uint64_t v112;
  int *v113;
  int *v114;
  int *v115;
  __int128 v116;
  _QWORD **v117;
  _QWORD **v118;
  void *v119;
  _QWORD *v120;
  _QWORD *v121;
  void *v122;
  void *v123;
  void *v124;
  uint64_t v125;
  _QWORD **v126;
  _QWORD **v127;
  void *v128;
  _QWORD *v129;
  _QWORD *v130;
  void *v131;
  void *v132;
  void *v133;
  unint64_t v134;
  unint64_t v135;
  BOOL v136;
  unint64_t v137;
  BOOL v138;
  unint64_t v139;
  BOOL v140;
  unint64_t v141;
  BOOL v142;
  unint64_t v143;
  BOOL v144;
  unint64_t v145;
  BOOL v146;
  unint64_t v147;
  BOOL v148;
  unint64_t v149;
  BOOL v150;
  unint64_t v151;
  BOOL v152;
  unint64_t v153;
  BOOL v154;
  unint64_t v155;
  BOOL v156;
  unint64_t v157;
  BOOL v158;
  unint64_t v159;
  BOOL v160;
  unint64_t v161;
  BOOL v162;
  unint64_t v163;
  BOOL v164;
  unint64_t v165;
  BOOL v166;
  int64_t v167;
  unint64_t v168;
  BOOL v169;
  int64_t v170;
  unint64_t v171;
  BOOL v172;
  int64_t v173;
  unint64_t v174;
  BOOL v175;
  int64_t v176;
  unint64_t v177;
  BOOL v178;
  int64_t v179;
  unint64_t v180;
  BOOL v181;
  int64_t v182;
  int64_t v183;
  int64_t v184;
  int64_t v185;
  int64_t v186;
  int64_t v187;
  int64_t v188;
  int64_t v189;
  int64_t v190;
  int64_t v191;
  int64_t v192;
  int64_t v193;
  int64_t v194;
  int64_t v195;
  int64_t v196;
  int64_t v197;
  int64_t v198;
  unsigned int v199[8];
  __int16 v200;
  uint64_t v201;
  uint64_t v202;
  int v203;
  const char *v204;
  uint64_t v205;
  _QWORD v206[3];
  void *v207;
  uint64_t v208;
  void *v209;
  _QWORD *v210;
  void *__p;
  _QWORD **v212;
  char v213;
  _QWORD v214[3];
  int *v215;
  unsigned int v216;
  unsigned int v217;
  _BYTE v218[96];
  _QWORD *v219;
  _QWORD *v220;
  _QWORD **v221;
  _QWORD **v222;
  char v223;
  uint64_t v224;

  v224 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v201 = 0;
  v202 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v201))
  {
LABEL_69:
    v125 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v216) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v206, a1, v125, v214);
    if (v206[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v206);
    if (v213)
    {
      v126 = (_QWORD **)__p;
      if (__p)
      {
        v127 = v212;
        v128 = __p;
        if (v212 != __p)
        {
          do
            v127 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v127 - 1);
          while (v127 != v126);
          v128 = __p;
        }
        v212 = v126;
        operator delete(v128);
      }
      v129 = v209;
      if (v209)
      {
        v130 = v210;
        v131 = v209;
        if (v210 != v209)
        {
          do
          {
            v133 = (void *)*--v130;
            v132 = v133;
            *v130 = 0;
            if (v133)
              operator delete[](v132);
          }
          while (v130 != v129);
          v131 = v209;
        }
        v210 = v129;
        operator delete(v131);
      }
      if (v207 != &v208)
        free(v207);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeMetalPixelFormat(v201, v202);
  if ((v3 & 0xFF00000000) == 0)
  {
    v200 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v214, a1, v2, v199);
    if (v214[0])
    {
      v203 = 3;
      v204 = "expected ";
      v205 = 9;
      v8 = &v203;
      v9 = v215;
      if (v216 >= v217)
      {
        v134 = v216 + 1;
        if (v215 <= &v203 && &v215[6 * v216] > &v203)
        {
          v167 = (char *)&v203 - (char *)v215;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          v9 = v215;
          v8 = (int *)((char *)v215 + v167);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v134, 24);
          v8 = &v203;
          v9 = v215;
        }
      }
      v10 = &v9[6 * v216];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v216;
      if (v214[0])
      {
        v203 = 3;
        v204 = "::mlir::mps::MetalPixelFormat";
        v205 = 29;
        v13 = &v203;
        v14 = v215;
        if (v12 >= v217)
        {
          v135 = v12 + 1;
          v136 = &v215[6 * v12] > &v203;
          if (v215 <= &v203 && v136)
          {
            v170 = (char *)&v203 - (char *)v215;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            v14 = v215;
            v13 = (int *)((char *)v215 + v170);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v135, 24);
            v13 = &v203;
            v14 = v215;
          }
        }
        v15 = &v14[6 * v216];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v216;
        if (v214[0])
        {
          v203 = 3;
          v204 = " to be one of: ";
          v205 = 15;
          v18 = &v203;
          v19 = v215;
          if (v17 >= v217)
          {
            v137 = v17 + 1;
            v138 = &v215[6 * v17] > &v203;
            if (v215 <= &v203 && v138)
            {
              v173 = (char *)&v203 - (char *)v215;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              v19 = v215;
              v18 = (int *)((char *)v215 + v173);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v137, 24);
              v18 = &v203;
              v19 = v215;
            }
          }
          v20 = &v19[6 * v216];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v216;
          if (v214[0])
          {
            v203 = 3;
            v204 = "R8Unorm";
            v205 = 7;
            v23 = &v203;
            v24 = v215;
            if (v22 >= v217)
            {
              v139 = v22 + 1;
              v140 = &v215[6 * v22] > &v203;
              if (v215 <= &v203 && v140)
              {
                v176 = (char *)&v203 - (char *)v215;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                v24 = v215;
                v23 = (int *)((char *)v215 + v176);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v139, 24);
                v23 = &v203;
                v24 = v215;
              }
            }
            v25 = &v24[6 * v216];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v216;
            if (v214[0])
            {
              v203 = 3;
              v204 = ", ";
              v205 = 2;
              v28 = &v203;
              v29 = v215;
              if (v27 >= v217)
              {
                v141 = v27 + 1;
                v142 = &v215[6 * v27] > &v203;
                if (v215 <= &v203 && v142)
                {
                  v179 = (char *)&v203 - (char *)v215;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  v29 = v215;
                  v28 = (int *)((char *)v215 + v179);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v141, 24);
                  v28 = &v203;
                  v29 = v215;
                }
              }
              v30 = &v29[6 * v216];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v216;
              if (v214[0])
              {
                v203 = 3;
                v204 = "RG8Unorm";
                v205 = 8;
                v33 = &v203;
                v34 = v215;
                if (v32 >= v217)
                {
                  v143 = v32 + 1;
                  v144 = &v215[6 * v32] > &v203;
                  if (v215 <= &v203 && v144)
                  {
                    v182 = (char *)&v203 - (char *)v215;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    v34 = v215;
                    v33 = (int *)((char *)v215 + v182);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v143, 24);
                    v33 = &v203;
                    v34 = v215;
                  }
                }
                v35 = &v34[6 * v216];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v216;
                if (v214[0])
                {
                  v203 = 3;
                  v204 = ", ";
                  v205 = 2;
                  v38 = &v203;
                  v39 = v215;
                  if (v37 >= v217)
                  {
                    v145 = v37 + 1;
                    v146 = &v215[6 * v37] > &v203;
                    if (v215 <= &v203 && v146)
                    {
                      v183 = (char *)&v203 - (char *)v215;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      v39 = v215;
                      v38 = (int *)((char *)v215 + v183);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v145, 24);
                      v38 = &v203;
                      v39 = v215;
                    }
                  }
                  v40 = &v39[6 * v216];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v216;
                  if (v214[0])
                  {
                    v203 = 3;
                    v204 = "RGBA8Unorm";
                    v205 = 10;
                    v43 = &v203;
                    v44 = v215;
                    if (v42 >= v217)
                    {
                      v147 = v42 + 1;
                      v148 = &v215[6 * v42] > &v203;
                      if (v215 <= &v203 && v148)
                      {
                        v184 = (char *)&v203 - (char *)v215;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        v44 = v215;
                        v43 = (int *)((char *)v215 + v184);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v147, 24);
                        v43 = &v203;
                        v44 = v215;
                      }
                    }
                    v45 = &v44[6 * v216];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v216;
                    if (v214[0])
                    {
                      v203 = 3;
                      v204 = ", ";
                      v205 = 2;
                      v48 = &v203;
                      v49 = v215;
                      if (v47 >= v217)
                      {
                        v149 = v47 + 1;
                        v150 = &v215[6 * v47] > &v203;
                        if (v215 <= &v203 && v150)
                        {
                          v185 = (char *)&v203 - (char *)v215;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          v49 = v215;
                          v48 = (int *)((char *)v215 + v185);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v149, 24);
                          v48 = &v203;
                          v49 = v215;
                        }
                      }
                      v50 = &v49[6 * v216];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v216;
                      if (v214[0])
                      {
                        v203 = 3;
                        v204 = "BGRA8Unorm";
                        v205 = 10;
                        v53 = &v203;
                        v54 = v215;
                        if (v52 >= v217)
                        {
                          v151 = v52 + 1;
                          v152 = &v215[6 * v52] > &v203;
                          if (v215 <= &v203 && v152)
                          {
                            v186 = (char *)&v203 - (char *)v215;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            v54 = v215;
                            v53 = (int *)((char *)v215 + v186);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v151, 24);
                            v53 = &v203;
                            v54 = v215;
                          }
                        }
                        v55 = &v54[6 * v216];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v216;
                        if (v214[0])
                        {
                          v203 = 3;
                          v204 = ", ";
                          v205 = 2;
                          v58 = &v203;
                          v59 = v215;
                          if (v57 >= v217)
                          {
                            v153 = v57 + 1;
                            v154 = &v215[6 * v57] > &v203;
                            if (v215 <= &v203 && v154)
                            {
                              v187 = (char *)&v203 - (char *)v215;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              v59 = v215;
                              v58 = (int *)((char *)v215 + v187);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v153, 24);
                              v58 = &v203;
                              v59 = v215;
                            }
                          }
                          v60 = &v59[6 * v216];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v216;
                          if (v214[0])
                          {
                            v203 = 3;
                            v204 = "R16Float";
                            v205 = 8;
                            v63 = &v203;
                            v64 = v215;
                            if (v62 >= v217)
                            {
                              v155 = v62 + 1;
                              v156 = &v215[6 * v62] > &v203;
                              if (v215 <= &v203 && v156)
                              {
                                v188 = (char *)&v203 - (char *)v215;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                v64 = v215;
                                v63 = (int *)((char *)v215 + v188);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v155, 24);
                                v63 = &v203;
                                v64 = v215;
                              }
                            }
                            v65 = &v64[6 * v216];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v216;
                            if (v214[0])
                            {
                              v203 = 3;
                              v204 = ", ";
                              v205 = 2;
                              v68 = &v203;
                              v69 = v215;
                              if (v67 >= v217)
                              {
                                v157 = v67 + 1;
                                v158 = &v215[6 * v67] > &v203;
                                if (v215 <= &v203 && v158)
                                {
                                  v189 = (char *)&v203 - (char *)v215;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  v69 = v215;
                                  v68 = (int *)((char *)v215 + v189);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v157, 24);
                                  v68 = &v203;
                                  v69 = v215;
                                }
                              }
                              v70 = &v69[6 * v216];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v216;
                              if (v214[0])
                              {
                                v203 = 3;
                                v204 = "RG16Float";
                                v205 = 9;
                                v73 = &v203;
                                v74 = v215;
                                if (v72 >= v217)
                                {
                                  v159 = v72 + 1;
                                  v160 = &v215[6 * v72] > &v203;
                                  if (v215 <= &v203 && v160)
                                  {
                                    v190 = (char *)&v203 - (char *)v215;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    v74 = v215;
                                    v73 = (int *)((char *)v215 + v190);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v159, 24);
                                    v73 = &v203;
                                    v74 = v215;
                                  }
                                }
                                v75 = &v74[6 * v216];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v216;
                                if (v214[0])
                                {
                                  v203 = 3;
                                  v204 = ", ";
                                  v205 = 2;
                                  v78 = &v203;
                                  v79 = v215;
                                  if (v77 >= v217)
                                  {
                                    v161 = v77 + 1;
                                    v162 = &v215[6 * v77] > &v203;
                                    if (v215 <= &v203 && v162)
                                    {
                                      v191 = (char *)&v203 - (char *)v215;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      v79 = v215;
                                      v78 = (int *)((char *)v215 + v191);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v161, 24);
                                      v78 = &v203;
                                      v79 = v215;
                                    }
                                  }
                                  v80 = &v79[6 * v216];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v216;
                                  if (v214[0])
                                  {
                                    v203 = 3;
                                    v204 = "RGBA16Float";
                                    v205 = 11;
                                    v83 = &v203;
                                    v84 = v215;
                                    if (v82 >= v217)
                                    {
                                      v163 = v82 + 1;
                                      v164 = &v215[6 * v82] > &v203;
                                      if (v215 <= &v203 && v164)
                                      {
                                        v192 = (char *)&v203 - (char *)v215;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        v84 = v215;
                                        v83 = (int *)((char *)v215 + v192);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v163, 24);
                                        v83 = &v203;
                                        v84 = v215;
                                      }
                                    }
                                    v85 = &v84[6 * v216];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v216;
                                    if (v214[0])
                                    {
                                      v203 = 3;
                                      v204 = ", ";
                                      v205 = 2;
                                      v88 = &v203;
                                      v89 = v215;
                                      if (v87 >= v217)
                                      {
                                        v165 = v87 + 1;
                                        v166 = &v215[6 * v87] > &v203;
                                        if (v215 <= &v203 && v166)
                                        {
                                          v193 = (char *)&v203 - (char *)v215;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          v89 = v215;
                                          v88 = (int *)((char *)v215 + v193);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v165, 24);
                                          v88 = &v203;
                                          v89 = v215;
                                        }
                                      }
                                      v90 = &v89[6 * v216];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v216;
                                      if (v214[0])
                                      {
                                        v203 = 3;
                                        v204 = "R32Float";
                                        v205 = 8;
                                        v93 = &v203;
                                        v94 = v215;
                                        if (v92 >= v217)
                                        {
                                          v168 = v92 + 1;
                                          v169 = &v215[6 * v92] > &v203;
                                          if (v215 <= &v203 && v169)
                                          {
                                            v194 = (char *)&v203 - (char *)v215;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            v94 = v215;
                                            v93 = (int *)((char *)v215 + v194);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v168, 24);
                                            v93 = &v203;
                                            v94 = v215;
                                          }
                                        }
                                        v95 = &v94[6 * v216];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        v97 = ++v216;
                                        if (v214[0])
                                        {
                                          v203 = 3;
                                          v204 = ", ";
                                          v205 = 2;
                                          v98 = &v203;
                                          v99 = v215;
                                          if (v97 >= v217)
                                          {
                                            v171 = v97 + 1;
                                            v172 = &v215[6 * v97] > &v203;
                                            if (v215 <= &v203 && v172)
                                            {
                                              v195 = (char *)&v203 - (char *)v215;
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              v99 = v215;
                                              v98 = (int *)((char *)v215 + v195);
                                            }
                                            else
                                            {
                                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v171, 24);
                                              v98 = &v203;
                                              v99 = v215;
                                            }
                                          }
                                          v100 = &v99[6 * v216];
                                          v101 = *(_OWORD *)v98;
                                          *((_QWORD *)v100 + 2) = *((_QWORD *)v98 + 2);
                                          *(_OWORD *)v100 = v101;
                                          v102 = ++v216;
                                          if (v214[0])
                                          {
                                            v203 = 3;
                                            v204 = "RG32Float";
                                            v205 = 9;
                                            v103 = &v203;
                                            v104 = v215;
                                            if (v102 >= v217)
                                            {
                                              v174 = v102 + 1;
                                              v175 = &v215[6 * v102] > &v203;
                                              if (v215 <= &v203 && v175)
                                              {
                                                v196 = (char *)&v203 - (char *)v215;
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                v104 = v215;
                                                v103 = (int *)((char *)v215 + v196);
                                              }
                                              else
                                              {
                                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v174, 24);
                                                v103 = &v203;
                                                v104 = v215;
                                              }
                                            }
                                            v105 = &v104[6 * v216];
                                            v106 = *(_OWORD *)v103;
                                            *((_QWORD *)v105 + 2) = *((_QWORD *)v103 + 2);
                                            *(_OWORD *)v105 = v106;
                                            v107 = ++v216;
                                            if (v214[0])
                                            {
                                              v203 = 3;
                                              v204 = ", ";
                                              v205 = 2;
                                              v108 = &v203;
                                              v109 = v215;
                                              if (v107 >= v217)
                                              {
                                                v177 = v107 + 1;
                                                v178 = &v215[6 * v107] > &v203;
                                                if (v215 <= &v203 && v178)
                                                {
                                                  v197 = (char *)&v203 - (char *)v215;
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  v109 = v215;
                                                  v108 = (int *)((char *)v215 + v197);
                                                }
                                                else
                                                {
                                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v177, 24);
                                                  v108 = &v203;
                                                  v109 = v215;
                                                }
                                              }
                                              v110 = &v109[6 * v216];
                                              v111 = *(_OWORD *)v108;
                                              *((_QWORD *)v110 + 2) = *((_QWORD *)v108 + 2);
                                              *(_OWORD *)v110 = v111;
                                              v112 = ++v216;
                                              if (v214[0])
                                              {
                                                v203 = 3;
                                                v204 = "RGBA32Float";
                                                v205 = 11;
                                                v113 = &v203;
                                                v114 = v215;
                                                if (v112 >= v217)
                                                {
                                                  v180 = v112 + 1;
                                                  v181 = &v215[6 * v112] > &v203;
                                                  if (v215 <= &v203 && v181)
                                                  {
                                                    v198 = (char *)&v203 - (char *)v215;
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    v114 = v215;
                                                    v113 = (int *)((char *)v215 + v198);
                                                  }
                                                  else
                                                  {
                                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v215, v218, v180, 24);
                                                    v113 = &v203;
                                                    v114 = v215;
                                                  }
                                                }
                                                v115 = &v114[6 * v216];
                                                v116 = *(_OWORD *)v113;
                                                *((_QWORD *)v115 + 2) = *((_QWORD *)v113 + 2);
                                                *(_OWORD *)v115 = v116;
                                                ++v216;
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v214);
    if (v214[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v214);
    if (v223)
    {
      v117 = v221;
      if (v221)
      {
        v118 = v222;
        v119 = v221;
        if (v222 != v221)
        {
          do
            v118 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v118 - 1);
          while (v118 != v117);
          v119 = v221;
        }
        v222 = v117;
        operator delete(v119);
      }
      v120 = v219;
      if (v219)
      {
        v121 = v220;
        v122 = v219;
        if (v220 != v219)
        {
          do
          {
            v124 = (void *)*--v121;
            v123 = v124;
            *v121 = 0;
            if (v124)
              operator delete[](v123);
          }
          while (v121 != v120);
          v122 = v219;
        }
        v220 = v120;
        operator delete(v122);
      }
      if (v215 != (int *)v218)
        free(v215);
    }
    goto LABEL_69;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v199[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v214[0] = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
    v214[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v214, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v199);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::MetalPixelFormatAttr::print(mlir::mps::MetalPixelFormatAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 9)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_16;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "R8Unorm";
  v9 = 7;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "RG8Unorm";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "RGBA8Unorm";
      v9 = 10;
      break;
    case 3u:
      v7 = 0;
      v8 = "BGRA8Unorm";
      v9 = 10;
      break;
    case 4u:
      v7 = 0;
      v8 = "R16Float";
      v9 = 8;
      break;
    case 5u:
      v7 = 0;
      v8 = "RG16Float";
      goto LABEL_15;
    case 6u:
      v7 = 0;
      v8 = "RGBA16Float";
      v9 = 11;
      break;
    case 7u:
      v7 = 0;
      v8 = "R32Float";
      v9 = 8;
      break;
    case 8u:
      v7 = 0;
      v8 = "RG32Float";
LABEL_15:
      v9 = 9;
      break;
    case 9u:
      v7 = 0;
      v8 = "RGBA32Float";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_16:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::NormalSamplingMethodAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, &v5);
}

uint64_t mlir::mps::NormalSamplingMethodAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  _QWORD **v35;
  _QWORD **v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  void *v42;
  uint64_t v43;
  _QWORD **v44;
  _QWORD **v45;
  void *v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  void *v50;
  void *v51;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  BOOL v59;
  unint64_t v60;
  BOOL v61;
  unint64_t v62;
  BOOL v63;
  unint64_t v64;
  BOOL v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  unsigned int v72[8];
  __int16 v73;
  uint64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  uint64_t v81;
  void *v82;
  _QWORD *v83;
  void *__p;
  _QWORD **v85;
  char v86;
  _QWORD v87[3];
  int *v88;
  unsigned int v89;
  unsigned int v90;
  _BYTE v91[96];
  _QWORD *v92;
  _QWORD *v93;
  _QWORD **v94;
  _QWORD **v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v74 = 0;
  v75 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v74))
  {
LABEL_47:
    v43 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v89) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v79, a1, v43, v87);
    if (v79[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    if (v86)
    {
      v44 = (_QWORD **)__p;
      if (__p)
      {
        v45 = v85;
        v46 = __p;
        if (v85 != __p)
        {
          do
            v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          v46 = __p;
        }
        v85 = v44;
        operator delete(v46);
      }
      v47 = v82;
      if (v82)
      {
        v48 = v83;
        v49 = v82;
        if (v83 != v82)
        {
          do
          {
            v51 = (void *)*--v48;
            v50 = v51;
            *v48 = 0;
            if (v51)
              operator delete[](v50);
          }
          while (v48 != v47);
          v49 = v82;
        }
        v83 = v47;
        operator delete(v49);
      }
      if (v80 != &v81)
        free(v80);
    }
    return 0;
  }
  if (v75 == 10)
  {
    if (*(_QWORD *)v74 != 0x6C6C756D5F786F62 || *(_WORD *)(v74 + 8) != 29285)
      goto LABEL_16;
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_68:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v72[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v87[0] = &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id;
    v87[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::NormalSamplingMethodAttrStorage,mlir::mps::NormalSamplingMethod>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail31NormalSamplingMethodAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_24NormalSamplingMethodAttrEJNS2_20NormalSamplingMethodEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v87, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id, v72);
  }
  if (v75 != 7 || (*(_DWORD *)v74 == 1601597033 ? (v3 = *(_DWORD *)(v74 + 3) == 1717855071) : (v3 = 0), !v3))
  {
LABEL_16:
    v73 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v87, a1, v2, v72);
    if (v87[0])
    {
      v76 = 3;
      v77 = "expected ";
      v78 = 9;
      v6 = &v76;
      v7 = v88;
      if (v89 >= v90)
      {
        v55 = v89 + 1;
        if (v88 <= &v76 && &v88[6 * v89] > &v76)
        {
          v66 = (char *)&v76 - (char *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
          v7 = v88;
          v6 = (int *)((char *)v88 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v55, 24);
          v6 = &v76;
          v7 = v88;
        }
      }
      v8 = &v7[6 * v89];
      v9 = *(_OWORD *)v6;
      *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
      *(_OWORD *)v8 = v9;
      v10 = ++v89;
      if (v87[0])
      {
        v76 = 3;
        v77 = "::mlir::mps::NormalSamplingMethod";
        v78 = 33;
        v11 = &v76;
        v12 = v88;
        if (v10 >= v90)
        {
          v56 = v10 + 1;
          v57 = &v88[6 * v10] > &v76;
          if (v88 <= &v76 && v57)
          {
            v67 = (char *)&v76 - (char *)v88;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
            v12 = v88;
            v11 = (int *)((char *)v88 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v56, 24);
            v11 = &v76;
            v12 = v88;
          }
        }
        v13 = &v12[6 * v89];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
        *(_OWORD *)v13 = v14;
        v15 = ++v89;
        if (v87[0])
        {
          v76 = 3;
          v77 = " to be one of: ";
          v78 = 15;
          v16 = &v76;
          v17 = v88;
          if (v15 >= v90)
          {
            v58 = v15 + 1;
            v59 = &v88[6 * v15] > &v76;
            if (v88 <= &v76 && v59)
            {
              v68 = (char *)&v76 - (char *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
              v17 = v88;
              v16 = (int *)((char *)v88 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v58, 24);
              v16 = &v76;
              v17 = v88;
            }
          }
          v18 = &v17[6 * v89];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
          *(_OWORD *)v18 = v19;
          v20 = ++v89;
          if (v87[0])
          {
            v76 = 3;
            v77 = "inv_cdf";
            v78 = 7;
            v21 = &v76;
            v22 = v88;
            if (v20 >= v90)
            {
              v60 = v20 + 1;
              v61 = &v88[6 * v20] > &v76;
              if (v88 <= &v76 && v61)
              {
                v69 = (char *)&v76 - (char *)v88;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                v22 = v88;
                v21 = (int *)((char *)v88 + v69);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v60, 24);
                v21 = &v76;
                v22 = v88;
              }
            }
            v23 = &v22[6 * v89];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
            *(_OWORD *)v23 = v24;
            v25 = ++v89;
            if (v87[0])
            {
              v76 = 3;
              v77 = ", ";
              v78 = 2;
              v26 = &v76;
              v27 = v88;
              if (v25 >= v90)
              {
                v62 = v25 + 1;
                v63 = &v88[6 * v25] > &v76;
                if (v88 <= &v76 && v63)
                {
                  v70 = (char *)&v76 - (char *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                  v27 = v88;
                  v26 = (int *)((char *)v88 + v70);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v62, 24);
                  v26 = &v76;
                  v27 = v88;
                }
              }
              v28 = &v27[6 * v89];
              v29 = *(_OWORD *)v26;
              *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
              *(_OWORD *)v28 = v29;
              v30 = ++v89;
              if (v87[0])
              {
                v76 = 3;
                v77 = "box_muller";
                v78 = 10;
                v31 = &v76;
                v32 = v88;
                if (v30 >= v90)
                {
                  v64 = v30 + 1;
                  v65 = &v88[6 * v30] > &v76;
                  if (v88 <= &v76 && v65)
                  {
                    v71 = (char *)&v76 - (char *)v88;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                    v32 = v88;
                    v31 = (int *)((char *)v88 + v71);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v64, 24);
                    v31 = &v76;
                    v32 = v88;
                  }
                }
                v33 = &v32[6 * v89];
                v34 = *(_OWORD *)v31;
                *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                *(_OWORD *)v33 = v34;
                ++v89;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v87);
    if (v87[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v87);
    if (v96)
    {
      v35 = v94;
      if (v94)
      {
        v36 = v95;
        v37 = v94;
        if (v95 != v94)
        {
          do
            v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
          while (v36 != v35);
          v37 = v94;
        }
        v95 = v35;
        operator delete(v37);
      }
      v38 = v92;
      if (v92)
      {
        v39 = v93;
        v40 = v92;
        if (v93 != v92)
        {
          do
          {
            v42 = (void *)*--v39;
            v41 = v42;
            *v39 = 0;
            if (v42)
              operator delete[](v41);
          }
          while (v39 != v38);
          v40 = v92;
        }
        v93 = v38;
        operator delete(v40);
      }
      if (v88 != (int *)v91)
        free(v88);
    }
    goto LABEL_47;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_68;
  return 0;
}

llvm::raw_ostream *mlir::mps::NormalSamplingMethodAttr::print(mlir::mps::NormalSamplingMethodAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  const char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = "";
  v8 = 10;
  if (v6 == 1)
    v7 = "box_muller";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 7;
  if (v6)
    v11 = v7;
  else
    v11 = "inv_cdf";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PaddingStyleAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v5);
}

uint64_t mlir::mps::PaddingStyleAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  _QWORD **v67;
  _QWORD **v68;
  void *v69;
  _QWORD *v70;
  _QWORD *v71;
  void *v72;
  void *v73;
  void *v74;
  uint64_t v75;
  _QWORD **v76;
  _QWORD **v77;
  void *v78;
  _QWORD *v79;
  _QWORD *v80;
  void *v81;
  void *v82;
  void *v83;
  unint64_t v84;
  unint64_t v85;
  BOOL v86;
  unint64_t v87;
  BOOL v88;
  unint64_t v89;
  BOOL v90;
  unint64_t v91;
  BOOL v92;
  unint64_t v93;
  BOOL v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  int64_t v107;
  int64_t v108;
  int64_t v109;
  int64_t v110;
  int64_t v111;
  int64_t v112;
  int64_t v113;
  int64_t v114;
  int64_t v115;
  int64_t v116;
  int64_t v117;
  int64_t v118;
  unsigned int v119[8];
  __int16 v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  const char *v124;
  uint64_t v125;
  _QWORD v126[3];
  void *v127;
  uint64_t v128;
  void *v129;
  _QWORD *v130;
  void *__p;
  _QWORD **v132;
  char v133;
  _QWORD v134[3];
  int *v135;
  unsigned int v136;
  unsigned int v137;
  _BYTE v138[96];
  _QWORD *v139;
  _QWORD *v140;
  _QWORD **v141;
  _QWORD **v142;
  char v143;
  uint64_t v144;

  v144 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v121 = 0;
  v122 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v121))
  {
LABEL_49:
    v75 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v136) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v126, a1, v75, v134);
    if (v126[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v126);
    if (v133)
    {
      v76 = (_QWORD **)__p;
      if (__p)
      {
        v77 = v132;
        v78 = __p;
        if (v132 != __p)
        {
          do
            v77 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v77 - 1);
          while (v77 != v76);
          v78 = __p;
        }
        v132 = v76;
        operator delete(v78);
      }
      v79 = v129;
      if (v129)
      {
        v80 = v130;
        v81 = v129;
        if (v130 != v129)
        {
          do
          {
            v83 = (void *)*--v80;
            v82 = v83;
            *v80 = 0;
            if (v83)
              operator delete[](v82);
          }
          while (v80 != v79);
          v81 = v129;
        }
        v130 = v79;
        operator delete(v81);
      }
      if (v127 != &v128)
        free(v127);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizePaddingStyle(v121, v122);
  if ((v3 & 0xFF00000000) == 0)
  {
    v120 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v134, a1, v2, v119);
    if (v134[0])
    {
      v123 = 3;
      v124 = "expected ";
      v125 = 9;
      v8 = &v123;
      v9 = v135;
      if (v136 >= v137)
      {
        v84 = v136 + 1;
        if (v135 <= &v123 && &v135[6 * v136] > &v123)
        {
          v107 = (char *)&v123 - (char *)v135;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          v9 = v135;
          v8 = (int *)((char *)v135 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v84, 24);
          v8 = &v123;
          v9 = v135;
        }
      }
      v10 = &v9[6 * v136];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v136;
      if (v134[0])
      {
        v123 = 3;
        v124 = "::mlir::mps::PaddingStyle";
        v125 = 25;
        v13 = &v123;
        v14 = v135;
        if (v12 >= v137)
        {
          v85 = v12 + 1;
          v86 = &v135[6 * v12] > &v123;
          if (v135 <= &v123 && v86)
          {
            v108 = (char *)&v123 - (char *)v135;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            v14 = v135;
            v13 = (int *)((char *)v135 + v108);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v85, 24);
            v13 = &v123;
            v14 = v135;
          }
        }
        v15 = &v14[6 * v136];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v136;
        if (v134[0])
        {
          v123 = 3;
          v124 = " to be one of: ";
          v125 = 15;
          v18 = &v123;
          v19 = v135;
          if (v17 >= v137)
          {
            v87 = v17 + 1;
            v88 = &v135[6 * v17] > &v123;
            if (v135 <= &v123 && v88)
            {
              v109 = (char *)&v123 - (char *)v135;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              v19 = v135;
              v18 = (int *)((char *)v135 + v109);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v87, 24);
              v18 = &v123;
              v19 = v135;
            }
          }
          v20 = &v19[6 * v136];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v136;
          if (v134[0])
          {
            v123 = 3;
            v124 = "EXPLICIT";
            v125 = 8;
            v23 = &v123;
            v24 = v135;
            if (v22 >= v137)
            {
              v89 = v22 + 1;
              v90 = &v135[6 * v22] > &v123;
              if (v135 <= &v123 && v90)
              {
                v110 = (char *)&v123 - (char *)v135;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                v24 = v135;
                v23 = (int *)((char *)v135 + v110);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v89, 24);
                v23 = &v123;
                v24 = v135;
              }
            }
            v25 = &v24[6 * v136];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v136;
            if (v134[0])
            {
              v123 = 3;
              v124 = ", ";
              v125 = 2;
              v28 = &v123;
              v29 = v135;
              if (v27 >= v137)
              {
                v91 = v27 + 1;
                v92 = &v135[6 * v27] > &v123;
                if (v135 <= &v123 && v92)
                {
                  v111 = (char *)&v123 - (char *)v135;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  v29 = v135;
                  v28 = (int *)((char *)v135 + v111);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v91, 24);
                  v28 = &v123;
                  v29 = v135;
                }
              }
              v30 = &v29[6 * v136];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v136;
              if (v134[0])
              {
                v123 = 3;
                v124 = "TF_VALID";
                v125 = 8;
                v33 = &v123;
                v34 = v135;
                if (v32 >= v137)
                {
                  v93 = v32 + 1;
                  v94 = &v135[6 * v32] > &v123;
                  if (v135 <= &v123 && v94)
                  {
                    v112 = (char *)&v123 - (char *)v135;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    v34 = v135;
                    v33 = (int *)((char *)v135 + v112);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v93, 24);
                    v33 = &v123;
                    v34 = v135;
                  }
                }
                v35 = &v34[6 * v136];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v136;
                if (v134[0])
                {
                  v123 = 3;
                  v124 = ", ";
                  v125 = 2;
                  v38 = &v123;
                  v39 = v135;
                  if (v37 >= v137)
                  {
                    v95 = v37 + 1;
                    v96 = &v135[6 * v37] > &v123;
                    if (v135 <= &v123 && v96)
                    {
                      v113 = (char *)&v123 - (char *)v135;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      v39 = v135;
                      v38 = (int *)((char *)v135 + v113);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v95, 24);
                      v38 = &v123;
                      v39 = v135;
                    }
                  }
                  v40 = &v39[6 * v136];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v136;
                  if (v134[0])
                  {
                    v123 = 3;
                    v124 = "TF_SAME";
                    v125 = 7;
                    v43 = &v123;
                    v44 = v135;
                    if (v42 >= v137)
                    {
                      v97 = v42 + 1;
                      v98 = &v135[6 * v42] > &v123;
                      if (v135 <= &v123 && v98)
                      {
                        v114 = (char *)&v123 - (char *)v135;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        v44 = v135;
                        v43 = (int *)((char *)v135 + v114);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v97, 24);
                        v43 = &v123;
                        v44 = v135;
                      }
                    }
                    v45 = &v44[6 * v136];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v136;
                    if (v134[0])
                    {
                      v123 = 3;
                      v124 = ", ";
                      v125 = 2;
                      v48 = &v123;
                      v49 = v135;
                      if (v47 >= v137)
                      {
                        v99 = v47 + 1;
                        v100 = &v135[6 * v47] > &v123;
                        if (v135 <= &v123 && v100)
                        {
                          v115 = (char *)&v123 - (char *)v135;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          v49 = v135;
                          v48 = (int *)((char *)v135 + v115);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v99, 24);
                          v48 = &v123;
                          v49 = v135;
                        }
                      }
                      v50 = &v49[6 * v136];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v136;
                      if (v134[0])
                      {
                        v123 = 3;
                        v124 = "EXPLICIT_OFFSET";
                        v125 = 15;
                        v53 = &v123;
                        v54 = v135;
                        if (v52 >= v137)
                        {
                          v101 = v52 + 1;
                          v102 = &v135[6 * v52] > &v123;
                          if (v135 <= &v123 && v102)
                          {
                            v116 = (char *)&v123 - (char *)v135;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            v54 = v135;
                            v53 = (int *)((char *)v135 + v116);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v101, 24);
                            v53 = &v123;
                            v54 = v135;
                          }
                        }
                        v55 = &v54[6 * v136];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v136;
                        if (v134[0])
                        {
                          v123 = 3;
                          v124 = ", ";
                          v125 = 2;
                          v58 = &v123;
                          v59 = v135;
                          if (v57 >= v137)
                          {
                            v103 = v57 + 1;
                            v104 = &v135[6 * v57] > &v123;
                            if (v135 <= &v123 && v104)
                            {
                              v117 = (char *)&v123 - (char *)v135;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              v59 = v135;
                              v58 = (int *)((char *)v135 + v117);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v103, 24);
                              v58 = &v123;
                              v59 = v135;
                            }
                          }
                          v60 = &v59[6 * v136];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v136;
                          if (v134[0])
                          {
                            v123 = 3;
                            v124 = "ONNX_SAME_LOWER";
                            v125 = 15;
                            v63 = &v123;
                            v64 = v135;
                            if (v62 >= v137)
                            {
                              v105 = v62 + 1;
                              v106 = &v135[6 * v62] > &v123;
                              if (v135 <= &v123 && v106)
                              {
                                v118 = (char *)&v123 - (char *)v135;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                v64 = v135;
                                v63 = (int *)((char *)v135 + v118);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v135, v138, v105, 24);
                                v63 = &v123;
                                v64 = v135;
                              }
                            }
                            v65 = &v64[6 * v136];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            ++v136;
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v134);
    if (v134[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v134);
    if (v143)
    {
      v67 = v141;
      if (v141)
      {
        v68 = v142;
        v69 = v141;
        if (v142 != v141)
        {
          do
            v68 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v68 - 1);
          while (v68 != v67);
          v69 = v141;
        }
        v142 = v67;
        operator delete(v69);
      }
      v70 = v139;
      if (v139)
      {
        v71 = v140;
        v72 = v139;
        if (v140 != v139)
        {
          do
          {
            v74 = (void *)*--v71;
            v73 = v74;
            *v71 = 0;
            if (v74)
              operator delete[](v73);
          }
          while (v71 != v70);
          v72 = v139;
        }
        v140 = v70;
        operator delete(v72);
      }
      if (v135 != (int *)v138)
        free(v135);
    }
    goto LABEL_49;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v119[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v134[0] = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
    v134[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v134, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, v119);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PaddingStyleAttr::print(mlir::mps::PaddingStyleAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 4)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "EXPLICIT";
  v9 = 8;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "TF_VALID";
      v9 = 8;
      break;
    case 2u:
      v7 = 0;
      v8 = "TF_SAME";
      v9 = 7;
      break;
    case 3u:
      v7 = 0;
      v8 = "EXPLICIT_OFFSET";
      goto LABEL_10;
    case 4u:
      v7 = 0;
      v8 = "ONNX_SAME_LOWER";
LABEL_10:
      v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PoolIndicesModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::PoolIndicesModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  uint64_t v87;
  int *v88;
  int *v89;
  int *v90;
  __int128 v91;
  uint64_t v92;
  int *v93;
  int *v94;
  int *v95;
  __int128 v96;
  _QWORD **v97;
  _QWORD **v98;
  void *v99;
  _QWORD *v100;
  _QWORD *v101;
  void *v102;
  void *v103;
  void *v104;
  uint64_t v105;
  _QWORD **v106;
  _QWORD **v107;
  void *v108;
  _QWORD *v109;
  _QWORD *v110;
  void *v111;
  void *v112;
  void *v113;
  unint64_t v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  unint64_t v135;
  BOOL v136;
  unint64_t v137;
  BOOL v138;
  unint64_t v139;
  BOOL v140;
  unint64_t v141;
  BOOL v142;
  unint64_t v143;
  BOOL v144;
  unint64_t v145;
  BOOL v146;
  int64_t v147;
  unint64_t v148;
  BOOL v149;
  int64_t v150;
  int64_t v151;
  int64_t v152;
  int64_t v153;
  int64_t v154;
  int64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  int64_t v161;
  int64_t v162;
  int64_t v163;
  int64_t v164;
  int64_t v165;
  int64_t v166;
  unsigned int v167[8];
  __int16 v168;
  _QWORD *v169;
  uint64_t v170;
  int v171;
  const char *v172;
  uint64_t v173;
  _QWORD v174[3];
  void *v175;
  uint64_t v176;
  void *v177;
  _QWORD *v178;
  void *__p;
  _QWORD **v180;
  char v181;
  _QWORD v182[3];
  int *v183;
  unsigned int v184;
  unsigned int v185;
  _BYTE v186[96];
  _QWORD *v187;
  _QWORD *v188;
  _QWORD **v189;
  _QWORD **v190;
  char v191;
  uint64_t v192;

  v192 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v169 = 0;
  v170 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v169))
  {
LABEL_61:
    v105 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v184) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v174, a1, v105, v182);
    if (v174[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v174);
    if (v181)
    {
      v106 = (_QWORD **)__p;
      if (__p)
      {
        v107 = v180;
        v108 = __p;
        if (v180 != __p)
        {
          do
            v107 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v107 - 1);
          while (v107 != v106);
          v108 = __p;
        }
        v180 = v106;
        operator delete(v108);
      }
      v109 = v177;
      if (v177)
      {
        v110 = v178;
        v111 = v177;
        if (v178 != v177)
        {
          do
          {
            v113 = (void *)*--v110;
            v112 = v113;
            *v110 = 0;
            if (v113)
              operator delete[](v112);
          }
          while (v110 != v109);
          v111 = v177;
        }
        v178 = v109;
        operator delete(v111);
      }
      if (v175 != &v176)
        free(v175);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizePoolIndicesMode(v169, v170);
  if ((v3 & 0xFF00000000) == 0)
  {
    v168 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v182, a1, v2, v167);
    if (v182[0])
    {
      v171 = 3;
      v172 = "expected ";
      v173 = 9;
      v8 = &v171;
      v9 = v183;
      if (v184 >= v185)
      {
        v114 = v184 + 1;
        if (v183 <= &v171 && &v183[6 * v184] > &v171)
        {
          v147 = (char *)&v171 - (char *)v183;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          v9 = v183;
          v8 = (int *)((char *)v183 + v147);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v114, 24);
          v8 = &v171;
          v9 = v183;
        }
      }
      v10 = &v9[6 * v184];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v184;
      if (v182[0])
      {
        v171 = 3;
        v172 = "::mlir::mps::PoolIndicesMode";
        v173 = 28;
        v13 = &v171;
        v14 = v183;
        if (v12 >= v185)
        {
          v115 = v12 + 1;
          v116 = &v183[6 * v12] > &v171;
          if (v183 <= &v171 && v116)
          {
            v150 = (char *)&v171 - (char *)v183;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            v14 = v183;
            v13 = (int *)((char *)v183 + v150);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v115, 24);
            v13 = &v171;
            v14 = v183;
          }
        }
        v15 = &v14[6 * v184];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v184;
        if (v182[0])
        {
          v171 = 3;
          v172 = " to be one of: ";
          v173 = 15;
          v18 = &v171;
          v19 = v183;
          if (v17 >= v185)
          {
            v117 = v17 + 1;
            v118 = &v183[6 * v17] > &v171;
            if (v183 <= &v171 && v118)
            {
              v151 = (char *)&v171 - (char *)v183;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              v19 = v183;
              v18 = (int *)((char *)v183 + v151);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v117, 24);
              v18 = &v171;
              v19 = v183;
            }
          }
          v20 = &v19[6 * v184];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v184;
          if (v182[0])
          {
            v171 = 3;
            v172 = "Global_Flatten1D";
            v173 = 16;
            v23 = &v171;
            v24 = v183;
            if (v22 >= v185)
            {
              v119 = v22 + 1;
              v120 = &v183[6 * v22] > &v171;
              if (v183 <= &v171 && v120)
              {
                v152 = (char *)&v171 - (char *)v183;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                v24 = v183;
                v23 = (int *)((char *)v183 + v152);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v119, 24);
                v23 = &v171;
                v24 = v183;
              }
            }
            v25 = &v24[6 * v184];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v184;
            if (v182[0])
            {
              v171 = 3;
              v172 = ", ";
              v173 = 2;
              v28 = &v171;
              v29 = v183;
              if (v27 >= v185)
              {
                v121 = v27 + 1;
                v122 = &v183[6 * v27] > &v171;
                if (v183 <= &v171 && v122)
                {
                  v153 = (char *)&v171 - (char *)v183;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  v29 = v183;
                  v28 = (int *)((char *)v183 + v153);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v121, 24);
                  v28 = &v171;
                  v29 = v183;
                }
              }
              v30 = &v29[6 * v184];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v184;
              if (v182[0])
              {
                v171 = 3;
                v172 = "Global_Flatten2D";
                v173 = 16;
                v33 = &v171;
                v34 = v183;
                if (v32 >= v185)
                {
                  v123 = v32 + 1;
                  v124 = &v183[6 * v32] > &v171;
                  if (v183 <= &v171 && v124)
                  {
                    v154 = (char *)&v171 - (char *)v183;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    v34 = v183;
                    v33 = (int *)((char *)v183 + v154);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v123, 24);
                    v33 = &v171;
                    v34 = v183;
                  }
                }
                v35 = &v34[6 * v184];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v184;
                if (v182[0])
                {
                  v171 = 3;
                  v172 = ", ";
                  v173 = 2;
                  v38 = &v171;
                  v39 = v183;
                  if (v37 >= v185)
                  {
                    v125 = v37 + 1;
                    v126 = &v183[6 * v37] > &v171;
                    if (v183 <= &v171 && v126)
                    {
                      v155 = (char *)&v171 - (char *)v183;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      v39 = v183;
                      v38 = (int *)((char *)v183 + v155);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v125, 24);
                      v38 = &v171;
                      v39 = v183;
                    }
                  }
                  v40 = &v39[6 * v184];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v184;
                  if (v182[0])
                  {
                    v171 = 3;
                    v172 = "Global_Flatten3D";
                    v173 = 16;
                    v43 = &v171;
                    v44 = v183;
                    if (v42 >= v185)
                    {
                      v127 = v42 + 1;
                      v128 = &v183[6 * v42] > &v171;
                      if (v183 <= &v171 && v128)
                      {
                        v156 = (char *)&v171 - (char *)v183;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        v44 = v183;
                        v43 = (int *)((char *)v183 + v156);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v127, 24);
                        v43 = &v171;
                        v44 = v183;
                      }
                    }
                    v45 = &v44[6 * v184];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v184;
                    if (v182[0])
                    {
                      v171 = 3;
                      v172 = ", ";
                      v173 = 2;
                      v48 = &v171;
                      v49 = v183;
                      if (v47 >= v185)
                      {
                        v129 = v47 + 1;
                        v130 = &v183[6 * v47] > &v171;
                        if (v183 <= &v171 && v130)
                        {
                          v157 = (char *)&v171 - (char *)v183;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          v49 = v183;
                          v48 = (int *)((char *)v183 + v157);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v129, 24);
                          v48 = &v171;
                          v49 = v183;
                        }
                      }
                      v50 = &v49[6 * v184];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v184;
                      if (v182[0])
                      {
                        v171 = 3;
                        v172 = "Global_Flatten4D";
                        v173 = 16;
                        v53 = &v171;
                        v54 = v183;
                        if (v52 >= v185)
                        {
                          v131 = v52 + 1;
                          v132 = &v183[6 * v52] > &v171;
                          if (v183 <= &v171 && v132)
                          {
                            v158 = (char *)&v171 - (char *)v183;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            v54 = v183;
                            v53 = (int *)((char *)v183 + v158);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v131, 24);
                            v53 = &v171;
                            v54 = v183;
                          }
                        }
                        v55 = &v54[6 * v184];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v184;
                        if (v182[0])
                        {
                          v171 = 3;
                          v172 = ", ";
                          v173 = 2;
                          v58 = &v171;
                          v59 = v183;
                          if (v57 >= v185)
                          {
                            v133 = v57 + 1;
                            v134 = &v183[6 * v57] > &v171;
                            if (v183 <= &v171 && v134)
                            {
                              v159 = (char *)&v171 - (char *)v183;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              v59 = v183;
                              v58 = (int *)((char *)v183 + v159);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v133, 24);
                              v58 = &v171;
                              v59 = v183;
                            }
                          }
                          v60 = &v59[6 * v184];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v184;
                          if (v182[0])
                          {
                            v171 = 3;
                            v172 = "Local_Flatten1D";
                            v173 = 15;
                            v63 = &v171;
                            v64 = v183;
                            if (v62 >= v185)
                            {
                              v135 = v62 + 1;
                              v136 = &v183[6 * v62] > &v171;
                              if (v183 <= &v171 && v136)
                              {
                                v160 = (char *)&v171 - (char *)v183;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                v64 = v183;
                                v63 = (int *)((char *)v183 + v160);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v135, 24);
                                v63 = &v171;
                                v64 = v183;
                              }
                            }
                            v65 = &v64[6 * v184];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v184;
                            if (v182[0])
                            {
                              v171 = 3;
                              v172 = ", ";
                              v173 = 2;
                              v68 = &v171;
                              v69 = v183;
                              if (v67 >= v185)
                              {
                                v137 = v67 + 1;
                                v138 = &v183[6 * v67] > &v171;
                                if (v183 <= &v171 && v138)
                                {
                                  v161 = (char *)&v171 - (char *)v183;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  v69 = v183;
                                  v68 = (int *)((char *)v183 + v161);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v137, 24);
                                  v68 = &v171;
                                  v69 = v183;
                                }
                              }
                              v70 = &v69[6 * v184];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v184;
                              if (v182[0])
                              {
                                v171 = 3;
                                v172 = "Local_Flatten2D";
                                v173 = 15;
                                v73 = &v171;
                                v74 = v183;
                                if (v72 >= v185)
                                {
                                  v139 = v72 + 1;
                                  v140 = &v183[6 * v72] > &v171;
                                  if (v183 <= &v171 && v140)
                                  {
                                    v162 = (char *)&v171 - (char *)v183;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    v74 = v183;
                                    v73 = (int *)((char *)v183 + v162);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v139, 24);
                                    v73 = &v171;
                                    v74 = v183;
                                  }
                                }
                                v75 = &v74[6 * v184];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v184;
                                if (v182[0])
                                {
                                  v171 = 3;
                                  v172 = ", ";
                                  v173 = 2;
                                  v78 = &v171;
                                  v79 = v183;
                                  if (v77 >= v185)
                                  {
                                    v141 = v77 + 1;
                                    v142 = &v183[6 * v77] > &v171;
                                    if (v183 <= &v171 && v142)
                                    {
                                      v163 = (char *)&v171 - (char *)v183;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      v79 = v183;
                                      v78 = (int *)((char *)v183 + v163);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v141, 24);
                                      v78 = &v171;
                                      v79 = v183;
                                    }
                                  }
                                  v80 = &v79[6 * v184];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v184;
                                  if (v182[0])
                                  {
                                    v171 = 3;
                                    v172 = "Local_Flatten3D";
                                    v173 = 15;
                                    v83 = &v171;
                                    v84 = v183;
                                    if (v82 >= v185)
                                    {
                                      v143 = v82 + 1;
                                      v144 = &v183[6 * v82] > &v171;
                                      if (v183 <= &v171 && v144)
                                      {
                                        v164 = (char *)&v171 - (char *)v183;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        v84 = v183;
                                        v83 = (int *)((char *)v183 + v164);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v143, 24);
                                        v83 = &v171;
                                        v84 = v183;
                                      }
                                    }
                                    v85 = &v84[6 * v184];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    v87 = ++v184;
                                    if (v182[0])
                                    {
                                      v171 = 3;
                                      v172 = ", ";
                                      v173 = 2;
                                      v88 = &v171;
                                      v89 = v183;
                                      if (v87 >= v185)
                                      {
                                        v145 = v87 + 1;
                                        v146 = &v183[6 * v87] > &v171;
                                        if (v183 <= &v171 && v146)
                                        {
                                          v165 = (char *)&v171 - (char *)v183;
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          v89 = v183;
                                          v88 = (int *)((char *)v183 + v165);
                                        }
                                        else
                                        {
                                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v145, 24);
                                          v88 = &v171;
                                          v89 = v183;
                                        }
                                      }
                                      v90 = &v89[6 * v184];
                                      v91 = *(_OWORD *)v88;
                                      *((_QWORD *)v90 + 2) = *((_QWORD *)v88 + 2);
                                      *(_OWORD *)v90 = v91;
                                      v92 = ++v184;
                                      if (v182[0])
                                      {
                                        v171 = 3;
                                        v172 = "Local_Flatten4D";
                                        v173 = 15;
                                        v93 = &v171;
                                        v94 = v183;
                                        if (v92 >= v185)
                                        {
                                          v148 = v92 + 1;
                                          v149 = &v183[6 * v92] > &v171;
                                          if (v183 <= &v171 && v149)
                                          {
                                            v166 = (char *)&v171 - (char *)v183;
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            v94 = v183;
                                            v93 = (int *)((char *)v183 + v166);
                                          }
                                          else
                                          {
                                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v183, v186, v148, 24);
                                            v93 = &v171;
                                            v94 = v183;
                                          }
                                        }
                                        v95 = &v94[6 * v184];
                                        v96 = *(_OWORD *)v93;
                                        *((_QWORD *)v95 + 2) = *((_QWORD *)v93 + 2);
                                        *(_OWORD *)v95 = v96;
                                        ++v184;
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v182);
    if (v182[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v182);
    if (v191)
    {
      v97 = v189;
      if (v189)
      {
        v98 = v190;
        v99 = v189;
        if (v190 != v189)
        {
          do
            v98 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v98 - 1);
          while (v98 != v97);
          v99 = v189;
        }
        v190 = v97;
        operator delete(v99);
      }
      v100 = v187;
      if (v187)
      {
        v101 = v188;
        v102 = v187;
        if (v188 != v187)
        {
          do
          {
            v104 = (void *)*--v101;
            v103 = v104;
            *v101 = 0;
            if (v104)
              operator delete[](v103);
          }
          while (v101 != v100);
          v102 = v187;
        }
        v188 = v100;
        operator delete(v102);
      }
      if (v183 != (int *)v186)
        free(v183);
    }
    goto LABEL_61;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v167[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v182[0] = &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id;
    v182[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PoolIndicesModeAttrStorage,mlir::mps::PoolIndicesMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26PoolIndicesModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19PoolIndicesModeAttrEJNS2_15PoolIndicesModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v182, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id, v167);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PoolIndicesModeAttr::print(mlir::mps::PoolIndicesModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 7)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_14;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "Global_Flatten1D";
  v9 = 16;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "Global_Flatten2D";
      v9 = 16;
      break;
    case 2u:
      v7 = 0;
      v8 = "Global_Flatten3D";
      v9 = 16;
      break;
    case 3u:
      v7 = 0;
      v8 = "Global_Flatten4D";
      v9 = 16;
      break;
    case 4u:
      v7 = 0;
      v8 = "Local_Flatten1D";
      goto LABEL_13;
    case 5u:
      v7 = 0;
      v8 = "Local_Flatten2D";
      goto LABEL_13;
    case 6u:
      v7 = 0;
      v8 = "Local_Flatten3D";
      goto LABEL_13;
    case 7u:
      v7 = 0;
      v8 = "Local_Flatten4D";
LABEL_13:
      v9 = 15;
      break;
    default:
      goto LABEL_6;
  }
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::RNNActivationAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v5);
}

uint64_t mlir::mps::RNNActivationAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  _QWORD **v77;
  _QWORD **v78;
  void *v79;
  _QWORD *v80;
  _QWORD *v81;
  void *v82;
  void *v83;
  void *v84;
  uint64_t v85;
  _QWORD **v86;
  _QWORD **v87;
  void *v88;
  _QWORD *v89;
  _QWORD *v90;
  void *v91;
  void *v92;
  void *v93;
  unint64_t v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  BOOL v98;
  unint64_t v99;
  BOOL v100;
  unint64_t v101;
  BOOL v102;
  unint64_t v103;
  BOOL v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  int64_t v121;
  int64_t v122;
  int64_t v123;
  int64_t v124;
  int64_t v125;
  int64_t v126;
  int64_t v127;
  int64_t v128;
  int64_t v129;
  int64_t v130;
  int64_t v131;
  int64_t v132;
  int64_t v133;
  int64_t v134;
  unsigned int v135[8];
  __int16 v136;
  int *v137;
  uint64_t v138;
  int v139;
  const char *v140;
  uint64_t v141;
  _QWORD v142[3];
  void *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  void *__p;
  _QWORD **v148;
  char v149;
  _QWORD v150[3];
  int *v151;
  unsigned int v152;
  unsigned int v153;
  _BYTE v154[96];
  _QWORD *v155;
  _QWORD *v156;
  _QWORD **v157;
  _QWORD **v158;
  char v159;
  uint64_t v160;

  v160 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v137 = 0;
  v138 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v137))
  {
LABEL_53:
    v85 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v152) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v142, a1, v85, v150);
    if (v142[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v142);
    if (v149)
    {
      v86 = (_QWORD **)__p;
      if (__p)
      {
        v87 = v148;
        v88 = __p;
        if (v148 != __p)
        {
          do
            v87 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v87 - 1);
          while (v87 != v86);
          v88 = __p;
        }
        v148 = v86;
        operator delete(v88);
      }
      v89 = v145;
      if (v145)
      {
        v90 = v146;
        v91 = v145;
        if (v146 != v145)
        {
          do
          {
            v93 = (void *)*--v90;
            v92 = v93;
            *v90 = 0;
            if (v93)
              operator delete[](v92);
          }
          while (v90 != v89);
          v91 = v145;
        }
        v146 = v89;
        operator delete(v91);
      }
      if (v143 != &v144)
        free(v143);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeRNNActivation(v137, v138);
  if ((v3 & 0xFF00000000) == 0)
  {
    v136 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v150, a1, v2, v135);
    if (v150[0])
    {
      v139 = 3;
      v140 = "expected ";
      v141 = 9;
      v8 = &v139;
      v9 = v151;
      if (v152 >= v153)
      {
        v94 = v152 + 1;
        if (v151 <= &v139 && &v151[6 * v152] > &v139)
        {
          v121 = (char *)&v139 - (char *)v151;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v9 = v151;
          v8 = (int *)((char *)v151 + v121);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v94, 24);
          v8 = &v139;
          v9 = v151;
        }
      }
      v10 = &v9[6 * v152];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v152;
      if (v150[0])
      {
        v139 = 3;
        v140 = "::mlir::mps::RNNActivation";
        v141 = 26;
        v13 = &v139;
        v14 = v151;
        if (v12 >= v153)
        {
          v95 = v12 + 1;
          v96 = &v151[6 * v12] > &v139;
          if (v151 <= &v139 && v96)
          {
            v122 = (char *)&v139 - (char *)v151;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v14 = v151;
            v13 = (int *)((char *)v151 + v122);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v95, 24);
            v13 = &v139;
            v14 = v151;
          }
        }
        v15 = &v14[6 * v152];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v152;
        if (v150[0])
        {
          v139 = 3;
          v140 = " to be one of: ";
          v141 = 15;
          v18 = &v139;
          v19 = v151;
          if (v17 >= v153)
          {
            v97 = v17 + 1;
            v98 = &v151[6 * v17] > &v139;
            if (v151 <= &v139 && v98)
            {
              v123 = (char *)&v139 - (char *)v151;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v19 = v151;
              v18 = (int *)((char *)v151 + v123);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v97, 24);
              v18 = &v139;
              v19 = v151;
            }
          }
          v20 = &v19[6 * v152];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v152;
          if (v150[0])
          {
            v139 = 3;
            v140 = "none";
            v141 = 4;
            v23 = &v139;
            v24 = v151;
            if (v22 >= v153)
            {
              v99 = v22 + 1;
              v100 = &v151[6 * v22] > &v139;
              if (v151 <= &v139 && v100)
              {
                v124 = (char *)&v139 - (char *)v151;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v24 = v151;
                v23 = (int *)((char *)v151 + v124);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v99, 24);
                v23 = &v139;
                v24 = v151;
              }
            }
            v25 = &v24[6 * v152];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v152;
            if (v150[0])
            {
              v139 = 3;
              v140 = ", ";
              v141 = 2;
              v28 = &v139;
              v29 = v151;
              if (v27 >= v153)
              {
                v101 = v27 + 1;
                v102 = &v151[6 * v27] > &v139;
                if (v151 <= &v139 && v102)
                {
                  v125 = (char *)&v139 - (char *)v151;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v29 = v151;
                  v28 = (int *)((char *)v151 + v125);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v101, 24);
                  v28 = &v139;
                  v29 = v151;
                }
              }
              v30 = &v29[6 * v152];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v152;
              if (v150[0])
              {
                v139 = 3;
                v140 = "relu";
                v141 = 4;
                v33 = &v139;
                v34 = v151;
                if (v32 >= v153)
                {
                  v103 = v32 + 1;
                  v104 = &v151[6 * v32] > &v139;
                  if (v151 <= &v139 && v104)
                  {
                    v126 = (char *)&v139 - (char *)v151;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v34 = v151;
                    v33 = (int *)((char *)v151 + v126);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v103, 24);
                    v33 = &v139;
                    v34 = v151;
                  }
                }
                v35 = &v34[6 * v152];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v152;
                if (v150[0])
                {
                  v139 = 3;
                  v140 = ", ";
                  v141 = 2;
                  v38 = &v139;
                  v39 = v151;
                  if (v37 >= v153)
                  {
                    v105 = v37 + 1;
                    v106 = &v151[6 * v37] > &v139;
                    if (v151 <= &v139 && v106)
                    {
                      v127 = (char *)&v139 - (char *)v151;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v39 = v151;
                      v38 = (int *)((char *)v151 + v127);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v105, 24);
                      v38 = &v139;
                      v39 = v151;
                    }
                  }
                  v40 = &v39[6 * v152];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v152;
                  if (v150[0])
                  {
                    v139 = 3;
                    v140 = "tanh";
                    v141 = 4;
                    v43 = &v139;
                    v44 = v151;
                    if (v42 >= v153)
                    {
                      v107 = v42 + 1;
                      v108 = &v151[6 * v42] > &v139;
                      if (v151 <= &v139 && v108)
                      {
                        v128 = (char *)&v139 - (char *)v151;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v44 = v151;
                        v43 = (int *)((char *)v151 + v128);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v107, 24);
                        v43 = &v139;
                        v44 = v151;
                      }
                    }
                    v45 = &v44[6 * v152];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v152;
                    if (v150[0])
                    {
                      v139 = 3;
                      v140 = ", ";
                      v141 = 2;
                      v48 = &v139;
                      v49 = v151;
                      if (v47 >= v153)
                      {
                        v109 = v47 + 1;
                        v110 = &v151[6 * v47] > &v139;
                        if (v151 <= &v139 && v110)
                        {
                          v129 = (char *)&v139 - (char *)v151;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v49 = v151;
                          v48 = (int *)((char *)v151 + v129);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v109, 24);
                          v48 = &v139;
                          v49 = v151;
                        }
                      }
                      v50 = &v49[6 * v152];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v152;
                      if (v150[0])
                      {
                        v139 = 3;
                        v140 = "sigmoid";
                        v141 = 7;
                        v53 = &v139;
                        v54 = v151;
                        if (v52 >= v153)
                        {
                          v111 = v52 + 1;
                          v112 = &v151[6 * v52] > &v139;
                          if (v151 <= &v139 && v112)
                          {
                            v130 = (char *)&v139 - (char *)v151;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v54 = v151;
                            v53 = (int *)((char *)v151 + v130);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v111, 24);
                            v53 = &v139;
                            v54 = v151;
                          }
                        }
                        v55 = &v54[6 * v152];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v152;
                        if (v150[0])
                        {
                          v139 = 3;
                          v140 = ", ";
                          v141 = 2;
                          v58 = &v139;
                          v59 = v151;
                          if (v57 >= v153)
                          {
                            v113 = v57 + 1;
                            v114 = &v151[6 * v57] > &v139;
                            if (v151 <= &v139 && v114)
                            {
                              v131 = (char *)&v139 - (char *)v151;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v59 = v151;
                              v58 = (int *)((char *)v151 + v131);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v113, 24);
                              v58 = &v139;
                              v59 = v151;
                            }
                          }
                          v60 = &v59[6 * v152];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v152;
                          if (v150[0])
                          {
                            v139 = 3;
                            v140 = "hard_sigmoid";
                            v141 = 12;
                            v63 = &v139;
                            v64 = v151;
                            if (v62 >= v153)
                            {
                              v115 = v62 + 1;
                              v116 = &v151[6 * v62] > &v139;
                              if (v151 <= &v139 && v116)
                              {
                                v132 = (char *)&v139 - (char *)v151;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v64 = v151;
                                v63 = (int *)((char *)v151 + v132);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v115, 24);
                                v63 = &v139;
                                v64 = v151;
                              }
                            }
                            v65 = &v64[6 * v152];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v152;
                            if (v150[0])
                            {
                              v139 = 3;
                              v140 = ", ";
                              v141 = 2;
                              v68 = &v139;
                              v69 = v151;
                              if (v67 >= v153)
                              {
                                v117 = v67 + 1;
                                v118 = &v151[6 * v67] > &v139;
                                if (v151 <= &v139 && v118)
                                {
                                  v133 = (char *)&v139 - (char *)v151;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v69 = v151;
                                  v68 = (int *)((char *)v151 + v133);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v117, 24);
                                  v68 = &v139;
                                  v69 = v151;
                                }
                              }
                              v70 = &v69[6 * v152];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v152;
                              if (v150[0])
                              {
                                v139 = 3;
                                v140 = "scaled_tanh";
                                v141 = 11;
                                v73 = &v139;
                                v74 = v151;
                                if (v72 >= v153)
                                {
                                  v119 = v72 + 1;
                                  v120 = &v151[6 * v72] > &v139;
                                  if (v151 <= &v139 && v120)
                                  {
                                    v134 = (char *)&v139 - (char *)v151;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v74 = v151;
                                    v73 = (int *)((char *)v151 + v134);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v151, v154, v119, 24);
                                    v73 = &v139;
                                    v74 = v151;
                                  }
                                }
                                v75 = &v74[6 * v152];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                ++v152;
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v150);
    if (v150[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v150);
    if (v159)
    {
      v77 = v157;
      if (v157)
      {
        v78 = v158;
        v79 = v157;
        if (v158 != v157)
        {
          do
            v78 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v78 - 1);
          while (v78 != v77);
          v79 = v157;
        }
        v158 = v77;
        operator delete(v79);
      }
      v80 = v155;
      if (v155)
      {
        v81 = v156;
        v82 = v155;
        if (v156 != v155)
        {
          do
          {
            v84 = (void *)*--v81;
            v83 = v84;
            *v81 = 0;
            if (v84)
              operator delete[](v83);
          }
          while (v81 != v80);
          v82 = v155;
        }
        v156 = v80;
        operator delete(v82);
      }
      if (v151 != (int *)v154)
        free(v151);
    }
    goto LABEL_53;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v135[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v150[0] = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v150[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v150, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, v135);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::RNNActivationAttr::print(mlir::mps::RNNActivationAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 5)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_11;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "none";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "relu";
      v9 = 4;
      break;
    case 2u:
      v7 = 0;
      v8 = "tanh";
      v9 = 4;
      break;
    case 3u:
      v7 = 0;
      v8 = "sigmoid";
      v9 = 7;
      break;
    case 4u:
      v7 = 0;
      v8 = "hard_sigmoid";
      v9 = 12;
      break;
    case 5u:
      v7 = 0;
      v8 = "scaled_tanh";
      v9 = 11;
      break;
    default:
      goto LABEL_6;
  }
LABEL_11:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::LSTMGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::LSTMGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v3;
  int *v4;
  int *v5;
  __int128 v6;
  uint64_t v7;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  _QWORD **v52;
  _QWORD **v53;
  void *v54;
  _QWORD *v55;
  _QWORD *v56;
  void *v57;
  void *v58;
  void *v59;
  unsigned int v60;
  uint64_t v61;
  _QWORD **v62;
  _QWORD **v63;
  void *v64;
  _QWORD *v65;
  _QWORD *v66;
  void *v67;
  void *v68;
  void *v69;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  BOOL v77;
  unint64_t v78;
  BOOL v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  unsigned int v98[8];
  __int16 v99;
  _DWORD *v100;
  uint64_t v101;
  int v102;
  const char *v103;
  uint64_t v104;
  _QWORD v105[3];
  void *v106;
  uint64_t v107;
  void *v108;
  _QWORD *v109;
  void *__p;
  _QWORD **v111;
  char v112;
  _QWORD v113[3];
  int *v114;
  unsigned int v115;
  unsigned int v116;
  _BYTE v117[96];
  _QWORD *v118;
  _QWORD *v119;
  _QWORD **v120;
  _QWORD **v121;
  char v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v100 = 0;
    v101 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v100))
    {
LABEL_49:
      v61 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v115) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v105, a1, v61, v113);
      if (v105[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v105);
      if (v112)
      {
        v62 = (_QWORD **)__p;
        if (__p)
        {
          v63 = v111;
          v64 = __p;
          if (v111 != __p)
          {
            do
              v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
            while (v63 != v62);
            v64 = __p;
          }
          v111 = v62;
          operator delete(v64);
        }
        v65 = v108;
        if (v108)
        {
          v66 = v109;
          v67 = v108;
          if (v109 != v108)
          {
            do
            {
              v69 = (void *)*--v66;
              v68 = v69;
              *v66 = 0;
              if (v69)
                operator delete[](v68);
            }
            while (v66 != v65);
            v67 = v108;
          }
          v109 = v65;
          operator delete(v67);
        }
        if (v106 != &v107)
          free(v106);
      }
      return 0;
    }
    if (v101 != 4)
    {
LABEL_8:
      v99 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v113, a1, v2, v98);
      if (v113[0])
      {
        v102 = 3;
        v103 = "expected ";
        v104 = 9;
        v3 = &v102;
        v4 = v114;
        if (v115 >= v116)
        {
          v73 = v115 + 1;
          if (v114 <= &v102 && &v114[6 * v115] > &v102)
          {
            v88 = (char *)&v102 - (char *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            v4 = v114;
            v3 = (int *)((char *)v114 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v73, 24);
            v3 = &v102;
            v4 = v114;
          }
        }
        v5 = &v4[6 * v115];
        v6 = *(_OWORD *)v3;
        *((_QWORD *)v5 + 2) = *((_QWORD *)v3 + 2);
        *(_OWORD *)v5 = v6;
        v7 = ++v115;
        if (v113[0])
        {
          v102 = 3;
          v103 = "::mlir::mps::LSTMGateLayout";
          v104 = 27;
          v8 = &v102;
          v9 = v114;
          if (v7 >= v116)
          {
            v74 = v7 + 1;
            v75 = &v114[6 * v7] > &v102;
            if (v114 <= &v102 && v75)
            {
              v89 = (char *)&v102 - (char *)v114;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              v9 = v114;
              v8 = (int *)((char *)v114 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v74, 24);
              v8 = &v102;
              v9 = v114;
            }
          }
          v10 = &v9[6 * v115];
          v11 = *(_OWORD *)v8;
          *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
          *(_OWORD *)v10 = v11;
          v12 = ++v115;
          if (v113[0])
          {
            v102 = 3;
            v103 = " to be one of: ";
            v104 = 15;
            v13 = &v102;
            v14 = v114;
            if (v12 >= v116)
            {
              v76 = v12 + 1;
              v77 = &v114[6 * v12] > &v102;
              if (v114 <= &v102 && v77)
              {
                v90 = (char *)&v102 - (char *)v114;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                v14 = v114;
                v13 = (int *)((char *)v114 + v90);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v76, 24);
                v13 = &v102;
                v14 = v114;
              }
            }
            v15 = &v14[6 * v115];
            v16 = *(_OWORD *)v13;
            *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
            *(_OWORD *)v15 = v16;
            v17 = ++v115;
            if (v113[0])
            {
              v102 = 3;
              v103 = "IFZO";
              v104 = 4;
              v18 = &v102;
              v19 = v114;
              if (v17 >= v116)
              {
                v78 = v17 + 1;
                v79 = &v114[6 * v17] > &v102;
                if (v114 <= &v102 && v79)
                {
                  v91 = (char *)&v102 - (char *)v114;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  v19 = v114;
                  v18 = (int *)((char *)v114 + v91);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v78, 24);
                  v18 = &v102;
                  v19 = v114;
                }
              }
              v20 = &v19[6 * v115];
              v21 = *(_OWORD *)v18;
              *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
              *(_OWORD *)v20 = v21;
              v22 = ++v115;
              if (v113[0])
              {
                v102 = 3;
                v103 = ", ";
                v104 = 2;
                v23 = &v102;
                v24 = v114;
                if (v22 >= v116)
                {
                  v80 = v22 + 1;
                  if (v114 <= &v102 && &v114[6 * v22] > &v102)
                  {
                    v92 = (char *)&v102 - (char *)v114;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    v24 = v114;
                    v23 = (int *)((char *)v114 + v92);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v80, 24);
                    v23 = &v102;
                    v24 = v114;
                  }
                }
                v25 = &v24[6 * v115];
                v26 = *(_OWORD *)v23;
                *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
                *(_OWORD *)v25 = v26;
                v27 = ++v115;
                if (v113[0])
                {
                  v102 = 3;
                  v103 = "IZFO";
                  v104 = 4;
                  v28 = &v102;
                  v29 = v114;
                  if (v27 >= v116)
                  {
                    v81 = v27 + 1;
                    if (v114 <= &v102 && &v114[6 * v27] > &v102)
                    {
                      v93 = (char *)&v102 - (char *)v114;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      v29 = v114;
                      v28 = (int *)((char *)v114 + v93);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v81, 24);
                      v28 = &v102;
                      v29 = v114;
                    }
                  }
                  v30 = &v29[6 * v115];
                  v31 = *(_OWORD *)v28;
                  *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
                  *(_OWORD *)v30 = v31;
                  v32 = ++v115;
                  if (v113[0])
                  {
                    v102 = 3;
                    v103 = ", ";
                    v104 = 2;
                    v33 = &v102;
                    v34 = v114;
                    if (v32 >= v116)
                    {
                      v82 = v32 + 1;
                      if (v114 <= &v102 && &v114[6 * v32] > &v102)
                      {
                        v94 = (char *)&v102 - (char *)v114;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        v34 = v114;
                        v33 = (int *)((char *)v114 + v94);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v82, 24);
                        v33 = &v102;
                        v34 = v114;
                      }
                    }
                    v35 = &v34[6 * v115];
                    v36 = *(_OWORD *)v33;
                    *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                    *(_OWORD *)v35 = v36;
                    v37 = ++v115;
                    if (v113[0])
                    {
                      v102 = 3;
                      v103 = "IFOZ";
                      v104 = 4;
                      v38 = &v102;
                      v39 = v114;
                      if (v37 >= v116)
                      {
                        v83 = v37 + 1;
                        if (v114 <= &v102 && &v114[6 * v37] > &v102)
                        {
                          v95 = (char *)&v102 - (char *)v114;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          v39 = v114;
                          v38 = (int *)((char *)v114 + v95);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v83, 24);
                          v38 = &v102;
                          v39 = v114;
                        }
                      }
                      v40 = &v39[6 * v115];
                      v41 = *(_OWORD *)v38;
                      *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                      *(_OWORD *)v40 = v41;
                      v42 = ++v115;
                      if (v113[0])
                      {
                        v102 = 3;
                        v103 = ", ";
                        v104 = 2;
                        v43 = &v102;
                        v44 = v114;
                        if (v42 >= v116)
                        {
                          v84 = v42 + 1;
                          v85 = &v114[6 * v42] > &v102;
                          if (v114 <= &v102 && v85)
                          {
                            v96 = (char *)&v102 - (char *)v114;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            v44 = v114;
                            v43 = (int *)((char *)v114 + v96);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v84, 24);
                            v43 = &v102;
                            v44 = v114;
                          }
                        }
                        v45 = &v44[6 * v115];
                        v46 = *(_OWORD *)v43;
                        *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                        *(_OWORD *)v45 = v46;
                        v47 = ++v115;
                        if (v113[0])
                        {
                          v102 = 3;
                          v103 = "IOFZ";
                          v104 = 4;
                          v48 = &v102;
                          v49 = v114;
                          if (v47 >= v116)
                          {
                            v86 = v47 + 1;
                            v87 = &v114[6 * v47] > &v102;
                            if (v114 <= &v102 && v87)
                            {
                              v97 = (char *)&v102 - (char *)v114;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              v49 = v114;
                              v48 = (int *)((char *)v114 + v97);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v86, 24);
                              v48 = &v102;
                              v49 = v114;
                            }
                          }
                          v50 = &v49[6 * v115];
                          v51 = *(_OWORD *)v48;
                          *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                          *(_OWORD *)v50 = v51;
                          ++v115;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v113);
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      if (v122)
      {
        v52 = v120;
        if (v120)
        {
          v53 = v121;
          v54 = v120;
          if (v121 != v120)
          {
            do
              v53 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v53 - 1);
            while (v53 != v52);
            v54 = v120;
          }
          v121 = v52;
          operator delete(v54);
        }
        v55 = v118;
        if (v118)
        {
          v56 = v119;
          v57 = v118;
          if (v119 != v118)
          {
            do
            {
              v59 = (void *)*--v56;
              v58 = v59;
              *v56 = 0;
              if (v59)
                operator delete[](v58);
            }
            while (v56 != v55);
            v57 = v118;
          }
          v119 = v55;
          operator delete(v57);
        }
        if (v114 != (int *)v117)
          free(v114);
      }
      goto LABEL_49;
    }
    switch(*v100)
    {
      case 0x4F5A4649:
        v60 = 0;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x4F465A49:
        v60 = 1;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x5A4F4649:
        v60 = 2;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          goto LABEL_74;
        break;
      case 0x5A464F49:
        v60 = 3;
        if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        {
LABEL_74:
          Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
          v98[0] = v60;
          AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
          v113[0] = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
          v113[1] = Context;
          return mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v113, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, v98);
        }
        break;
      default:
        goto LABEL_8;
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::LSTMGateLayoutAttr::print(mlir::mps::LSTMGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "IFZO";
  v9 = 4;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "IZFO";
      goto LABEL_9;
    case 2u:
      v7 = 0;
      v8 = "IFOZ";
      goto LABEL_9;
    case 3u:
      v7 = 0;
      v8 = "IOFZ";
LABEL_9:
      v9 = 4;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::GRUGateLayoutAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v5);
}

uint64_t mlir::mps::GRUGateLayoutAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD **v45;
  _QWORD **v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  void *v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD **v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD **v109;
  _QWORD **v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v89 = 0;
    v90 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
    {
LABEL_53:
      v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v104) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
      if (v94[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
      if (v101)
      {
        v55 = (_QWORD **)__p;
        if (__p)
        {
          v56 = v100;
          v57 = __p;
          if (v100 != __p)
          {
            do
              v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
            while (v56 != v55);
            v57 = __p;
          }
          v100 = v55;
          operator delete(v57);
        }
        v58 = v97;
        if (v97)
        {
          v59 = v98;
          v60 = v97;
          if (v98 != v97)
          {
            do
            {
              v62 = (void *)*--v59;
              v61 = v62;
              *v59 = 0;
              if (v62)
                operator delete[](v61);
            }
            while (v59 != v58);
            v60 = v97;
          }
          v98 = v58;
          operator delete(v60);
        }
        if (v95 != &v96)
          free(v95);
      }
      return 0;
    }
    if (v90 != 3)
    {
LABEL_16:
      v88 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
      if (v102[0])
      {
        v91 = 3;
        v92 = "expected ";
        v93 = 9;
        v6 = &v91;
        v7 = v103;
        if (v104 >= v105)
        {
          v66 = v104 + 1;
          if (v103 <= &v91 && &v103[6 * v104] > &v91)
          {
            v79 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v7 = v103;
            v6 = (int *)((char *)v103 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
            v6 = &v91;
            v7 = v103;
          }
        }
        v8 = &v7[6 * v104];
        v9 = *(_OWORD *)v6;
        *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
        *(_OWORD *)v8 = v9;
        v10 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = "::mlir::mps::GRUGateLayout";
          v93 = 26;
          v11 = &v91;
          v12 = v103;
          if (v10 >= v105)
          {
            v67 = v10 + 1;
            v68 = &v103[6 * v10] > &v91;
            if (v103 <= &v91 && v68)
            {
              v80 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v12 = v103;
              v11 = (int *)((char *)v103 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
              v11 = &v91;
              v12 = v103;
            }
          }
          v13 = &v12[6 * v104];
          v14 = *(_OWORD *)v11;
          *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
          *(_OWORD *)v13 = v14;
          v15 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = " to be one of: ";
            v93 = 15;
            v16 = &v91;
            v17 = v103;
            if (v15 >= v105)
            {
              v69 = v15 + 1;
              v70 = &v103[6 * v15] > &v91;
              if (v103 <= &v91 && v70)
              {
                v81 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v17 = v103;
                v16 = (int *)((char *)v103 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
                v16 = &v91;
                v17 = v103;
              }
            }
            v18 = &v17[6 * v104];
            v19 = *(_OWORD *)v16;
            *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
            *(_OWORD *)v18 = v19;
            v20 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = "ZRO";
              v93 = 3;
              v21 = &v91;
              v22 = v103;
              if (v20 >= v105)
              {
                v71 = v20 + 1;
                v72 = &v103[6 * v20] > &v91;
                if (v103 <= &v91 && v72)
                {
                  v82 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v22 = v103;
                  v21 = (int *)((char *)v103 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                  v21 = &v91;
                  v22 = v103;
                }
              }
              v23 = &v22[6 * v104];
              v24 = *(_OWORD *)v21;
              *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
              *(_OWORD *)v23 = v24;
              v25 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = ", ";
                v93 = 2;
                v26 = &v91;
                v27 = v103;
                if (v25 >= v105)
                {
                  v73 = v25 + 1;
                  if (v103 <= &v91 && &v103[6 * v25] > &v91)
                  {
                    v83 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v27 = v103;
                    v26 = (int *)((char *)v103 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                    v26 = &v91;
                    v27 = v103;
                  }
                }
                v28 = &v27[6 * v104];
                v29 = *(_OWORD *)v26;
                *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
                *(_OWORD *)v28 = v29;
                v30 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = "RZO";
                  v93 = 3;
                  v31 = &v91;
                  v32 = v103;
                  if (v30 >= v105)
                  {
                    v74 = v30 + 1;
                    if (v103 <= &v91 && &v103[6 * v30] > &v91)
                    {
                      v84 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v32 = v103;
                      v31 = (int *)((char *)v103 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                      v31 = &v91;
                      v32 = v103;
                    }
                  }
                  v33 = &v32[6 * v104];
                  v34 = *(_OWORD *)v31;
                  *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                  *(_OWORD *)v33 = v34;
                  v35 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = ", ";
                    v93 = 2;
                    v36 = &v91;
                    v37 = v103;
                    if (v35 >= v105)
                    {
                      v75 = v35 + 1;
                      v76 = &v103[6 * v35] > &v91;
                      if (v103 <= &v91 && v76)
                      {
                        v85 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v37 = v103;
                        v36 = (int *)((char *)v103 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                        v36 = &v91;
                        v37 = v103;
                      }
                    }
                    v38 = &v37[6 * v104];
                    v39 = *(_OWORD *)v36;
                    *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                    *(_OWORD *)v38 = v39;
                    v40 = ++v104;
                    if (v102[0])
                    {
                      v91 = 3;
                      v92 = "ROZ";
                      v93 = 3;
                      v41 = &v91;
                      v42 = v103;
                      if (v40 >= v105)
                      {
                        v77 = v40 + 1;
                        v78 = &v103[6 * v40] > &v91;
                        if (v103 <= &v91 && v78)
                        {
                          v86 = (char *)&v91 - (char *)v103;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v42 = v103;
                          v41 = (int *)((char *)v103 + v86);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                          v41 = &v91;
                          v42 = v103;
                        }
                      }
                      v43 = &v42[6 * v104];
                      v44 = *(_OWORD *)v41;
                      *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                      *(_OWORD *)v43 = v44;
                      ++v104;
                    }
                  }
                }
              }
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
      if (v102[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
      if (v111)
      {
        v45 = v109;
        if (v109)
        {
          v46 = v110;
          v47 = v109;
          if (v110 != v109)
          {
            do
              v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
            while (v46 != v45);
            v47 = v109;
          }
          v110 = v45;
          operator delete(v47);
        }
        v48 = v107;
        if (v107)
        {
          v49 = v108;
          v50 = v107;
          if (v108 != v107)
          {
            do
            {
              v52 = (void *)*--v49;
              v51 = v52;
              *v49 = 0;
              if (v52)
                operator delete[](v51);
            }
            while (v49 != v48);
            v50 = v107;
          }
          v108 = v48;
          operator delete(v50);
        }
        if (v103 != (int *)v106)
          free(v103);
      }
      goto LABEL_53;
    }
    if (*(_WORD *)v89 == 21082 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 0;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else if (*(_WORD *)v89 == 23122 && *(_BYTE *)(v89 + 2) == 79)
    {
      v53 = 1;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        goto LABEL_76;
    }
    else
    {
      if (*(_WORD *)v89 != 20306 || *(_BYTE *)(v89 + 2) != 90)
        goto LABEL_16;
      v53 = 2;
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
LABEL_76:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v87[0] = v53;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
        v102[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, v87);
      }
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::GRUGateLayoutAttr::print(mlir::mps::GRUGateLayoutAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "ZRO";
LABEL_13:
    v8 = 3;
    goto LABEL_14;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "ROZ";
    goto LABEL_13;
  }
  v7 = v6 != 1;
  if (v6 == 1)
    v8 = 3;
  else
    v8 = 0;
  if (v6 == 1)
    v9 = "RZO";
  else
    v9 = "";
LABEL_14:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::StencilPaddingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::StencilPaddingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  uint64_t v3;
  unsigned int v4;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  int *v8;
  int *v9;
  int *v10;
  __int128 v11;
  uint64_t v12;
  int *v13;
  int *v14;
  int *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  int *v19;
  int *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  int *v24;
  int *v25;
  __int128 v26;
  uint64_t v27;
  int *v28;
  int *v29;
  int *v30;
  __int128 v31;
  uint64_t v32;
  int *v33;
  int *v34;
  int *v35;
  __int128 v36;
  uint64_t v37;
  int *v38;
  int *v39;
  int *v40;
  __int128 v41;
  uint64_t v42;
  int *v43;
  int *v44;
  int *v45;
  __int128 v46;
  uint64_t v47;
  int *v48;
  int *v49;
  int *v50;
  __int128 v51;
  uint64_t v52;
  int *v53;
  int *v54;
  int *v55;
  __int128 v56;
  uint64_t v57;
  int *v58;
  int *v59;
  int *v60;
  __int128 v61;
  uint64_t v62;
  int *v63;
  int *v64;
  int *v65;
  __int128 v66;
  uint64_t v67;
  int *v68;
  int *v69;
  int *v70;
  __int128 v71;
  uint64_t v72;
  int *v73;
  int *v74;
  int *v75;
  __int128 v76;
  uint64_t v77;
  int *v78;
  int *v79;
  int *v80;
  __int128 v81;
  uint64_t v82;
  int *v83;
  int *v84;
  int *v85;
  __int128 v86;
  _QWORD **v87;
  _QWORD **v88;
  void *v89;
  _QWORD *v90;
  _QWORD *v91;
  void *v92;
  void *v93;
  void *v94;
  uint64_t v95;
  _QWORD **v96;
  _QWORD **v97;
  void *v98;
  _QWORD *v99;
  _QWORD *v100;
  void *v101;
  void *v102;
  void *v103;
  unint64_t v104;
  unint64_t v105;
  BOOL v106;
  unint64_t v107;
  BOOL v108;
  unint64_t v109;
  BOOL v110;
  unint64_t v111;
  BOOL v112;
  unint64_t v113;
  BOOL v114;
  unint64_t v115;
  BOOL v116;
  unint64_t v117;
  BOOL v118;
  unint64_t v119;
  BOOL v120;
  unint64_t v121;
  BOOL v122;
  unint64_t v123;
  BOOL v124;
  unint64_t v125;
  BOOL v126;
  unint64_t v127;
  BOOL v128;
  unint64_t v129;
  BOOL v130;
  unint64_t v131;
  BOOL v132;
  unint64_t v133;
  BOOL v134;
  int64_t v135;
  int64_t v136;
  int64_t v137;
  int64_t v138;
  int64_t v139;
  int64_t v140;
  int64_t v141;
  int64_t v142;
  int64_t v143;
  int64_t v144;
  int64_t v145;
  int64_t v146;
  int64_t v147;
  int64_t v148;
  int64_t v149;
  int64_t v150;
  unsigned int v151[8];
  __int16 v152;
  int *v153;
  uint64_t v154;
  int v155;
  const char *v156;
  uint64_t v157;
  _QWORD v158[3];
  void *v159;
  uint64_t v160;
  void *v161;
  _QWORD *v162;
  void *__p;
  _QWORD **v164;
  char v165;
  _QWORD v166[3];
  int *v167;
  unsigned int v168;
  unsigned int v169;
  _BYTE v170[96];
  _QWORD *v171;
  _QWORD *v172;
  _QWORD **v173;
  _QWORD **v174;
  char v175;
  uint64_t v176;

  v176 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v153 = 0;
  v154 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v153))
  {
LABEL_57:
    v95 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v168) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v158, a1, v95, v166);
    if (v158[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v158);
    if (v165)
    {
      v96 = (_QWORD **)__p;
      if (__p)
      {
        v97 = v164;
        v98 = __p;
        if (v164 != __p)
        {
          do
            v97 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v97 - 1);
          while (v97 != v96);
          v98 = __p;
        }
        v164 = v96;
        operator delete(v98);
      }
      v99 = v161;
      if (v161)
      {
        v100 = v162;
        v101 = v161;
        if (v162 != v161)
        {
          do
          {
            v103 = (void *)*--v100;
            v102 = v103;
            *v100 = 0;
            if (v103)
              operator delete[](v102);
          }
          while (v100 != v99);
          v101 = v161;
        }
        v162 = v99;
        operator delete(v101);
      }
      if (v159 != &v160)
        free(v159);
    }
    return 0;
  }
  v3 = mlir::mps::symbolizeStencilPaddingMode(v153, v154);
  if ((v3 & 0xFF00000000) == 0)
  {
    v152 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v166, a1, v2, v151);
    if (v166[0])
    {
      v155 = 3;
      v156 = "expected ";
      v157 = 9;
      v8 = &v155;
      v9 = v167;
      if (v168 >= v169)
      {
        v104 = v168 + 1;
        if (v167 <= &v155 && &v167[6 * v168] > &v155)
        {
          v135 = (char *)&v155 - (char *)v167;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v9 = v167;
          v8 = (int *)((char *)v167 + v135);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v104, 24);
          v8 = &v155;
          v9 = v167;
        }
      }
      v10 = &v9[6 * v168];
      v11 = *(_OWORD *)v8;
      *((_QWORD *)v10 + 2) = *((_QWORD *)v8 + 2);
      *(_OWORD *)v10 = v11;
      v12 = ++v168;
      if (v166[0])
      {
        v155 = 3;
        v156 = "::mlir::mps::StencilPaddingMode";
        v157 = 31;
        v13 = &v155;
        v14 = v167;
        if (v12 >= v169)
        {
          v105 = v12 + 1;
          v106 = &v167[6 * v12] > &v155;
          if (v167 <= &v155 && v106)
          {
            v136 = (char *)&v155 - (char *)v167;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v14 = v167;
            v13 = (int *)((char *)v167 + v136);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v105, 24);
            v13 = &v155;
            v14 = v167;
          }
        }
        v15 = &v14[6 * v168];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
        *(_OWORD *)v15 = v16;
        v17 = ++v168;
        if (v166[0])
        {
          v155 = 3;
          v156 = " to be one of: ";
          v157 = 15;
          v18 = &v155;
          v19 = v167;
          if (v17 >= v169)
          {
            v107 = v17 + 1;
            v108 = &v167[6 * v17] > &v155;
            if (v167 <= &v155 && v108)
            {
              v137 = (char *)&v155 - (char *)v167;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v19 = v167;
              v18 = (int *)((char *)v167 + v137);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v107, 24);
              v18 = &v155;
              v19 = v167;
            }
          }
          v20 = &v19[6 * v168];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
          *(_OWORD *)v20 = v21;
          v22 = ++v168;
          if (v166[0])
          {
            v155 = 3;
            v156 = "zero";
            v157 = 4;
            v23 = &v155;
            v24 = v167;
            if (v22 >= v169)
            {
              v109 = v22 + 1;
              v110 = &v167[6 * v22] > &v155;
              if (v167 <= &v155 && v110)
              {
                v138 = (char *)&v155 - (char *)v167;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v24 = v167;
                v23 = (int *)((char *)v167 + v138);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v109, 24);
                v23 = &v155;
                v24 = v167;
              }
            }
            v25 = &v24[6 * v168];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            v27 = ++v168;
            if (v166[0])
            {
              v155 = 3;
              v156 = ", ";
              v157 = 2;
              v28 = &v155;
              v29 = v167;
              if (v27 >= v169)
              {
                v111 = v27 + 1;
                v112 = &v167[6 * v27] > &v155;
                if (v167 <= &v155 && v112)
                {
                  v139 = (char *)&v155 - (char *)v167;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v29 = v167;
                  v28 = (int *)((char *)v167 + v139);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v111, 24);
                  v28 = &v155;
                  v29 = v167;
                }
              }
              v30 = &v29[6 * v168];
              v31 = *(_OWORD *)v28;
              *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
              *(_OWORD *)v30 = v31;
              v32 = ++v168;
              if (v166[0])
              {
                v155 = 3;
                v156 = "constant";
                v157 = 8;
                v33 = &v155;
                v34 = v167;
                if (v32 >= v169)
                {
                  v113 = v32 + 1;
                  v114 = &v167[6 * v32] > &v155;
                  if (v167 <= &v155 && v114)
                  {
                    v140 = (char *)&v155 - (char *)v167;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v34 = v167;
                    v33 = (int *)((char *)v167 + v140);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v113, 24);
                    v33 = &v155;
                    v34 = v167;
                  }
                }
                v35 = &v34[6 * v168];
                v36 = *(_OWORD *)v33;
                *((_QWORD *)v35 + 2) = *((_QWORD *)v33 + 2);
                *(_OWORD *)v35 = v36;
                v37 = ++v168;
                if (v166[0])
                {
                  v155 = 3;
                  v156 = ", ";
                  v157 = 2;
                  v38 = &v155;
                  v39 = v167;
                  if (v37 >= v169)
                  {
                    v115 = v37 + 1;
                    v116 = &v167[6 * v37] > &v155;
                    if (v167 <= &v155 && v116)
                    {
                      v141 = (char *)&v155 - (char *)v167;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v39 = v167;
                      v38 = (int *)((char *)v167 + v141);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v115, 24);
                      v38 = &v155;
                      v39 = v167;
                    }
                  }
                  v40 = &v39[6 * v168];
                  v41 = *(_OWORD *)v38;
                  *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
                  *(_OWORD *)v40 = v41;
                  v42 = ++v168;
                  if (v166[0])
                  {
                    v155 = 3;
                    v156 = "clampToEdge";
                    v157 = 11;
                    v43 = &v155;
                    v44 = v167;
                    if (v42 >= v169)
                    {
                      v117 = v42 + 1;
                      v118 = &v167[6 * v42] > &v155;
                      if (v167 <= &v155 && v118)
                      {
                        v142 = (char *)&v155 - (char *)v167;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v44 = v167;
                        v43 = (int *)((char *)v167 + v142);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v117, 24);
                        v43 = &v155;
                        v44 = v167;
                      }
                    }
                    v45 = &v44[6 * v168];
                    v46 = *(_OWORD *)v43;
                    *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
                    *(_OWORD *)v45 = v46;
                    v47 = ++v168;
                    if (v166[0])
                    {
                      v155 = 3;
                      v156 = ", ";
                      v157 = 2;
                      v48 = &v155;
                      v49 = v167;
                      if (v47 >= v169)
                      {
                        v119 = v47 + 1;
                        v120 = &v167[6 * v47] > &v155;
                        if (v167 <= &v155 && v120)
                        {
                          v143 = (char *)&v155 - (char *)v167;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v49 = v167;
                          v48 = (int *)((char *)v167 + v143);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v119, 24);
                          v48 = &v155;
                          v49 = v167;
                        }
                      }
                      v50 = &v49[6 * v168];
                      v51 = *(_OWORD *)v48;
                      *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
                      *(_OWORD *)v50 = v51;
                      v52 = ++v168;
                      if (v166[0])
                      {
                        v155 = 3;
                        v156 = "mirror";
                        v157 = 6;
                        v53 = &v155;
                        v54 = v167;
                        if (v52 >= v169)
                        {
                          v121 = v52 + 1;
                          v122 = &v167[6 * v52] > &v155;
                          if (v167 <= &v155 && v122)
                          {
                            v144 = (char *)&v155 - (char *)v167;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v54 = v167;
                            v53 = (int *)((char *)v167 + v144);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v121, 24);
                            v53 = &v155;
                            v54 = v167;
                          }
                        }
                        v55 = &v54[6 * v168];
                        v56 = *(_OWORD *)v53;
                        *((_QWORD *)v55 + 2) = *((_QWORD *)v53 + 2);
                        *(_OWORD *)v55 = v56;
                        v57 = ++v168;
                        if (v166[0])
                        {
                          v155 = 3;
                          v156 = ", ";
                          v157 = 2;
                          v58 = &v155;
                          v59 = v167;
                          if (v57 >= v169)
                          {
                            v123 = v57 + 1;
                            v124 = &v167[6 * v57] > &v155;
                            if (v167 <= &v155 && v124)
                            {
                              v145 = (char *)&v155 - (char *)v167;
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v59 = v167;
                              v58 = (int *)((char *)v167 + v145);
                            }
                            else
                            {
                              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v123, 24);
                              v58 = &v155;
                              v59 = v167;
                            }
                          }
                          v60 = &v59[6 * v168];
                          v61 = *(_OWORD *)v58;
                          *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
                          *(_OWORD *)v60 = v61;
                          v62 = ++v168;
                          if (v166[0])
                          {
                            v155 = 3;
                            v156 = "mirrorWithEdge";
                            v157 = 14;
                            v63 = &v155;
                            v64 = v167;
                            if (v62 >= v169)
                            {
                              v125 = v62 + 1;
                              v126 = &v167[6 * v62] > &v155;
                              if (v167 <= &v155 && v126)
                              {
                                v146 = (char *)&v155 - (char *)v167;
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v64 = v167;
                                v63 = (int *)((char *)v167 + v146);
                              }
                              else
                              {
                                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v125, 24);
                                v63 = &v155;
                                v64 = v167;
                              }
                            }
                            v65 = &v64[6 * v168];
                            v66 = *(_OWORD *)v63;
                            *((_QWORD *)v65 + 2) = *((_QWORD *)v63 + 2);
                            *(_OWORD *)v65 = v66;
                            v67 = ++v168;
                            if (v166[0])
                            {
                              v155 = 3;
                              v156 = ", ";
                              v157 = 2;
                              v68 = &v155;
                              v69 = v167;
                              if (v67 >= v169)
                              {
                                v127 = v67 + 1;
                                v128 = &v167[6 * v67] > &v155;
                                if (v167 <= &v155 && v128)
                                {
                                  v147 = (char *)&v155 - (char *)v167;
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v69 = v167;
                                  v68 = (int *)((char *)v167 + v147);
                                }
                                else
                                {
                                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v127, 24);
                                  v68 = &v155;
                                  v69 = v167;
                                }
                              }
                              v70 = &v69[6 * v168];
                              v71 = *(_OWORD *)v68;
                              *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
                              *(_OWORD *)v70 = v71;
                              v72 = ++v168;
                              if (v166[0])
                              {
                                v155 = 3;
                                v156 = "periodic";
                                v157 = 8;
                                v73 = &v155;
                                v74 = v167;
                                if (v72 >= v169)
                                {
                                  v129 = v72 + 1;
                                  v130 = &v167[6 * v72] > &v155;
                                  if (v167 <= &v155 && v130)
                                  {
                                    v148 = (char *)&v155 - (char *)v167;
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v74 = v167;
                                    v73 = (int *)((char *)v167 + v148);
                                  }
                                  else
                                  {
                                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v129, 24);
                                    v73 = &v155;
                                    v74 = v167;
                                  }
                                }
                                v75 = &v74[6 * v168];
                                v76 = *(_OWORD *)v73;
                                *((_QWORD *)v75 + 2) = *((_QWORD *)v73 + 2);
                                *(_OWORD *)v75 = v76;
                                v77 = ++v168;
                                if (v166[0])
                                {
                                  v155 = 3;
                                  v156 = ", ";
                                  v157 = 2;
                                  v78 = &v155;
                                  v79 = v167;
                                  if (v77 >= v169)
                                  {
                                    v131 = v77 + 1;
                                    v132 = &v167[6 * v77] > &v155;
                                    if (v167 <= &v155 && v132)
                                    {
                                      v149 = (char *)&v155 - (char *)v167;
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v79 = v167;
                                      v78 = (int *)((char *)v167 + v149);
                                    }
                                    else
                                    {
                                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v131, 24);
                                      v78 = &v155;
                                      v79 = v167;
                                    }
                                  }
                                  v80 = &v79[6 * v168];
                                  v81 = *(_OWORD *)v78;
                                  *((_QWORD *)v80 + 2) = *((_QWORD *)v78 + 2);
                                  *(_OWORD *)v80 = v81;
                                  v82 = ++v168;
                                  if (v166[0])
                                  {
                                    v155 = 3;
                                    v156 = "antiPeriodic";
                                    v157 = 12;
                                    v83 = &v155;
                                    v84 = v167;
                                    if (v82 >= v169)
                                    {
                                      v133 = v82 + 1;
                                      v134 = &v167[6 * v82] > &v155;
                                      if (v167 <= &v155 && v134)
                                      {
                                        v150 = (char *)&v155 - (char *)v167;
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v84 = v167;
                                        v83 = (int *)((char *)v167 + v150);
                                      }
                                      else
                                      {
                                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v167, v170, v133, 24);
                                        v83 = &v155;
                                        v84 = v167;
                                      }
                                    }
                                    v85 = &v84[6 * v168];
                                    v86 = *(_OWORD *)v83;
                                    *((_QWORD *)v85 + 2) = *((_QWORD *)v83 + 2);
                                    *(_OWORD *)v85 = v86;
                                    ++v168;
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v166);
    if (v166[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v166);
    if (v175)
    {
      v87 = v173;
      if (v173)
      {
        v88 = v174;
        v89 = v173;
        if (v174 != v173)
        {
          do
            v88 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v88 - 1);
          while (v88 != v87);
          v89 = v173;
        }
        v174 = v87;
        operator delete(v89);
      }
      v90 = v171;
      if (v171)
      {
        v91 = v172;
        v92 = v171;
        if (v172 != v171)
        {
          do
          {
            v94 = (void *)*--v91;
            v93 = v94;
            *v91 = 0;
            if (v94)
              operator delete[](v93);
          }
          while (v91 != v90);
          v92 = v171;
        }
        v172 = v90;
        operator delete(v92);
      }
      if (v167 != (int *)v170)
        free(v167);
    }
    goto LABEL_57;
  }
  v4 = v3;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
  {
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v151[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v166[0] = &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id;
    v166[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::StencilPaddingModeAttrStorage,mlir::mps::StencilPaddingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail29StencilPaddingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_22StencilPaddingModeAttrEJNS2_18StencilPaddingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v166, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id, v151);
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::StencilPaddingModeAttr::print(mlir::mps::StencilPaddingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  size_t v6;
  char v7;
  const char *v8;
  llvm::raw_ostream *v9;
  void *v10;
  llvm::raw_ostream *result;
  _BYTE *v12;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(unsigned int *)(*(_QWORD *)this + 8);
    if (v6 > 6)
    {
LABEL_6:
      v6 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_12;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(unsigned int *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "zero";
  switch((int)v6)
  {
    case 0:
      v7 = 0;
      v8 = "constant";
      v6 = 8;
      break;
    case 1:
      v7 = 0;
      v8 = "mirror";
      v6 = 6;
      break;
    case 2:
      v7 = 0;
      v8 = "mirrorWithEdge";
      v6 = 14;
      break;
    case 3:
      v7 = 0;
      v8 = "clampToEdge";
      v6 = 11;
      break;
    case 4:
      break;
    case 5:
      v7 = 0;
      v8 = "periodic";
      v6 = 8;
      break;
    case 6:
      v7 = 0;
      v8 = "antiPeriodic";
      v6 = 12;
      break;
    default:
      goto LABEL_6;
  }
LABEL_12:
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v10 = (void *)*((_QWORD *)v9 + 4);
  if (v6 <= *((_QWORD *)v9 + 3) - (_QWORD)v10)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v10, v8, v6);
      *((_QWORD *)v9 + 4) += v6;
    }
  }
  else
  {
    llvm::raw_ostream::write(v9, v8, v6);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v12)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v12 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeAlignmentModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  _QWORD *v50;
  void *v51;
  void *v52;
  void *v53;
  uint64_t v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  void *v62;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  BOOL v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  BOOL v76;
  unint64_t v77;
  BOOL v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  unsigned int v87[8];
  __int16 v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  const char *v92;
  uint64_t v93;
  _QWORD v94[3];
  void *v95;
  uint64_t v96;
  void *v97;
  _QWORD *v98;
  void *__p;
  _QWORD **v100;
  char v101;
  _QWORD v102[3];
  int *v103;
  unsigned int v104;
  unsigned int v105;
  _BYTE v106[96];
  _QWORD *v107;
  _QWORD *v108;
  _QWORD **v109;
  _QWORD **v110;
  char v111;
  uint64_t v112;

  v112 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v89 = 0;
  v90 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v89))
  {
LABEL_59:
    v54 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v104) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v94, a1, v54, v102);
    if (v94[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v94);
    if (v101)
    {
      v55 = (_QWORD **)__p;
      if (__p)
      {
        v56 = v100;
        v57 = __p;
        if (v100 != __p)
        {
          do
            v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
          while (v56 != v55);
          v57 = __p;
        }
        v100 = v55;
        operator delete(v57);
      }
      v58 = v97;
      if (v97)
      {
        v59 = v98;
        v60 = v97;
        if (v98 != v97)
        {
          do
          {
            v62 = (void *)*--v59;
            v61 = v62;
            *v59 = 0;
            if (v62)
              operator delete[](v61);
          }
          while (v59 != v58);
          v60 = v97;
        }
        v98 = v58;
        operator delete(v60);
      }
      if (v95 != &v96)
        free(v95);
    }
    return 0;
  }
  if (v90 == 12)
  {
    if (*(_QWORD *)v89 != 0x726F436E67696C61 || *(_DWORD *)(v89 + 8) != 1936876910)
      goto LABEL_24;
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
    goto LABEL_80;
  }
  if (v90 == 13)
  {
    if (*(_QWORD *)v89 != 0x6F4374657366666FLL || *(_QWORD *)(v89 + 5) != 0x7372656E726F4374)
      goto LABEL_24;
    v4 = 2;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_80:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v87[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v102[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
    v102[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v102, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, v87);
  }
  if (v90 != 16
    || (*(_QWORD *)v89 == 0x41746C7561666564 ? (v3 = *(_QWORD *)(v89 + 8) == 0x746E656D6E67696CLL) : (v3 = 0), !v3))
  {
LABEL_24:
    v88 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v102, a1, v2, v87);
    if (v102[0])
    {
      v91 = 3;
      v92 = "expected ";
      v93 = 9;
      v7 = &v91;
      v8 = v103;
      if (v104 >= v105)
      {
        v66 = v104 + 1;
        if (v103 <= &v91 && &v103[6 * v104] > &v91)
        {
          v79 = (char *)&v91 - (char *)v103;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
          v8 = v103;
          v7 = (int *)((char *)v103 + v79);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v66, 24);
          v7 = &v91;
          v8 = v103;
        }
      }
      v9 = &v8[6 * v104];
      v10 = *(_OWORD *)v7;
      *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
      *(_OWORD *)v9 = v10;
      v11 = ++v104;
      if (v102[0])
      {
        v91 = 3;
        v92 = "::mlir::mps::CropResizeAlignmentMode";
        v93 = 36;
        v12 = &v91;
        v13 = v103;
        if (v11 >= v105)
        {
          v67 = v11 + 1;
          v68 = &v103[6 * v11] > &v91;
          if (v103 <= &v91 && v68)
          {
            v80 = (char *)&v91 - (char *)v103;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
            v13 = v103;
            v12 = (int *)((char *)v103 + v80);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v67, 24);
            v12 = &v91;
            v13 = v103;
          }
        }
        v14 = &v13[6 * v104];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v104;
        if (v102[0])
        {
          v91 = 3;
          v92 = " to be one of: ";
          v93 = 15;
          v17 = &v91;
          v18 = v103;
          if (v16 >= v105)
          {
            v69 = v16 + 1;
            v70 = &v103[6 * v16] > &v91;
            if (v103 <= &v91 && v70)
            {
              v81 = (char *)&v91 - (char *)v103;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
              v18 = v103;
              v17 = (int *)((char *)v103 + v81);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v69, 24);
              v17 = &v91;
              v18 = v103;
            }
          }
          v19 = &v18[6 * v104];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          v21 = ++v104;
          if (v102[0])
          {
            v91 = 3;
            v92 = "defaultAlignment";
            v93 = 16;
            v22 = &v91;
            v23 = v103;
            if (v21 >= v105)
            {
              v71 = v21 + 1;
              v72 = &v103[6 * v21] > &v91;
              if (v103 <= &v91 && v72)
              {
                v82 = (char *)&v91 - (char *)v103;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                v23 = v103;
                v22 = (int *)((char *)v103 + v82);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v71, 24);
                v22 = &v91;
                v23 = v103;
              }
            }
            v24 = &v23[6 * v104];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            v26 = ++v104;
            if (v102[0])
            {
              v91 = 3;
              v92 = ", ";
              v93 = 2;
              v27 = &v91;
              v28 = v103;
              if (v26 >= v105)
              {
                v73 = v26 + 1;
                if (v103 <= &v91 && &v103[6 * v26] > &v91)
                {
                  v83 = (char *)&v91 - (char *)v103;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                  v28 = v103;
                  v27 = (int *)((char *)v103 + v83);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v73, 24);
                  v27 = &v91;
                  v28 = v103;
                }
              }
              v29 = &v28[6 * v104];
              v30 = *(_OWORD *)v27;
              *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
              *(_OWORD *)v29 = v30;
              v31 = ++v104;
              if (v102[0])
              {
                v91 = 3;
                v92 = "alignCorners";
                v93 = 12;
                v32 = &v91;
                v33 = v103;
                if (v31 >= v105)
                {
                  v74 = v31 + 1;
                  if (v103 <= &v91 && &v103[6 * v31] > &v91)
                  {
                    v84 = (char *)&v91 - (char *)v103;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                    v33 = v103;
                    v32 = (int *)((char *)v103 + v84);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v74, 24);
                    v32 = &v91;
                    v33 = v103;
                  }
                }
                v34 = &v33[6 * v104];
                v35 = *(_OWORD *)v32;
                *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                *(_OWORD *)v34 = v35;
                v36 = ++v104;
                if (v102[0])
                {
                  v91 = 3;
                  v92 = ", ";
                  v93 = 2;
                  v37 = &v91;
                  v38 = v103;
                  if (v36 >= v105)
                  {
                    v75 = v36 + 1;
                    v76 = &v103[6 * v36] > &v91;
                    if (v103 <= &v91 && v76)
                    {
                      v85 = (char *)&v91 - (char *)v103;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                      v38 = v103;
                      v37 = (int *)((char *)v103 + v85);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v75, 24);
                      v37 = &v91;
                      v38 = v103;
                    }
                  }
                  v39 = &v38[6 * v104];
                  v40 = *(_OWORD *)v37;
                  *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                  *(_OWORD *)v39 = v40;
                  v41 = ++v104;
                  if (v102[0])
                  {
                    v91 = 3;
                    v92 = "offsetCorners";
                    v93 = 13;
                    v42 = &v91;
                    v43 = v103;
                    if (v41 >= v105)
                    {
                      v77 = v41 + 1;
                      v78 = &v103[6 * v41] > &v91;
                      if (v103 <= &v91 && v78)
                      {
                        v86 = (char *)&v91 - (char *)v103;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                        v43 = v103;
                        v42 = (int *)((char *)v103 + v86);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v103, v106, v77, 24);
                        v42 = &v91;
                        v43 = v103;
                      }
                    }
                    v44 = &v43[6 * v104];
                    v45 = *(_OWORD *)v42;
                    *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                    *(_OWORD *)v44 = v45;
                    ++v104;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v102);
    if (v102[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v102);
    if (v111)
    {
      v46 = v109;
      if (v109)
      {
        v47 = v110;
        v48 = v109;
        if (v110 != v109)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = v109;
        }
        v110 = v46;
        operator delete(v48);
      }
      v49 = v107;
      if (v107)
      {
        v50 = v108;
        v51 = v107;
        if (v108 != v107)
        {
          do
          {
            v53 = (void *)*--v50;
            v52 = v53;
            *v50 = 0;
            if (v53)
              operator delete[](v52);
          }
          while (v50 != v49);
          v51 = v107;
        }
        v108 = v49;
        operator delete(v51);
      }
      if (v103 != (int *)v106)
        free(v103);
    }
    goto LABEL_59;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_80;
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeAlignmentModeAttr::print(mlir::mps::CropResizeAlignmentModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "defaultAlignment";
    v8 = 16;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "offsetCorners";
    v8 = 13;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 12;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "alignCorners";
    else
      v9 = "";
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CropResizeCoordinateModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v7;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  uint64_t v36;
  int *v37;
  int *v38;
  int *v39;
  __int128 v40;
  uint64_t v41;
  int *v42;
  int *v43;
  int *v44;
  __int128 v45;
  uint64_t v46;
  int *v47;
  int *v48;
  int *v49;
  __int128 v50;
  uint64_t v51;
  int *v52;
  int *v53;
  int *v54;
  __int128 v55;
  uint64_t v56;
  int *v57;
  int *v58;
  int *v59;
  __int128 v60;
  _QWORD **v61;
  _QWORD **v62;
  void *v63;
  _QWORD *v64;
  _QWORD *v65;
  void *v66;
  void *v67;
  void *v68;
  uint64_t v69;
  _QWORD **v70;
  _QWORD **v71;
  void *v72;
  _QWORD *v73;
  _QWORD *v74;
  void *v75;
  void *v76;
  void *v77;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v81;
  unint64_t v82;
  BOOL v83;
  unint64_t v84;
  BOOL v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  BOOL v93;
  unint64_t v94;
  BOOL v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  unsigned int v106[8];
  __int16 v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  const char *v111;
  uint64_t v112;
  _QWORD v113[3];
  void *v114;
  uint64_t v115;
  void *v116;
  _QWORD *v117;
  void *__p;
  _QWORD **v119;
  char v120;
  _QWORD v121[3];
  int *v122;
  unsigned int v123;
  unsigned int v124;
  _BYTE v125[96];
  _QWORD *v126;
  _QWORD *v127;
  _QWORD **v128;
  _QWORD **v129;
  char v130;
  uint64_t v131;

  v131 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v108 = 0;
  v109 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v108))
  {
LABEL_75:
    v69 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v123) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v113, a1, v69, v121);
    if (v113[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    if (v120)
    {
      v70 = (_QWORD **)__p;
      if (__p)
      {
        v71 = v119;
        v72 = __p;
        if (v119 != __p)
        {
          do
            v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
          while (v71 != v70);
          v72 = __p;
        }
        v119 = v70;
        operator delete(v72);
      }
      v73 = v116;
      if (v116)
      {
        v74 = v117;
        v75 = v116;
        if (v117 != v116)
        {
          do
          {
            v77 = (void *)*--v74;
            v76 = v77;
            *v74 = 0;
            if (v77)
              operator delete[](v76);
          }
          while (v74 != v73);
          v75 = v116;
        }
        v117 = v73;
        operator delete(v75);
      }
      if (v114 != &v115)
        free(v114);
    }
    return 0;
  }
  if (v109 == 17)
  {
    if (*(_QWORD *)v108 == 0x577372656E726F63
      && *(_QWORD *)(v108 + 8) == 0x7372694668746469
      && *(_BYTE *)(v108 + 16) == 116)
    {
      v7 = 1;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
    else
    {
      if (*(_QWORD *)v108 != 0x57737265746E6563
        || *(_QWORD *)(v108 + 8) != 0x7372694668746469
        || *(_BYTE *)(v108 + 16) != 116)
      {
        goto LABEL_36;
      }
      v7 = 3;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
LABEL_100:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v106[0] = v7;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v121[0] = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    v121[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v121, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, v106);
  }
  if (v109 != 18)
  {
LABEL_36:
    v107 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v121, a1, v2, v106);
    if (v121[0])
    {
      v110 = 3;
      v111 = "expected ";
      v112 = 9;
      v12 = &v110;
      v13 = v122;
      if (v123 >= v124)
      {
        v81 = v123 + 1;
        if (v122 <= &v110 && &v122[6 * v123] > &v110)
        {
          v96 = (char *)&v110 - (char *)v122;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
          v13 = v122;
          v12 = (int *)((char *)v122 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v81, 24);
          v12 = &v110;
          v13 = v122;
        }
      }
      v14 = &v13[6 * v123];
      v15 = *(_OWORD *)v12;
      *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
      *(_OWORD *)v14 = v15;
      v16 = ++v123;
      if (v121[0])
      {
        v110 = 3;
        v111 = "::mlir::mps::CropResizeCoordinateMode";
        v112 = 37;
        v17 = &v110;
        v18 = v122;
        if (v16 >= v124)
        {
          v82 = v16 + 1;
          v83 = &v122[6 * v16] > &v110;
          if (v122 <= &v110 && v83)
          {
            v97 = (char *)&v110 - (char *)v122;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
            v18 = v122;
            v17 = (int *)((char *)v122 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v82, 24);
            v17 = &v110;
            v18 = v122;
          }
        }
        v19 = &v18[6 * v123];
        v20 = *(_OWORD *)v17;
        *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
        *(_OWORD *)v19 = v20;
        v21 = ++v123;
        if (v121[0])
        {
          v110 = 3;
          v111 = " to be one of: ";
          v112 = 15;
          v22 = &v110;
          v23 = v122;
          if (v21 >= v124)
          {
            v84 = v21 + 1;
            v85 = &v122[6 * v21] > &v110;
            if (v122 <= &v110 && v85)
            {
              v98 = (char *)&v110 - (char *)v122;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
              v23 = v122;
              v22 = (int *)((char *)v122 + v98);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v84, 24);
              v22 = &v110;
              v23 = v122;
            }
          }
          v24 = &v23[6 * v123];
          v25 = *(_OWORD *)v22;
          *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
          *(_OWORD *)v24 = v25;
          v26 = ++v123;
          if (v121[0])
          {
            v110 = 3;
            v111 = "cornersHeightFirst";
            v112 = 18;
            v27 = &v110;
            v28 = v122;
            if (v26 >= v124)
            {
              v86 = v26 + 1;
              v87 = &v122[6 * v26] > &v110;
              if (v122 <= &v110 && v87)
              {
                v99 = (char *)&v110 - (char *)v122;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                v28 = v122;
                v27 = (int *)((char *)v122 + v99);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v86, 24);
                v27 = &v110;
                v28 = v122;
              }
            }
            v29 = &v28[6 * v123];
            v30 = *(_OWORD *)v27;
            *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
            *(_OWORD *)v29 = v30;
            v31 = ++v123;
            if (v121[0])
            {
              v110 = 3;
              v111 = ", ";
              v112 = 2;
              v32 = &v110;
              v33 = v122;
              if (v31 >= v124)
              {
                v88 = v31 + 1;
                if (v122 <= &v110 && &v122[6 * v31] > &v110)
                {
                  v100 = (char *)&v110 - (char *)v122;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                  v33 = v122;
                  v32 = (int *)((char *)v122 + v100);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v88, 24);
                  v32 = &v110;
                  v33 = v122;
                }
              }
              v34 = &v33[6 * v123];
              v35 = *(_OWORD *)v32;
              *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
              *(_OWORD *)v34 = v35;
              v36 = ++v123;
              if (v121[0])
              {
                v110 = 3;
                v111 = "cornersWidthFirst";
                v112 = 17;
                v37 = &v110;
                v38 = v122;
                if (v36 >= v124)
                {
                  v89 = v36 + 1;
                  if (v122 <= &v110 && &v122[6 * v36] > &v110)
                  {
                    v101 = (char *)&v110 - (char *)v122;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                    v38 = v122;
                    v37 = (int *)((char *)v122 + v101);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v89, 24);
                    v37 = &v110;
                    v38 = v122;
                  }
                }
                v39 = &v38[6 * v123];
                v40 = *(_OWORD *)v37;
                *((_QWORD *)v39 + 2) = *((_QWORD *)v37 + 2);
                *(_OWORD *)v39 = v40;
                v41 = ++v123;
                if (v121[0])
                {
                  v110 = 3;
                  v111 = ", ";
                  v112 = 2;
                  v42 = &v110;
                  v43 = v122;
                  if (v41 >= v124)
                  {
                    v90 = v41 + 1;
                    if (v122 <= &v110 && &v122[6 * v41] > &v110)
                    {
                      v102 = (char *)&v110 - (char *)v122;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                      v43 = v122;
                      v42 = (int *)((char *)v122 + v102);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v90, 24);
                      v42 = &v110;
                      v43 = v122;
                    }
                  }
                  v44 = &v43[6 * v123];
                  v45 = *(_OWORD *)v42;
                  *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
                  *(_OWORD *)v44 = v45;
                  v46 = ++v123;
                  if (v121[0])
                  {
                    v110 = 3;
                    v111 = "centersHeightFirst";
                    v112 = 18;
                    v47 = &v110;
                    v48 = v122;
                    if (v46 >= v124)
                    {
                      v91 = v46 + 1;
                      if (v122 <= &v110 && &v122[6 * v46] > &v110)
                      {
                        v103 = (char *)&v110 - (char *)v122;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                        v48 = v122;
                        v47 = (int *)((char *)v122 + v103);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v91, 24);
                        v47 = &v110;
                        v48 = v122;
                      }
                    }
                    v49 = &v48[6 * v123];
                    v50 = *(_OWORD *)v47;
                    *((_QWORD *)v49 + 2) = *((_QWORD *)v47 + 2);
                    *(_OWORD *)v49 = v50;
                    v51 = ++v123;
                    if (v121[0])
                    {
                      v110 = 3;
                      v111 = ", ";
                      v112 = 2;
                      v52 = &v110;
                      v53 = v122;
                      if (v51 >= v124)
                      {
                        v92 = v51 + 1;
                        v93 = &v122[6 * v51] > &v110;
                        if (v122 <= &v110 && v93)
                        {
                          v104 = (char *)&v110 - (char *)v122;
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                          v53 = v122;
                          v52 = (int *)((char *)v122 + v104);
                        }
                        else
                        {
                          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v92, 24);
                          v52 = &v110;
                          v53 = v122;
                        }
                      }
                      v54 = &v53[6 * v123];
                      v55 = *(_OWORD *)v52;
                      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
                      *(_OWORD *)v54 = v55;
                      v56 = ++v123;
                      if (v121[0])
                      {
                        v110 = 3;
                        v111 = "centersWidthFirst";
                        v112 = 17;
                        v57 = &v110;
                        v58 = v122;
                        if (v56 >= v124)
                        {
                          v94 = v56 + 1;
                          v95 = &v122[6 * v56] > &v110;
                          if (v122 <= &v110 && v95)
                          {
                            v105 = (char *)&v110 - (char *)v122;
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                            v58 = v122;
                            v57 = (int *)((char *)v122 + v105);
                          }
                          else
                          {
                            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v122, v125, v94, 24);
                            v57 = &v110;
                            v58 = v122;
                          }
                        }
                        v59 = &v58[6 * v123];
                        v60 = *(_OWORD *)v57;
                        *((_QWORD *)v59 + 2) = *((_QWORD *)v57 + 2);
                        *(_OWORD *)v59 = v60;
                        ++v123;
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v121);
    if (v121[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v121);
    if (v130)
    {
      v61 = v128;
      if (v128)
      {
        v62 = v129;
        v63 = v128;
        if (v129 != v128)
        {
          do
            v62 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v62 - 1);
          while (v62 != v61);
          v63 = v128;
        }
        v129 = v61;
        operator delete(v63);
      }
      v64 = v126;
      if (v126)
      {
        v65 = v127;
        v66 = v126;
        if (v127 != v126)
        {
          do
          {
            v68 = (void *)*--v65;
            v67 = v68;
            *v65 = 0;
            if (v68)
              operator delete[](v67);
          }
          while (v65 != v64);
          v66 = v126;
        }
        v127 = v64;
        operator delete(v66);
      }
      if (v122 != (int *)v125)
        free(v122);
    }
    goto LABEL_75;
  }
  if (*(_QWORD *)v108 == 0x487372656E726F63
    && *(_QWORD *)(v108 + 8) == 0x7269467468676965
    && *(_WORD *)(v108 + 16) == 29811)
  {
    v7 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
    goto LABEL_100;
  }
  if (*(_QWORD *)v108 != 0x48737265746E6563
    || *(_QWORD *)(v108 + 8) != 0x7269467468676965
    || *(_WORD *)(v108 + 16) != 29811)
  {
    goto LABEL_36;
  }
  v7 = 2;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_100;
  return 0;
}

llvm::raw_ostream *mlir::mps::CropResizeCoordinateModeAttr::print(mlir::mps::CropResizeCoordinateModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  unsigned int v6;
  char v7;
  const char *v8;
  size_t v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6 > 3)
    {
LABEL_6:
      v9 = 0;
      v8 = "";
      v7 = 1;
      goto LABEL_10;
    }
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  }
  v7 = 0;
  v8 = "cornersHeightFirst";
  v9 = 18;
  switch(v6)
  {
    case 0u:
      break;
    case 1u:
      v7 = 0;
      v8 = "cornersWidthFirst";
      goto LABEL_9;
    case 2u:
      v7 = 0;
      v8 = "centersHeightFirst";
      v9 = 18;
      break;
    case 3u:
      v7 = 0;
      v8 = "centersWidthFirst";
LABEL_9:
      v9 = 17;
      break;
    default:
      goto LABEL_6;
  }
LABEL_10:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v9 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if ((v7 & 1) == 0)
    {
      memcpy(v11, v8, v9);
      *((_QWORD *)v10 + 4) += v9;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v8, v9);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PruningMetricAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningMetricAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  BOOL v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  void *v40;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  BOOL v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  unsigned int v55[8];
  __int16 v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  const char *v60;
  uint64_t v61;
  _QWORD v62[3];
  void *v63;
  uint64_t v64;
  void *v65;
  _QWORD *v66;
  void *__p;
  _QWORD **v68;
  char v69;
  _QWORD v70[3];
  int *v71;
  unsigned int v72;
  unsigned int v73;
  _BYTE v74[96];
  _QWORD *v75;
  _QWORD *v76;
  _QWORD **v77;
  _QWORD **v78;
  char v79;
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    v57 = 0;
    v58 = 0;
    if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v57))
    {
LABEL_38:
      v32 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
      LOWORD(v72) = 259;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v62, a1, v32, v70);
      if (v62[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
      if (v69)
      {
        v33 = (_QWORD **)__p;
        if (__p)
        {
          v34 = v68;
          v35 = __p;
          if (v68 != __p)
          {
            do
              v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
            while (v34 != v33);
            v35 = __p;
          }
          v68 = v33;
          operator delete(v35);
        }
        v36 = v65;
        if (v65)
        {
          v37 = v66;
          v38 = v65;
          if (v66 != v65)
          {
            do
            {
              v40 = (void *)*--v37;
              v39 = v40;
              *v37 = 0;
              if (v40)
                operator delete[](v39);
            }
            while (v37 != v36);
            v38 = v65;
          }
          v66 = v36;
          operator delete(v38);
        }
        if (v63 != &v64)
          free(v63);
      }
      return 0;
    }
    if (v58 != 17
      || (*(_QWORD *)v57 == 0x647574696E67616DLL ? (v3 = *(_QWORD *)(v57 + 8) == 0x6E696E7572705F65) : (v3 = 0),
          v3 ? (v4 = *(_BYTE *)(v57 + 16) == 103) : (v4 = 0),
          !v4))
    {
      v56 = 257;
      (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v70, a1, v2, v55);
      if (v70[0])
      {
        v59 = 3;
        v60 = "expected ";
        v61 = 9;
        v5 = &v59;
        v6 = v71;
        if (v72 >= v73)
        {
          v44 = v72 + 1;
          if (v71 <= &v59 && &v71[6 * v72] > &v59)
          {
            v51 = (char *)&v59 - (char *)v71;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            v6 = v71;
            v5 = (int *)((char *)v71 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v44, 24);
            v5 = &v59;
            v6 = v71;
          }
        }
        v7 = &v6[6 * v72];
        v8 = *(_OWORD *)v5;
        *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
        *(_OWORD *)v7 = v8;
        v9 = ++v72;
        if (v70[0])
        {
          v59 = 3;
          v60 = "::mlir::mps::PruningMetric";
          v61 = 26;
          v10 = &v59;
          v11 = v71;
          if (v9 >= v73)
          {
            v45 = v9 + 1;
            v46 = &v71[6 * v9] > &v59;
            if (v71 <= &v59 && v46)
            {
              v52 = (char *)&v59 - (char *)v71;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              v11 = v71;
              v10 = (int *)((char *)v71 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v45, 24);
              v10 = &v59;
              v11 = v71;
            }
          }
          v12 = &v11[6 * v72];
          v13 = *(_OWORD *)v10;
          *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
          *(_OWORD *)v12 = v13;
          v14 = ++v72;
          if (v70[0])
          {
            v59 = 3;
            v60 = " to be one of: ";
            v61 = 15;
            v15 = &v59;
            v16 = v71;
            if (v14 >= v73)
            {
              v47 = v14 + 1;
              v48 = &v71[6 * v14] > &v59;
              if (v71 <= &v59 && v48)
              {
                v53 = (char *)&v59 - (char *)v71;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                v16 = v71;
                v15 = (int *)((char *)v71 + v53);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v47, 24);
                v15 = &v59;
                v16 = v71;
              }
            }
            v17 = &v16[6 * v72];
            v18 = *(_OWORD *)v15;
            *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
            *(_OWORD *)v17 = v18;
            v19 = ++v72;
            if (v70[0])
            {
              v59 = 3;
              v60 = "magnitude_pruning";
              v61 = 17;
              v20 = &v59;
              v21 = v71;
              if (v19 >= v73)
              {
                v49 = v19 + 1;
                v50 = &v71[6 * v19] > &v59;
                if (v71 <= &v59 && v50)
                {
                  v54 = (char *)&v59 - (char *)v71;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  v21 = v71;
                  v20 = (int *)((char *)v71 + v54);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v71, v74, v49, 24);
                  v20 = &v59;
                  v21 = v71;
                }
              }
              v22 = &v21[6 * v72];
              v23 = *(_OWORD *)v20;
              *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
              *(_OWORD *)v22 = v23;
              ++v72;
            }
          }
        }
      }
      mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v70);
      if (v70[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v70);
      if (v79)
      {
        v24 = v77;
        if (v77)
        {
          v25 = v78;
          v26 = v77;
          if (v78 != v77)
          {
            do
              v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            v26 = v77;
          }
          v78 = v24;
          operator delete(v26);
        }
        v27 = v75;
        if (v75)
        {
          v28 = v76;
          v29 = v75;
          if (v76 != v75)
          {
            do
            {
              v31 = (void *)*--v28;
              v30 = v31;
              *v28 = 0;
              if (v31)
                operator delete[](v30);
            }
            while (v28 != v27);
            v29 = v75;
          }
          v76 = v27;
          operator delete(v29);
        }
        if (v71 != (int *)v74)
          free(v71);
      }
      goto LABEL_38;
    }
    if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    {
      Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
      v55[0] = 0;
      AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
      v70[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id;
      v70[1] = Context;
      return mlir::StorageUniquer::get<mlir::mps::detail::PruningMetricAttrStorage,mlir::mps::PruningMetric>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24PruningMetricAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17PruningMetricAttrEJNS2_13PruningMetricEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id, v55);
    }
  }
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningMetricAttr::print(mlir::mps::PruningMetricAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  size_t v7;
  llvm::raw_ostream *v8;
  uint64_t v9;
  const char *v10;
  llvm::raw_ostream *result;
  _BYTE *v12;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (v6)
    v7 = 0;
  else
    v7 = 17;
  v8 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v9 = *((_QWORD *)v8 + 4);
  if (v7 <= *((_QWORD *)v8 + 3) - v9)
  {
    if (!v6)
    {
      *(_BYTE *)(v9 + 16) = 103;
      *(_OWORD *)v9 = *(_OWORD *)"magnitude_pruning";
      *((_QWORD *)v8 + 4) += 17;
    }
  }
  else
  {
    if (v6)
      v10 = "";
    else
      v10 = "magnitude_pruning";
    llvm::raw_ostream::write(v8, v10, v7);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v12)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v12 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::PruningStructureAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, &v5);
}

uint64_t mlir::mps::PruningStructureAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  BOOL v3;
  unsigned int v4;
  int *v7;
  int *v8;
  int *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  int *v13;
  int *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  int *v18;
  int *v19;
  __int128 v20;
  uint64_t v21;
  int *v22;
  int *v23;
  int *v24;
  __int128 v25;
  uint64_t v26;
  int *v27;
  int *v28;
  int *v29;
  __int128 v30;
  uint64_t v31;
  int *v32;
  int *v33;
  int *v34;
  __int128 v35;
  _QWORD **v36;
  _QWORD **v37;
  void *v38;
  _QWORD *v39;
  _QWORD *v40;
  void *v41;
  void *v42;
  void *v43;
  uint64_t v44;
  _QWORD **v45;
  _QWORD **v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  unint64_t v65;
  BOOL v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  unsigned int v73[8];
  __int16 v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  const char *v78;
  uint64_t v79;
  _QWORD v80[3];
  void *v81;
  uint64_t v82;
  void *v83;
  _QWORD *v84;
  void *__p;
  _QWORD **v86;
  char v87;
  _QWORD v88[3];
  int *v89;
  unsigned int v90;
  unsigned int v91;
  _BYTE v92[96];
  _QWORD *v93;
  _QWORD *v94;
  _QWORD **v95;
  _QWORD **v96;
  char v97;
  uint64_t v98;

  v98 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v75 = 0;
  v76 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v75))
  {
LABEL_50:
    v44 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v90) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v80, a1, v44, v88);
    if (v80[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v80);
    if (v87)
    {
      v45 = (_QWORD **)__p;
      if (__p)
      {
        v46 = v86;
        v47 = __p;
        if (v86 != __p)
        {
          do
            v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
          while (v46 != v45);
          v47 = __p;
        }
        v86 = v45;
        operator delete(v47);
      }
      v48 = v83;
      if (v83)
      {
        v49 = v84;
        v50 = v83;
        if (v84 != v83)
        {
          do
          {
            v52 = (void *)*--v49;
            v51 = v52;
            *v49 = 0;
            if (v52)
              operator delete[](v51);
          }
          while (v49 != v48);
          v50 = v83;
        }
        v84 = v48;
        operator delete(v50);
      }
      if (v81 != &v82)
        free(v81);
    }
    return 0;
  }
  if (v76 == 20)
  {
    if (*(_QWORD *)v75 != 0x64315F6B636F6C62
      || *(_QWORD *)(v75 + 8) != 0x7572705F345F325FLL
      || *(_DWORD *)(v75 + 16) != 1735289198)
    {
      goto LABEL_19;
    }
    v4 = 1;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_71:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v73[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v88[0] = &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id;
    v88[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::PruningStructureAttrStorage,mlir::mps::PruningStructure>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27PruningStructureAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20PruningStructureAttrEJNS2_16PruningStructureEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v88, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id, v73);
  }
  if (v76 != 14
    || (*(_QWORD *)v75 == 0x705F6D6F646E6172 ? (v3 = *(_QWORD *)(v75 + 6) == 0x676E696E7572705FLL) : (v3 = 0), !v3))
  {
LABEL_19:
    v74 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v88, a1, v2, v73);
    if (v88[0])
    {
      v77 = 3;
      v78 = "expected ";
      v79 = 9;
      v7 = &v77;
      v8 = v89;
      if (v90 >= v91)
      {
        v56 = v90 + 1;
        if (v89 <= &v77 && &v89[6 * v90] > &v77)
        {
          v67 = (char *)&v77 - (char *)v89;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
          v8 = v89;
          v7 = (int *)((char *)v89 + v67);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v56, 24);
          v7 = &v77;
          v8 = v89;
        }
      }
      v9 = &v8[6 * v90];
      v10 = *(_OWORD *)v7;
      *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
      *(_OWORD *)v9 = v10;
      v11 = ++v90;
      if (v88[0])
      {
        v77 = 3;
        v78 = "::mlir::mps::PruningStructure";
        v79 = 29;
        v12 = &v77;
        v13 = v89;
        if (v11 >= v91)
        {
          v57 = v11 + 1;
          v58 = &v89[6 * v11] > &v77;
          if (v89 <= &v77 && v58)
          {
            v68 = (char *)&v77 - (char *)v89;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
            v13 = v89;
            v12 = (int *)((char *)v89 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v57, 24);
            v12 = &v77;
            v13 = v89;
          }
        }
        v14 = &v13[6 * v90];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
        *(_OWORD *)v14 = v15;
        v16 = ++v90;
        if (v88[0])
        {
          v77 = 3;
          v78 = " to be one of: ";
          v79 = 15;
          v17 = &v77;
          v18 = v89;
          if (v16 >= v91)
          {
            v59 = v16 + 1;
            v60 = &v89[6 * v16] > &v77;
            if (v89 <= &v77 && v60)
            {
              v69 = (char *)&v77 - (char *)v89;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
              v18 = v89;
              v17 = (int *)((char *)v89 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v59, 24);
              v17 = &v77;
              v18 = v89;
            }
          }
          v19 = &v18[6 * v90];
          v20 = *(_OWORD *)v17;
          *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
          *(_OWORD *)v19 = v20;
          v21 = ++v90;
          if (v88[0])
          {
            v77 = 3;
            v78 = "random_pruning";
            v79 = 14;
            v22 = &v77;
            v23 = v89;
            if (v21 >= v91)
            {
              v61 = v21 + 1;
              v62 = &v89[6 * v21] > &v77;
              if (v89 <= &v77 && v62)
              {
                v70 = (char *)&v77 - (char *)v89;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                v23 = v89;
                v22 = (int *)((char *)v89 + v70);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v61, 24);
                v22 = &v77;
                v23 = v89;
              }
            }
            v24 = &v23[6 * v90];
            v25 = *(_OWORD *)v22;
            *((_QWORD *)v24 + 2) = *((_QWORD *)v22 + 2);
            *(_OWORD *)v24 = v25;
            v26 = ++v90;
            if (v88[0])
            {
              v77 = 3;
              v78 = ", ";
              v79 = 2;
              v27 = &v77;
              v28 = v89;
              if (v26 >= v91)
              {
                v63 = v26 + 1;
                v64 = &v89[6 * v26] > &v77;
                if (v89 <= &v77 && v64)
                {
                  v71 = (char *)&v77 - (char *)v89;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                  v28 = v89;
                  v27 = (int *)((char *)v89 + v71);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v63, 24);
                  v27 = &v77;
                  v28 = v89;
                }
              }
              v29 = &v28[6 * v90];
              v30 = *(_OWORD *)v27;
              *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
              *(_OWORD *)v29 = v30;
              v31 = ++v90;
              if (v88[0])
              {
                v77 = 3;
                v78 = "block_1d_2_4_pruning";
                v79 = 20;
                v32 = &v77;
                v33 = v89;
                if (v31 >= v91)
                {
                  v65 = v31 + 1;
                  v66 = &v89[6 * v31] > &v77;
                  if (v89 <= &v77 && v66)
                  {
                    v72 = (char *)&v77 - (char *)v89;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                    v33 = v89;
                    v32 = (int *)((char *)v89 + v72);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v89, v92, v65, 24);
                    v32 = &v77;
                    v33 = v89;
                  }
                }
                v34 = &v33[6 * v90];
                v35 = *(_OWORD *)v32;
                *((_QWORD *)v34 + 2) = *((_QWORD *)v32 + 2);
                *(_OWORD *)v34 = v35;
                ++v90;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v88);
    if (v88[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v88);
    if (v97)
    {
      v36 = v95;
      if (v95)
      {
        v37 = v96;
        v38 = v95;
        if (v96 != v95)
        {
          do
            v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
          while (v37 != v36);
          v38 = v95;
        }
        v96 = v36;
        operator delete(v38);
      }
      v39 = v93;
      if (v93)
      {
        v40 = v94;
        v41 = v93;
        if (v94 != v93)
        {
          do
          {
            v43 = (void *)*--v40;
            v42 = v43;
            *v40 = 0;
            if (v43)
              operator delete[](v42);
          }
          while (v40 != v39);
          v41 = v93;
        }
        v94 = v39;
        operator delete(v41);
      }
      if (v89 != (int *)v92)
        free(v89);
    }
    goto LABEL_50;
  }
  v4 = 0;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_71;
  return 0;
}

llvm::raw_ostream *mlir::mps::PruningStructureAttr::print(mlir::mps::PruningStructureAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  const char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = "";
  v8 = 20;
  if (v6 == 1)
    v7 = "block_1d_2_4_pruning";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 14;
  if (v6)
    v11 = v7;
  else
    v11 = "random_pruning";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::SimilarityTypeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v5);
}

uint64_t mlir::mps::SimilarityTypeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  _QWORD **v43;
  _QWORD **v44;
  void *v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  void *v49;
  void *v50;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v54;
  unint64_t v55;
  BOOL v56;
  unint64_t v57;
  BOOL v58;
  unint64_t v59;
  BOOL v60;
  unint64_t v61;
  BOOL v62;
  unint64_t v63;
  BOOL v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  unsigned int v71[8];
  __int16 v72;
  _QWORD *v73;
  uint64_t v74;
  int v75;
  const char *v76;
  uint64_t v77;
  _QWORD v78[3];
  void *v79;
  uint64_t v80;
  void *v81;
  _QWORD *v82;
  void *__p;
  _QWORD **v84;
  char v85;
  _QWORD v86[3];
  int *v87;
  unsigned int v88;
  unsigned int v89;
  _BYTE v90[96];
  _QWORD *v91;
  _QWORD *v92;
  _QWORD **v93;
  _QWORD **v94;
  char v95;
  uint64_t v96;

  v96 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v73 = 0;
  v74 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v73))
  {
LABEL_44:
    v42 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v88) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v78, a1, v42, v86);
    if (v78[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v78);
    if (v85)
    {
      v43 = (_QWORD **)__p;
      if (__p)
      {
        v44 = v84;
        v45 = __p;
        if (v84 != __p)
        {
          do
            v44 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v44 - 1);
          while (v44 != v43);
          v45 = __p;
        }
        v84 = v43;
        operator delete(v45);
      }
      v46 = v81;
      if (v81)
      {
        v47 = v82;
        v48 = v81;
        if (v82 != v81)
        {
          do
          {
            v50 = (void *)*--v47;
            v49 = v50;
            *v47 = 0;
            if (v50)
              operator delete[](v49);
          }
          while (v47 != v46);
          v48 = v81;
        }
        v82 = v46;
        operator delete(v48);
      }
      if (v79 != &v80)
        free(v79);
    }
    return 0;
  }
  if (v74 != 8)
  {
    if (v74 != 11)
      goto LABEL_13;
    if (*v73 != 0x646F72705F746F64 || *(_QWORD *)((char *)v73 + 3) != 0x746375646F72705FLL)
      goto LABEL_13;
    v4 = 0;
    if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      return 0;
LABEL_65:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v71[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v86[0] = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
    v86[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v86, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, v71);
  }
  if (*v73 != 0x666669645F736261)
  {
LABEL_13:
    v72 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v86, a1, v2, v71);
    if (v86[0])
    {
      v75 = 3;
      v76 = "expected ";
      v77 = 9;
      v5 = &v75;
      v6 = v87;
      if (v88 >= v89)
      {
        v54 = v88 + 1;
        if (v87 <= &v75 && &v87[6 * v88] > &v75)
        {
          v65 = (char *)&v75 - (char *)v87;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v6 = v87;
          v5 = (int *)((char *)v87 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v54, 24);
          v5 = &v75;
          v6 = v87;
        }
      }
      v7 = &v6[6 * v88];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v88;
      if (v86[0])
      {
        v75 = 3;
        v76 = "::mlir::mps::SimilarityType";
        v77 = 27;
        v10 = &v75;
        v11 = v87;
        if (v9 >= v89)
        {
          v55 = v9 + 1;
          v56 = &v87[6 * v9] > &v75;
          if (v87 <= &v75 && v56)
          {
            v66 = (char *)&v75 - (char *)v87;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v11 = v87;
            v10 = (int *)((char *)v87 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v55, 24);
            v10 = &v75;
            v11 = v87;
          }
        }
        v12 = &v11[6 * v88];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v88;
        if (v86[0])
        {
          v75 = 3;
          v76 = " to be one of: ";
          v77 = 15;
          v15 = &v75;
          v16 = v87;
          if (v14 >= v89)
          {
            v57 = v14 + 1;
            v58 = &v87[6 * v14] > &v75;
            if (v87 <= &v75 && v58)
            {
              v67 = (char *)&v75 - (char *)v87;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v16 = v87;
              v15 = (int *)((char *)v87 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v57, 24);
              v15 = &v75;
              v16 = v87;
            }
          }
          v17 = &v16[6 * v88];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v88;
          if (v86[0])
          {
            v75 = 3;
            v76 = "dot_product";
            v77 = 11;
            v20 = &v75;
            v21 = v87;
            if (v19 >= v89)
            {
              v59 = v19 + 1;
              v60 = &v87[6 * v19] > &v75;
              if (v87 <= &v75 && v60)
              {
                v68 = (char *)&v75 - (char *)v87;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v21 = v87;
                v20 = (int *)((char *)v87 + v68);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v59, 24);
                v20 = &v75;
                v21 = v87;
              }
            }
            v22 = &v21[6 * v88];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v88;
            if (v86[0])
            {
              v75 = 3;
              v76 = ", ";
              v77 = 2;
              v25 = &v75;
              v26 = v87;
              if (v24 >= v89)
              {
                v61 = v24 + 1;
                v62 = &v87[6 * v24] > &v75;
                if (v87 <= &v75 && v62)
                {
                  v69 = (char *)&v75 - (char *)v87;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v26 = v87;
                  v25 = (int *)((char *)v87 + v69);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v61, 24);
                  v25 = &v75;
                  v26 = v87;
                }
              }
              v27 = &v26[6 * v88];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v88;
              if (v86[0])
              {
                v75 = 3;
                v76 = "abs_diff";
                v77 = 8;
                v30 = &v75;
                v31 = v87;
                if (v29 >= v89)
                {
                  v63 = v29 + 1;
                  v64 = &v87[6 * v29] > &v75;
                  if (v87 <= &v75 && v64)
                  {
                    v70 = (char *)&v75 - (char *)v87;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v31 = v87;
                    v30 = (int *)((char *)v87 + v70);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v87, v90, v63, 24);
                    v30 = &v75;
                    v31 = v87;
                  }
                }
                v32 = &v31[6 * v88];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                ++v88;
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v86);
    if (v86[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v86);
    if (v95)
    {
      v34 = v93;
      if (v93)
      {
        v35 = v94;
        v36 = v93;
        if (v94 != v93)
        {
          do
            v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
          while (v35 != v34);
          v36 = v93;
        }
        v94 = v34;
        operator delete(v36);
      }
      v37 = v91;
      if (v91)
      {
        v38 = v92;
        v39 = v91;
        if (v92 != v91)
        {
          do
          {
            v41 = (void *)*--v38;
            v40 = v41;
            *v38 = 0;
            if (v41)
              operator delete[](v40);
          }
          while (v38 != v37);
          v39 = v91;
        }
        v92 = v37;
        operator delete(v39);
      }
      if (v87 != (int *)v90)
        free(v87);
    }
    goto LABEL_44;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_65;
  return 0;
}

llvm::raw_ostream *mlir::mps::SimilarityTypeAttr::print(mlir::mps::SimilarityTypeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  const char *v7;
  uint64_t v8;
  BOOL v9;
  size_t v10;
  const char *v11;
  llvm::raw_ostream *v12;
  void *v13;
  llvm::raw_ostream *result;
  _BYTE *v15;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  v7 = "";
  v8 = 8;
  if (v6 == 1)
    v7 = "abs_diff";
  else
    v8 = 0;
  if (v6)
    v9 = v6 != 1;
  else
    v9 = 0;
  if (v6)
    v10 = v8;
  else
    v10 = 11;
  if (v6)
    v11 = v7;
  else
    v11 = "dot_product";
  v12 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (void *)*((_QWORD *)v12 + 4);
  if (v10 <= *((_QWORD *)v12 + 3) - (_QWORD)v13)
  {
    if (!v9)
    {
      memcpy(v13, v11, v10);
      *((_QWORD *)v12 + 4) += v10;
    }
  }
  else
  {
    llvm::raw_ostream::write(v12, v11, v10);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v15 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v15)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v15 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::FFTScalingModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::FFTScalingModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v3;
  int *v5;
  int *v6;
  int *v7;
  __int128 v8;
  uint64_t v9;
  int *v10;
  int *v11;
  int *v12;
  __int128 v13;
  uint64_t v14;
  int *v15;
  int *v16;
  int *v17;
  __int128 v18;
  uint64_t v19;
  int *v20;
  int *v21;
  int *v22;
  __int128 v23;
  uint64_t v24;
  int *v25;
  int *v26;
  int *v27;
  __int128 v28;
  uint64_t v29;
  int *v30;
  int *v31;
  int *v32;
  __int128 v33;
  uint64_t v34;
  int *v35;
  int *v36;
  int *v37;
  __int128 v38;
  uint64_t v39;
  int *v40;
  int *v41;
  int *v42;
  __int128 v43;
  _QWORD **v44;
  _QWORD **v45;
  void *v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  _QWORD **v53;
  _QWORD **v54;
  void *v55;
  _QWORD *v56;
  _QWORD *v57;
  void *v58;
  void *v59;
  void *v60;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v64;
  unint64_t v65;
  BOOL v66;
  unint64_t v67;
  BOOL v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  BOOL v74;
  unint64_t v75;
  BOOL v76;
  int64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  unsigned int v85[8];
  __int16 v86;
  _DWORD *v87;
  uint64_t v88;
  int v89;
  const char *v90;
  uint64_t v91;
  _QWORD v92[3];
  void *v93;
  uint64_t v94;
  void *v95;
  _QWORD *v96;
  void *__p;
  _QWORD **v98;
  char v99;
  _QWORD v100[3];
  int *v101;
  unsigned int v102;
  unsigned int v103;
  _BYTE v104[96];
  _QWORD *v105;
  _QWORD *v106;
  _QWORD **v107;
  _QWORD **v108;
  char v109;
  uint64_t v110;

  v110 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v87 = 0;
  v88 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v87))
  {
LABEL_48:
    v52 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v102) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v92, a1, v52, v100);
    if (v92[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v92);
    if (v99)
    {
      v53 = (_QWORD **)__p;
      if (__p)
      {
        v54 = v98;
        v55 = __p;
        if (v98 != __p)
        {
          do
            v54 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v54 - 1);
          while (v54 != v53);
          v55 = __p;
        }
        v98 = v53;
        operator delete(v55);
      }
      v56 = v95;
      if (v95)
      {
        v57 = v96;
        v58 = v95;
        if (v96 != v95)
        {
          do
          {
            v60 = (void *)*--v57;
            v59 = v60;
            *v57 = 0;
            if (v60)
              operator delete[](v59);
          }
          while (v57 != v56);
          v58 = v95;
        }
        v96 = v56;
        operator delete(v58);
      }
      if (v93 != &v94)
        free(v93);
    }
    return 0;
  }
  if (v88 != 7)
  {
    if (v88 == 4)
    {
      if (*v87 == 1701736302)
      {
        v3 = 0;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          return 0;
        goto LABEL_71;
      }
      if (*v87 == 1702521203)
      {
        v3 = 1;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
          return 0;
LABEL_71:
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v85[0] = v3;
        AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
        v100[0] = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
        v100[1] = Context;
        return mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v100, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, v85);
      }
    }
    goto LABEL_13;
  }
  if (*v87 != 1953066613 || *(_DWORD *)((char *)v87 + 3) != 2037539188)
  {
LABEL_13:
    v86 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v100, a1, v2, v85);
    if (v100[0])
    {
      v89 = 3;
      v90 = "expected ";
      v91 = 9;
      v5 = &v89;
      v6 = v101;
      if (v102 >= v103)
      {
        v64 = v102 + 1;
        if (v101 <= &v89 && &v101[6 * v102] > &v89)
        {
          v77 = (char *)&v89 - (char *)v101;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          v6 = v101;
          v5 = (int *)((char *)v101 + v77);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v64, 24);
          v5 = &v89;
          v6 = v101;
        }
      }
      v7 = &v6[6 * v102];
      v8 = *(_OWORD *)v5;
      *((_QWORD *)v7 + 2) = *((_QWORD *)v5 + 2);
      *(_OWORD *)v7 = v8;
      v9 = ++v102;
      if (v100[0])
      {
        v89 = 3;
        v90 = "::mlir::mps::FFTScalingMode";
        v91 = 27;
        v10 = &v89;
        v11 = v101;
        if (v9 >= v103)
        {
          v65 = v9 + 1;
          v66 = &v101[6 * v9] > &v89;
          if (v101 <= &v89 && v66)
          {
            v78 = (char *)&v89 - (char *)v101;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            v11 = v101;
            v10 = (int *)((char *)v101 + v78);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v65, 24);
            v10 = &v89;
            v11 = v101;
          }
        }
        v12 = &v11[6 * v102];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        v14 = ++v102;
        if (v100[0])
        {
          v89 = 3;
          v90 = " to be one of: ";
          v91 = 15;
          v15 = &v89;
          v16 = v101;
          if (v14 >= v103)
          {
            v67 = v14 + 1;
            v68 = &v101[6 * v14] > &v89;
            if (v101 <= &v89 && v68)
            {
              v79 = (char *)&v89 - (char *)v101;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              v16 = v101;
              v15 = (int *)((char *)v101 + v79);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v67, 24);
              v15 = &v89;
              v16 = v101;
            }
          }
          v17 = &v16[6 * v102];
          v18 = *(_OWORD *)v15;
          *((_QWORD *)v17 + 2) = *((_QWORD *)v15 + 2);
          *(_OWORD *)v17 = v18;
          v19 = ++v102;
          if (v100[0])
          {
            v89 = 3;
            v90 = "none";
            v91 = 4;
            v20 = &v89;
            v21 = v101;
            if (v19 >= v103)
            {
              v69 = v19 + 1;
              v70 = &v101[6 * v19] > &v89;
              if (v101 <= &v89 && v70)
              {
                v80 = (char *)&v89 - (char *)v101;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                v21 = v101;
                v20 = (int *)((char *)v101 + v80);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v69, 24);
                v20 = &v89;
                v21 = v101;
              }
            }
            v22 = &v21[6 * v102];
            v23 = *(_OWORD *)v20;
            *((_QWORD *)v22 + 2) = *((_QWORD *)v20 + 2);
            *(_OWORD *)v22 = v23;
            v24 = ++v102;
            if (v100[0])
            {
              v89 = 3;
              v90 = ", ";
              v91 = 2;
              v25 = &v89;
              v26 = v101;
              if (v24 >= v103)
              {
                v71 = v24 + 1;
                if (v101 <= &v89 && &v101[6 * v24] > &v89)
                {
                  v81 = (char *)&v89 - (char *)v101;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  v26 = v101;
                  v25 = (int *)((char *)v101 + v81);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v71, 24);
                  v25 = &v89;
                  v26 = v101;
                }
              }
              v27 = &v26[6 * v102];
              v28 = *(_OWORD *)v25;
              *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
              *(_OWORD *)v27 = v28;
              v29 = ++v102;
              if (v100[0])
              {
                v89 = 3;
                v90 = "size";
                v91 = 4;
                v30 = &v89;
                v31 = v101;
                if (v29 >= v103)
                {
                  v72 = v29 + 1;
                  if (v101 <= &v89 && &v101[6 * v29] > &v89)
                  {
                    v82 = (char *)&v89 - (char *)v101;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    v31 = v101;
                    v30 = (int *)((char *)v101 + v82);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v72, 24);
                    v30 = &v89;
                    v31 = v101;
                  }
                }
                v32 = &v31[6 * v102];
                v33 = *(_OWORD *)v30;
                *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
                *(_OWORD *)v32 = v33;
                v34 = ++v102;
                if (v100[0])
                {
                  v89 = 3;
                  v90 = ", ";
                  v91 = 2;
                  v35 = &v89;
                  v36 = v101;
                  if (v34 >= v103)
                  {
                    v73 = v34 + 1;
                    v74 = &v101[6 * v34] > &v89;
                    if (v101 <= &v89 && v74)
                    {
                      v83 = (char *)&v89 - (char *)v101;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      v36 = v101;
                      v35 = (int *)((char *)v101 + v83);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v73, 24);
                      v35 = &v89;
                      v36 = v101;
                    }
                  }
                  v37 = &v36[6 * v102];
                  v38 = *(_OWORD *)v35;
                  *((_QWORD *)v37 + 2) = *((_QWORD *)v35 + 2);
                  *(_OWORD *)v37 = v38;
                  v39 = ++v102;
                  if (v100[0])
                  {
                    v89 = 3;
                    v90 = "unitary";
                    v91 = 7;
                    v40 = &v89;
                    v41 = v101;
                    if (v39 >= v103)
                    {
                      v75 = v39 + 1;
                      v76 = &v101[6 * v39] > &v89;
                      if (v101 <= &v89 && v76)
                      {
                        v84 = (char *)&v89 - (char *)v101;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        v41 = v101;
                        v40 = (int *)((char *)v101 + v84);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v101, v104, v75, 24);
                        v40 = &v89;
                        v41 = v101;
                      }
                    }
                    v42 = &v41[6 * v102];
                    v43 = *(_OWORD *)v40;
                    *((_QWORD *)v42 + 2) = *((_QWORD *)v40 + 2);
                    *(_OWORD *)v42 = v43;
                    ++v102;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v100);
    if (v100[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v100);
    if (v109)
    {
      v44 = v107;
      if (v107)
      {
        v45 = v108;
        v46 = v107;
        if (v108 != v107)
        {
          do
            v45 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v45 - 1);
          while (v45 != v44);
          v46 = v107;
        }
        v108 = v44;
        operator delete(v46);
      }
      v47 = v105;
      if (v105)
      {
        v48 = v106;
        v49 = v105;
        if (v106 != v105)
        {
          do
          {
            v51 = (void *)*--v48;
            v50 = v51;
            *v48 = 0;
            if (v51)
              operator delete[](v50);
          }
          while (v48 != v47);
          v49 = v105;
        }
        v106 = v47;
        operator delete(v49);
      }
      if (v101 != (int *)v104)
        free(v101);
    }
    goto LABEL_48;
  }
  v3 = 2;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_71;
  return 0;
}

llvm::raw_ostream *mlir::mps::FFTScalingModeAttr::print(mlir::mps::FFTScalingModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "none";
    v8 = 4;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "unitary";
    v8 = 7;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 4;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "size";
    else
      v9 = "";
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MPSBufferTensorAttr::parse(mlir::AsmParser *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD **v5;
  _QWORD **v6;
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  void *v11;
  void *v12;
  _QWORD **v13;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  void *v20;
  char v21;
  uint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t v26;
  _QWORD **v27;
  _QWORD **v28;
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  mlir::MLIRContext *Context;
  _BYTE v39[24];
  char v40;
  __int16 v41;
  _QWORD v42[24];
  _QWORD v43[3];
  uint64_t *v44;
  uint64_t v45;
  void *v46;
  _QWORD *v47;
  void *v48;
  _QWORD **v49;
  char v50;
  _BYTE v51[23];
  _QWORD v52[3];
  void *v53;
  uint64_t v54;
  void *v55;
  _QWORD *v56;
  void *v57;
  _QWORD **v58;
  char v59;
  _QWORD v60[3];
  uint64_t *v61;
  uint64_t v62;
  void *v63;
  _QWORD *v64;
  void *__p;
  _QWORD **v66;
  char v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!a2)
  {
    *(_QWORD *)v39 = "expected a trailing type";
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v52, a1, v4, v39);
    if (v52[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v52);
    if (!v59)
      return 0;
    v13 = (_QWORD **)v57;
    if (v57)
    {
      v14 = v58;
      v15 = v57;
      if (v58 != v57)
      {
        do
          v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        v15 = v57;
      }
      v58 = v13;
      operator delete(v15);
    }
    v16 = v55;
    if (v55)
    {
      v17 = v56;
      v18 = v55;
      if (v56 != v55)
      {
        do
        {
          v20 = (void *)*--v17;
          v19 = v20;
          *v17 = 0;
          if (v20)
            operator delete[](v19);
        }
        while (v17 != v16);
        v18 = v55;
      }
      v56 = v16;
      operator delete(v18);
    }
    v24 = v53;
    if (v53 == &v54)
      return 0;
    goto LABEL_45;
  }
  if (*(_UNKNOWN **)(*a2 + 136) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    *(_QWORD *)v39 = "invalid kind of type specified";
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v60, a1, v4, v39);
    if (v60[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
    if (!v67)
      return 0;
    v5 = (_QWORD **)__p;
    if (__p)
    {
      v6 = v66;
      v7 = __p;
      if (v66 != __p)
      {
        do
          v6 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v6 - 1);
        while (v6 != v5);
        v7 = __p;
      }
      v66 = v5;
      operator delete(v7);
    }
    v8 = v63;
    if (v63)
    {
      v9 = v64;
      v10 = v63;
      if (v64 != v63)
      {
        do
        {
          v12 = (void *)*--v9;
          v11 = v12;
          *v9 = 0;
          if (v12)
            operator delete[](v11);
        }
        while (v9 != v8);
        v10 = v63;
      }
      v64 = v8;
      operator delete(v10);
    }
    v24 = v61;
    if (v61 == &v62)
      return 0;
    goto LABEL_45;
  }
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
  {
    mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(a1, (uint64_t)v39);
    v21 = v39[0];
    *(_OWORD *)v51 = *(_OWORD *)&v39[1];
    *(_QWORD *)&v51[15] = *(_QWORD *)&v39[16];
    v22 = *(_QWORD *)a1;
    if (v40)
    {
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(v22 + 128))(a1))
      {
        v41 = 257;
        if (!(*(unsigned __int8 (**)(mlir::AsmParser *, const char *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 368))(a1, "handle_offset", 13, v39)|| !(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 136))(a1))
        {
          return 0;
        }
        *(_QWORD *)v39 = 0;
        if (!mlir::AsmParser::parseInteger<unsigned long long>((uint64_t)a1, (uint64_t *)v39))
        {
          v35 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
          v41 = 259;
          (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v42, a1, v35, v39);
          mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v42);
          return 0;
        }
        v23 = *(_QWORD *)v39;
      }
      else
      {
        v23 = 0;
      }
      if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
      {
        v37 = a2;
        Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
        v39[0] = v21;
        *(_OWORD *)&v39[1] = *(_OWORD *)v51;
        *(_QWORD *)&v39[16] = *(_QWORD *)&v51[15];
        v36 = v23;
        return mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>((uint64_t)a1, v4, &Context, &v37, (uint64_t)v39, &v36);
      }
      return 0;
    }
    v26 = (*(uint64_t (**)(mlir::AsmParser *))(v22 + 40))(a1);
    v41 = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _BYTE *))(*(_QWORD *)a1 + 24))(v43, a1, v26, v39);
    if (v43[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v43);
    if (!v50)
      return 0;
    v27 = (_QWORD **)v48;
    if (v48)
    {
      v28 = v49;
      v29 = v48;
      if (v49 != v48)
      {
        do
          v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
        while (v28 != v27);
        v29 = v48;
      }
      v49 = v27;
      operator delete(v29);
    }
    v30 = v46;
    if (v46)
    {
      v31 = v47;
      v32 = v46;
      if (v47 != v46)
      {
        do
        {
          v34 = (void *)*--v31;
          v33 = v34;
          *v31 = 0;
          if (v34)
            operator delete[](v33);
        }
        while (v31 != v30);
        v32 = v46;
      }
      v47 = v30;
      operator delete(v32);
    }
    v24 = v44;
    if (v44 == &v45)
      return 0;
LABEL_45:
    free(v24);
  }
  return 0;
}

void mlir::AsmParser::parseResourceHandle<mlir::mps::MPSDialectResourceBlobHandle>(mlir::AsmParser *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  mlir::Dialect *Dialect;
  void *v6;
  unsigned __int8 v7;
  void **p_vtable;
  int *v9;
  char *v10;
  char *v11;
  __int128 v12;
  char *v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  char *v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  _QWORD **v31;
  _QWORD **v32;
  void *v33;
  _QWORD *v34;
  void *v35;
  void *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  char *v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  __int128 v51;
  uint64_t v52;
  char v53;
  __int16 v54;
  const void **v55;
  const char *v56;
  uint64_t v57;
  __int16 v58;
  int v59;
  const char *v60;
  uint64_t v61;
  char *Context;
  unint64_t v63;
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v4 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  Context = (char *)mlir::AsmParser::getContext(a1);
  Dialect = mlir::MLIRContext::getOrLoadDialect(Context, (uint64_t)"mps", 3, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSDialect,void>::id, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<std::unique_ptr<mlir::Dialect> ()(void)>::callback_fn<mlir::mps::MPSDialect * mlir::MLIRContext::getOrLoadDialect<mlir::mps::MPSDialect>(void)::{lambda(void)#1}>, (uint64_t)&Context);
  if (Dialect)
  {
    (*(void (**)(__int128 *__return_ptr, mlir::AsmParser *, mlir::Dialect *))(*(_QWORD *)a1 + 584))(&v51, a1, Dialect);
    if (!v53)
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      return;
    }
    v6 = (void *)*((_QWORD *)&v51 + 1);
    p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
    if ((v7 & 1) == 0)
    {
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      if (v40)
      {
        Context = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MPSDialectResourceBlobHandle]";
        v63 = 89;
        v41 = llvm::StringRef::find((uint64_t *)&Context, "DesiredTypeName = ", 0x12uLL, 0);
        if (v63 >= v41)
          v42 = v41;
        else
          v42 = v63;
        v43 = &Context[v42];
        v44 = v63 - v42;
        if (v63 - v42 >= 0x12)
          v45 = 18;
        else
          v45 = v63 - v42;
        v46 = v44 - v45;
        if (v46 >= v46 - 1)
          v47 = v46 - 1;
        else
          v47 = v46;
        mlir::detail::TypeIDResolver<mlir::mps::MPSDialectResourceBlobHandle,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v43[v45], v47);
        p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      }
    }
    if (v6 == p_vtable[491])
    {
      *(_OWORD *)a2 = v51;
      *(_QWORD *)(a2 + 16) = v52;
      *(_BYTE *)(a2 + 24) = 1;
      return;
    }
    v58 = 257;
    (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, const void ***))(*(_QWORD *)a1 + 24))(&Context, a1, v4, &v55);
    if (Context)
    {
      v59 = 3;
      v60 = "provided resource handle differs from the expected resource type";
      v61 = 64;
      v9 = &v59;
      v10 = (char *)v64;
      if (v65 >= v66)
      {
        v38 = v65 + 1;
        if (v64 <= &v59 && (char *)v64 + 24 * v65 > (char *)&v59)
        {
          v49 = (char *)&v59 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v38, 24);
          v10 = (char *)v64;
          v9 = (int *)((char *)v64 + v49);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v38, 24);
          v9 = &v59;
          v10 = (char *)v64;
        }
      }
      v11 = &v10[24 * v65];
      v12 = *(_OWORD *)v9;
      *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v11 = v12;
      ++v65;
      v13 = Context;
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      if (v13)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
      if (!v72)
        return;
    }
    else
    {
      *(_BYTE *)a2 = 0;
      *(_BYTE *)(a2 + 24) = 0;
      if (!v72)
        return;
    }
    v31 = (_QWORD **)__p;
    if (__p)
    {
      v32 = v71;
      v33 = __p;
      if (v71 != __p)
      {
        do
          v32 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v32 - 1);
        while (v32 != v31);
        v33 = __p;
      }
      v71 = v31;
      operator delete(v33);
    }
    v26 = v68;
    if (!v68)
    {
LABEL_47:
      if (v64 != v67)
        free(v64);
      return;
    }
    v34 = v69;
    v28 = v68;
    if (v69 == v68)
    {
LABEL_46:
      v69 = v26;
      operator delete(v28);
      goto LABEL_47;
    }
    do
    {
      v36 = (void *)*--v34;
      v35 = v36;
      *v34 = 0;
      if (v36)
        operator delete[](v35);
    }
    while (v34 != v26);
LABEL_45:
    v28 = v68;
    goto LABEL_46;
  }
  v54 = 257;
  (*(void (**)(char **__return_ptr, mlir::AsmParser *, uint64_t, __int128 *))(*(_QWORD *)a1 + 24))(&Context, a1, v4, &v51);
  if (!Context)
    goto LABEL_18;
  LODWORD(v55) = 3;
  v56 = "dialect '";
  v57 = 9;
  v14 = &v55;
  v15 = (char *)v64;
  if (v65 >= v66)
  {
    v37 = v65 + 1;
    if (v64 <= &v55 && (char *)v64 + 24 * v65 > (char *)&v55)
    {
      v48 = (char *)&v55 - (_BYTE *)v64;
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v37, 24);
      v15 = (char *)v64;
      v14 = (const void ***)((char *)v64 + v48);
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v37, 24);
      v14 = &v55;
      v15 = (char *)v64;
    }
  }
  v16 = &v15[24 * v65];
  v17 = *(_OWORD *)v14;
  *((_QWORD *)v16 + 2) = v14[2];
  *(_OWORD *)v16 = v17;
  ++v65;
  if (!Context)
    goto LABEL_18;
  v58 = 262;
  v55 = (const void **)"mps";
  v56 = (const char *)3;
  mlir::Diagnostic::operator<<((uint64_t)&v63, &v55);
  if (Context)
  {
    LODWORD(v55) = 3;
    v56 = "' is unknown";
    v57 = 12;
    v18 = &v55;
    v19 = (char *)v64;
    if (v65 >= v66)
    {
      v39 = v65 + 1;
      if (v64 <= &v55 && (char *)v64 + 24 * v65 > (char *)&v55)
      {
        v50 = (char *)&v55 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v39, 24);
        v19 = (char *)v64;
        v18 = (const void ***)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v39, 24);
        v18 = &v55;
        v19 = (char *)v64;
      }
    }
    v20 = &v19[24 * v65];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v65;
    v22 = Context;
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
    if (v22)
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Context);
  }
  else
  {
LABEL_18:
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 24) = 0;
  }
  if (v72)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v71;
      v25 = __p;
      if (v71 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v71 = v23;
      operator delete(v25);
    }
    v26 = v68;
    if (!v68)
      goto LABEL_47;
    v27 = v69;
    v28 = v68;
    if (v69 == v68)
      goto LABEL_46;
    do
    {
      v30 = (void *)*--v27;
      v29 = v30;
      *v27 = 0;
      if (v30)
        operator delete[](v29);
    }
    while (v27 != v26);
    goto LABEL_45;
  }
}

uint64_t mlir::AsmParser::getChecked<mlir::mps::MPSBufferTensorAttr,mlir::MLIRContext *,mlir::RankedTensorType,mlir::mps::MPSDialectResourceBlobHandle,unsigned long long>(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3, _QWORD **a4, uint64_t a5, uint64_t *a6)
{
  mlir::MLIRContext *v6;
  _QWORD *v7;
  unsigned __int8 **AttributeUniquer;
  _QWORD v10[2];
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD v16[2];

  v10[0] = a1;
  v10[1] = &v11;
  v11 = a2;
  v6 = *a3;
  v7 = *a4;
  v12 = *(_OWORD *)a5;
  v13 = *(_QWORD *)(a5 + 16);
  v14 = *a6;
  v15 = v7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v6);
  v16[0] = &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  v16[1] = v6;
  return mlir::StorageUniquer::get<mlir::mps::detail::MPSBufferTensorAttrStorage,mlir::RankedTensorType &,mlir::mps::MPSDialectResourceBlobHandle &,unsigned long long &>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail26MPSBufferTensorAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_19MPSBufferTensorAttrEJRNS1_16RankedTensorTypeERNS2_28MPSDialectResourceBlobHandleERyEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESK_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSM_E_EEvlS5_, (uint64_t)v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id, (uint64_t *)&v15, &v12, &v14);
}

llvm::raw_ostream *mlir::mps::MPSBufferTensorAttr::print(mlir::mps::MPSBufferTensorAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  __int128 v6;
  llvm::raw_ostream *v7;
  _BYTE *v8;
  llvm::raw_ostream *v9;
  _BYTE *v10;
  llvm::raw_ostream *v11;
  void *v12;
  llvm::raw_ostream *v13;
  _BYTE *v14;
  llvm::raw_ostream *v15;
  _BYTE *v16;
  llvm::raw_ostream *v17;
  _BYTE *v18;
  unint64_t v19;
  llvm::raw_ostream *v20;
  llvm::raw_ostream *result;
  _BYTE *v22;
  __int128 v23;
  uint64_t v24;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) == v5)
  {
    llvm::raw_ostream::write(v4, "<", 1uLL);
  }
  else
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
  }
  v6 = *(_OWORD *)(*(_QWORD *)this + 16);
  v24 = *(_QWORD *)(*(_QWORD *)this + 32);
  v23 = v6;
  (*(void (**)(mlir::AsmPrinter *, __int128 *))(*(_QWORD *)a2 + 80))(a2, &v23);
  if (!*(_QWORD *)(*(_QWORD *)this + 40))
    goto LABEL_25;
  v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v8 = (_BYTE *)*((_QWORD *)v7 + 4);
  if (*((_BYTE **)v7 + 3) == v8)
  {
    llvm::raw_ostream::write(v7, ",", 1uLL);
  }
  else
  {
    *v8 = 44;
    ++*((_QWORD *)v7 + 4);
  }
  v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v10 = (_BYTE *)*((_QWORD *)v9 + 4);
  if ((unint64_t)v10 >= *((_QWORD *)v9 + 3))
  {
    llvm::raw_ostream::write(v9, 32);
  }
  else
  {
    *((_QWORD *)v9 + 4) = v10 + 1;
    *v10 = 32;
  }
  v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v12 = (void *)*((_QWORD *)v11 + 4);
  if (*((_QWORD *)v11 + 3) - (_QWORD)v12 > 0xCuLL)
  {
    qmemcpy(v12, "handle_offset", 13);
    *((_QWORD *)v11 + 4) += 13;
  }
  else
  {
    llvm::raw_ostream::write(v11, "handle_offset", 0xDuLL);
  }
  v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v14 = (_BYTE *)*((_QWORD *)v13 + 4);
  if ((unint64_t)v14 >= *((_QWORD *)v13 + 3))
  {
    llvm::raw_ostream::write(v13, 32);
  }
  else
  {
    *((_QWORD *)v13 + 4) = v14 + 1;
    *v14 = 32;
  }
  v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v16 = (_BYTE *)*((_QWORD *)v15 + 4);
  if (*((_BYTE **)v15 + 3) == v16)
  {
    llvm::raw_ostream::write(v15, "=", 1uLL);
    if (!*(_QWORD *)(*(_QWORD *)this + 40))
      goto LABEL_25;
  }
  else
  {
    *v16 = 61;
    ++*((_QWORD *)v15 + 4);
    if (!*(_QWORD *)(*(_QWORD *)this + 40))
      goto LABEL_25;
  }
  v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v18 = (_BYTE *)*((_QWORD *)v17 + 4);
  if ((unint64_t)v18 >= *((_QWORD *)v17 + 3))
  {
    llvm::raw_ostream::write(v17, 32);
  }
  else
  {
    *((_QWORD *)v17 + 4) = v18 + 1;
    *v18 = 32;
  }
  v19 = *(_QWORD *)(*(_QWORD *)this + 40);
  v20 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  llvm::raw_ostream::operator<<(v20, v19);
LABEL_25:
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v22 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v22)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v22 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::CallInlineModeAttr::get(mlir::MLIRContext *a1, unsigned int a2)
{
  unsigned __int8 **AttributeUniquer;
  unsigned int v5;
  _QWORD v6[2];

  v5 = a2;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(a1);
  v6[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  v6[1] = a1;
  return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v6, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v5);
}

uint64_t mlir::mps::CallInlineModeAttr::parse(mlir::AsmParser *a1)
{
  uint64_t v2;
  unsigned int v4;
  int *v6;
  int *v7;
  int *v8;
  __int128 v9;
  uint64_t v10;
  int *v11;
  int *v12;
  int *v13;
  __int128 v14;
  uint64_t v15;
  int *v16;
  int *v17;
  int *v18;
  __int128 v19;
  uint64_t v20;
  int *v21;
  int *v22;
  int *v23;
  __int128 v24;
  uint64_t v25;
  int *v26;
  int *v27;
  int *v28;
  __int128 v29;
  uint64_t v30;
  int *v31;
  int *v32;
  int *v33;
  __int128 v34;
  uint64_t v35;
  int *v36;
  int *v37;
  int *v38;
  __int128 v39;
  uint64_t v40;
  int *v41;
  int *v42;
  int *v43;
  __int128 v44;
  _QWORD **v45;
  _QWORD **v46;
  void *v47;
  _QWORD *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  void *v52;
  uint64_t v53;
  _QWORD **v54;
  _QWORD **v55;
  void *v56;
  _QWORD *v57;
  _QWORD *v58;
  void *v59;
  void *v60;
  void *v61;
  mlir::MLIRContext *Context;
  unsigned __int8 **AttributeUniquer;
  unint64_t v65;
  unint64_t v66;
  BOOL v67;
  unint64_t v68;
  BOOL v69;
  unint64_t v70;
  BOOL v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  BOOL v75;
  unint64_t v76;
  BOOL v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  unsigned int v86[8];
  __int16 v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  const char *v91;
  uint64_t v92;
  _QWORD v93[3];
  void *v94;
  uint64_t v95;
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD **v99;
  char v100;
  _QWORD v101[3];
  int *v102;
  unsigned int v103;
  unsigned int v104;
  _BYTE v105[96];
  _QWORD *v106;
  _QWORD *v107;
  _QWORD **v108;
  _QWORD **v109;
  char v110;
  uint64_t v111;

  v111 = *MEMORY[0x1E0C80C00];
  mlir::AsmParser::getContext(a1);
  (*(void (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 152))(a1))
    return 0;
  v2 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
  v88 = 0;
  v89 = 0;
  if (!mlir::AsmParser::parseKeyword(a1, (llvm::StringRef *)&v88))
  {
LABEL_55:
    v53 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 40))(a1);
    LOWORD(v103) = 259;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, _QWORD *))(*(_QWORD *)a1 + 24))(v93, a1, v53, v101);
    if (v93[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v93);
    if (v100)
    {
      v54 = (_QWORD **)__p;
      if (__p)
      {
        v55 = v99;
        v56 = __p;
        if (v99 != __p)
        {
          do
            v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
          while (v55 != v54);
          v56 = __p;
        }
        v99 = v54;
        operator delete(v56);
      }
      v57 = v96;
      if (v96)
      {
        v58 = v97;
        v59 = v96;
        if (v97 != v96)
        {
          do
          {
            v61 = (void *)*--v58;
            v60 = v61;
            *v58 = 0;
            if (v61)
              operator delete[](v60);
          }
          while (v58 != v57);
          v59 = v96;
        }
        v97 = v57;
        operator delete(v59);
      }
      if (v94 != &v95)
        free(v94);
    }
    return 0;
  }
  if (v89 != 2)
  {
    if (v89 == 9)
    {
      if (*(_QWORD *)v88 != 0x6974616D6F747561 || *(_BYTE *)(v88 + 8) != 99)
        goto LABEL_20;
      v4 = 2;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
    else
    {
      if (v89 != 3)
        goto LABEL_20;
      if (*(_WORD *)v88 != 26223 || *(_BYTE *)(v88 + 2) != 102)
        goto LABEL_20;
      v4 = 0;
      if (!(*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
        return 0;
    }
LABEL_76:
    Context = (mlir::MLIRContext *)mlir::AsmParser::getContext(a1);
    v86[0] = v4;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(Context);
    v101[0] = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
    v101[1] = Context;
    return mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v101, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, v86);
  }
  if (*(_WORD *)v88 != 28271)
  {
LABEL_20:
    v87 = 257;
    (*(void (**)(_QWORD *__return_ptr, mlir::AsmParser *, uint64_t, unsigned int *))(*(_QWORD *)a1 + 24))(v101, a1, v2, v86);
    if (v101[0])
    {
      v90 = 3;
      v91 = "expected ";
      v92 = 9;
      v6 = &v90;
      v7 = v102;
      if (v103 >= v104)
      {
        v65 = v103 + 1;
        if (v102 <= &v90 && &v102[6 * v103] > &v90)
        {
          v78 = (char *)&v90 - (char *)v102;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
          v7 = v102;
          v6 = (int *)((char *)v102 + v78);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v65, 24);
          v6 = &v90;
          v7 = v102;
        }
      }
      v8 = &v7[6 * v103];
      v9 = *(_OWORD *)v6;
      *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
      *(_OWORD *)v8 = v9;
      v10 = ++v103;
      if (v101[0])
      {
        v90 = 3;
        v91 = "::mlir::mps::CallInlineMode";
        v92 = 27;
        v11 = &v90;
        v12 = v102;
        if (v10 >= v104)
        {
          v66 = v10 + 1;
          v67 = &v102[6 * v10] > &v90;
          if (v102 <= &v90 && v67)
          {
            v79 = (char *)&v90 - (char *)v102;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
            v12 = v102;
            v11 = (int *)((char *)v102 + v79);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v66, 24);
            v11 = &v90;
            v12 = v102;
          }
        }
        v13 = &v12[6 * v103];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = *((_QWORD *)v11 + 2);
        *(_OWORD *)v13 = v14;
        v15 = ++v103;
        if (v101[0])
        {
          v90 = 3;
          v91 = " to be one of: ";
          v92 = 15;
          v16 = &v90;
          v17 = v102;
          if (v15 >= v104)
          {
            v68 = v15 + 1;
            v69 = &v102[6 * v15] > &v90;
            if (v102 <= &v90 && v69)
            {
              v80 = (char *)&v90 - (char *)v102;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
              v17 = v102;
              v16 = (int *)((char *)v102 + v80);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v68, 24);
              v16 = &v90;
              v17 = v102;
            }
          }
          v18 = &v17[6 * v103];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = *((_QWORD *)v16 + 2);
          *(_OWORD *)v18 = v19;
          v20 = ++v103;
          if (v101[0])
          {
            v90 = 3;
            v91 = "off";
            v92 = 3;
            v21 = &v90;
            v22 = v102;
            if (v20 >= v104)
            {
              v70 = v20 + 1;
              v71 = &v102[6 * v20] > &v90;
              if (v102 <= &v90 && v71)
              {
                v81 = (char *)&v90 - (char *)v102;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                v22 = v102;
                v21 = (int *)((char *)v102 + v81);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v70, 24);
                v21 = &v90;
                v22 = v102;
              }
            }
            v23 = &v22[6 * v103];
            v24 = *(_OWORD *)v21;
            *((_QWORD *)v23 + 2) = *((_QWORD *)v21 + 2);
            *(_OWORD *)v23 = v24;
            v25 = ++v103;
            if (v101[0])
            {
              v90 = 3;
              v91 = ", ";
              v92 = 2;
              v26 = &v90;
              v27 = v102;
              if (v25 >= v104)
              {
                v72 = v25 + 1;
                if (v102 <= &v90 && &v102[6 * v25] > &v90)
                {
                  v82 = (char *)&v90 - (char *)v102;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                  v27 = v102;
                  v26 = (int *)((char *)v102 + v82);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v72, 24);
                  v26 = &v90;
                  v27 = v102;
                }
              }
              v28 = &v27[6 * v103];
              v29 = *(_OWORD *)v26;
              *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
              *(_OWORD *)v28 = v29;
              v30 = ++v103;
              if (v101[0])
              {
                v90 = 3;
                v91 = "on";
                v92 = 2;
                v31 = &v90;
                v32 = v102;
                if (v30 >= v104)
                {
                  v73 = v30 + 1;
                  if (v102 <= &v90 && &v102[6 * v30] > &v90)
                  {
                    v83 = (char *)&v90 - (char *)v102;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                    v32 = v102;
                    v31 = (int *)((char *)v102 + v83);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v73, 24);
                    v31 = &v90;
                    v32 = v102;
                  }
                }
                v33 = &v32[6 * v103];
                v34 = *(_OWORD *)v31;
                *((_QWORD *)v33 + 2) = *((_QWORD *)v31 + 2);
                *(_OWORD *)v33 = v34;
                v35 = ++v103;
                if (v101[0])
                {
                  v90 = 3;
                  v91 = ", ";
                  v92 = 2;
                  v36 = &v90;
                  v37 = v102;
                  if (v35 >= v104)
                  {
                    v74 = v35 + 1;
                    v75 = &v102[6 * v35] > &v90;
                    if (v102 <= &v90 && v75)
                    {
                      v84 = (char *)&v90 - (char *)v102;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                      v37 = v102;
                      v36 = (int *)((char *)v102 + v84);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v74, 24);
                      v36 = &v90;
                      v37 = v102;
                    }
                  }
                  v38 = &v37[6 * v103];
                  v39 = *(_OWORD *)v36;
                  *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
                  *(_OWORD *)v38 = v39;
                  v40 = ++v103;
                  if (v101[0])
                  {
                    v90 = 3;
                    v91 = "automatic";
                    v92 = 9;
                    v41 = &v90;
                    v42 = v102;
                    if (v40 >= v104)
                    {
                      v76 = v40 + 1;
                      v77 = &v102[6 * v40] > &v90;
                      if (v102 <= &v90 && v77)
                      {
                        v85 = (char *)&v90 - (char *)v102;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                        v42 = v102;
                        v41 = (int *)((char *)v102 + v85);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v102, v105, v76, 24);
                        v41 = &v90;
                        v42 = v102;
                      }
                    }
                    v43 = &v42[6 * v103];
                    v44 = *(_OWORD *)v41;
                    *((_QWORD *)v43 + 2) = *((_QWORD *)v41 + 2);
                    *(_OWORD *)v43 = v44;
                    ++v103;
                  }
                }
              }
            }
          }
        }
      }
    }
    mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v101);
    if (v101[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v101);
    if (v110)
    {
      v45 = v108;
      if (v108)
      {
        v46 = v109;
        v47 = v108;
        if (v109 != v108)
        {
          do
            v46 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v46 - 1);
          while (v46 != v45);
          v47 = v108;
        }
        v109 = v45;
        operator delete(v47);
      }
      v48 = v106;
      if (v106)
      {
        v49 = v107;
        v50 = v106;
        if (v107 != v106)
        {
          do
          {
            v52 = (void *)*--v49;
            v51 = v52;
            *v49 = 0;
            if (v52)
              operator delete[](v51);
          }
          while (v49 != v48);
          v50 = v106;
        }
        v107 = v48;
        operator delete(v50);
      }
      if (v102 != (int *)v105)
        free(v102);
    }
    goto LABEL_55;
  }
  v4 = 1;
  if ((*(unsigned __int8 (**)(mlir::AsmParser *))(*(_QWORD *)a1 + 168))(a1))
    goto LABEL_76;
  return 0;
}

llvm::raw_ostream *mlir::mps::CallInlineModeAttr::print(mlir::mps::CallInlineModeAttr *this, mlir::AsmPrinter *a2)
{
  llvm::raw_ostream *v4;
  _BYTE *v5;
  int v6;
  BOOL v7;
  size_t v8;
  const char *v9;
  llvm::raw_ostream *v10;
  void *v11;
  llvm::raw_ostream *result;
  _BYTE *v13;

  mlir::Attribute::getContext(this);
  v4 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v5 = (_BYTE *)*((_QWORD *)v4 + 4);
  if (*((_BYTE **)v4 + 3) != v5)
  {
    *v5 = 60;
    ++*((_QWORD *)v4 + 4);
    v6 = *(_DWORD *)(*(_QWORD *)this + 8);
    if (v6)
      goto LABEL_3;
LABEL_11:
    v7 = 0;
    v9 = "off";
    v8 = 3;
    goto LABEL_13;
  }
  llvm::raw_ostream::write(v4, "<", 1uLL);
  v6 = *(_DWORD *)(*(_QWORD *)this + 8);
  if (!v6)
    goto LABEL_11;
LABEL_3:
  if (v6 == 2)
  {
    v7 = 0;
    v9 = "automatic";
    v8 = 9;
  }
  else
  {
    v7 = v6 != 1;
    if (v6 == 1)
      v8 = 2;
    else
      v8 = 0;
    if (v6 == 1)
      v9 = "on";
    else
      v9 = "";
  }
LABEL_13:
  v10 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v11 = (void *)*((_QWORD *)v10 + 4);
  if (v8 <= *((_QWORD *)v10 + 3) - (_QWORD)v11)
  {
    if (!v7)
    {
      memcpy(v11, v9, v8);
      *((_QWORD *)v10 + 4) += v8;
    }
  }
  else
  {
    llvm::raw_ostream::write(v10, v9, v8);
  }
  result = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a2 + 16))(a2);
  v13 = (_BYTE *)*((_QWORD *)result + 4);
  if (*((_BYTE **)result + 3) == v13)
    return llvm::raw_ostream::write(result, ">", 1uLL);
  *v13 = 62;
  ++*((_QWORD *)result + 4);
  return result;
}

uint64_t mlir::mps::MPSDialect::parseAttribute(uint64_t a1, mlir::AsmParser *a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  BOOL v9;
  BOOL v16;
  BOOL v18;
  BOOL v20;
  BOOL v21;
  BOOL v23;
  BOOL v24;
  BOOL v27;
  BOOL v32;
  BOOL v34;
  BOOL v35;
  BOOL v37;
  BOOL v38;
  BOOL v41;
  BOOL v42;
  uint64_t v47;
  const void **v48;
  const void ***v49;
  char *v50;
  char *v51;
  __int128 v52;
  const void ***v53;
  char *v54;
  char *v55;
  __int128 v56;
  const void **v57;
  uint64_t v58;
  const void ***v59;
  char *v60;
  char *v61;
  __int128 v62;
  _QWORD **v63;
  _QWORD **v64;
  void *v65;
  _QWORD *v66;
  _QWORD *v67;
  void *v68;
  void *v69;
  void *v70;
  uint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  int64_t v76;
  int64_t v77;
  int64_t v78;
  char v79[32];
  __int16 v80;
  const void **v81;
  uint64_t v82;
  uint64_t v83;
  __int16 v84;
  mlir::AsmParser *v85;
  uint64_t v86;
  uint64_t v87;
  void *v88;
  unsigned int v89;
  unsigned int v90;
  _BYTE v91[96];
  void *v92;
  _QWORD *v93;
  void *__p;
  _QWORD **v95;
  char v96;
  uint64_t v97;

  v97 = *MEMORY[0x1E0C80C00];
  v6 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a2 + 40))(a2);
  v85 = a2;
  v7 = (*(uint64_t (**)(mlir::AsmParser *))(*(_QWORD *)a2 + 40))(a2);
  BYTE2(v89) = 0;
  v87 = 0;
  v88 = 0;
  v86 = v7;
  LOBYTE(v89) = 0;
  if (!(*(unsigned __int8 (**)(mlir::AsmParser *, uint64_t *))(*(_QWORD *)a2 + 608))(a2, &v87))
  {
    LOWORD(v89) = 256;
    if (!BYTE2(v89))
      BYTE2(v89) = 1;
    goto LABEL_238;
  }
  v81 = (const void **)"tensor_data_layout";
  v82 = 18;
  if (BYTE2(v89))
  {
LABEL_238:
    v47 = 0;
LABEL_239:
    v8 = 0;
    v48 = 0;
    goto LABEL_240;
  }
  v8 = v88;
  if (v88)
  {
    if (v88 == (void *)18)
    {
      v9 = *(_QWORD *)v87 == 0x645F726F736E6574 && *(_QWORD *)(v87 + 8) == 0x6F79616C5F617461;
      if (v9 && *(_WORD *)(v87 + 16) == 29813)
      {
        v72 = mlir::mps::TensorDataLayoutAttr::parse(a2);
        goto LABEL_301;
      }
    }
    v81 = (const void **)"reduction_mode";
    v82 = 14;
  }
  else
  {
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"reduction_mode";
    v82 = 14;
    if (BYTE2(v89))
      goto LABEL_238;
    v8 = v88;
    if (!v88)
    {
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"device_hint";
      v82 = 11;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_19;
LABEL_197:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"scatter_mode";
      v82 = 12;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_25;
LABEL_199:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"padding_mode";
      v82 = 12;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_31;
LABEL_201:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"sampling_mode";
      v82 = 13;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_37;
LABEL_203:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"nearest_rounding_mode";
      v82 = 21;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_43;
LABEL_205:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"sparse_tensor_storage";
      v82 = 21;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_52;
LABEL_207:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"texture_tensor_pixel_format";
      v82 = 27;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_61;
LABEL_209:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"random_normal_sampling_method";
      v82 = 29;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_73;
LABEL_211:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"padding_style";
      v82 = 13;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_85;
LABEL_213:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"pooling_indices_mode";
      v82 = 20;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_91;
LABEL_215:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"rnn_activation";
      v82 = 14;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_100;
LABEL_217:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"lstm_gate_layout";
      v82 = 16;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_106;
LABEL_219:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"gru_gate_layout";
      v82 = 15;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_112;
LABEL_221:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"stencil_padding_mode";
      v82 = 20;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_118;
LABEL_223:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"crop_resize_alignment_mode";
      v82 = 26;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_127;
LABEL_225:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"crop_resize_coordinate_mode";
      v82 = 27;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_139;
LABEL_227:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"pruning_metric";
      v82 = 14;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_151;
      goto LABEL_229;
    }
  }
  if (v8 == (void *)14 && *(_QWORD *)v87 == 0x6F69746375646572 && *(_QWORD *)(v87 + 6) == 0x65646F6D5F6E6F69)
  {
    v72 = mlir::mps::ReductionModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"device_hint";
  v82 = 11;
  if (!v8)
    goto LABEL_197;
LABEL_19:
  if (v8 == (void *)11 && *(_QWORD *)v87 == 0x685F656369766564 && *(_QWORD *)(v87 + 3) == 0x746E69685F656369)
  {
    v72 = mlir::mps::DeviceHintAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"scatter_mode";
  v82 = 12;
  if (!v8)
    goto LABEL_199;
LABEL_25:
  if (v8 == (void *)12 && *(_QWORD *)v87 == 0x5F72657474616373 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    v72 = mlir::mps::ScatterModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"padding_mode";
  v82 = 12;
  if (!v8)
    goto LABEL_201;
LABEL_31:
  if (v8 == (void *)12 && *(_QWORD *)v87 == 0x5F676E6964646170 && *(_DWORD *)(v87 + 8) == 1701080941)
  {
    v72 = mlir::mps::PaddingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"sampling_mode";
  v82 = 13;
  if (!v8)
    goto LABEL_203;
LABEL_37:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x676E696C706D6173 && *(_QWORD *)(v87 + 5) == 0x65646F6D5F676E69)
  {
    v72 = mlir::mps::SamplingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"nearest_rounding_mode";
  v82 = 21;
  if (!v8)
    goto LABEL_205;
LABEL_43:
  if (v8 == (void *)21)
  {
    v16 = *(_QWORD *)v87 == 0x5F7473657261656ELL && *(_QWORD *)(v87 + 8) == 0x676E69646E756F72;
    if (v16 && *(_QWORD *)(v87 + 13) == 0x65646F6D5F676E69)
    {
      v72 = mlir::mps::NearestRoundingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"sparse_tensor_storage";
  v82 = 21;
  if (!v8)
    goto LABEL_207;
LABEL_52:
  if (v8 == (void *)21)
  {
    v18 = *(_QWORD *)v87 == 0x745F657372617073 && *(_QWORD *)(v87 + 8) == 0x74735F726F736E65;
    if (v18 && *(_QWORD *)(v87 + 13) == 0x656761726F74735FLL)
    {
      v72 = mlir::mps::SparseTensorStorageAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"texture_tensor_pixel_format";
  v82 = 27;
  if (!v8)
    goto LABEL_209;
LABEL_61:
  if (v8 == (void *)27)
  {
    v20 = *(_QWORD *)v87 == 0x5F65727574786574 && *(_QWORD *)(v87 + 8) == 0x705F726F736E6574;
    v21 = v20 && *(_QWORD *)(v87 + 16) == 0x726F665F6C657869;
    if (v21 && *(_QWORD *)(v87 + 19) == 0x74616D726F665F6CLL)
    {
      v72 = mlir::mps::MetalPixelFormatAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"random_normal_sampling_method";
  v82 = 29;
  if (!v8)
    goto LABEL_211;
LABEL_73:
  if (v8 == (void *)29)
  {
    v23 = *(_QWORD *)v87 == 0x6E5F6D6F646E6172 && *(_QWORD *)(v87 + 8) == 0x61735F6C616D726FLL;
    v24 = v23 && *(_QWORD *)(v87 + 16) == 0x6D5F676E696C706DLL;
    if (v24 && *(_QWORD *)(v87 + 21) == 0x646F6874656D5F67)
    {
      v72 = mlir::mps::NormalSamplingMethodAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"padding_style";
  v82 = 13;
  if (!v8)
    goto LABEL_213;
LABEL_85:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x5F676E6964646170 && *(_QWORD *)(v87 + 5) == 0x656C7974735F676ELL)
  {
    v72 = mlir::mps::PaddingStyleAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"pooling_indices_mode";
  v82 = 20;
  if (!v8)
    goto LABEL_215;
LABEL_91:
  if (v8 == (void *)20)
  {
    v27 = *(_QWORD *)v87 == 0x5F676E696C6F6F70 && *(_QWORD *)(v87 + 8) == 0x5F73656369646E69;
    if (v27 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      v72 = mlir::mps::PoolIndicesModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"rnn_activation";
  v82 = 14;
  if (!v8)
    goto LABEL_217;
LABEL_100:
  if (v8 == (void *)14 && *(_QWORD *)v87 == 0x697463615F6E6E72 && *(_QWORD *)(v87 + 6) == 0x6E6F697461766974)
  {
    v72 = mlir::mps::RNNActivationAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"lstm_gate_layout";
  v82 = 16;
  if (!v8)
    goto LABEL_219;
LABEL_106:
  if (v8 == (void *)16 && *(_QWORD *)v87 == 0x7461675F6D74736CLL && *(_QWORD *)(v87 + 8) == 0x74756F79616C5F65)
  {
    v72 = mlir::mps::LSTMGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"gru_gate_layout";
  v82 = 15;
  if (!v8)
    goto LABEL_221;
LABEL_112:
  if (v8 == (void *)15 && *(_QWORD *)v87 == 0x657461675F757267 && *(_QWORD *)(v87 + 7) == 0x74756F79616C5F65)
  {
    v72 = mlir::mps::GRUGateLayoutAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"stencil_padding_mode";
  v82 = 20;
  if (!v8)
    goto LABEL_223;
LABEL_118:
  if (v8 == (void *)20)
  {
    v32 = *(_QWORD *)v87 == 0x5F6C69636E657473 && *(_QWORD *)(v87 + 8) == 0x5F676E6964646170;
    if (v32 && *(_DWORD *)(v87 + 16) == 1701080941)
    {
      v72 = mlir::mps::StencilPaddingModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"crop_resize_alignment_mode";
  v82 = 26;
  if (!v8)
    goto LABEL_225;
LABEL_127:
  if (v8 == (void *)26)
  {
    v34 = *(_QWORD *)v87 == 0x7365725F706F7263 && *(_QWORD *)(v87 + 8) == 0x67696C615F657A69;
    v35 = v34 && *(_QWORD *)(v87 + 16) == 0x6F6D5F746E656D6ELL;
    if (v35 && *(_WORD *)(v87 + 24) == 25956)
    {
      v72 = mlir::mps::CropResizeAlignmentModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"crop_resize_coordinate_mode";
  v82 = 27;
  if (!v8)
    goto LABEL_227;
LABEL_139:
  if (v8 == (void *)27)
  {
    v37 = *(_QWORD *)v87 == 0x7365725F706F7263 && *(_QWORD *)(v87 + 8) == 0x726F6F635F657A69;
    v38 = v37 && *(_QWORD *)(v87 + 16) == 0x6D5F6574616E6964;
    if (v38 && *(_QWORD *)(v87 + 19) == 0x65646F6D5F657461)
    {
      v72 = mlir::mps::CropResizeCoordinateModeAttr::parse(a2);
      goto LABEL_301;
    }
  }
  v81 = (const void **)"pruning_metric";
  v82 = 14;
  if (v8)
  {
LABEL_151:
    if (v8 == (void *)14 && *(_QWORD *)v87 == 0x5F676E696E757270 && *(_QWORD *)(v87 + 6) == 0x63697274656D5F67)
    {
      v72 = mlir::mps::PruningMetricAttr::parse(a2);
      goto LABEL_301;
    }
    v81 = (const void **)"pruning_structure";
    v82 = 17;
    if (v8)
      goto LABEL_157;
    goto LABEL_231;
  }
LABEL_229:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  v81 = (const void **)"pruning_structure";
  v82 = 17;
  if (BYTE2(v89))
    goto LABEL_238;
  v8 = v88;
  if (v88)
  {
LABEL_157:
    if (v8 != (void *)17
      || (*(_QWORD *)v87 == 0x5F676E696E757270 ? (v41 = *(_QWORD *)(v87 + 8) == 0x7275746375727473) : (v41 = 0),
          v41 ? (v42 = *(_BYTE *)(v87 + 16) == 101) : (v42 = 0),
          !v42))
    {
      v81 = (const void **)"similarity_type";
      v82 = 15;
      if (v8)
        goto LABEL_166;
LABEL_233:
      (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
      v81 = (const void **)"fft_scaling_mode";
      v82 = 16;
      if (BYTE2(v89))
        goto LABEL_238;
      v8 = v88;
      if (v88)
        goto LABEL_172;
      goto LABEL_235;
    }
    v72 = mlir::mps::PruningStructureAttr::parse(a2);
LABEL_301:
    v47 = v72;
    LOBYTE(v89) = v72 != 0;
    *(_WORD *)((char *)&v89 + 1) = 257;
    goto LABEL_239;
  }
LABEL_231:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  v81 = (const void **)"similarity_type";
  v82 = 15;
  if (BYTE2(v89))
    goto LABEL_238;
  v8 = v88;
  if (!v88)
    goto LABEL_233;
LABEL_166:
  if (v8 == (void *)15 && *(_QWORD *)v87 == 0x6972616C696D6973 && *(_QWORD *)(v87 + 7) == 0x657079745F797469)
  {
    v72 = mlir::mps::SimilarityTypeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"fft_scaling_mode";
  v82 = 16;
  if (!v8)
  {
LABEL_235:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"buffer_tensor";
    v82 = 13;
    if (!BYTE2(v89))
    {
      v8 = v88;
      if (v88)
        goto LABEL_178;
      goto LABEL_237;
    }
    goto LABEL_238;
  }
LABEL_172:
  if (v8 == (void *)16 && *(_QWORD *)v87 == 0x6C6163735F746666 && *(_QWORD *)(v87 + 8) == 0x65646F6D5F676E69)
  {
    v72 = mlir::mps::FFTScalingModeAttr::parse(a2);
    goto LABEL_301;
  }
  v81 = (const void **)"buffer_tensor";
  v82 = 13;
  if (!v8)
  {
LABEL_237:
    (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
    v81 = (const void **)"call_inline_mode";
    v82 = 16;
    if (!BYTE2(v89))
    {
      v8 = v88;
      if (v88)
        goto LABEL_184;
      goto LABEL_303;
    }
    goto LABEL_238;
  }
LABEL_178:
  if (v8 == (void *)13 && *(_QWORD *)v87 == 0x745F726566667562 && *(_QWORD *)(v87 + 5) == 0x726F736E65745F72)
  {
    v72 = mlir::mps::MPSBufferTensorAttr::parse(a2, a3);
    goto LABEL_301;
  }
  v81 = (const void **)"call_inline_mode";
  v82 = 16;
  if (v8)
  {
LABEL_184:
    if (v8 == (void *)16 && *(_QWORD *)v87 == 0x6C6E695F6C6C6163 && *(_QWORD *)(v87 + 8) == 0x65646F6D5F656E69)
    {
      v47 = mlir::mps::CallInlineModeAttr::parse(a2);
      v8 = 0;
      v48 = 0;
      LOBYTE(v89) = v47 != 0;
      *(_WORD *)((char *)&v89 + 1) = 257;
      goto LABEL_240;
    }
    goto LABEL_306;
  }
LABEL_303:
  (*(void (**)(mlir::AsmParser *, const void ***, uint64_t))(*(_QWORD *)v85 + 616))(v85, &v81, 1);
  if (BYTE2(v89))
  {
    v8 = 0;
    v48 = 0;
    v47 = 0;
    goto LABEL_240;
  }
  v8 = v88;
LABEL_306:
  v47 = 0;
  v48 = (const void **)v87;
  LOWORD(v89) = 0;
  BYTE2(v89) = 1;
LABEL_240:
  if ((unsigned __int16)mlir::AsmParser::KeywordSwitch<mlir::OptionalParseResult>::operator mlir::OptionalParseResult((uint64_t *)&v85) <= 0xFFu)
  {
    v80 = 257;
    (*(void (**)(mlir::AsmParser **__return_ptr, mlir::AsmParser *, uint64_t, char *))(*(_QWORD *)a2 + 24))(&v85, a2, v6, v79);
    if (v85)
    {
      LODWORD(v81) = 3;
      v83 = 19;
      v49 = &v81;
      v50 = (char *)v88;
      if (v89 >= v90)
      {
        v73 = v89 + 1;
        if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
        {
          v76 = (char *)&v81 - (_BYTE *)v88;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          v50 = (char *)v88;
          v49 = (const void ***)((char *)v88 + v76);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v73, 24);
          v49 = &v81;
          v50 = (char *)v88;
        }
      }
      v51 = &v50[24 * v89];
      v52 = *(_OWORD *)v49;
      *((_QWORD *)v51 + 2) = v49[2];
      *(_OWORD *)v51 = v52;
      ++v89;
      if (v85)
      {
        v84 = 261;
        v81 = v48;
        v82 = (uint64_t)v8;
        mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
        if (v85)
        {
          LODWORD(v81) = 3;
          v83 = 14;
          v53 = &v81;
          v54 = (char *)v88;
          if (v89 >= v90)
          {
            v74 = v89 + 1;
            if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
            {
              v77 = (char *)&v81 - (_BYTE *)v88;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              v54 = (char *)v88;
              v53 = (const void ***)((char *)v88 + v77);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v74, 24);
              v53 = &v81;
              v54 = (char *)v88;
            }
          }
          v55 = &v54[24 * v89];
          v56 = *(_OWORD *)v53;
          *((_QWORD *)v55 + 2) = v53[2];
          *(_OWORD *)v55 = v56;
          ++v89;
          if (v85)
          {
            v57 = *(const void ***)(a1 + 8);
            v58 = *(_QWORD *)(a1 + 16);
            v84 = 261;
            v81 = v57;
            v82 = v58;
            mlir::Diagnostic::operator<<((uint64_t)&v86, &v81);
            if (v85)
            {
              LODWORD(v81) = 3;
              v83 = 1;
              v59 = &v81;
              v60 = (char *)v88;
              if (v89 >= v90)
              {
                v75 = v89 + 1;
                if (v88 <= &v81 && (char *)v88 + 24 * v89 > (char *)&v81)
                {
                  v78 = (char *)&v81 - (_BYTE *)v88;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  v60 = (char *)v88;
                  v59 = (const void ***)((char *)v88 + v78);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v88, v91, v75, 24);
                  v59 = &v81;
                  v60 = (char *)v88;
                }
              }
              v61 = &v60[24 * v89];
              v62 = *(_OWORD *)v59;
              *((_QWORD *)v61 + 2) = v59[2];
              *(_OWORD *)v61 = v62;
              ++v89;
              if (v85)
                mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v85);
            }
          }
        }
      }
    }
    if (v96)
    {
      v63 = (_QWORD **)__p;
      if (__p)
      {
        v64 = v95;
        v65 = __p;
        if (v95 != __p)
        {
          do
            v64 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v64 - 1);
          while (v64 != v63);
          v65 = __p;
        }
        v95 = v63;
        operator delete(v65);
      }
      v66 = v92;
      if (v92)
      {
        v67 = v93;
        v68 = v92;
        if (v93 != v92)
        {
          do
          {
            v70 = (void *)*--v67;
            v69 = v70;
            *v67 = 0;
            if (v70)
              operator delete[](v69);
          }
          while (v67 != v66);
          v68 = v92;
        }
        v93 = v66;
        operator delete(v68);
      }
      if (v88 != v91)
        free(v88);
    }
    return 0;
  }
  return v47;
}

void mlir::mps::MPSDialect::printAttribute(uint64_t a1, uint64_t a2, mlir::AsmPrinter *a3)
{
  void *v4;
  llvm::raw_ostream *v5;
  _OWORD *v6;
  llvm::raw_ostream *v7;
  uint64_t v8;
  llvm::raw_ostream *v9;
  void *v10;
  llvm::raw_ostream *v11;
  uint64_t v12;
  llvm::raw_ostream *v13;
  uint64_t v14;
  llvm::raw_ostream *v15;
  uint64_t v16;
  llvm::raw_ostream *v17;
  void *v18;
  llvm::raw_ostream *v19;
  void *v20;
  llvm::raw_ostream *v21;
  void *v22;
  llvm::raw_ostream *v23;
  void *v24;
  llvm::raw_ostream *v25;
  void *v26;
  llvm::raw_ostream *v27;
  void *v28;
  llvm::raw_ostream *v29;
  uint64_t v30;
  llvm::raw_ostream *v31;
  void *v32;
  llvm::raw_ostream *v33;
  _OWORD *v34;
  llvm::raw_ostream *v35;
  void *v36;
  llvm::raw_ostream *v37;
  uint64_t v38;
  llvm::raw_ostream *v39;
  void *v40;
  llvm::raw_ostream *v41;
  void *v42;
  llvm::raw_ostream *v43;
  void *v44;
  llvm::raw_ostream *v45;
  uint64_t v46;
  llvm::raw_ostream *v47;
  void *v48;
  llvm::raw_ostream *v49;
  _OWORD *v50;
  llvm::raw_ostream *v51;
  void *v52;
  uint64_t v53;

  v4 = *(void **)(*(_QWORD *)a2 + 136);
  if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    v53 = a2;
    v7 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v8 = *((_QWORD *)v7 + 4);
    if ((unint64_t)(*((_QWORD *)v7 + 3) - v8) > 0x11)
    {
      *(_WORD *)(v8 + 16) = 29813;
      *(_OWORD *)v8 = *(_OWORD *)"tensor_data_layout";
      *((_QWORD *)v7 + 4) += 18;
    }
    else
    {
      llvm::raw_ostream::write(v7, "tensor_data_layout", 0x12uLL);
    }
    mlir::mps::TensorDataLayoutAttr::print((mlir::mps::TensorDataLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ReductionModeAttr,void>::id)
  {
    v53 = a2;
    v9 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v10 = (void *)*((_QWORD *)v9 + 4);
    if (*((_QWORD *)v9 + 3) - (_QWORD)v10 > 0xDuLL)
    {
      qmemcpy(v10, "reduction_mode", 14);
      *((_QWORD *)v9 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v9, "reduction_mode", 0xEuLL);
    }
    mlir::mps::ReductionModeAttr::print((mlir::mps::ReductionModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::DeviceHintAttr,void>::id)
  {
    v53 = a2;
    v11 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v12 = *((_QWORD *)v11 + 4);
    if ((unint64_t)(*((_QWORD *)v11 + 3) - v12) > 0xA)
    {
      *(_DWORD *)(v12 + 7) = 1953393000;
      *(_QWORD *)v12 = *(_QWORD *)"device_hint";
      *((_QWORD *)v11 + 4) += 11;
    }
    else
    {
      llvm::raw_ostream::write(v11, "device_hint", 0xBuLL);
    }
    mlir::mps::DeviceHintAttr::print((mlir::mps::DeviceHintAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::ScatterModeAttr,void>::id)
  {
    v53 = a2;
    v13 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v14 = *((_QWORD *)v13 + 4);
    if ((unint64_t)(*((_QWORD *)v13 + 3) - v14) > 0xB)
    {
      *(_DWORD *)(v14 + 8) = 1701080941;
      *(_QWORD *)v14 = *(_QWORD *)"scatter_mode";
      *((_QWORD *)v13 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v13, "scatter_mode", 0xCuLL);
    }
    mlir::mps::ScatterModeAttr::print((mlir::mps::ScatterModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingModeAttr,void>::id)
  {
    v53 = a2;
    v15 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v16 = *((_QWORD *)v15 + 4);
    if ((unint64_t)(*((_QWORD *)v15 + 3) - v16) > 0xB)
    {
      *(_DWORD *)(v16 + 8) = 1701080941;
      *(_QWORD *)v16 = *(_QWORD *)"padding_mode";
      *((_QWORD *)v15 + 4) += 12;
    }
    else
    {
      llvm::raw_ostream::write(v15, "padding_mode", 0xCuLL);
    }
    mlir::mps::PaddingModeAttr::print((mlir::mps::PaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    v53 = a2;
    v17 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v18 = (void *)*((_QWORD *)v17 + 4);
    if (*((_QWORD *)v17 + 3) - (_QWORD)v18 > 0xCuLL)
    {
      qmemcpy(v18, "sampling_mode", 13);
      *((_QWORD *)v17 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v17, "sampling_mode", 0xDuLL);
    }
    mlir::mps::SamplingModeAttr::print((mlir::mps::SamplingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NearestRoundingModeAttr,void>::id)
  {
    v53 = a2;
    v19 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v20 = (void *)*((_QWORD *)v19 + 4);
    if (*((_QWORD *)v19 + 3) - (_QWORD)v20 > 0x14uLL)
    {
      qmemcpy(v20, "nearest_rounding_mode", 21);
      *((_QWORD *)v19 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v19, "nearest_rounding_mode", 0x15uLL);
    }
    mlir::mps::NearestRoundingModeAttr::print((mlir::mps::NearestRoundingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    v53 = a2;
    v21 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v22 = (void *)*((_QWORD *)v21 + 4);
    if (*((_QWORD *)v21 + 3) - (_QWORD)v22 > 0x14uLL)
    {
      qmemcpy(v22, "sparse_tensor_storage", 21);
      *((_QWORD *)v21 + 4) += 21;
    }
    else
    {
      llvm::raw_ostream::write(v21, "sparse_tensor_storage", 0x15uLL);
    }
    mlir::mps::SparseTensorStorageAttr::print((mlir::mps::SparseTensorStorageAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    v53 = a2;
    v23 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v24 = (void *)*((_QWORD *)v23 + 4);
    if (*((_QWORD *)v23 + 3) - (_QWORD)v24 > 0x1AuLL)
    {
      qmemcpy(v24, "texture_tensor_pixel_format", 27);
      *((_QWORD *)v23 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v23, "texture_tensor_pixel_format", 0x1BuLL);
    }
    mlir::mps::MetalPixelFormatAttr::print((mlir::mps::MetalPixelFormatAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::NormalSamplingMethodAttr,void>::id)
  {
    v53 = a2;
    v25 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v26 = (void *)*((_QWORD *)v25 + 4);
    if (*((_QWORD *)v25 + 3) - (_QWORD)v26 > 0x1CuLL)
    {
      qmemcpy(v26, "random_normal_sampling_method", 29);
      *((_QWORD *)v25 + 4) += 29;
    }
    else
    {
      llvm::raw_ostream::write(v25, "random_normal_sampling_method", 0x1DuLL);
    }
    mlir::mps::NormalSamplingMethodAttr::print((mlir::mps::NormalSamplingMethodAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    v53 = a2;
    v27 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v28 = (void *)*((_QWORD *)v27 + 4);
    if (*((_QWORD *)v27 + 3) - (_QWORD)v28 > 0xCuLL)
    {
      qmemcpy(v28, "padding_style", 13);
      *((_QWORD *)v27 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v27, "padding_style", 0xDuLL);
    }
    mlir::mps::PaddingStyleAttr::print((mlir::mps::PaddingStyleAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PoolIndicesModeAttr,void>::id)
  {
    v53 = a2;
    v29 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v30 = *((_QWORD *)v29 + 4);
    if ((unint64_t)(*((_QWORD *)v29 + 3) - v30) > 0x13)
    {
      *(_DWORD *)(v30 + 16) = 1701080941;
      *(_OWORD *)v30 = *(_OWORD *)"pooling_indices_mode";
      *((_QWORD *)v29 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v29, "pooling_indices_mode", 0x14uLL);
    }
    mlir::mps::PoolIndicesModeAttr::print((mlir::mps::PoolIndicesModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    v53 = a2;
    v31 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v32 = (void *)*((_QWORD *)v31 + 4);
    if (*((_QWORD *)v31 + 3) - (_QWORD)v32 > 0xDuLL)
    {
      qmemcpy(v32, "rnn_activation", 14);
      *((_QWORD *)v31 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v31, "rnn_activation", 0xEuLL);
    }
    mlir::mps::RNNActivationAttr::print((mlir::mps::RNNActivationAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    v53 = a2;
    v33 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v34 = (_OWORD *)*((_QWORD *)v33 + 4);
    if (*((_QWORD *)v33 + 3) - (_QWORD)v34 > 0xFuLL)
    {
      *v34 = *(_OWORD *)"lstm_gate_layout";
      *((_QWORD *)v33 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v33, "lstm_gate_layout", 0x10uLL);
    }
    mlir::mps::LSTMGateLayoutAttr::print((mlir::mps::LSTMGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    v53 = a2;
    v35 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v36 = (void *)*((_QWORD *)v35 + 4);
    if (*((_QWORD *)v35 + 3) - (_QWORD)v36 > 0xEuLL)
    {
      qmemcpy(v36, "gru_gate_layout", 15);
      *((_QWORD *)v35 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v35, "gru_gate_layout", 0xFuLL);
    }
    mlir::mps::GRUGateLayoutAttr::print((mlir::mps::GRUGateLayoutAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::StencilPaddingModeAttr,void>::id)
  {
    v53 = a2;
    v37 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v38 = *((_QWORD *)v37 + 4);
    if ((unint64_t)(*((_QWORD *)v37 + 3) - v38) > 0x13)
    {
      *(_DWORD *)(v38 + 16) = 1701080941;
      *(_OWORD *)v38 = *(_OWORD *)"stencil_padding_mode";
      *((_QWORD *)v37 + 4) += 20;
    }
    else
    {
      llvm::raw_ostream::write(v37, "stencil_padding_mode", 0x14uLL);
    }
    mlir::mps::StencilPaddingModeAttr::print((mlir::mps::StencilPaddingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    v53 = a2;
    v39 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v40 = (void *)*((_QWORD *)v39 + 4);
    if (*((_QWORD *)v39 + 3) - (_QWORD)v40 > 0x19uLL)
    {
      qmemcpy(v40, "crop_resize_alignment_mode", 26);
      *((_QWORD *)v39 + 4) += 26;
    }
    else
    {
      llvm::raw_ostream::write(v39, "crop_resize_alignment_mode", 0x1AuLL);
    }
    mlir::mps::CropResizeAlignmentModeAttr::print((mlir::mps::CropResizeAlignmentModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    v53 = a2;
    v41 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v42 = (void *)*((_QWORD *)v41 + 4);
    if (*((_QWORD *)v41 + 3) - (_QWORD)v42 > 0x1AuLL)
    {
      qmemcpy(v42, "crop_resize_coordinate_mode", 27);
      *((_QWORD *)v41 + 4) += 27;
    }
    else
    {
      llvm::raw_ostream::write(v41, "crop_resize_coordinate_mode", 0x1BuLL);
    }
    mlir::mps::CropResizeCoordinateModeAttr::print((mlir::mps::CropResizeCoordinateModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningMetricAttr,void>::id)
  {
    v53 = a2;
    v43 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v44 = (void *)*((_QWORD *)v43 + 4);
    if (*((_QWORD *)v43 + 3) - (_QWORD)v44 > 0xDuLL)
    {
      qmemcpy(v44, "pruning_metric", 14);
      *((_QWORD *)v43 + 4) += 14;
    }
    else
    {
      llvm::raw_ostream::write(v43, "pruning_metric", 0xEuLL);
    }
    mlir::mps::PruningMetricAttr::print((mlir::mps::PruningMetricAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::PruningStructureAttr,void>::id)
  {
    v53 = a2;
    v45 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v46 = *((_QWORD *)v45 + 4);
    if ((unint64_t)(*((_QWORD *)v45 + 3) - v46) > 0x10)
    {
      *(_BYTE *)(v46 + 16) = 101;
      *(_OWORD *)v46 = *(_OWORD *)"pruning_structure";
      *((_QWORD *)v45 + 4) += 17;
    }
    else
    {
      llvm::raw_ostream::write(v45, "pruning_structure", 0x11uLL);
    }
    mlir::mps::PruningStructureAttr::print((mlir::mps::PruningStructureAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    v53 = a2;
    v47 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v48 = (void *)*((_QWORD *)v47 + 4);
    if (*((_QWORD *)v47 + 3) - (_QWORD)v48 > 0xEuLL)
    {
      qmemcpy(v48, "similarity_type", 15);
      *((_QWORD *)v47 + 4) += 15;
    }
    else
    {
      llvm::raw_ostream::write(v47, "similarity_type", 0xFuLL);
    }
    mlir::mps::SimilarityTypeAttr::print((mlir::mps::SimilarityTypeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    v53 = a2;
    v49 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v50 = (_OWORD *)*((_QWORD *)v49 + 4);
    if (*((_QWORD *)v49 + 3) - (_QWORD)v50 > 0xFuLL)
    {
      *v50 = *(_OWORD *)"fft_scaling_mode";
      *((_QWORD *)v49 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v49, "fft_scaling_mode", 0x10uLL);
    }
    mlir::mps::FFTScalingModeAttr::print((mlir::mps::FFTScalingModeAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    v53 = a2;
    v51 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v52 = (void *)*((_QWORD *)v51 + 4);
    if (*((_QWORD *)v51 + 3) - (_QWORD)v52 > 0xCuLL)
    {
      qmemcpy(v52, "buffer_tensor", 13);
      *((_QWORD *)v51 + 4) += 13;
    }
    else
    {
      llvm::raw_ostream::write(v51, "buffer_tensor", 0xDuLL);
    }
    mlir::mps::MPSBufferTensorAttr::print((mlir::mps::MPSBufferTensorAttr *)&v53, a3);
  }
  else if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    v53 = a2;
    v5 = (llvm::raw_ostream *)(*(uint64_t (**)(mlir::AsmPrinter *))(*(_QWORD *)a3 + 16))(a3);
    v6 = (_OWORD *)*((_QWORD *)v5 + 4);
    if (*((_QWORD *)v5 + 3) - (_QWORD)v6 > 0xFuLL)
    {
      *v6 = *(_OWORD *)"call_inline_mode";
      *((_QWORD *)v5 + 4) += 16;
    }
    else
    {
      llvm::raw_ostream::write(v5, "call_inline_mode", 0x10uLL);
    }
    mlir::mps::CallInlineModeAttr::print((mlir::mps::CallInlineModeAttr *)&v53, a3);
  }
}

uint64_t mlir::mps::detail::ACosOpGenericAdaptorBase::ACosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.acos", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ACosOp::build(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  unsigned int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 v13;
  void *__src;
  uint64_t v15;
  _BYTE v16[16];
  __int128 v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v11 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v16;
  v15 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v13, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v12, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v17 = v13;
  if ((_DWORD)v15 != 1)
  {
    if (!(_DWORD)v15)
    {
      if (HIDWORD(v15))
      {
        v5 = 0;
LABEL_6:
        bzero((char *)__src + 8 * v5, 8 - 8 * v5);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v16, 1uLL, 8);
      v5 = v15;
      if ((_DWORD)v15 != 1)
        goto LABEL_6;
    }
LABEL_7:
    LODWORD(v15) = 1;
  }
  v6 = mlir::ValueRange::dereference_iterator(&v17, 0);
  *(_QWORD *)__src = *(_QWORD *)(v6 + 8) & 0xFFFFFFFFFFFFFFF8;
  v7 = __src;
  v8 = v15;
  v9 = *(unsigned int *)(a2 + 72);
  v10 = v9 + v15;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v8)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v16)
    free(__src);
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v14;
  uint64_t *p_OperandRange;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t Value;
  uint64_t v59;
  uint64_t OperandRange;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v11 = (void *)*((_QWORD *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v54 = a2;
    v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v42 = v14;
      v59 = v14;
      OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange))
        return 1;
      v57 = v42;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    v61 = " #";
    v62 = 2;
    p_OperandRange = &OperandRange;
    v16 = (char *)v64;
    if (v65 >= v66)
    {
      v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        v50 = (char *)&OperandRange - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        v16 = (char *)v64;
        p_OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_OperandRange = &OperandRange;
        v16 = (char *)v64;
      }
    }
    v17 = &v16[24 * v65];
    v18 = *(_OWORD *)p_OperandRange;
    *((_QWORD *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      v61 = (const char *)a5;
      v20 = &OperandRange;
      v21 = (char *)v64;
      if (v19 >= v66)
      {
        v45 = v19 + 1;
        v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          v51 = (char *)&OperandRange - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v21 = (char *)v64;
          v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v20 = &OperandRange;
          v21 = (char *)v64;
        }
      }
      v22 = &v21[24 * v65];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        v61 = " must be tensor of mps native type values or tensor of complex values, but got ";
        v62 = 79;
        v25 = &OperandRange;
        v26 = (char *)v64;
        if (v24 >= v66)
        {
          v47 = v24 + 1;
          v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            v52 = (char *)&OperandRange - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v26 = (char *)v64;
            v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v25 = &OperandRange;
            v26 = (char *)v64;
          }
        }
        v27 = &v26[24 * v65];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v65;
        if (v63[0])
        {
          v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          v30 = (char *)v64;
          if (v65 >= v66)
          {
            v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              v53 = (char *)&OperandRange - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v30 = (char *)v64;
              v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v29 = &OperandRange;
              v30 = (char *)v64;
            }
          }
          v31 = &v30[24 * v65];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v65;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v37 = v68;
    if (v68)
    {
      v38 = v69;
      v39 = v68;
      if (v69 != v68)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v68;
      }
      v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67)
      free(v64);
  }
  return v33;
}

uint64_t mlir::mps::detail::ACoshOpGenericAdaptorBase::ACoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.acosh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ASinOpGenericAdaptorBase::ASinOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.asin", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ASinhOpGenericAdaptorBase::ASinhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.asinh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ATan2OpGenericAdaptorBase::ATan2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atan2", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ATan2Op::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Float32Type *v6;
  mlir::MLIRContext *Context;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  mlir::MLIRContext *v15[2];
  void *__src;
  uint64_t v17;
  _QWORD v18[3];

  v18[2] = *MEMORY[0x1E0C80C00];
  v12 = a4;
  v13 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v13, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  __src = v18;
  v17 = 0x200000000;
  v6 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v15, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v14, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v8 = __src;
  v9 = v17;
  v10 = *(unsigned int *)(a2 + 72);
  v11 = v10 + v17;
  if (v11 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v9)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v10), v8, 8 * v9);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v10 + v9;
  if (__src != v18)
    free(__src);
}

BOOL mlir::mps::ATan2Op::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::detail::ATanOpGenericAdaptorBase::ATanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atan", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ATanhOpGenericAdaptorBase::ATanhOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.atanh", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AbsoluteOpGenericAdaptorBase::AbsoluteOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::AbsoluteOp::getODSOperands(mlir::mps::AbsoluteOp *this, unsigned int a2)
{
  if ((*(_BYTE *)(*(_QWORD *)this + 46) & 0x80) != 0)
    return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * a2;
  else
    return 32 * a2;
}

uint64_t mlir::mps::detail::AbsoluteSquareOpGenericAdaptorBase::AbsoluteSquareOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.absolute_square", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AddOpGenericAdaptorBase::AddOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.add", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AndOpGenericAdaptorBase::AndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.and", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::AssignVariableOpGenericAdaptorBase::AssignVariableOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.assign_variable", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::AssignVariableOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v6;

  v5 = a4;
  v6 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v6, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v5, 1);
}

void mlir::mps::AssignVariableOp::getEffects(uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unsigned __int8 v4;
  uint64_t v5;
  uint64_t **v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;
  const char **v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  int v14;
  unsigned __int8 v15;
  char *v16;
  unint64_t v17;
  unint64_t v18;
  const char *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  const char *v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v3 = mlir::SideEffects::Effect::Base<mlir::MemoryEffects::Write,mlir::MemoryEffects::Effect>::get();
  if ((v4 & 1) == 0)
  {
    v24 = v3;
    v3 = v24;
    if (v14)
    {
      if ((v15 & 1) == 0
      {
        v25 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::SideEffects::DefaultResource]";
        v26 = 84;
        v17 = llvm::StringRef::find((uint64_t *)&v25, "DesiredTypeName = ", 0x12uLL, 0);
        if (v26 >= v17)
          v18 = v17;
        else
          v18 = v26;
        v19 = &v25[v18];
        v20 = v26 - v18;
        if (v26 - v18 >= 0x12)
          v21 = 18;
        else
          v21 = v26 - v18;
        v22 = v20 - v21;
        if (v22 >= v22 - 1)
          v23 = v22 - 1;
        else
          v23 = v22;
        mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v19[v21], v23);
      }
      mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance = (uint64_t)&unk_1E0E25AA8;
      *(_QWORD *)algn_1EDC058A8 = mlir::detail::TypeIDResolver<mlir::SideEffects::DefaultResource,void>::resolveTypeID(void)::id;
      v3 = v24;
    }
  }
  v5 = *(unsigned int *)(a2 + 8);
  if (v5 >= *(_DWORD *)(a2 + 12))
  {
    v25 = (const char *)v3;
    v26 = (unint64_t)&mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    v7 = v5 + 1;
    v27 = 0;
    v28[0] = 0;
    *(_QWORD *)((char *)v28 + 5) = 0;
    v8 = *(_QWORD *)a2 + 40 * (unint64_t)v5 > (unint64_t)&v25;
    if (*(_QWORD *)a2 <= (unint64_t)&v25 && v8)
    {
      v16 = (char *)&v25 - *(_QWORD *)a2;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v7, 40);
      v9 = *(_QWORD *)a2;
      v10 = (const char **)&v16[*(_QWORD *)a2];
    }
    else
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2, (void *)(a2 + 16), v7, 40);
      v9 = *(_QWORD *)a2;
      v10 = &v25;
    }
    v11 = v9 + 40 * *(unsigned int *)(a2 + 8);
    v12 = *(_OWORD *)v10;
    v13 = *((_OWORD *)v10 + 1);
    *(_QWORD *)(v11 + 32) = v10[4];
    *(_OWORD *)v11 = v12;
    *(_OWORD *)(v11 + 16) = v13;
  }
  else
  {
    v6 = (uint64_t **)(*(_QWORD *)a2 + 40 * v5);
    *v6 = v3;
    v6[1] = &mlir::SideEffects::Resource::Base<mlir::SideEffects::DefaultResource,mlir::SideEffects::Resource>::get(void)::instance;
    v6[2] = 0;
    v6[3] = 0;
    *(uint64_t **)((char *)v6 + 29) = 0;
  }
  ++*(_DWORD *)(a2 + 8);
}

uint64_t mlir::mps::detail::BandPartOpGenericAdaptorBase::BandPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.band_part", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BandPartOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  mlir::MLIRContext *Context;
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  void *__src;
  uint64_t v21;
  _BYTE v22[16];
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v15 = a4;
  v16 = a3;
  v14 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v14, 1);
  __src = v22;
  v21 = 0x200000000;
  v6 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v18, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v17, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v23[0] = v18;
  v23[1] = v19;
  if (v19)
  {
    v8 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v23, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v9 = v21;
    if (v21 >= HIDWORD(v21))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v22, v21 + 1, 8);
      v9 = v21;
    }
    *((_QWORD *)__src + v9) = v8;
    v10 = v21 + 1;
    LODWORD(v21) = v10;
    v11 = __src;
    v12 = *(unsigned int *)(a2 + 72);
    v13 = v12 + v10;
    if (v13 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v13, 8);
      LODWORD(v12) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v6, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v10 = v21;
    v11 = __src;
    v12 = *(unsigned int *)(a2 + 72);
    v13 = v12 + v21;
    if (v13 > *(unsigned int *)(a2 + 76))
      goto LABEL_5;
  }
  if (v10)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v12), v11, 8 * v10);
    LODWORD(v12) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v12 + v10;
  if (__src != v22)
    free(__src);
}

BOOL mlir::mps::BandPartOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  _QWORD *v10;
  int ArgOperands;
  uint64_t v12;
  void *v13;
  uint64_t v15;
  uint64_t v16;
  _QWORD *ArgAttrsAttr;
  uint64_t v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  _QWORD **v38;
  _QWORD **v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  void *v49;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  const void **v61;
  uint64_t v62;
  __int16 v63;
  _QWORD v64[2];
  _QWORD v65[2];
  _QWORD v66[2];
  uint64_t OperandRange;
  const void **v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[3];
  void *v72;
  unsigned int v73;
  unsigned int v74;
  _BYTE v75[96];
  void *v76;
  _QWORD *v77;
  void *__p;
  _QWORD **v79;
  char v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_4;
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  v10 = *a2;
  if (!ArgOperands)
    goto LABEL_4;
  v61 = a2;
  v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v61);
  v10 = *a2;
  if (!v12)
  {
    v47 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v68 = a2;
    v69 = v47;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = *a2;
    v49 = (void *)*((_QWORD *)*a2 + 17);
    if (v49 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v49 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  else
  {
LABEL_4:
    v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_13;
    }
  }
  v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v66[0] = a2;
  v66[1] = v15;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
  {
    v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v65[0] = a2;
    v65[1] = v16;
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
    v81 = 1;
    if (v18 == 1 && *ArgAttrsAttr == v81)
      return 1;
  }
LABEL_13:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v46;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  v63 = 261;
  v61 = a3;
  v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    v69 = (uint64_t)" #";
    v70 = 2;
    v19 = &v68;
    v20 = (char *)v72;
    if (v73 >= v74)
    {
      v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        v57 = (char *)&v68 - (_BYTE *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v20 = (char *)v72;
        v19 = (const void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v19 = &v68;
        v20 = (char *)v72;
      }
    }
    v21 = &v20[24 * v73];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      v69 = a5;
      v24 = &v68;
      v25 = (char *)v72;
      if (v23 >= v74)
      {
        v52 = v23 + 1;
        v53 = (char *)v72 + 24 * v23 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          v58 = (char *)&v68 - (_BYTE *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v25 = (char *)v72;
          v24 = (const void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v24 = &v68;
          v25 = (char *)v72;
        }
      }
      v26 = &v25[24 * v73];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        v69 = (uint64_t)" must be 0D tensor of mps index type values or static-shape defined tensor with shape equal to [1"
                       "] or unranked tensor of mps index type values, but got ";
        v70 = 152;
        v29 = &v68;
        v30 = (char *)v72;
        if (v28 >= v74)
        {
          v54 = v28 + 1;
          v55 = (char *)v72 + 24 * v28 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            v59 = (char *)&v68 - (_BYTE *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v30 = (char *)v72;
            v29 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v29 = &v68;
            v30 = (char *)v72;
          }
        }
        v31 = &v30[24 * v73];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v73;
        if (v71[0])
        {
          v33 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          v34 = (char *)v72;
          if (v73 >= v74)
          {
            v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              v60 = (char *)&v68 - (_BYTE *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v34 = (char *)v72;
              v33 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v33 = &v68;
              v34 = (char *)v72;
            }
          }
          v35 = &v34[24 * v73];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v73;
        }
      }
    }
  }
  v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  if (v80)
  {
    v38 = (_QWORD **)__p;
    if (__p)
    {
      v39 = v79;
      v40 = __p;
      if (v79 != __p)
      {
        do
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        v40 = __p;
      }
      v79 = v38;
      operator delete(v40);
    }
    v41 = v76;
    if (v76)
    {
      v42 = v77;
      v43 = v76;
      if (v77 != v76)
      {
        do
        {
          v45 = (void *)*--v42;
          v44 = v45;
          *v42 = 0;
          if (v45)
            operator delete[](v44);
        }
        while (v42 != v41);
        v43 = v76;
      }
      v77 = v41;
      operator delete(v43);
    }
    if (v72 != v75)
      free(v72);
  }
  return v37;
}

uint64_t mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::BatchToSpaceOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.batch_to_space", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BatchToSpaceOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "pixel_shuffle", 0xDuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 58;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::BatchToSpaceOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"pixel_shuffle", 13, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties]";
        v15 = 113;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[386];
    return a1[32];
  }
  return result;
}

void mlir::mps::BatchToSpaceOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7)
{
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t v12;
  mlir::MLIRContext *Context;
  unint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29[2];
  void *__src;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v26 = a4;
  v27 = a3;
  v24 = a6;
  v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  if (a7)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::BatchToSpaceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v32;
  v31 = 0x200000000;
  v12 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v14 = mlir::ValueRange::ValueRange(&v28, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BatchToSpaceOp::inferReturnTypes((uint64_t)v14, v12, 1, v29[0], v29[1], v15, v16, v17, v22, v23, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v18 = __src;
  v19 = v31;
  v20 = *(unsigned int *)(a2 + 72);
  v21 = v20 + v31;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v19)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v32)
    free(__src);
}

BOOL mlir::mps::BatchToSpaceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u)
    || !mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 3u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  _UNKNOWN **v10;
  int ArgOperands;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  uint64_t v37;
  _QWORD **v38;
  _QWORD **v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  unint64_t v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  BOOL v52;
  unint64_t v53;
  int64_t v54;
  int64_t v55;
  int64_t v56;
  int64_t v57;
  const void **v58;
  uint64_t v59;
  __int16 v60;
  _QWORD v61[2];
  _QWORD v62[2];
  _QWORD v63[2];
  _QWORD v64[2];
  uint64_t OperandRange;
  const void **v66;
  uint64_t v67;
  uint64_t v68;
  _QWORD v69[3];
  void *v70;
  unsigned int v71;
  unsigned int v72;
  _BYTE v73[96];
  void *v74;
  _QWORD *v75;
  void *__p;
  _QWORD **v77;
  char v78;
  uint64_t v79;

  v79 = *MEMORY[0x1E0C80C00];
  v10 = (_UNKNOWN **)*a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_4;
  v69[0] = a2;
  v69[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v69);
  v10 = (_UNKNOWN **)*a2;
  if (!ArgOperands)
    goto LABEL_4;
  v58 = a2;
  v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
  v10 = (_UNKNOWN **)*a2;
  if (!v12)
  {
    v18 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v66 = a2;
    v67 = v18;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = (_UNKNOWN **)*a2;
    if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_13;
  }
  else
  {
LABEL_4:
    if (v10[17] != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_13;
  }
  v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v64[0] = a2;
  v64[1] = v13;
  v14 = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v64);
  v10 = (_UNKNOWN **)*a2;
  if (v14)
  {
    v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v63[0] = a2;
    v63[1] = v15;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v63);
    v10 = (_UNKNOWN **)*a2;
    if (v16 == 1)
    {
      v17 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
      v62[0] = a2;
      v62[1] = v17;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
      if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      {
        return 1;
      }
      v10 = (_UNKNOWN **)*a2;
    }
  }
LABEL_13:
  if (v10[17] == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v46 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v61[0] = a2;
    v61[1] = v46;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
  }
  v60 = 261;
  v58 = a3;
  v59 = a4;
  mlir::Operation::emitOpError(a1, &v58, (uint64_t)v69);
  if (v69[0])
  {
    LODWORD(v66) = 3;
    v67 = (uint64_t)" #";
    v68 = 2;
    v19 = &v66;
    v20 = (char *)v70;
    if (v71 >= v72)
    {
      v48 = v71 + 1;
      if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
      {
        v54 = (char *)&v66 - (_BYTE *)v70;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        v20 = (char *)v70;
        v19 = (const void ***)((char *)v70 + v54);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v48, 24);
        v19 = &v66;
        v20 = (char *)v70;
      }
    }
    v21 = &v20[24 * v71];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v71;
    if (v69[0])
    {
      LODWORD(v66) = 5;
      v67 = a5;
      v24 = &v66;
      v25 = (char *)v70;
      if (v23 >= v72)
      {
        v49 = v23 + 1;
        v50 = (char *)v70 + 24 * v23 > (char *)&v66;
        if (v70 <= &v66 && v50)
        {
          v55 = (char *)&v66 - (_BYTE *)v70;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          v25 = (char *)v70;
          v24 = (const void ***)((char *)v70 + v55);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v49, 24);
          v24 = &v66;
          v25 = (char *)v70;
        }
      }
      v26 = &v25[24 * v71];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v71;
      if (v69[0])
      {
        LODWORD(v66) = 3;
        v67 = (uint64_t)" must be 0D tensor of mps index type values or 1D tensor of mps index type values or unranked ten"
                       "sor of mps index type values, but got ";
        v68 = 135;
        v29 = &v66;
        v30 = (char *)v70;
        if (v28 >= v72)
        {
          v51 = v28 + 1;
          v52 = (char *)v70 + 24 * v28 > (char *)&v66;
          if (v70 <= &v66 && v52)
          {
            v56 = (char *)&v66 - (_BYTE *)v70;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            v30 = (char *)v70;
            v29 = (const void ***)((char *)v70 + v56);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v51, 24);
            v29 = &v66;
            v30 = (char *)v70;
          }
        }
        v31 = &v30[24 * v71];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v71;
        if (v69[0])
        {
          v33 = &v66;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v66, (uint64_t)a2);
          v34 = (char *)v70;
          if (v71 >= v72)
          {
            v53 = v71 + 1;
            if (v70 <= &v66 && (char *)v70 + 24 * v71 > (char *)&v66)
            {
              v57 = (char *)&v66 - (_BYTE *)v70;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              v34 = (char *)v70;
              v33 = (const void ***)((char *)v70 + v57);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v70, v73, v53, 24);
              v33 = &v66;
              v34 = (char *)v70;
            }
          }
          v35 = &v34[24 * v71];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v71;
        }
      }
    }
  }
  v37 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v69);
  if (v69[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v69);
  if (v78)
  {
    v38 = (_QWORD **)__p;
    if (__p)
    {
      v39 = v77;
      v40 = __p;
      if (v77 != __p)
      {
        do
          v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
        while (v39 != v38);
        v40 = __p;
      }
      v77 = v38;
      operator delete(v40);
    }
    v41 = v74;
    if (v74)
    {
      v42 = v75;
      v43 = v74;
      if (v75 != v74)
      {
        do
        {
          v45 = (void *)*--v42;
          v44 = v45;
          *v42 = 0;
          if (v45)
            operator delete[](v44);
        }
        while (v42 != v41);
        v43 = v74;
      }
      v75 = v41;
      operator delete(v43);
    }
    if (v70 != v73)
      free(v70);
  }
  return v37;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps4(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    {
      return 1;
    }
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_24;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 1)
        goto LABEL_24;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      {
        goto LABEL_24;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_24:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of int values or 1D tensor of int values, but got ";
        v60 = 75;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::BiasAddGradOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add_grad", 17, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::BiasAddGradOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "data_format", 0xBuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 56;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::BiasAddGradOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"data_format", 11, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is NHWC or NCHW";
        v31 = 70;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties]";
        v15 = 112;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddGradOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[388];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::mps::BiasAddGradOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51))
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of floating point values, but got ";
        v55 = 50;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v13 = &v53;
    v14 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = (char *)v57;
        v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v13 = &v53;
        v14 = (char *)v57;
      }
    }
    v15 = &v14[24 * v58];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
    *(_OWORD *)v15 = v16;
    v17 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v18 = &v53;
      v19 = (char *)v57;
      if (v17 >= v59)
      {
        v42 = v17 + 1;
        v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = (char *)v57;
          v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v18 = &v53;
          v19 = (char *)v57;
        }
      }
      v20 = &v19[24 * v58];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of mps native type values, but got ";
        v55 = 51;
        v23 = &v53;
        v24 = (char *)v57;
        if (v22 >= v59)
        {
          v44 = v22 + 1;
          v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = (char *)v57;
            v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v23 = &v53;
            v24 = (char *)v57;
          }
        }
        v25 = &v24[24 * v58];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v58;
        if (v56[0])
        {
          v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v28 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = (char *)v57;
              v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v27 = &v53;
              v28 = (char *)v57;
            }
          }
          v29 = &v28[24 * v58];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          ++v58;
        }
      }
    }
  }
  v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v31;
}

uint64_t mlir::mps::detail::BiasAddOpGenericAdaptorBase::BiasAddOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bias_add", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[390];
    return a1[32];
  }
  return result;
}

void mlir::mps::BiasAddOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  mlir::MLIRContext *v8;
  unsigned __int8 **AttributeUniquer;
  uint64_t v10;
  uint64_t v11;
  mlir::MLIRContext *Context;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *__src;
  uint64_t v25;
  _BYTE v26[16];
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v19 = a4;
  v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  v8 = *a1;
  LODWORD(v27[0]) = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v8);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v25 = (uint64_t)v8;
  v10 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, (unsigned int *)v27);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::BiasAddOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v10;
  __src = v26;
  v25 = 0x200000000;
  v11 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v22, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v27[0] = v22;
  v27[1] = v23;
  if (v23)
  {
    v13 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v14 = v25;
    if (v25 >= HIDWORD(v25))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, v25 + 1, 8);
      v14 = v25;
    }
    *((_QWORD *)__src + v14) = v13;
    v15 = v25 + 1;
    LODWORD(v25) = v15;
    v16 = __src;
    v17 = *(unsigned int *)(a2 + 72);
    v18 = v17 + v15;
    if (v18 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
      LODWORD(v17) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v11, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v15 = v25;
    v16 = __src;
    v17 = *(unsigned int *)(a2 + 72);
    v18 = v17 + v25;
    if (v18 > *(unsigned int *)(a2 + 76))
      goto LABEL_5;
  }
  if (v15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v16, 8 * v15);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v15;
  if (__src != v26)
    free(__src);
}

BOOL mlir::mps::BiasAddOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  _DWORD *v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (_DWORD *)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v3, (const void **)"data_format", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::BitwiseAndOpGenericAdaptorBase::BitwiseAndOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_and", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::BitwiseAndOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64))
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of int values, but got ";
        v55 = 39;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::detail::BitwiseLeftShiftOpGenericAdaptorBase::BitwiseLeftShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_left_shift", 22, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseNotOpGenericAdaptorBase::BitwiseNotOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_not", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseOrOpGenericAdaptorBase::BitwiseOrOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_or", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwisePopcountOpGenericAdaptorBase::BitwisePopcountOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_popcount", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseRightShiftOpGenericAdaptorBase::BitwiseRightShiftOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_right_shift", 23, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BitwiseXorOpGenericAdaptorBase::BitwiseXorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.bitwise_xor", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::BroadcastGradientArgsOpGenericAdaptorBase::BroadcastGradientArgsOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_gradient_args", 27, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BroadcastGradientArgsOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  mlir::MLIRContext *Context;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21[2];
  void *__src;
  uint64_t v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v18 = a4;
  v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  __src = v24;
  v23 = 0x200000000;
  v6 = *a1;
  v7 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v20, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BroadcastGradientArgsOp::inferReturnTypes(v6, v7, 1, v21[0], v21[1], v9, v10, v11, v16, v17, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v12 = __src;
  v13 = v23;
  v14 = *(unsigned int *)(a2 + 72);
  v15 = v14 + v23;
  if (v15 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v13)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v14), v12, 8 * v13);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v13;
  if (__src != v24)
    free(__src);
}

BOOL mlir::mps::BroadcastGradientArgsOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::detail::BroadcastToOpGenericAdaptorBase::BroadcastToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.broadcast_to", 16, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::BroadcastToOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20[2];
  void *__src;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v17 = a4;
  v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  v22 = 0x200000000;
  v5 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v7 = mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::BroadcastToOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v11 = __src;
  v12 = v22;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23)
    free(__src);
}

BOOL mlir::mps::BroadcastToOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::CallOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  int *v62;
  char *v63;
  char *v64;
  __int128 v65;
  _QWORD **v66;
  _QWORD **v67;
  void *v68;
  _QWORD *v69;
  void *v70;
  void *v71;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  int64_t v80;
  int64_t v81;
  int64_t v82;
  int64_t v83;
  int64_t v84;
  int64_t v85;
  int64_t v86;
  uint64_t v87;
  int v88;
  const char *v89;
  uint64_t v90;
  _QWORD v91[3];
  void *v92;
  unsigned int v93;
  unsigned int v94;
  _BYTE v95[96];
  void *v96;
  _QWORD *v97;
  void *__p;
  _QWORD **v99;
  char v100;
  uint64_t v101;

  v101 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v87 = v6;
  if (!v6)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected DictionaryAttr to set properties";
      v90 = 41;
      v26 = &v88;
      v27 = (char *)v92;
      if (v93 >= v94)
      {
        v73 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v80 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          v27 = (char *)v92;
          v26 = (int *)((char *)v92 + v80);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v73, 24);
          v26 = &v88;
          v27 = (char *)v92;
        }
      }
      v28 = &v27[24 * v93];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v99;
      v32 = __p;
      if (v99 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v99 = v30;
      operator delete(v32);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v33 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_93;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v87, "inlineMode", 0xAuLL);
  if (!v8)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected key entry for inlineMode in DictionaryAttr to set Properties.";
      v90 = 70;
      v36 = &v88;
      v37 = (char *)v92;
      if (v93 >= v94)
      {
        v75 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v82 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          v37 = (char *)v92;
          v36 = (int *)((char *)v92 + v82);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v75, 24);
          v36 = &v88;
          v37 = (char *)v92;
        }
      }
      v38 = &v37[24 * v93];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v99;
      v42 = __p;
      if (v99 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v99 = v40;
      operator delete(v42);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v43 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_93;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v90 = 55;
      v10 = &v88;
      v11 = (char *)v92;
      if (v93 >= v94)
      {
        v74 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v81 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          v11 = (char *)v92;
          v10 = (int *)((char *)v92 + v81);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v74, 24);
          v10 = &v88;
          v11 = (char *)v92;
        }
      }
      v12 = &v11[24 * v93];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v93;
      if (v91[0])
      {
        v14 = &v88;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v9);
        v15 = (char *)v92;
        if (v93 >= v94)
        {
          v76 = v93 + 1;
          if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
          {
            v83 = (char *)&v88 - (_BYTE *)v92;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            v15 = (char *)v92;
            v14 = (int *)((char *)v92 + v83);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v76, 24);
            v14 = &v88;
            v15 = (char *)v92;
          }
        }
        v16 = &v15[24 * v93];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        ++v93;
        if (v91[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
      }
    }
    if (!v100)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v99;
      v20 = __p;
      if (v99 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v99 = v18;
      operator delete(v20);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v22 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_93;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v87, "symbolName", 0xAuLL);
  if (!v46)
  {
    a3(v91, a4);
    if (v91[0])
    {
      v88 = 3;
      v89 = "expected key entry for symbolName in DictionaryAttr to set Properties.";
      v90 = 70;
      v62 = &v88;
      v63 = (char *)v92;
      if (v93 >= v94)
      {
        v78 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v85 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          v63 = (char *)v92;
          v62 = (int *)((char *)v92 + v85);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v78, 24);
          v62 = &v88;
          v63 = (char *)v92;
        }
      }
      v64 = &v63[24 * v93];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = *((_QWORD *)v62 + 2);
      *(_OWORD *)v64 = v65;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
    if (!v100)
      return 0;
    v66 = (_QWORD **)__p;
    if (__p)
    {
      v67 = v99;
      v68 = __p;
      if (v99 != __p)
      {
        do
          v67 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v67 - 1);
        while (v67 != v66);
        v68 = __p;
      }
      v99 = v66;
      operator delete(v68);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v69 = v97;
    v23 = v96;
    if (v97 == v96)
      goto LABEL_94;
    do
    {
      v71 = (void *)*--v69;
      v70 = v71;
      *v69 = 0;
      if (v71)
        operator delete[](v70);
    }
    while (v69 != v21);
    goto LABEL_93;
  }
  v47 = v46;
  if (*(_UNKNOWN **)(*(_QWORD *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::StringAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v91, a4);
  if (v91[0])
  {
    v88 = 3;
    v90 = 55;
    v48 = &v88;
    v49 = (char *)v92;
    if (v93 >= v94)
    {
      v77 = v93 + 1;
      if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
      {
        v84 = (char *)&v88 - (_BYTE *)v92;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        v49 = (char *)v92;
        v48 = (int *)((char *)v92 + v84);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v77, 24);
        v48 = &v88;
        v49 = (char *)v92;
      }
    }
    v50 = &v49[24 * v93];
    v51 = *(_OWORD *)v48;
    *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
    *(_OWORD *)v50 = v51;
    ++v93;
    if (v91[0])
    {
      v52 = &v88;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v88, v47);
      v53 = (char *)v92;
      if (v93 >= v94)
      {
        v79 = v93 + 1;
        if (v92 <= &v88 && (char *)v92 + 24 * v93 > (char *)&v88)
        {
          v86 = (char *)&v88 - (_BYTE *)v92;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          v53 = (char *)v92;
          v52 = (int *)((char *)v92 + v86);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v92, v95, v79, 24);
          v52 = &v88;
          v53 = (char *)v92;
        }
      }
      v54 = &v53[24 * v93];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v93;
      if (v91[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v91);
    }
  }
  if (v100)
  {
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v99;
      v58 = __p;
      if (v99 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v99 = v56;
      operator delete(v58);
    }
    v21 = v96;
    if (!v96)
      goto LABEL_95;
    v59 = v97;
    v23 = v96;
    if (v97 == v96)
    {
LABEL_94:
      v97 = v21;
      operator delete(v23);
LABEL_95:
      if (v92 != v95)
        free(v92);
      return 0;
    }
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
LABEL_93:
    v23 = v96;
    goto LABEL_94;
  }
  return 0;
}

uint64_t mlir::mps::CallOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inlineMode", 10, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"symbolName", 10, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CallInlineMode";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CallOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CallOpGenericAdaptorBase::Properties]";
        v15 = 105;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CallOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[392];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::CallInlineModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CallInlineModeAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::CallOp::build(mlir::StringAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, mlir::MLIRContext *a8, unsigned int a9)
{
  uint64_t StringAttr;
  mlir::MLIRContext *v16;
  unsigned __int8 **AttributeUniquer;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  mlir::MLIRContext *v23;
  __int16 v24;
  unsigned int v25;

  mlir::OperationState::addOperands(a2, a5, a6);
  v24 = 261;
  v22 = a7;
  v23 = a8;
  StringAttr = mlir::Builder::getStringAttr(a1, (mlir::MLIRContext *)&v22);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = StringAttr;
  v16 = *a1;
  v25 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  v22 = &mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id;
  v23 = v16;
  v18 = mlir::StorageUniquer::get<mlir::mps::detail::CallInlineModeAttrStorage,mlir::mps::CallInlineMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25CallInlineModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18CallInlineModeAttrEJNS2_14CallInlineModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v22, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CallInlineModeAttr,void>::id, &v25);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CallOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v18;
  v19 = *(unsigned int *)(a2 + 72);
  if (a4 + v19 > (unint64_t)*(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), a4 + v19, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if (a4)
  {
    v20 = 0;
    v21 = *(_QWORD *)(a2 + 64) + 8 * v19;
    do
    {
      *(_QWORD *)(v21 + 8 * v20) = mlir::TypeRange::dereference_iterator(a3, v20);
      ++v20;
    }
    while (a4 != v20);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + a4;
}

uint64_t mlir::mps::CallOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t NextResultAtOffset;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  const void **v31[4];
  __int16 v32;
  _QWORD v33[3];
  void *v34;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  void *__p;
  _QWORD **v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (!*v3)
  {
    v31[0] = (const void **)"requires attribute 'inlineMode'";
    v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    if (!v40)
      return v15;
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v39;
      v18 = __p;
      if (v39 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v39 = v16;
      operator delete(v18);
    }
    v19 = v36;
    if (v36)
    {
      v20 = v37;
      v21 = v36;
      if (v37 == v36)
        goto LABEL_52;
      do
      {
        v23 = (void *)*--v20;
        v22 = v23;
        *v20 = 0;
        if (v23)
          operator delete[](v22);
      }
      while (v20 != v19);
LABEL_51:
      v21 = v36;
LABEL_52:
      v37 = v19;
      operator delete(v21);
    }
LABEL_53:
    if (v34 != &v35)
      free(v34);
    return v15;
  }
  v5 = v3[1];
  if (!v5)
  {
    v31[0] = (const void **)"requires attribute 'symbolName'";
    v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    if (!v40)
      return v15;
    v24 = (_QWORD **)__p;
    if (__p)
    {
      v25 = v39;
      v26 = __p;
      if (v39 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v39 = v24;
      operator delete(v26);
    }
    v19 = v36;
    if (v36)
    {
      v27 = v37;
      v21 = v36;
      if (v37 == v36)
        goto LABEL_52;
      do
      {
        v29 = (void *)*--v27;
        v28 = v29;
        *v27 = 0;
        if (v29)
          operator delete[](v28);
      }
      while (v27 != v19);
      goto LABEL_51;
    }
    goto LABEL_53;
  }
  v33[0] = v2;
  if (!mlir::cf::__mlir_ods_local_attr_constraint_ControlFlowOps0(v5, (const void **)"symbolName", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps2(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
  v33[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(v4, (const void **)"inlineMode", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps3(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
  v6 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) != 0)
  {
    v7 = *((unsigned int *)v6 + 17);
    if ((_DWORD)v7)
    {
      v8 = 0;
      v9 = v6[9] + 24;
      while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(_QWORD *)(*(_QWORD *)v9 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v8))
      {
        ++v8;
        v9 += 32;
        if (v7 == v8)
        {
          v6 = *this;
          goto LABEL_14;
        }
      }
      return 0;
    }
  }
LABEL_14:
  v10 = *((unsigned int *)v6 + 9);
  v11 = v6 - 2;
  if (v10)
    v12 = (uint64_t)v11;
  else
    v12 = 0;
  if ((_DWORD)v10)
  {
    v13 = 0;
    while (1)
    {
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v12, v13);
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v13))break;
      if (v10 == ++v13)
        return 1;
    }
    return 0;
  }
  return 1;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps8(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  int *v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)v51, 64)
      || mlir::Type::isF16((mlir::Type *)v51)
      || mlir::Type::isF32((mlir::Type *)v51)
      || mlir::Type::isBF16((mlir::Type *)v51)
      || *((_UNKNOWN **)*v51[0] + 17) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v13 = &v53;
    v14 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = (char *)v57;
        v13 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v13 = &v53;
        v14 = (char *)v57;
      }
    }
    v15 = &v14[24 * v58];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
    *(_OWORD *)v15 = v16;
    v17 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v18 = &v53;
      v19 = (char *)v57;
      if (v17 >= v59)
      {
        v42 = v17 + 1;
        v43 = (char *)v57 + 24 * v17 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = (char *)v57;
          v18 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v18 = &v53;
          v19 = (char *)v57;
        }
      }
      v20 = &v19[24 * v58];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      v22 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be variadic of tensor of mps native type values, but got ";
        v55 = 63;
        v23 = &v53;
        v24 = (char *)v57;
        if (v22 >= v59)
        {
          v44 = v22 + 1;
          v45 = (char *)v57 + 24 * v22 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = (char *)v57;
            v23 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v23 = &v53;
            v24 = (char *)v57;
          }
        }
        v25 = &v24[24 * v58];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
        *(_OWORD *)v25 = v26;
        ++v58;
        if (v56[0])
        {
          v27 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v28 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = (char *)v57;
              v27 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v27 = &v53;
              v28 = (char *)v57;
            }
          }
          v29 = &v28[24 * v58];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = *((_QWORD *)v27 + 2);
          *(_OWORD *)v29 = v30;
          ++v58;
        }
      }
    }
  }
  v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v31;
}

uint64_t mlir::mps::detail::CastOpGenericAdaptorBase::CastOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cast", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD **v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v26 = &v56;
      v27 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v27 = (char *)v60;
          v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v26 = &v56;
          v27 = (char *)v60;
        }
      }
      v28 = &v27[24 * v61];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v67;
      v32 = __p;
      if (v67 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v67 = v30;
      operator delete(v32);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v33 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "resultElementType", 0x11uLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for resultElementType in DictionaryAttr to set Properties.";
      v58 = 77;
      v36 = &v56;
      v37 = (char *)v60;
      if (v61 >= v62)
      {
        v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v53 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v37 = (char *)v60;
          v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v36 = &v56;
          v37 = (char *)v60;
        }
      }
      v38 = &v37[24 * v61];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v67;
      v42 = __p;
      if (v67 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v67 = v40;
      operator delete(v42);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v43 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 62;
    v10 = &v56;
    v11 = (char *)v60;
    if (v61 >= v62)
    {
      v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v52 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v11 = (char *)v60;
        v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v10 = &v56;
        v11 = (char *)v60;
      }
    }
    v12 = &v11[24 * v61];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v61;
    if (v59[0])
    {
      v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v15 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v15 = (char *)v60;
          v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v14 = &v56;
          v15 = (char *)v60;
        }
      }
      v16 = &v15[24 * v61];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v67;
      v20 = __p;
      if (v67 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v67 = v18;
      operator delete(v20);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v22 = v65;
    v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_57:
    v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::CastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"resultElementType", 17, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CastOpGenericAdaptorBase::Properties]";
        v15 = 105;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CastOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[394];
    return a1[32];
  }
  return result;
}

void mlir::mps::CastOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::UnknownLoc *v7;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v10;
  mlir::MLIRContext *v11;
  int v12;
  int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19[2];
  unint64_t v20[2];
  void *__src;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a4;
  __src = v23;
  v22 = 0x200000000;
  v7 = *a1;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v10 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v7, v11, v12, v20[0], v20[1], Dictionary, v10, v13, v19[0], v19[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v14 = __src;
  v15 = v22;
  v16 = *(unsigned int *)(a2 + 72);
  v17 = v16 + v22;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v23)
    free(__src);
}

{
  uint64_t v7;
  mlir::UnknownLoc *v8;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v11;
  mlir::MLIRContext *v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20[2];
  unint64_t v21[2];
  void *__src;
  uint64_t v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  v7 = mlir::TypeAttr::get(a4);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CastOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v7;
  __src = v24;
  v23 = 0x200000000;
  v8 = *a1;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v11 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CastOp::inferReturnTypes(v8, v12, v13, v21[0], v21[1], Dictionary, v11, v14, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v15 = __src;
  v16 = v23;
  v17 = *(unsigned int *)(a2 + 72);
  v18 = v17 + v23;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v16)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v24)
    free(__src);
}

BOOL mlir::mps::CastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t v6;
  _QWORD **v7;
  _QWORD **v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  void *v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD **v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v16 = (const void **)"requires attribute 'resultElementType'";
    v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = (_QWORD **)__p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = (void *)*--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              operator delete[](v13);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.ceil", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ClampOpGenericAdaptorBase::ClampOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.clamp", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ClampOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  mlir::MLIRContext *Context;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16[2];
  void *__src;
  uint64_t v18;
  _QWORD v19[3];

  v19[2] = *MEMORY[0x1E0C80C00];
  v13 = a4;
  v14 = a3;
  v12 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v14, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v13, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  __src = v19;
  v18 = 0x200000000;
  v6 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v16, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v15, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v8 = __src;
  v9 = v18;
  v10 = *(unsigned int *)(a2 + 72);
  v11 = v10 + v18;
  if (v11 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v11, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v9)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v10), v8, 8 * v9);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v10 + v9;
  if (__src != v19)
    free(__src);
}

BOOL mlir::mps::ClampOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::ColToImOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t *v55;
  char *v56;
  char *v57;
  __int128 v58;
  _QWORD **v59;
  _QWORD **v60;
  void *v61;
  _QWORD *v62;
  void *v63;
  void *v64;
  uint64_t *v65;
  char *v66;
  char *v67;
  __int128 v68;
  uint64_t *v69;
  char *v70;
  char *v71;
  __int128 v72;
  _QWORD **v73;
  _QWORD **v74;
  void *v75;
  _QWORD *v76;
  void *v77;
  void *v78;
  uint64_t *v79;
  char *v80;
  char *v81;
  __int128 v82;
  _QWORD **v83;
  _QWORD **v84;
  void *v85;
  _QWORD *v86;
  void *v87;
  void *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  _QWORD v112[3];
  void *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[96];
  void *v117;
  _QWORD *v118;
  void *__p;
  _QWORD **v120;
  char v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected DictionaryAttr to set properties";
      v111 = 41;
      v26 = &v109;
      v27 = (char *)v113;
      if (v114 >= v115)
      {
        v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v99 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v27 = (char *)v113;
          v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v26 = &v109;
          v27 = (char *)v113;
        }
      }
      v28 = &v27[24 * v114];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v120;
      v32 = __p;
      if (v120 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v120 = v30;
      operator delete(v32);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v33 = v118;
    v23 = v117;
    if (v118 == v117)
    {
LABEL_117:
      v118 = v21;
      operator delete(v23);
LABEL_118:
      if (v113 != v116)
        free(v113);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_116:
    v23 = v117;
    goto LABEL_117;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v111 = 71;
      v36 = &v109;
      v37 = (char *)v113;
      if (v114 >= v115)
      {
        v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v101 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v37 = (char *)v113;
          v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v36 = &v109;
          v37 = (char *)v113;
        }
      }
      v38 = &v37[24 * v114];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = v36[2];
      *(_OWORD *)v38 = v39;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v120;
      v42 = __p;
      if (v120 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v120 = v40;
      operator delete(v42);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v43 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_116;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 56;
      v10 = &v109;
      v11 = (char *)v113;
      if (v114 >= v115)
      {
        v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v100 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v11 = (char *)v113;
          v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v10 = &v109;
          v11 = (char *)v113;
        }
      }
      v12 = &v11[24 * v114];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v114;
      if (v112[0])
      {
        v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        v15 = (char *)v113;
        if (v114 >= v115)
        {
          v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v102 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v15 = (char *)v113;
            v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v14 = &v109;
            v15 = (char *)v113;
          }
        }
        v16 = &v15[24 * v114];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v120;
      v20 = __p;
      if (v120 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v120 = v18;
      operator delete(v20);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v22 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_116;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v111 = 74;
      v55 = &v109;
      v56 = (char *)v113;
      if (v114 >= v115)
      {
        v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v103 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v56 = (char *)v113;
          v55 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v55 = &v109;
          v56 = (char *)v113;
        }
      }
      v57 = &v56[24 * v114];
      v58 = *(_OWORD *)v55;
      *((_QWORD *)v57 + 2) = v55[2];
      *(_OWORD *)v57 = v58;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v59 = (_QWORD **)__p;
    if (__p)
    {
      v60 = v120;
      v61 = __p;
      if (v120 != __p)
      {
        do
          v60 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v60 - 1);
        while (v60 != v59);
        v61 = __p;
      }
      v120 = v59;
      operator delete(v61);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v62 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v64 = (void *)*--v62;
      v63 = v64;
      *v62 = 0;
      if (v64)
        operator delete[](v63);
    }
    while (v62 != v21);
    goto LABEL_116;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 59;
      v65 = &v109;
      v66 = (char *)v113;
      if (v114 >= v115)
      {
        v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v104 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v66 = (char *)v113;
          v65 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v65 = &v109;
          v66 = (char *)v113;
        }
      }
      v67 = &v66[24 * v114];
      v68 = *(_OWORD *)v65;
      *((_QWORD *)v67 + 2) = v65[2];
      *(_OWORD *)v67 = v68;
      ++v114;
      if (v112[0])
      {
        v69 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        v70 = (char *)v113;
        if (v114 >= v115)
        {
          v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v105 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v70 = (char *)v113;
            v69 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v69 = &v109;
            v70 = (char *)v113;
          }
        }
        v71 = &v70[24 * v114];
        v72 = *(_OWORD *)v69;
        *((_QWORD *)v71 + 2) = v69[2];
        *(_OWORD *)v71 = v72;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v73 = (_QWORD **)__p;
    if (__p)
    {
      v74 = v120;
      v75 = __p;
      if (v120 != __p)
      {
        do
          v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
        while (v74 != v73);
        v75 = __p;
      }
      v120 = v73;
      operator delete(v75);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v76 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v78 = (void *)*--v76;
      v77 = v78;
      *v76 = 0;
      if (v78)
        operator delete[](v77);
    }
    while (v76 != v21);
    goto LABEL_116;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v111 = 76;
      v79 = &v109;
      v80 = (char *)v113;
      if (v114 >= v115)
      {
        v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v106 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v80 = (char *)v113;
          v79 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v79 = &v109;
          v80 = (char *)v113;
        }
      }
      v81 = &v80[24 * v114];
      v82 = *(_OWORD *)v79;
      *((_QWORD *)v81 + 2) = v79[2];
      *(_OWORD *)v81 = v82;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v83 = (_QWORD **)__p;
    if (__p)
    {
      v84 = v120;
      v85 = __p;
      if (v120 != __p)
      {
        do
          v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
        while (v84 != v83);
        v85 = __p;
      }
      v120 = v83;
      operator delete(v85);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_118;
    v86 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_117;
    do
    {
      v88 = (void *)*--v86;
      v87 = v88;
      *v86 = 0;
      if (v88)
        operator delete[](v87);
    }
    while (v86 != v21);
    goto LABEL_116;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "kernel_sizes", 0xCuLL);
    v109 = v50;
    if (v50)
    {
      v51 = v50;
      if ((mlir::DenseIntElementsAttr::classof(v50) & 1) == 0)
      {
        a3(v112, a4);
LABEL_127:
        mlir::InFlightDiagnostic::append<mlir::Attribute>(v90, &v109);
        goto LABEL_128;
      }
      a1[3] = v51;
      v52 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
      v109 = v52;
      if (v52)
      {
        v53 = v52;
        if ((mlir::DenseIntElementsAttr::classof(v52) & 1) != 0)
        {
          a1[4] = v53;
          return 1;
        }
        a3(v112, a4);
        goto LABEL_127;
      }
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for kernel_sizes in DictionaryAttr to set Properties.");
    }
LABEL_128:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v89, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::ColToImOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  void *v33;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x1E0C80C00];
  v36 = a1;
  v37 = v39;
  v38 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    v6 = v38;
  }
  v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v13 = v38;
    }
    v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v19 = v38;
    }
    v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"kernel_sizes", 12, v21);
    v24 = v23;
    v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v25 = v38;
    }
    v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    v30 = v29;
    v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v31 = v38;
    }
    v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v33 = v37;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v37 == v39)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (mlir::MLIRContext *)v37, v8);
  v33 = v37;
  if (v37 != v39)
LABEL_24:
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::ColToImOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ColToImOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xCuLL:
      result = memcmp(__s1, "kernel_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::ColToImOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"kernel_sizes", 12, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
}

BOOL mlir::mps::ColToImOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(const void ***__return_ptr, uint64_t), uint64_t a4)
{
  _DWORD *v8;
  _QWORD *v9;
  const void **v10;
  _QWORD *v11;
  _QWORD *v12;
  _BOOL8 result;

  v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v8, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v9, (const void **)"dilation_rates", (const char *)0xE, a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v11, (const void **)"kernel_sizes", (const char *)0xC, a3, a4))
        {
          v12 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v12, (const void **)"strides", (const char *)7, a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && a1[2] < 2u)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NCHW or NHWC";
        v31 = 77;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(_QWORD *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t NumElements;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  _QWORD *v41;
  _QWORD v42[2];
  uint64_t OperandRange;
  _QWORD *v44;
  _QWORD v45[2];
  _QWORD v46[2];
  void *v47;
  unsigned int v48;
  const void **v49;
  const char *v50;
  uint64_t v51;
  __int16 v52;
  const void **v53;
  char v54[8];
  uint64_t v55;
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD **v63;
  char v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_7;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46[0] = v12;
  v46[1] = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  v65 = 2;
  if (v14 != 1 || *ArgAttrsAttr != v65)
    goto LABEL_7;
  v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      v33 = *(_QWORD *)v47;
      operator delete[](v47);
      if (!v33)
        goto LABEL_7;
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    return 1;
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    v50 = "attribute '";
    v51 = 11;
    v15 = &v49;
    v16 = (char *)v56;
    if (v57 >= v58)
    {
      v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        v39 = (char *)&v49 - (_BYTE *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v16 = (char *)v56;
        v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v15 = &v49;
        v16 = (char *)v56;
      }
    }
    v17 = &v16[24 * v57];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    ++v57;
    if (v53)
    {
      v52 = 261;
      v49 = a2;
      v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {2}";
        v51 = 77;
        v19 = &v49;
        v20 = (char *)v56;
        if (v57 >= v58)
        {
          v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            v40 = (char *)&v49 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v20 = (char *)v56;
            v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v19 = &v49;
            v20 = (char *)v56;
          }
        }
        v21 = &v20[24 * v57];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = v19[2];
        *(_OWORD *)v21 = v22;
        ++v57;
      }
    }
  }
  v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  if (v64)
  {
    v24 = (_QWORD **)__p;
    if (__p)
    {
      v25 = v63;
      v26 = __p;
      if (v63 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v63 = v24;
      operator delete(v26);
    }
    v27 = v60;
    if (v60)
    {
      v28 = v61;
      v29 = v60;
      if (v61 != v60)
      {
        do
        {
          v31 = (void *)*--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            operator delete[](v30);
        }
        while (v28 != v27);
        v29 = v60;
      }
      v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59)
      free(v56);
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  void *v33;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  const void **v39;
  _QWORD v40[2];
  uint64_t OperandRange;
  const void **v42;
  const char *v43;
  uint64_t v44;
  __int16 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_13;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v42 = a1;
  v43 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46 = v12;
  v47 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
  v57 = xmmword_181240890;
  if (v14 == 2 && *ArgAttrsAttr == (_QWORD)v57 && ArgAttrsAttr[1] == *((_QWORD *)&v57 + 1))
  {
    v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = "attribute '";
    v44 = 11;
    v18 = &v42;
    v19 = (char *)v48;
    if (v49 >= v50)
    {
      v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v19 = (char *)v48;
        v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v18 = &v42;
        v19 = (char *)v48;
      }
    }
    v20 = &v19[24 * v49];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v49;
    if (v46)
    {
      v45 = 261;
      v42 = a2;
      v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {4, 2}";
        v44 = 71;
        v22 = &v42;
        v23 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v38 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v23 = (char *)v48;
            v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = &v42;
            v23 = (char *)v48;
          }
        }
        v24 = &v23[24 * v49];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = v22[2];
        *(_OWORD *)v24 = v25;
        ++v49;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v26 = (_QWORD **)__p;
    if (__p)
    {
      v27 = v55;
      v28 = __p;
      if (v55 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v55 = v26;
      operator delete(v28);
    }
    v29 = v52;
    if (v52)
    {
      v30 = v53;
      v31 = v52;
      if (v53 != v52)
      {
        do
        {
          v33 = (void *)*--v30;
          v32 = v33;
          *v30 = 0;
          if (v33)
            operator delete[](v32);
        }
        while (v30 != v29);
        v31 = v52;
      }
      v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51)
      free(v48);
  }
  return v17;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[396];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::TensorDataLayoutAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::ColToImOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, __int128 *a5, uint64_t a6, __int128 *a7, uint64_t a8, __int128 *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t FormattedPaddingImToCol;

  v16 = mlir::mps::get2DElementsForImToCol(a1, a5);
  v17 = mlir::mps::get2DElementsForImToCol(a1, a7);
  v18 = mlir::mps::get2DElementsForImToCol(a1, a9);
  FormattedPaddingImToCol = mlir::mps::getFormattedPaddingImToCol(a1, a11, a12, a13);
  mlir::mps::ColToImOp::build((mlir::MLIRContext **)a1, a2, a3, a4, v16, v17, v18, FormattedPaddingImToCol, a13);
}

void mlir::mps::ColToImOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9)
{
  mlir::MLIRContext *v15;
  unsigned __int8 **AttributeUniquer;
  uint64_t v17;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v20;
  unint64_t *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32[2];
  unint64_t v33[2];
  void *__src;
  uint64_t v35;
  _QWORD v36[3];

  v36[2] = *MEMORY[0x1E0C80C00];
  v29 = a4;
  v30 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v30, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = a5;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v15 = *a1;
  v31 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v35 = (uint64_t)v15;
  v17 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v31);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v17;
  __src = v36;
  v35 = 0x200000000;
  mlir::ValueRange::ValueRange(v33, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v20 = *(__int128 **)(a2 + 256);
  v21 = mlir::ValueRange::ValueRange(v32, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ColToImOp::inferReturnTypes((uint64_t)v21, v22, v23, v33[0], v33[1], Dictionary, v20, v24, v32[0], v32[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v25 = __src;
  v26 = v35;
  v27 = *(unsigned int *)(a2 + 72);
  v28 = v27 + v35;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v26)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v36)
    free(__src);
}

BOOL mlir::mps::ColToImOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t NextResultAtOffset;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  _QWORD **v38;
  _QWORD **v39;
  void *v40;
  _QWORD *v41;
  void *v42;
  void *v43;
  const void **v45[4];
  __int16 v46;
  _QWORD v47[3];
  void *v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(_QWORD **)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
            {
              return 0;
            }
            if (*((_DWORD *)*this + 9))
              v9 = (uint64_t)(*this - 2);
            else
              v9 = 0;
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
          }
          v45[0] = (const void **)"requires attribute 'strides'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v38 = (_QWORD **)__p;
            if (__p)
            {
              v39 = v53;
              v40 = __p;
              if (v53 != __p)
              {
                do
                  v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                v40 = __p;
              }
              v53 = v38;
              operator delete(v40);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_93;
            v41 = v51;
            v17 = v50;
            if (v51 == v50)
            {
LABEL_92:
              v51 = v15;
              operator delete(v17);
LABEL_93:
              if (v48 != &v49)
                free(v48);
              return v11;
            }
            do
            {
              v43 = (void *)*--v41;
              v42 = v43;
              *v41 = 0;
              if (v43)
                operator delete[](v42);
            }
            while (v41 != v15);
LABEL_91:
            v17 = v50;
            goto LABEL_92;
          }
        }
        else
        {
          v45[0] = (const void **)"requires attribute 'kernel_sizes'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v32 = (_QWORD **)__p;
            if (__p)
            {
              v33 = v53;
              v34 = __p;
              if (v53 != __p)
              {
                do
                  v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                v34 = __p;
              }
              v53 = v32;
              operator delete(v34);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_93;
            v35 = v51;
            v17 = v50;
            if (v51 == v50)
              goto LABEL_92;
            do
            {
              v37 = (void *)*--v35;
              v36 = v37;
              *v35 = 0;
              if (v37)
                operator delete[](v36);
            }
            while (v35 != v15);
            goto LABEL_91;
          }
        }
      }
      else
      {
        v45[0] = (const void **)"requires attribute 'explicit_padding'";
        v46 = 259;
        mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        if (v54)
        {
          v26 = (_QWORD **)__p;
          if (__p)
          {
            v27 = v53;
            v28 = __p;
            if (v53 != __p)
            {
              do
                v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              v28 = __p;
            }
            v53 = v26;
            operator delete(v28);
          }
          v15 = v50;
          if (!v50)
            goto LABEL_93;
          v29 = v51;
          v17 = v50;
          if (v51 == v50)
            goto LABEL_92;
          do
          {
            v31 = (void *)*--v29;
            v30 = v31;
            *v29 = 0;
            if (v31)
              operator delete[](v30);
          }
          while (v29 != v15);
          goto LABEL_91;
        }
      }
    }
    else
    {
      v45[0] = (const void **)"requires attribute 'dilation_rates'";
      v46 = 259;
      mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
      v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      if (v54)
      {
        v20 = (_QWORD **)__p;
        if (__p)
        {
          v21 = v53;
          v22 = __p;
          if (v53 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v53 = v20;
          operator delete(v22);
        }
        v15 = v50;
        if (!v50)
          goto LABEL_93;
        v23 = v51;
        v17 = v50;
        if (v51 == v50)
          goto LABEL_92;
        do
        {
          v25 = (void *)*--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v23 != v15);
        goto LABEL_91;
      }
    }
  }
  else
  {
    v45[0] = (const void **)"requires attribute 'data_layout'";
    v46 = 259;
    mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    if (v54)
    {
      v12 = (_QWORD **)__p;
      if (__p)
      {
        v13 = v53;
        v14 = __p;
        if (v53 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v53 = v12;
        operator delete(v14);
      }
      v15 = v50;
      if (!v50)
        goto LABEL_93;
      v16 = v51;
      v17 = v50;
      if (v51 == v50)
        goto LABEL_92;
      do
      {
        v19 = (void *)*--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          operator delete[](v18);
      }
      while (v16 != v15);
      goto LABEL_91;
    }
  }
  return v11;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps9(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 3)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 3D tensor of 32-bit float values, but got ";
        v60 = 93;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 4)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF32((mlir::Type *)&OperandRange))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit float values or 4D tensor of 32-bit float values, but got ";
        v60 = 93;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::ConcatOpGenericAdaptorBase::ConcatOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.concat", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ConcatOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "interleave", 0xAuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 55;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::ConcatOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"interleave", 10, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[398];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConcatOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  mlir::MLIRContext *v9;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v11;
  mlir::MLIRContext *v12;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v15;
  int v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22[2];
  char *v23[2];
  void *__src;
  uint64_t v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  v21 = a5;
  mlir::OperationState::addOperands(a2, a3, a4);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v26;
  v25 = 0x200000000;
  v11 = *a1;
  v12 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange((unint64_t *)v23, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v15 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ConcatOp::inferReturnTypes(v11, v12, 1, v23[0], (unint64_t)v23[1], Dictionary, v15, v16, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v17 = __src;
  v18 = v25;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v25;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v26)
    free(__src);
}

BOOL mlir::mps::ConcatOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  uint64_t v16;
  uint64_t NextResultAtOffset;
  uint64_t *v19;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v19 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"interleave", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v19))return 0;
  v4 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
  {
    v7 = 0;
    v6 = 0xFFFFFFFFLL;
LABEL_5:
    v8 = 0;
    v9 = v7 + 24;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(*this, (const void **)(*(_QWORD *)(*(_QWORD *)v9 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8))
    {
      ++v8;
      v9 += 32;
      if (v6 == v8)
      {
        v4 = *this;
        if ((*((_BYTE *)*this + 46) & 0x80) != 0)
          goto LABEL_11;
        v10 = 0;
        v11 = -2;
        goto LABEL_12;
      }
    }
    return 0;
  }
  v5 = *((_DWORD *)v4 + 17);
  v6 = (v5 - 1);
  if (v5 != 1)
  {
    v7 = v4[9];
    goto LABEL_5;
  }
  LODWORD(v8) = 0;
LABEL_11:
  v12 = *((_DWORD *)v4 + 17);
  v10 = v4[9];
  v11 = v12 - 2;
LABEL_12:
  v13 = (v11 + 1);
  v14 = (v11 + 2) - v13;
  for (i = v10 + 32 * v13 + 24;
        mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)i + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v8);
        i += 32)
  {
    LODWORD(v8) = v8 + 1;
    if (!--v14)
    {
      if (*((_DWORD *)*this + 9))
        v16 = (uint64_t)(*this - 2);
      else
        v16 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
  }
  return 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps11(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v14;
  uint64_t *p_OperandRange;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t Value;
  uint64_t v59;
  uint64_t OperandRange;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v11 = (void *)*((_QWORD *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v54 = a2;
    v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v42 = v14;
      v59 = v14;
      OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange))
        return 1;
      v57 = v42;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    v61 = " #";
    v62 = 2;
    p_OperandRange = &OperandRange;
    v16 = (char *)v64;
    if (v65 >= v66)
    {
      v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        v50 = (char *)&OperandRange - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        v16 = (char *)v64;
        p_OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_OperandRange = &OperandRange;
        v16 = (char *)v64;
      }
    }
    v17 = &v16[24 * v65];
    v18 = *(_OWORD *)p_OperandRange;
    *((_QWORD *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      v61 = (const char *)a5;
      v20 = &OperandRange;
      v21 = (char *)v64;
      if (v19 >= v66)
      {
        v45 = v19 + 1;
        v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          v51 = (char *)&OperandRange - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v21 = (char *)v64;
          v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v20 = &OperandRange;
          v21 = (char *)v64;
        }
      }
      v22 = &v21[24 * v65];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        v61 = " must be variadic of tensor of mps native type values or tensor of complex values, but got ";
        v62 = 91;
        v25 = &OperandRange;
        v26 = (char *)v64;
        if (v24 >= v66)
        {
          v47 = v24 + 1;
          v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            v52 = (char *)&OperandRange - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v26 = (char *)v64;
            v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v25 = &OperandRange;
            v26 = (char *)v64;
          }
        }
        v27 = &v26[24 * v65];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v65;
        if (v63[0])
        {
          v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          v30 = (char *)v64;
          if (v65 >= v66)
          {
            v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              v53 = (char *)&OperandRange - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v30 = (char *)v64;
              v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v29 = &OperandRange;
              v30 = (char *)v64;
            }
          }
          v31 = &v30[24 * v65];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v65;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v37 = v68;
    if (v68)
    {
      v38 = v69;
      v39 = v68;
      if (v69 != v68)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v68;
      }
      v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67)
      free(v64);
  }
  return v33;
}

uint64_t mlir::mps::detail::ConjugateOpGenericAdaptorBase::ConjugateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conjugate", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *this, uint64_t a2, _QWORD **a3, uint64_t a4, uint64_t a5)
{
  char *v8;
  _QWORD *v9;
  void *v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v15;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v17;
  pthread_rwlock_t **v18;
  uint64_t v19;
  _QWORD *v20;

  *(_QWORD *)this = a2;
  *((_BYTE *)this + 8) = 0;
  v8 = (char *)this + 8;
  *((_BYTE *)this + 16) = 0;
  v9 = *a3;
  *((_QWORD *)this + 3) = *a3;
  if (v9
    && ((v10 = *(void **)(*v9 + 136),
         v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id,
         v10 != &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      ? (v12 = 0)
      : (v12 = v9),
        v20 = v12,
        v11))
  {
    v15 = v9[2];
    Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v20);
    v18 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v17) + 48);
    llvm::sys::RWMutexImpl::lock(v18);
    ++*(_QWORD *)(v15 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v18);
    v19 = *(_QWORD *)this;
    *((_QWORD *)this + 4) = a4;
    *((_QWORD *)this + 5) = a5;
    if (!v19)
      return this;
  }
  else
  {
    *((_QWORD *)this + 4) = a4;
    *((_QWORD *)this + 5) = a5;
    if (!a2)
      return this;
  }
  v13 = mlir::Attribute::getContext(this);
  if (*((_BYTE *)this + 16))
    *((_BYTE *)this + 16) = 0;
  mlir::OperationName::OperationName(v8, "mps.constant", 12, v13);
  *((_BYTE *)this + 16) = 1;
  return this;
}

mlir::Attribute *mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(mlir::Attribute *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  _QWORD **v8;
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  if (BYTE3(v4))
    v8 = (_QWORD **)v5;
  else
    v8 = 0;
  mlir::ValueRange::ValueRange(v10, v7, v6);
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase(a1, v3, v8, v10[0], v10[1]);
  return a1;
}

uint64_t mlir::mps::ConstantOp::setPropertiesFromAttr(_QWORD *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  _QWORD *v9;
  void *v10;
  BOOL v11;
  _QWORD *v12;
  uint64_t v13;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v15;
  pthread_rwlock_t **v16;
  int *v18;
  char *v19;
  char *v20;
  __int128 v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  int *v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  unint64_t v40;
  unint64_t v41;
  int64_t v42;
  int64_t v43;
  uint64_t v44;
  int v45;
  const char *v46;
  uint64_t v47;
  _QWORD v48[3];
  void *v49;
  unsigned int v50;
  unsigned int v51;
  _BYTE v52[96];
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v44 = v6;
  if (!v6)
  {
    a3(v48, a4);
    if (v48[0])
    {
      v45 = 3;
      v46 = "expected DictionaryAttr to set properties";
      v47 = 41;
      v18 = &v45;
      v19 = (char *)v49;
      if (v50 >= v51)
      {
        v40 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          v42 = (char *)&v45 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          v19 = (char *)v49;
          v18 = (int *)((char *)v49 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v40, 24);
          v18 = &v45;
          v19 = (char *)v49;
        }
      }
      v20 = &v19[24 * v50];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = *((_QWORD *)v18 + 2);
      *(_OWORD *)v20 = v21;
      ++v50;
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (!v57)
      return 0;
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v56;
      v24 = __p;
      if (v56 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v56 = v22;
      operator delete(v24);
    }
    v25 = v53;
    if (!v53)
      goto LABEL_47;
    v26 = v54;
    v27 = v53;
    if (v54 == v53)
      goto LABEL_46;
    do
    {
      v29 = (void *)*--v26;
      v28 = v29;
      *v26 = 0;
      if (v29)
        operator delete[](v28);
    }
    while (v26 != v25);
    goto LABEL_45;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v44, "value", 5uLL);
  if (!v8)
  {
    a3(v48, a4);
    if (v48[0])
    {
      v45 = 3;
      v46 = "expected key entry for value in DictionaryAttr to set Properties.";
      v47 = 65;
      v30 = &v45;
      v31 = (char *)v49;
      if (v50 >= v51)
      {
        v41 = v50 + 1;
        if (v49 <= &v45 && (char *)v49 + 24 * v50 > (char *)&v45)
        {
          v43 = (char *)&v45 - (_BYTE *)v49;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          v31 = (char *)v49;
          v30 = (int *)((char *)v49 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v52, v41, 24);
          v30 = &v45;
          v31 = (char *)v49;
        }
      }
      v32 = &v31[24 * v50];
      v33 = *(_OWORD *)v30;
      *((_QWORD *)v32 + 2) = *((_QWORD *)v30 + 2);
      *(_OWORD *)v32 = v33;
      ++v50;
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    }
    if (!v57)
      return 0;
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v56;
      v36 = __p;
      if (v56 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v56 = v34;
      operator delete(v36);
    }
    v25 = v53;
    if (!v53)
    {
LABEL_47:
      if (v49 != v52)
        free(v49);
      return 0;
    }
    v37 = v54;
    v27 = v53;
    if (v54 == v53)
    {
LABEL_46:
      v54 = v25;
      operator delete(v27);
      goto LABEL_47;
    }
    do
    {
      v39 = (void *)*--v37;
      v38 = v39;
      *v37 = 0;
      if (v39)
        operator delete[](v38);
    }
    while (v37 != v25);
LABEL_45:
    v27 = v53;
    goto LABEL_46;
  }
  v9 = v8;
  v10 = *(void **)(*v8 + 136);
  v11 = v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
  if (v10 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
    v12 = v8;
  else
    v12 = 0;
  v48[0] = v12;
  if (v11)
  {
    v13 = v8[2];
    Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)v48);
    v16 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v15) + 48);
    llvm::sys::RWMutexImpl::lock(v16);
    ++*(_QWORD *)(v13 + 88);
    llvm::sys::RWMutexImpl::unlock_shared(v16);
  }
  *a1 = v9;
  return 1;
}

uint64_t mlir::mps::ConstantOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, mlir::MLIRContext *a2)
{
  uint64_t v2;
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  void *v11;
  mlir::DictionaryAttr *v13;
  void *v14;
  uint64_t v15;
  _QWORD v16[7];

  v16[6] = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v14 = v16;
  v15 = 0x300000000;
  v2 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    v2 = mlir::UnitAttr::get(a1, a2);
  NamedAttr = mlir::Builder::getNamedAttr(&v13, (uint64_t)"value", 5, v2);
  v5 = v4;
  v6 = v15;
  if (v15 >= HIDWORD(v15))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v14, v16, v15 + 1, 16);
    v6 = v15;
  }
  v7 = (uint64_t *)((char *)v14 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = __CFADD__((_DWORD)v15, 1);
  v9 = (v15 + 1);
  LODWORD(v15) = v15 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    v11 = v14;
    if (v14 == v16)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v13, (mlir::MLIRContext *)v14, v9);
  v11 = v14;
  if (v14 != v16)
LABEL_10:
    free(v11);
  return DictionaryAttr;
}

unint64_t mlir::mps::ConstantOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned __int8 v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unsigned __int8 v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v17;
  int v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;

  v1 = *a1;
  if (*(_UNKNOWN **)(*(_QWORD *)*a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
  {
    v27 = llvm::hash_value(**(_QWORD ***)(v1 + 16), *(_QWORD *)(*(_QWORD *)(v1 + 16) + 8));
    v6 = *(_QWORD *)(v1 + 40);
    if ((v7 & 1) == 0)
    {
      v24 = *(_QWORD *)(v1 + 40);
      v6 = v24;
      if (v21)
      {
        v22 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override)
          v22 = 0xFF51AFD7ED558CCDLL;
        llvm::hashing::detail::get_execution_seed(void)::seed = v22;
        v6 = v24;
      }
    }
    v8 = HIDWORD(v6);
    v9 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v6) ^ HIDWORD(v6));
    v26 = 0x9DDFEA08EB382D69
        * ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) ^ ((0x9DDFEA08EB382D69 * (v8 ^ (v9 >> 47) ^ v9)) >> 47));
    v10 = *(_QWORD *)(v1 + 8);
    if ((v9 & 1) == 0
    {
      v23 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v23 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v23;
    }
    v11 = 0x9DDFEA08EB382D69
        * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v10) ^ HIDWORD(v10));
    v12 = 0x9DDFEA08EB382D69 * (HIDWORD(v10) ^ (v11 >> 47) ^ v11);
    v25 = 0x9DDFEA08EB382D69 * (v12 ^ (v12 >> 47));
    v5 = llvm::hash_combine<llvm::hash_code,llvm::hash_code,llvm::hash_code>(&v27, (uint64_t *)&v26, (uint64_t *)&v25);
    if ((v13 & 1) == 0)
      goto LABEL_9;
  }
  else
  {
    if ((v2 & 1) == 0
    {
      v20 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v20 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v20;
    }
    v3 = 0x9DDFEA08EB382D69
       * ((llvm::hashing::detail::get_execution_seed(void)::seed + 8 * v1) ^ HIDWORD(v1));
    v4 = 0x9DDFEA08EB382D69 * (HIDWORD(v1) ^ (v3 >> 47) ^ v3);
    v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
    if ((v4 & 1) == 0)
    {
LABEL_9:
      v17 = v5;
      v5 = v17;
      if (v18)
      {
        v19 = llvm::hashing::detail::fixed_seed_override;
        if (!llvm::hashing::detail::fixed_seed_override)
          v19 = 0xFF51AFD7ED558CCDLL;
        llvm::hashing::detail::get_execution_seed(void)::seed = v19;
        v5 = v17;
      }
    }
  }
  v14 = llvm::hashing::detail::get_execution_seed(void)::seed ^ HIDWORD(v5);
  v15 = 0x9DDFEA08EB382D69 * (v14 ^ (8 * v5 + 8));
  return 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) ^ ((0x9DDFEA08EB382D69 * (v14 ^ (v15 >> 47) ^ v15)) >> 47));
}

uint64_t mlir::mps::ConstantOp::readProperties(uint64_t a1, _QWORD *a2)
{
  _QWORD *v3;
  _QWORD *v4;
  void *v5;
  BOOL v6;
  _QWORD *v7;
  uint64_t v8;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v10;
  pthread_rwlock_t **v11;
  _QWORD *v13;
  _QWORD *v14;

  v3 = (_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(a2);
  v13 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, _QWORD **))(*(_QWORD *)a1 + 48))(a1, &v13))
    return 0;
  v4 = v13;
  if (v13)
  {
    v5 = *(void **)(*v13 + 136);
    v6 = v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v7 = v13;
    else
      v7 = 0;
    v14 = v7;
    if (v6)
    {
      v8 = v13[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v14);
      v11 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v10) + 48);
      llvm::sys::RWMutexImpl::lock(v11);
      ++*(_QWORD *)(v8 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v11);
    }
  }
  *v3 = v4;
  return 1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ConstantOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[400];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  void *v6;
  BOOL v7;
  _QWORD *v8;
  uint64_t v9;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v11;
  pthread_rwlock_t **v12;
  _QWORD *Type;
  _QWORD *v14;
  uint64_t v15;
  _QWORD v16[2];
  _QWORD *v17;

  v16[0] = a3;
  v16[1] = a4;
  if (a3)
  {
    v6 = *(void **)(*a3 + 136);
    v7 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    v8 = v6 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a3 : 0;
    v17 = v8;
    if (v7)
    {
      v9 = a3[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v17);
      v12 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v11) + 48);
      llvm::sys::RWMutexImpl::lock(v12);
      ++*(_QWORD *)(v9 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v12);
    }
  }
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a3;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v16);
  v14 = Type;
  if (Type)
    mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v15 = *(unsigned int *)(a2 + 72);
  if (v15 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15 + 1, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v15) = v14;
  ++*(_DWORD *)(a2 + 72);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::ConstantProperty & mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::ConstantProperty]";
        v15 = 77;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::ConstantProperty,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[402];
    return a1[32];
  }
  return result;
}

void mlir::mps::ConstantOp::build(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  void *v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v13;
  pthread_rwlock_t **v14;
  _QWORD *v15;

  if (a4)
  {
    v7 = *(void **)(*a4 + 136);
    v8 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    v9 = v7 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? a4 : 0;
    v15 = v9;
    if (v8)
    {
      v11 = a4[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v15);
      v14 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v13) + 48);
      llvm::sys::RWMutexImpl::lock(v14);
      ++*(_QWORD *)(v11 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v14);
      *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a4;
      v10 = *(unsigned int *)(a2 + 72);
      if (v10 < *(_DWORD *)(a2 + 76))
        goto LABEL_8;
      goto LABEL_7;
    }
  }
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::ConstantProperty>((_QWORD *)a2) = a4;
  v10 = *(unsigned int *)(a2 + 72);
  if (v10 >= *(_DWORD *)(a2 + 76))
  {
LABEL_7:
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10 + 1, 8);
    LODWORD(v10) = *(_DWORD *)(a2 + 72);
  }
LABEL_8:
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v10) = a3;
  ++*(_DWORD *)(a2 + 72);
}

void mlir::mps::ConstantOp::build(mlir::mps::ConstantOp *this, mlir::OpBuilder *a2, mlir::OperationState *a3)
{
  uint64_t IntegerType;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  int v11;

  v11 = (int)a3;
  IntegerType = mlir::Builder::getIntegerType(this, 0x20u, 1);
  v5 = (_QWORD *)mlir::RankedTensorType::get(0, 0, IntegerType, 0);
  v6 = v5;
  if (v5)
    v7 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v5 + 8);
  else
    v7 = 0;
  v8 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v6, v7, &v11, 4, 4, 1, 1);
  v9 = v8;
  if (v8)
  {
    v8 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v8 + 8);
    v10 = (uint64_t)v8;
  }
  else
  {
    v10 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v8, (uint64_t)a2, v9, v10);
}

void mlir::mps::ConstantOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t IntegerType;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  v8 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v14, 1, IntegerType, 0);
  v9 = v8;
  if (v8)
    v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  else
    v10 = 0;
  v11 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v10, a3, 4 * a4, 4, 1, 1);
  v12 = v11;
  if (v11)
  {
    v11 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8);
    v13 = (uint64_t)v11;
  }
  else
  {
    v13 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v11, a2, v12, v13);
}

{
  uint64_t IntegerType;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD v14[2];

  v14[1] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 1);
  v8 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v14, 1, IntegerType, 0);
  v9 = v8;
  if (v8)
    v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v8 + 8);
  else
    v10 = 0;
  v11 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v9, v10, a3, 8 * a4, 8, 1, 1);
  v12 = v11;
  if (v11)
  {
    v11 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v11 + 8);
    v13 = (uint64_t)v11;
  }
  else
  {
    v13 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v11, a2, v12, v13);
}

void mlir::mps::ConstantOp::build(mlir::Float32Type **this, mlir::OpBuilder *a2, mlir::OperationState *a3, float a4)
{
  uint64_t F32Type;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  float v12;

  v12 = a4;
  F32Type = mlir::Builder::getF32Type(this, a2);
  v6 = (_QWORD *)mlir::RankedTensorType::get(0, 0, F32Type, 0);
  v7 = v6;
  if (v6)
    v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v6 + 8);
  else
    v8 = 0;
  v9 = (_QWORD *)mlir::DenseElementsAttr::getFromRawBuffer(v7, v8, &v12, 4, 4, 0, 1);
  v10 = v9;
  if (v9)
  {
    v9 = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*v9 + 8);
    v11 = (uint64_t)v9;
  }
  else
  {
    v11 = 0;
  }
  mlir::mps::ConstantOp::build((uint64_t)v9, (uint64_t)a2, v10, v11);
}

uint64_t mlir::mps::ConstantOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t *v4;
  const void **v5;
  const void *v6;
  void *v7;
  void *v9;
  uint64_t *p_OperandRange;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char v28;
  _QWORD **v29;
  _QWORD **v30;
  void *v31;
  _QWORD *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  const void **v49;
  uint64_t v50;
  __int16 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t Value;
  uint64_t OperandRange;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD **v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  v4 = *this;
  v5 = (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  v6 = *v5;
  v7 = (void *)*((_QWORD *)*v5 + 17);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v59[0] = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
    v59[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v59);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
    if (mlir::Type::isF16((mlir::Type *)&OperandRange))
      return 1;
    if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      return 1;
    if (mlir::Type::isBF16((mlir::Type *)&OperandRange))
      return 1;
    v9 = *(void **)(*(_QWORD *)OperandRange + 136);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      return 1;
    if (v9 == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v54 = OperandRange;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v54);
      if (mlir::Type::isF16((mlir::Type *)&Value))
        return 1;
      v52 = OperandRange;
      v53 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52);
      if (mlir::Type::isF32((mlir::Type *)&v53))
        return 1;
    }
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      return 1;
    }
    v6 = *v5;
    v7 = (void *)*((_QWORD *)*v5 + 17);
  }
  if (v7 != &mlir::detail::TypeIDResolver<mlir::MemRefType,void>::id)
    goto LABEL_91;
  v49 = v5;
  v50 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v49);
  if (!mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isF16((mlir::Type *)&OperandRange)
    && !mlir::Type::isF32((mlir::Type *)&OperandRange)
    && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
  {
    v37 = *(void **)(*(_QWORD *)OperandRange + 136);
    if (v37 != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      if (v37 != &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id
        || (v54 = OperandRange,
            Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v54),
            !mlir::Type::isF16((mlir::Type *)&Value))
        && (v52 = OperandRange,
            v53 = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v52),
            !mlir::Type::isF32((mlir::Type *)&v53)))
      {
        if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          && *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
        {
LABEL_91:
          v51 = 261;
          v49 = (const void **)"result";
          v50 = 6;
          mlir::Operation::emitOpError(v4, &v49, (uint64_t)v59);
          if (v59[0])
          {
            LODWORD(OperandRange) = 3;
            v57 = " #";
            v58 = 2;
            p_OperandRange = &OperandRange;
            v11 = (char *)v60;
            if (v61 >= v62)
            {
              v39 = v61 + 1;
              if (v60 <= &OperandRange && (char *)v60 + 24 * v61 > (char *)&OperandRange)
              {
                v45 = (char *)&OperandRange - (_BYTE *)v60;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v39, 24);
                v11 = (char *)v60;
                p_OperandRange = (uint64_t *)((char *)v60 + v45);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v39, 24);
                p_OperandRange = &OperandRange;
                v11 = (char *)v60;
              }
            }
            v12 = &v11[24 * v61];
            v13 = *(_OWORD *)p_OperandRange;
            *((_QWORD *)v12 + 2) = p_OperandRange[2];
            *(_OWORD *)v12 = v13;
            v14 = ++v61;
            if (v59[0])
            {
              LODWORD(OperandRange) = 5;
              v57 = 0;
              v15 = &OperandRange;
              v16 = (char *)v60;
              if (v14 >= v62)
              {
                v40 = v14 + 1;
                v41 = (char *)v60 + 24 * v14 > (char *)&OperandRange;
                if (v60 <= &OperandRange && v41)
                {
                  v46 = (char *)&OperandRange - (_BYTE *)v60;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v40, 24);
                  v16 = (char *)v60;
                  v15 = (uint64_t *)((char *)v60 + v46);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v40, 24);
                  v15 = &OperandRange;
                  v16 = (char *)v60;
                }
              }
              v17 = &v16[24 * v61];
              v18 = *(_OWORD *)v15;
              *((_QWORD *)v17 + 2) = v15[2];
              *(_OWORD *)v17 = v18;
              v19 = ++v61;
              if (v59[0])
              {
                LODWORD(OperandRange) = 3;
                v57 = " must be tensor of mps native type or complex or quantized values or memref of mps native type or "
                      "complex or quantized values, but got ";
                v58 = 135;
                v20 = &OperandRange;
                v21 = (char *)v60;
                if (v19 >= v62)
                {
                  v42 = v19 + 1;
                  v43 = (char *)v60 + 24 * v19 > (char *)&OperandRange;
                  if (v60 <= &OperandRange && v43)
                  {
                    v47 = (char *)&OperandRange - (_BYTE *)v60;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v42, 24);
                    v21 = (char *)v60;
                    v20 = (uint64_t *)((char *)v60 + v47);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v42, 24);
                    v20 = &OperandRange;
                    v21 = (char *)v60;
                  }
                }
                v22 = &v21[24 * v61];
                v23 = *(_OWORD *)v20;
                *((_QWORD *)v22 + 2) = v20[2];
                *(_OWORD *)v22 = v23;
                ++v61;
                if (v59[0])
                {
                  v24 = &OperandRange;
                  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)v5);
                  v25 = (char *)v60;
                  if (v61 >= v62)
                  {
                    v44 = v61 + 1;
                    if (v60 <= &OperandRange && (char *)v60 + 24 * v61 > (char *)&OperandRange)
                    {
                      v48 = (char *)&OperandRange - (_BYTE *)v60;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
                      v25 = (char *)v60;
                      v24 = (uint64_t *)((char *)v60 + v48);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v44, 24);
                      v24 = &OperandRange;
                      v25 = (char *)v60;
                    }
                  }
                  v26 = &v25[24 * v61];
                  v27 = *(_OWORD *)v24;
                  *((_QWORD *)v26 + 2) = v24[2];
                  *(_OWORD *)v26 = v27;
                  ++v61;
                }
              }
            }
          }
          v28 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
          if (v59[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
          if (v68)
          {
            v29 = (_QWORD **)__p;
            if (__p)
            {
              v30 = v67;
              v31 = __p;
              if (v67 != __p)
              {
                do
                  v30 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v30 - 1);
                while (v30 != v29);
                v31 = __p;
              }
              v67 = v29;
              operator delete(v31);
            }
            v32 = v64;
            if (v64)
            {
              v33 = v65;
              v34 = v64;
              if (v65 != v64)
              {
                do
                {
                  v36 = (void *)*--v33;
                  v35 = v36;
                  *v33 = 0;
                  if (v36)
                    operator delete[](v35);
                }
                while (v33 != v32);
                v34 = v64;
              }
              v65 = v32;
              operator delete(v34);
            }
            if (v60 != v63)
              free(v60);
          }
          if (!v28)
            return 0;
        }
      }
    }
  }
  return 1;
}

uint64_t mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Conv2DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d_data_gradient", 25, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  uint64_t *v62;
  char *v63;
  char *v64;
  __int128 v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD **v70;
  _QWORD **v71;
  void *v72;
  _QWORD *v73;
  void *v74;
  void *v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  __int128 v79;
  _QWORD **v80;
  _QWORD **v81;
  void *v82;
  _QWORD *v83;
  void *v84;
  void *v85;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  const char *v111;
  uint64_t v112;
  _QWORD v113[3];
  void *v114;
  unsigned int v115;
  unsigned int v116;
  _BYTE v117[96];
  void *v118;
  _QWORD *v119;
  void *__p;
  _QWORD **v121;
  char v122;
  uint64_t v123;

  v123 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v109 = v6;
  if (!v6)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected DictionaryAttr to set properties";
      v112 = 41;
      v26 = &v110;
      v27 = (char *)v114;
      if (v115 >= v116)
      {
        v92 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v100 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          v27 = (char *)v114;
          v26 = (uint64_t *)((char *)v114 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v92, 24);
          v26 = &v110;
          v27 = (char *)v114;
        }
      }
      v28 = &v27[24 * v115];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v121;
      v32 = __p;
      if (v121 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v121 = v30;
      operator delete(v32);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v33 = v119;
    v23 = v118;
    if (v119 == v118)
    {
LABEL_116:
      v119 = v21;
      operator delete(v23);
LABEL_117:
      if (v114 != v117)
        free(v114);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_115:
    v23 = v118;
    goto LABEL_116;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v109, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v112 = 71;
      v36 = &v110;
      v37 = (char *)v114;
      if (v115 >= v116)
      {
        v94 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v102 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          v37 = (char *)v114;
          v36 = (uint64_t *)((char *)v114 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v94, 24);
          v36 = &v110;
          v37 = (char *)v114;
        }
      }
      v38 = &v37[24 * v115];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = v36[2];
      *(_OWORD *)v38 = v39;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v121;
      v42 = __p;
      if (v121 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v121 = v40;
      operator delete(v42);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v43 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v112 = 56;
      v10 = &v110;
      v11 = (char *)v114;
      if (v115 >= v116)
      {
        v93 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v101 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          v11 = (char *)v114;
          v10 = (uint64_t *)((char *)v114 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v93, 24);
          v10 = &v110;
          v11 = (char *)v114;
        }
      }
      v12 = &v11[24 * v115];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v115;
      if (v113[0])
      {
        v14 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v9);
        v15 = (char *)v114;
        if (v115 >= v116)
        {
          v95 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            v103 = (char *)&v110 - (_BYTE *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            v15 = (char *)v114;
            v14 = (uint64_t *)((char *)v114 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v95, 24);
            v14 = &v110;
            v15 = (char *)v114;
          }
        }
        v16 = &v15[24 * v115];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v115;
        if (v113[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v121;
      v20 = __p;
      if (v121 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v121 = v18;
      operator delete(v20);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v22 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v109, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v112 = 74;
      v52 = &v110;
      v53 = (char *)v114;
      if (v115 >= v116)
      {
        v96 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v104 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          v53 = (char *)v114;
          v52 = (uint64_t *)((char *)v114 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v96, 24);
          v52 = &v110;
          v53 = (char *)v114;
        }
      }
      v54 = &v53[24 * v115];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v121;
      v58 = __p;
      if (v121 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v121 = v56;
      operator delete(v58);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v59 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v112 = 59;
      v62 = &v110;
      v63 = (char *)v114;
      if (v115 >= v116)
      {
        v97 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v105 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          v63 = (char *)v114;
          v62 = (uint64_t *)((char *)v114 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v97, 24);
          v62 = &v110;
          v63 = (char *)v114;
        }
      }
      v64 = &v63[24 * v115];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = v62[2];
      *(_OWORD *)v64 = v65;
      ++v115;
      if (v113[0])
      {
        v66 = &v110;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v110, v47);
        v67 = (char *)v114;
        if (v115 >= v116)
        {
          v98 = v115 + 1;
          if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
          {
            v106 = (char *)&v110 - (_BYTE *)v114;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            v67 = (char *)v114;
            v66 = (uint64_t *)((char *)v114 + v106);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v98, 24);
            v66 = &v110;
            v67 = (char *)v114;
          }
        }
        v68 = &v67[24 * v115];
        v69 = *(_OWORD *)v66;
        *((_QWORD *)v68 + 2) = v66[2];
        *(_OWORD *)v68 = v69;
        ++v115;
        if (v113[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
      }
    }
    if (!v122)
      return 0;
    v70 = (_QWORD **)__p;
    if (__p)
    {
      v71 = v121;
      v72 = __p;
      if (v121 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v121 = v70;
      operator delete(v72);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v73 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v75 = (void *)*--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        operator delete[](v74);
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v109, "explicit_padding", 0x10uLL);
  v108 = v48;
  if (!v48)
  {
    a3(v113, a4);
    if (v113[0])
    {
      LODWORD(v110) = 3;
      v111 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v112 = 76;
      v76 = &v110;
      v77 = (char *)v114;
      if (v115 >= v116)
      {
        v99 = v115 + 1;
        if (v114 <= &v110 && (char *)v114 + 24 * v115 > (char *)&v110)
        {
          v107 = (char *)&v110 - (_BYTE *)v114;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          v77 = (char *)v114;
          v76 = (uint64_t *)((char *)v114 + v107);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v114, v117, v99, 24);
          v76 = &v110;
          v77 = (char *)v114;
        }
      }
      v78 = &v77[24 * v115];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = v76[2];
      *(_OWORD *)v78 = v79;
      ++v115;
      if (v113[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v113);
    }
    if (!v122)
      return 0;
    v80 = (_QWORD **)__p;
    if (__p)
    {
      v81 = v121;
      v82 = __p;
      if (v121 != __p)
      {
        do
          v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        v82 = __p;
      }
      v121 = v80;
      operator delete(v82);
    }
    v21 = v118;
    if (!v118)
      goto LABEL_117;
    v83 = v119;
    v23 = v118;
    if (v119 == v118)
      goto LABEL_116;
    do
    {
      v85 = (void *)*--v83;
      v84 = v85;
      *v83 = 0;
      if (v85)
        operator delete[](v84);
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    v50 = mlir::DictionaryAttr::get((uint64_t)&v109, "groups", 6uLL);
    v110 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a1[3] = v50;
        v88 = mlir::DictionaryAttr::get((uint64_t)&v109, "padding_style", 0xDuLL);
        v110 = v88;
        if (!v88)
        {
          a3(v113, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for padding_style in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        if (*(_UNKNOWN **)(*(_QWORD *)v88 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
        {
          a1[4] = v88;
          v89 = mlir::DictionaryAttr::get((uint64_t)&v109, "strides", 7uLL);
          v110 = v89;
          if (!v89)
          {
            a3(v113, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for strides in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          v90 = v89;
          if ((mlir::DenseIntElementsAttr::classof(v89) & 1) != 0)
          {
            a1[5] = v90;
            v91 = mlir::DictionaryAttr::get((uint64_t)&v109, "weights_layout", 0xEuLL);
            v110 = v91;
            if (!v91)
            {
              a3(v113, a4);
              mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
              goto LABEL_123;
            }
            if (*(_UNKNOWN **)(*(_QWORD *)v91 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            {
              a1[6] = v91;
              return 1;
            }
            a3(v113, a4);
          }
          else
          {
            a3(v113, a4);
          }
        }
        else
        {
          a3(v113, a4);
        }
      }
      else
      {
        a3(v113, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v110);
    }
    else
    {
      a3(v113, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v113, "expected key entry for groups in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
    return 0;
  }
  a3(v113, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v108);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v113);
  return 0;
}

uint64_t mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x1E0C80C00];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"groups", 6, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"padding_style", 13, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"strides", 7, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"weights_layout", 14, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

unint64_t mlir::mps::Conv2DDataGradientOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  int v27;
  int v28;
  unint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  int v33;
  int v34;
  unint64_t v35;
  int v36;
  int v37;
  unint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  int v42;
  int v43;
  unint64_t v44;
  int v45;
  unint64_t v46;
  int v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t *v54;
  unint64_t *v55;
  unint64_t *v56;
  unint64_t *v57;
  unint64_t *v58;
  unint64_t *v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  _OWORD v82[4];
  _OWORD v83[3];
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;

  v86 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v54 = a1;
    v68 = *a1;
    v1 = v68;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v28 = v27;
    a1 = v54;
    if (v28)
    {
      v29 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v29 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v29;
      v1 = v68;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v54;
    }
  }
  v4 = v3[19];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v55 = a1;
    v61 = v3[19];
    v69 = v1;
    v49 = a1[1];
    v4 = v61;
    v1 = v69;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v31 = v30;
    v5 = v49;
    a1 = v55;
    if (v31)
    {
      v32 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v32 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v32;
      v5 = v49;
      a1 = v55;
      v4 = v61;
      v1 = v69;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v5);
  v8 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v5) ^ HIDWORD(v5));
  v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v56 = a1;
    v62 = v4;
    v70 = v1;
    v50 = a1[2];
    v4 = v62;
    v1 = v70;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v34 = v33;
    v9 = v50;
    a1 = v56;
    if (v34)
    {
      v35 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v35 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v35;
      v9 = v50;
      a1 = v56;
      v4 = v62;
      v1 = v70;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v9) ^ HIDWORD(v9));
  v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v57 = a1;
    v63 = v4;
    v71 = v1;
    v51 = a1[3];
    v4 = v63;
    v1 = v71;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    v12 = v51;
    a1 = v57;
    if (v37)
    {
      v38 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v38 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v38;
      v12 = v51;
      a1 = v57;
      v4 = v63;
      v1 = v71;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v58 = a1;
    v64 = v4;
    v72 = v1;
    v52 = a1[4];
    v4 = v64;
    v1 = v72;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v40 = v39;
    v15 = v52;
    a1 = v58;
    if (v40)
    {
      v41 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v41 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v41;
      v15 = v52;
      a1 = v58;
      v4 = v64;
      v1 = v72;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v78 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v59 = a1;
    v65 = v4;
    v73 = v1;
    v53 = a1[5];
    v4 = v65;
    v1 = v73;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v43 = v42;
    v18 = v53;
    a1 = v59;
    if (v43)
    {
      v44 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v44 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v44;
      v18 = v53;
      a1 = v59;
      v4 = v65;
      v1 = v73;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v18) ^ HIDWORD(v18));
  v77 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  v21 = a1[6];
  if ((v20 & 1) == 0)
  {
    v66 = v4;
    v74 = v1;
    v60 = a1[6];
    v21 = v60;
    v4 = v66;
    v1 = v74;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v45)
    {
      v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v46 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      v21 = v60;
      v4 = v66;
      v1 = v74;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v22 = HIDWORD(v21);
  v23 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v21) ^ HIDWORD(v21));
  v76 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  v84 = 0;
  memset(v83, 0, sizeof(v83));
  memset(v82, 0, sizeof(v82));
  if ((v23 & 1) == 0)
  {
    v67 = v4;
    v75 = v1;
    v4 = v67;
    v1 = v75;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v47)
    {
      v48 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v48 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v48;
      v4 = v67;
      v1 = v75;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v24 = HIDWORD(v1);
  v25 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v85 = v3[19];
  *(_QWORD *)&v82[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v24 ^ (v25 >> 47) ^ v25)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v24 ^ (v25 >> 47) ^ v25)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v82, 0, (_QWORD *)v82 + 1, (char *)v83, (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79, (uint64_t *)&v78, (uint64_t *)&v77, (uint64_t *)&v76);
}

uint64_t mlir::mps::Conv2DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"groups", 6, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v10);
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  const void **v13;
  uint64_t v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v13, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
            {
              v14 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  const void **v38;
  _QWORD v39[2];
  uint64_t OperandRange;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_9;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v41 = a1;
  v42 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v45 = v12;
  v46 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  v56 = 4;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = "attribute '";
    v43 = 11;
    v17 = &v41;
    v18 = (char *)v47;
    if (v48 >= v49)
    {
      v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v18 = (char *)v47;
        v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v17 = &v41;
        v18 = (char *)v47;
      }
    }
    v19 = &v18[24 * v48];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    ++v48;
    if (v45)
    {
      v44 = 261;
      v41 = a2;
      v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {4}";
        v43 = 68;
        v21 = &v41;
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 64))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 64-bit unsigned integer attribute";
        v33 = 65;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = (void *)*--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid padding_style";
        v31 = 51;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::Conv2DDataGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[404];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::PaddingStyleAttr]";
  v41 = 77;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::Conv2DDataGradientOp::setStridesAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 96) + 40), a2);
}

void mlir::mps::Conv2DDataGradientOp::setDilationRatesAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 96) + 8), a2);
}

void mlir::mps::Conv2DDataGradientOp::setExplicitPaddingAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 96) + 16), a2);
}

void mlir::mps::Conv2DDataGradientOp::setDataLayoutAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, **(_QWORD **)(*(_QWORD *)(*a1 + 48) + 96), a2);
}

void mlir::mps::Conv2DDataGradientOp::setWeightsLayoutAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 96) + 48), a2);
}

void mlir::mps::Conv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned int a15, unsigned int a16, unsigned int a17)
{
  uint64_t IntegerType;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD v33[3];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  _QWORD v42[2];
  void *v43;
  uint64_t v44;
  __int128 v45;
  void *v46;
  uint64_t v47;
  _BYTE v48[64];
  _OWORD *v49;
  uint64_t v50;
  _OWORD v51[2];
  _OWORD *v52;
  uint64_t v53;
  _OWORD v54[2];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v52 = v54;
  v54[0] = xmmword_1812503B8;
  v54[1] = unk_1812503C8;
  v53 = 0x400000004;
  v49 = v51;
  v51[0] = xmmword_1812503B8;
  v51[1] = unk_1812503C8;
  v50 = 0x400000004;
  v46 = v48;
  memset(v48, 0, sizeof(v48));
  v47 = 0x800000008;
  v39 = 0;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v34 = 0u;
  memset(v33, 0, sizeof(v33));
  mlir::mps::buildConv2DDescriptor(a3, a4, a6, a7, a8, a9, a10, (uint64_t)v33, a12, a13, a14, a15, a16, a17, v54, (uint64_t)v51, (uint64_t)v48, 0);
  v43 = &v45;
  v45 = xmmword_181240890;
  v44 = 0x200000002;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v19 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v45, 2, IntegerType, 0);
  v40 = v42;
  v42[0] = 4;
  v41 = 0x200000001;
  v20 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v21 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v42, 1, v20, 0);
  v22 = v21;
  if (v21)
    v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  else
    v23 = 0;
  v24 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v23, v52, 8 * v53, 8, 1, 0);
  if (v22)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v25, v49, 8 * v50, 8, 1, 0);
  if (v19)
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  else
    v27 = 0;
  v28 = mlir::DenseElementsAttr::getFromRawBuffer(v19, v27, v46, 8 * v47, 8, 1, 0);
  mlir::mps::Conv2DDataGradientOp::build(a1, a2, a3, a4, a5, v34, v24, v26, v28, a15, a16, a17);
  if (v40 != v42)
    free(v40);
  if (v43 != &v45)
    free(v43);
  if (v46 != v48)
    free(v46);
  if (v49 != v51)
    free(v49);
  if (v52 != v54)
    free(v52);
}

void mlir::mps::Conv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v20;
  unsigned __int8 **AttributeUniquer;
  uint64_t v22;
  mlir::MLIRContext *v23;
  unsigned __int8 **v24;
  uint64_t v25;
  mlir::MLIRContext *v26;
  unsigned __int8 **v27;
  uint64_t v28;
  mlir::UnknownLoc *v29;
  mlir::MLIRContext *v30;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v33;
  int v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43[2];
  unint64_t v44[2];
  void *__src;
  uint64_t v46;
  _QWORD v47[3];

  v47[2] = *MEMORY[0x1E0C80C00];
  v40 = a4;
  v41 = a3;
  v39 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  if (a5)
    mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a9;
  v20 = *(mlir::MLIRContext **)a1;
  v42 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v20);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v46 = (uint64_t)v20;
  v22 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v42);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v22;
  v23 = *(mlir::MLIRContext **)a1;
  v42 = a11;
  v24 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v46 = (uint64_t)v23;
  v25 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v24, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v25;
  v26 = *(mlir::MLIRContext **)a1;
  v42 = a12;
  v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v46 = (uint64_t)v26;
  v28 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v28;
  __src = v47;
  v46 = 0x200000000;
  v29 = *(mlir::UnknownLoc **)a1;
  v30 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v44, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v33 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v43, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DDataGradientOp::inferReturnTypes(v29, v30, 1, v44[0], v44[1], Dictionary, v33, v34, v43[0], v43[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v35 = __src;
  v36 = v46;
  v37 = *(unsigned int *)(a2 + 72);
  v38 = v37 + v46;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v36)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v47)
    free(__src);
}

BOOL mlir::mps::Conv2DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t *v11;
  unint64_t v12;
  unsigned int v13;
  uint64_t ODSOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  void *v34;
  void *v35;
  _QWORD **v36;
  _QWORD **v37;
  void *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  _QWORD **v42;
  _QWORD **v43;
  void *v44;
  _QWORD *v45;
  void *v46;
  void *v47;
  _QWORD **v48;
  _QWORD **v49;
  void *v50;
  _QWORD *v51;
  void *v52;
  void *v53;
  _QWORD **v54;
  _QWORD **v55;
  void *v56;
  _QWORD *v57;
  void *v58;
  void *v59;
  const char *v61;
  uint64_t v62;
  uint64_t NextResultAtOffset;
  uint64_t v64;
  unsigned int v65;
  const void **v66[4];
  __int16 v67;
  _QWORD v68[3];
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD **v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (!*v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v28 = (_QWORD **)__p;
    if (__p)
    {
      v29 = v74;
      v30 = __p;
      if (v74 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v74 = v28;
      operator delete(v30);
    }
    v31 = v71;
    if (v71)
    {
      v32 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v35 = (void *)*--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          operator delete[](v34);
      }
      while (v32 != v31);
LABEL_96:
      v33 = v71;
LABEL_97:
      v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70)
      free(v69);
    return v27;
  }
  v5 = (const void **)v3[1];
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v36 = (_QWORD **)__p;
    if (__p)
    {
      v37 = v74;
      v38 = __p;
      if (v74 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v74 = v36;
      operator delete(v38);
    }
    v31 = v71;
    if (v71)
    {
      v39 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v41 = (void *)*--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          operator delete[](v40);
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v6 = (const void **)v3[2];
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v42 = (_QWORD **)__p;
    if (__p)
    {
      v43 = v74;
      v44 = __p;
      if (v74 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v74 = v42;
      operator delete(v44);
    }
    v31 = v71;
    if (v71)
    {
      v45 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v47 = (void *)*--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          operator delete[](v46);
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v7 = (const void **)v3[3];
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v48 = (_QWORD **)__p;
    if (__p)
    {
      v49 = v74;
      v50 = __p;
      if (v74 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v74 = v48;
      operator delete(v50);
    }
    v31 = v71;
    if (v71)
    {
      v51 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v53 = (void *)*--v51;
        v52 = v53;
        *v51 = 0;
        if (v53)
          operator delete[](v52);
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v8 = v3[4];
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v54 = (_QWORD **)__p;
    if (__p)
    {
      v55 = v74;
      v56 = __p;
      if (v74 != __p)
      {
        do
          v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        v56 = __p;
      }
      v74 = v54;
      operator delete(v56);
    }
    v31 = v71;
    if (v71)
    {
      v57 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v59 = (void *)*--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          operator delete[](v58);
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v9 = (const void **)v3[5];
  if (!v9)
  {
    v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v26 = v68;
    goto LABEL_104;
  }
  v10 = v3[6];
  if (!v10)
  {
    v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v11 = *this;
  v12 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v11, v12, (const void **)"operand", (const void **)7, 0))return 0;
  v13 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    v18 = ODSOperands + 24;
    while (1)
    {
      v19 = *this;
      v20 = *(_QWORD *)(*(_QWORD *)v18 + 8) & 0xFFFFFFFFFFFFFFF8;
      v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v19, v20, (const void **)"operand", (const void **)7, (int)v17 + 1))return 0;
      ++v17;
      v18 += 32;
      if (v16 == v17)
      {
        v13 = v17 + 1;
        break;
      }
    }
  }
  v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    v64 = v23;
    v26 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<unsigned long>(v25, &v64);
LABEL_104:
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v62 = (uint64_t)(*this - 2);
  else
    v62 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::Conv2DOpGenericAdaptorBase::Conv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_2d", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv2DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[406];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  uint64_t IntegerType;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v35[4];
  void *v36[2];
  _OWORD v37[7];
  void *v38;
  uint64_t v39;
  _BYTE v40[64];
  _BYTE *v41;
  uint64_t v42;
  _BYTE v43[32];
  _QWORD *v44;
  uint64_t v45;
  _QWORD v46[6];

  v46[4] = *MEMORY[0x1E0C80C00];
  v44 = v46;
  memset_pattern16(v46, &unk_181233190, 0x20uLL);
  v45 = 0x400000004;
  v41 = v43;
  memset_pattern16(v43, &unk_181233190, 0x20uLL);
  v42 = 0x400000004;
  v38 = v40;
  memset(v40, 0, sizeof(v40));
  v39 = 0x800000008;
  mlir::mps::buildConv2DDescriptor(a3, a4, a5, a6, a7, a8, a9, (uint64_t)v36, a11, a12, a13, a14, a15, a16, v46, (uint64_t)v43, (uint64_t)v40, 0);
  v36[0] = v37;
  v37[0] = xmmword_181240890;
  v36[1] = (void *)0x400000002;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v17 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v37, 2, IntegerType, 0);
  v35[0] = 4;
  v18 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v19 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v35, 1, v18, 0);
  v20 = v19;
  if (v19)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  else
    v21 = 0;
  v22 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, v44, 8 * v45, 8, 1, 0);
  if (v20)
    v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  else
    v23 = 0;
  v24 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v23, v41, 8 * v42, 8, 1, 0);
  if (v17)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v25, v38, 8 * v39, 8, 1, 0);
  mlir::mps::Conv2DOp::build(a1, a2, a3, a4, a5, v22, v24, v26, a14, a15, a16);
  if (v36[0] != v37)
    free(v36[0]);
  if (v38 != v40)
    free(v38);
  if (v41 != v43)
    free(v41);
  if (v44 != v46)
    free(v44);
}

void mlir::mps::Conv2DOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  mlir::UnknownLoc *v17;
  mlir::MLIRContext *v18;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v21;
  int v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[2];
  unint64_t v30[2];
  void *__src;
  uint64_t v32;
  _QWORD v33[3];

  v33[2] = *MEMORY[0x1E0C80C00];
  v27 = a4;
  v28 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = a5;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a9;
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a10;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = a11;
  __src = v33;
  v32 = 0x200000000;
  v17 = *a1;
  v18 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v30, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v21 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DOp::inferReturnTypes(v17, v18, 1, v30[0], v30[1], Dictionary, v21, v22, v29[0], v29[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v23 = __src;
  v24 = v32;
  v25 = *(unsigned int *)(a2 + 72);
  v26 = v25 + v32;
  if (v26 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v26, 8);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v24)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v25), v23, 8 * v24);
    LODWORD(v25) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v25 + v24;
  if (__src != v33)
    free(__src);
}

void mlir::mps::Conv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v19;
  unsigned __int8 **AttributeUniquer;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::MLIRContext *v25;
  unsigned __int8 **v26;
  uint64_t v27;
  mlir::UnknownLoc *v28;
  mlir::MLIRContext *v29;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v32;
  int v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int v40;
  unint64_t v41[2];
  unint64_t v42[2];
  void *__src;
  uint64_t v44;
  _QWORD v45[3];

  v45[2] = *MEMORY[0x1E0C80C00];
  v38 = a4;
  v39 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v19 = *(mlir::MLIRContext **)a1;
  v40 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v44 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v40);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v21;
  v22 = *(mlir::MLIRContext **)a1;
  v40 = a10;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v44 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v40);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v24;
  v25 = *(mlir::MLIRContext **)a1;
  v40 = a11;
  v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v44 = (uint64_t)v25;
  v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v40);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v27;
  __src = v45;
  v44 = 0x200000000;
  v28 = *(mlir::UnknownLoc **)a1;
  v29 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v42, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v32 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v41, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DOp::inferReturnTypes(v28, v29, 1, v42[0], v42[1], Dictionary, v32, v33, v41[0], v41[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v34 = __src;
  v35 = v44;
  v36 = *(unsigned int *)(a2 + 72);
  v37 = v36 + v44;
  if (v37 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v37, 8);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v35)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v36), v34, 8 * v35);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v36 + v35;
  if (__src != v45)
    free(__src);
}

BOOL mlir::mps::Conv2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = (const void **)v3[3];
        if (v7)
        {
          v8 = v3[4];
          if (v8)
          {
            v9 = (const void **)v3[5];
            if (v9)
            {
              v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = (_QWORD **)__p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = (void *)*--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                operator delete[](v44);
            }
            while (v43 != v17);
LABEL_94:
            v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = (_QWORD **)__p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_95;
            do
            {
              v39 = (void *)*--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                operator delete[](v38);
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = (_QWORD **)__p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_96;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_95;
          do
          {
            v33 = (void *)*--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              operator delete[](v32);
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = (_QWORD **)__p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_96;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_95;
        do
        {
          v27 = (void *)*--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            operator delete[](v26);
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = (_QWORD **)__p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_96;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_95;
      do
      {
        v21 = (void *)*--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          operator delete[](v20);
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv2DWeightsGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        v15 = 122;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[408];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, unsigned int a15, unsigned int a16, unsigned int a17)
{
  uint64_t IntegerType;
  _QWORD *v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _OWORD v33[3];
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  void *v40;
  uint64_t v41;
  _QWORD v42[2];
  void *v43;
  uint64_t v44;
  __int128 v45;
  void *v46;
  uint64_t v47;
  _BYTE v48[64];
  _OWORD *v49;
  uint64_t v50;
  _OWORD v51[2];
  _OWORD *v52;
  uint64_t v53;
  _OWORD v54[2];
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v52 = v54;
  v54[0] = xmmword_1812503B8;
  v54[1] = unk_1812503C8;
  v53 = 0x400000004;
  v49 = v51;
  v51[0] = xmmword_1812503B8;
  v51[1] = unk_1812503C8;
  v50 = 0x400000004;
  v46 = v48;
  memset(v48, 0, sizeof(v48));
  v47 = 0x800000008;
  v39 = 0;
  v37 = 0u;
  v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v34 = 0u;
  memset(v33, 0, sizeof(v33));
  mlir::mps::buildConv2DDescriptor(a3, a4, a6, a7, a8, a9, a10, (uint64_t)v33, a12, a13, a14, a15, a16, a17, v54, (uint64_t)v51, (uint64_t)v48, 0);
  v43 = &v45;
  v45 = xmmword_181240890;
  v44 = 0x200000002;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v19 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v45, 2, IntegerType, 0);
  v40 = v42;
  v42[0] = 4;
  v41 = 0x200000001;
  v20 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v21 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v42, 1, v20, 0);
  v22 = v21;
  if (v21)
    v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v21 + 8);
  else
    v23 = 0;
  v24 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v23, v52, 8 * v53, 8, 1, 0);
  if (v22)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v22 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v22, v25, v49, 8 * v50, 8, 1, 0);
  if (v19)
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  else
    v27 = 0;
  v28 = mlir::DenseElementsAttr::getFromRawBuffer(v19, v27, v46, 8 * v47, 8, 1, 0);
  mlir::mps::Conv2DWeightsGradientOp::build(a1, a2, a3, a4, a5, v34, v24, v26, v28, a15, a16, a17);
  if (v40 != v42)
    free(v40);
  if (v43 != &v45)
    free(v43);
  if (v46 != v48)
    free(v46);
  if (v49 != v51)
    free(v49);
  if (v52 != v54)
    free(v52);
}

void mlir::mps::Conv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v19;
  unsigned __int8 **AttributeUniquer;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::MLIRContext *v25;
  unsigned __int8 **v26;
  uint64_t v27;
  mlir::UnknownLoc *v28;
  mlir::MLIRContext *v29;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v32;
  int v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unint64_t v42[2];
  unint64_t v43[2];
  void *__src;
  uint64_t v45;
  _QWORD v46[3];

  v46[2] = *MEMORY[0x1E0C80C00];
  v39 = a4;
  v40 = a3;
  v38 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v38, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a9;
  v19 = *(mlir::MLIRContext **)a1;
  v41 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v45 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v41);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v21;
  v22 = *(mlir::MLIRContext **)a1;
  v41 = a11;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v45 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v24;
  v25 = *(mlir::MLIRContext **)a1;
  v41 = a12;
  v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v45 = (uint64_t)v25;
  v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v27;
  __src = v46;
  v45 = 0x200000000;
  v28 = *(mlir::UnknownLoc **)a1;
  v29 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v43, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v32 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v42, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv2DWeightsGradientOp::inferReturnTypes(v28, v29, 1, v43[0], v43[1], Dictionary, v32, v33, v42[0], v42[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v34 = __src;
  v35 = v45;
  v36 = *(unsigned int *)(a2 + 72);
  v37 = v36 + v45;
  if (v37 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v37, 8);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v35)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v36), v34, 8 * v35);
    LODWORD(v36) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v36 + v35;
  if (__src != v46)
    free(__src);
}

BOOL mlir::mps::Conv2DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  const void **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = (const void **)v3[3];
        if (v7)
        {
          v8 = v3[4];
          if (v8)
          {
            v9 = (const void **)v3[5];
            if (v9)
            {
              v10 = v3[6];
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this,
                                         *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                         (const void **)"operand",
                                         (const void **)7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = (_QWORD **)__p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = (void *)*--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                operator delete[](v44);
            }
            while (v43 != v17);
LABEL_95:
            v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = (_QWORD **)__p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_96;
            do
            {
              v39 = (void *)*--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                operator delete[](v38);
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = (_QWORD **)__p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_97;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_96;
          do
          {
            v33 = (void *)*--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              operator delete[](v32);
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = (_QWORD **)__p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_97;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_96;
        do
        {
          v27 = (void *)*--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            operator delete[](v26);
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = (_QWORD **)__p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_97;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_96;
      do
      {
        v21 = (void *)*--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          operator delete[](v20);
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Conv3DDataGradientOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d_data_gradient", 25, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t llvm::all_of<mlir::DenseIntElementsAttr,mlir::mps::Conv3DDataGradientOpAdaptor::verify(mlir::Location)::$_0>(uint64_t *a1)
{
  uint64_t v2;
  uint64_t NumElements;
  BOOL v4;
  uint64_t v5;
  uint64_t v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  uint64_t *v13;
  unsigned int v14;

  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v10, *a1, 0);
  v2 = *a1;
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)a1);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v7, v2, NumElements);
  while (1)
  {
    v4 = v10 == v7 && v11 == v8;
    if (v4 && v12 == v9)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*(&v10, (llvm::APInt *)&v13);
    if (v14 <= 0x40)
    {
      if (!v13)
        return 0;
    }
    else
    {
      v5 = *v13;
      operator delete[](v13);
      if (!v5)
        return 0;
    }
    ++v12;
  }
  return 1;
}

uint64_t mlir::mps::Conv3DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _DWORD *v8;
  _QWORD *v9;
  const void **v10;
  const void **v11;
  uint64_t v12;
  _QWORD *v13;
  _DWORD *v14;
  _BOOL8 result;

  v8 = (_DWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v11, (const void **)"groups", (const char *)6, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v12, (const void **)"padding_style", (const char *)0xD, a3, a4))
          {
            v13 = (_QWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v13, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))a3, a4))
            {
              v14 = (_DWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v14, (const void **)"weights_layout", (const char *)0xE, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 7) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of NDHWC or NCDHW";
        v31 = 79;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(_QWORD *a1, const void **a2, const char *a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  uint64_t NumElements;
  uint64_t v33;
  BOOL v34;
  uint64_t v35;
  unint64_t v37;
  unint64_t v38;
  int64_t v39;
  int64_t v40;
  _QWORD *v41;
  _QWORD v42[2];
  uint64_t OperandRange;
  _QWORD *v44;
  _QWORD v45[2];
  _QWORD v46[2];
  void *v47;
  unsigned int v48;
  const void **v49;
  const char *v50;
  uint64_t v51;
  __int16 v52;
  const void **v53;
  char v54[8];
  uint64_t v55;
  void *v56;
  unsigned int v57;
  unsigned int v58;
  _BYTE v59[96];
  void *v60;
  _QWORD *v61;
  void *__p;
  _QWORD **v63;
  char v64;
  uint64_t v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_7;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*a1 + 8);
  v45[0] = a1;
  v45[1] = v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)v45);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46[0] = v12;
  v46[1] = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v46);
  v65 = 5;
  if (v14 != 1 || *ArgAttrsAttr != v65)
    goto LABEL_7;
  v44 = a1;
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v53, (uint64_t)a1, 0);
  NumElements = mlir::DenseElementsAttr::getNumElements((mlir::DenseElementsAttr *)&v44);
  mlir::DenseElementsAttr::IntElementIterator::IntElementIterator(&v49, (uint64_t)a1, NumElements);
  while (1)
  {
    v34 = v53 == v49 && v54[0] == v50;
    if (v34 && v55 == v51)
      break;
    mlir::DenseElementsAttr::IntElementIterator::operator*((uint64_t *)&v53, (llvm::APInt *)&v47);
    if (v48 > 0x40)
    {
      v33 = *(_QWORD *)v47;
      operator delete[](v47);
      if (!v33)
        goto LABEL_7;
    }
    else if (!v47)
    {
      goto LABEL_7;
    }
    ++v55;
  }
  v41 = a1;
  v42[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v41);
  v42[1] = v35;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v42);
  if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
    return 1;
LABEL_7:
  a4(&v53, a5);
  if (v53)
  {
    LODWORD(v49) = 3;
    v50 = "attribute '";
    v51 = 11;
    v15 = &v49;
    v16 = (char *)v56;
    if (v57 >= v58)
    {
      v37 = v57 + 1;
      if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
      {
        v39 = (char *)&v49 - (_BYTE *)v56;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v16 = (char *)v56;
        v15 = (const void ***)((char *)v56 + v39);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v37, 24);
        v15 = &v49;
        v16 = (char *)v56;
      }
    }
    v17 = &v16[24 * v57];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    ++v57;
    if (v53)
    {
      v52 = 261;
      v49 = a2;
      v50 = a3;
      mlir::Diagnostic::operator<<((uint64_t)v54, &v49);
      if (v53)
      {
        LODWORD(v49) = 3;
        v50 = "' failed to satisfy constraint: positive ui64 elements attribute of shape {5}";
        v51 = 77;
        v19 = &v49;
        v20 = (char *)v56;
        if (v57 >= v58)
        {
          v38 = v57 + 1;
          if (v56 <= &v49 && (char *)v56 + 24 * v57 > (char *)&v49)
          {
            v40 = (char *)&v49 - (_BYTE *)v56;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v20 = (char *)v56;
            v19 = (const void ***)((char *)v56 + v40);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v56, v59, v38, 24);
            v19 = &v49;
            v20 = (char *)v56;
          }
        }
        v21 = &v20[24 * v57];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = v19[2];
        *(_OWORD *)v21 = v22;
        ++v57;
      }
    }
  }
  v23 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v53);
  if (v53)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v53);
  if (v64)
  {
    v24 = (_QWORD **)__p;
    if (__p)
    {
      v25 = v63;
      v26 = __p;
      if (v63 != __p)
      {
        do
          v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
        while (v25 != v24);
        v26 = __p;
      }
      v63 = v24;
      operator delete(v26);
    }
    v27 = v60;
    if (v60)
    {
      v28 = v61;
      v29 = v60;
      if (v61 != v60)
      {
        do
        {
          v31 = (void *)*--v28;
          v30 = v31;
          *v28 = 0;
          if (v31)
            operator delete[](v30);
        }
        while (v28 != v27);
        v29 = v60;
      }
      v61 = v27;
      operator delete(v29);
    }
    if (v56 != v59)
      free(v56);
  }
  return v23;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  void *v33;
  unint64_t v35;
  unint64_t v36;
  int64_t v37;
  int64_t v38;
  const void **v39;
  _QWORD v40[2];
  uint64_t OperandRange;
  const void **v42;
  const char *v43;
  uint64_t v44;
  __int16 v45;
  _QWORD *v46;
  _QWORD *v47;
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  __int128 v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_13;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v42 = a1;
  v43 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v42);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v46 = v12;
  v47 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v46);
  v57 = xmmword_181233130;
  if (v14 == 2 && *ArgAttrsAttr == (_QWORD)v57 && ArgAttrsAttr[1] == *((_QWORD *)&v57 + 1))
  {
    v39 = a1;
    v40[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v39);
    v40[1] = v16;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v40);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_13:
  a4(&v46, a5);
  if (v46)
  {
    LODWORD(v42) = 3;
    v43 = "attribute '";
    v44 = 11;
    v18 = &v42;
    v19 = (char *)v48;
    if (v49 >= v50)
    {
      v35 = v49 + 1;
      if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
      {
        v37 = (char *)&v42 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v19 = (char *)v48;
        v18 = (const void ***)((char *)v48 + v37);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v35, 24);
        v18 = &v42;
        v19 = (char *)v48;
      }
    }
    v20 = &v19[24 * v49];
    v21 = *(_OWORD *)v18;
    *((_QWORD *)v20 + 2) = v18[2];
    *(_OWORD *)v20 = v21;
    ++v49;
    if (v46)
    {
      v45 = 261;
      v42 = a2;
      v43 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v47, &v42);
      if (v46)
      {
        LODWORD(v42) = 3;
        v43 = "' failed to satisfy constraint: ui64 elements attribute of shape {5, 2}";
        v44 = 71;
        v22 = &v42;
        v23 = (char *)v48;
        if (v49 >= v50)
        {
          v36 = v49 + 1;
          if (v48 <= &v42 && (char *)v48 + 24 * v49 > (char *)&v42)
          {
            v38 = (char *)&v42 - (_BYTE *)v48;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v23 = (char *)v48;
            v22 = (const void ***)((char *)v48 + v38);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v36, 24);
            v22 = &v42;
            v23 = (char *)v48;
          }
        }
        v24 = &v23[24 * v49];
        v25 = *(_OWORD *)v22;
        *((_QWORD *)v24 + 2) = v22[2];
        *(_OWORD *)v24 = v25;
        ++v49;
      }
    }
  }
  v17 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v46);
  if (v46)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v46);
  if (v56)
  {
    v26 = (_QWORD **)__p;
    if (__p)
    {
      v27 = v55;
      v28 = __p;
      if (v55 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v55 = v26;
      operator delete(v28);
    }
    v29 = v52;
    if (v52)
    {
      v30 = v53;
      v31 = v52;
      if (v53 != v52)
      {
        do
        {
          v33 = (void *)*--v30;
          v32 = v33;
          *v30 = 0;
          if (v33)
            operator delete[](v32);
        }
        while (v30 != v29);
        v31 = v52;
      }
      v53 = v29;
      operator delete(v31);
    }
    if (v48 != v51)
      free(v48);
  }
  return v17;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(_DWORD *a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;
  const void ***v8;
  char *v9;
  char *v10;
  __int128 v11;
  const void ***v12;
  char *v13;
  char *v14;
  __int128 v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id
    && (a1[2] - 9) < 2)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v8 = &v29;
    v9 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v9 = (char *)v35;
        v8 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = &v29;
        v9 = (char *)v35;
      }
    }
    v10 = &v9[24 * v36];
    v11 = *(_OWORD *)v8;
    *((_QWORD *)v10 + 2) = v8[2];
    *(_OWORD *)v10 = v11;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid TensorDataLayout is one of DHWIO or OIDHW";
        v31 = 79;
        v12 = &v29;
        v13 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v13 = (char *)v35;
            v12 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = &v29;
            v13 = (char *)v35;
          }
        }
        v14 = &v13[24 * v36];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v36;
      }
    }
  }
  v7 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v7;
}

BOOL mlir::mps::Conv3DDataGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[410];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v23;

  v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a7, a8, a14);
  v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  v23 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);
  mlir::mps::Conv3DDataGradientOp::build(a1, a2, a3, a4, a5, a6, v17, v18, v23, a13, a14, a15);
}

void mlir::mps::Conv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v20;
  unsigned __int8 **AttributeUniquer;
  uint64_t v22;
  mlir::MLIRContext *v23;
  unsigned __int8 **v24;
  uint64_t v25;
  mlir::MLIRContext *v26;
  unsigned __int8 **v27;
  uint64_t v28;
  mlir::UnknownLoc *v29;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v32;
  mlir::MLIRContext *v33;
  int v34;
  int v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  unint64_t v44[2];
  unint64_t v45[2];
  void *__src;
  uint64_t v47;
  _QWORD v48[3];

  v48[2] = *MEMORY[0x1E0C80C00];
  v41 = a4;
  v42 = a3;
  v40 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v42, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  if (a5)
    mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a9;
  v20 = *(mlir::MLIRContext **)a1;
  v43 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v20);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v47 = (uint64_t)v20;
  v22 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v43);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v22;
  v23 = *(mlir::MLIRContext **)a1;
  v43 = a11;
  v24 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v47 = (uint64_t)v23;
  v25 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v24, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v43);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v25;
  v26 = *(mlir::MLIRContext **)a1;
  v43 = a12;
  v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v47 = (uint64_t)v26;
  v28 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v43);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v28;
  __src = v48;
  v47 = 0x200000000;
  v29 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v45, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v32 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v44, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DDataGradientOp::inferReturnTypes(v29, v33, v34, v45[0], v45[1], Dictionary, v32, v35, v44[0], v44[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v36 = __src;
  v37 = v47;
  v38 = *(unsigned int *)(a2 + 72);
  v39 = v38 + v47;
  if (v39 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v39, 8);
    LODWORD(v38) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v37)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v38), v36, 8 * v37);
    LODWORD(v38) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v38 + v37;
  if (__src != v48)
    free(__src);
}

BOOL mlir::mps::Conv3DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t *v11;
  const void **v12;
  unsigned int v13;
  uint64_t ODSOperands;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  const void **v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  void *v34;
  void *v35;
  _QWORD **v36;
  _QWORD **v37;
  void *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  _QWORD **v42;
  _QWORD **v43;
  void *v44;
  _QWORD *v45;
  void *v46;
  void *v47;
  _QWORD **v48;
  _QWORD **v49;
  void *v50;
  _QWORD *v51;
  void *v52;
  void *v53;
  _QWORD **v54;
  _QWORD **v55;
  void *v56;
  _QWORD *v57;
  void *v58;
  void *v59;
  const char *v61;
  uint64_t v62;
  uint64_t NextResultAtOffset;
  uint64_t v64;
  unsigned int v65;
  const void **v66[4];
  __int16 v67;
  _QWORD v68[3];
  void *v69;
  uint64_t v70;
  void *v71;
  _QWORD *v72;
  void *__p;
  _QWORD **v74;
  char v75;
  uint64_t v76;

  v76 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (!*(_QWORD *)v3)
  {
    v66[0] = (const void **)"requires attribute 'data_layout'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v28 = (_QWORD **)__p;
    if (__p)
    {
      v29 = v74;
      v30 = __p;
      if (v74 != __p)
      {
        do
          v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
        while (v29 != v28);
        v30 = __p;
      }
      v74 = v28;
      operator delete(v30);
    }
    v31 = v71;
    if (v71)
    {
      v32 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v35 = (void *)*--v32;
        v34 = v35;
        *v32 = 0;
        if (v35)
          operator delete[](v34);
      }
      while (v32 != v31);
LABEL_96:
      v33 = v71;
LABEL_97:
      v72 = v31;
      operator delete(v33);
    }
LABEL_98:
    if (v69 != &v70)
      free(v69);
    return v27;
  }
  v5 = *(_QWORD **)(v3 + 8);
  if (!v5)
  {
    v66[0] = (const void **)"requires attribute 'dilation_rates'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v36 = (_QWORD **)__p;
    if (__p)
    {
      v37 = v74;
      v38 = __p;
      if (v74 != __p)
      {
        do
          v37 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v37 - 1);
        while (v37 != v36);
        v38 = __p;
      }
      v74 = v36;
      operator delete(v38);
    }
    v31 = v71;
    if (v71)
    {
      v39 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v41 = (void *)*--v39;
        v40 = v41;
        *v39 = 0;
        if (v41)
          operator delete[](v40);
      }
      while (v39 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v6 = *(const void ***)(v3 + 16);
  if (!v6)
  {
    v66[0] = (const void **)"requires attribute 'explicit_padding'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v42 = (_QWORD **)__p;
    if (__p)
    {
      v43 = v74;
      v44 = __p;
      if (v74 != __p)
      {
        do
          v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
        while (v43 != v42);
        v44 = __p;
      }
      v74 = v42;
      operator delete(v44);
    }
    v31 = v71;
    if (v71)
    {
      v45 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v47 = (void *)*--v45;
        v46 = v47;
        *v45 = 0;
        if (v47)
          operator delete[](v46);
      }
      while (v45 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v7 = *(const void ***)(v3 + 24);
  if (!v7)
  {
    v66[0] = (const void **)"requires attribute 'groups'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v48 = (_QWORD **)__p;
    if (__p)
    {
      v49 = v74;
      v50 = __p;
      if (v74 != __p)
      {
        do
          v49 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v49 - 1);
        while (v49 != v48);
        v50 = __p;
      }
      v74 = v48;
      operator delete(v50);
    }
    v31 = v71;
    if (v71)
    {
      v51 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v53 = (void *)*--v51;
        v52 = v53;
        *v51 = 0;
        if (v53)
          operator delete[](v52);
      }
      while (v51 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v8 = *(_QWORD *)(v3 + 32);
  if (!v8)
  {
    v66[0] = (const void **)"requires attribute 'padding_style'";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v68);
    if (v68[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v68);
    if (!v75)
      return v27;
    v54 = (_QWORD **)__p;
    if (__p)
    {
      v55 = v74;
      v56 = __p;
      if (v74 != __p)
      {
        do
          v55 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v55 - 1);
        while (v55 != v54);
        v56 = __p;
      }
      v74 = v54;
      operator delete(v56);
    }
    v31 = v71;
    if (v71)
    {
      v57 = v72;
      v33 = v71;
      if (v72 == v71)
        goto LABEL_97;
      do
      {
        v59 = (void *)*--v57;
        v58 = v59;
        *v57 = 0;
        if (v59)
          operator delete[](v58);
      }
      while (v57 != v31);
      goto LABEL_96;
    }
    goto LABEL_98;
  }
  v9 = *(_QWORD **)(v3 + 40);
  if (!v9)
  {
    v61 = "requires attribute 'strides'";
LABEL_103:
    v66[0] = (const void **)v61;
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v26 = v68;
    goto LABEL_104;
  }
  v10 = *(_DWORD **)(v3 + 48);
  if (!v10)
  {
    v61 = "requires attribute 'weights_layout'";
    goto LABEL_103;
  }
  v68[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v68[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v68))return 0;
  v11 = *this;
  v12 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
  v65 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(v11, v12, (const void **)"operand", 7, 0))return 0;
  v13 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v15)
  {
    v16 = v15;
    v17 = 0;
    v18 = ODSOperands + 24;
    while (1)
    {
      v19 = *this;
      v20 = (const void **)(*(_QWORD *)(*(_QWORD *)v18 + 8) & 0xFFFFFFFFFFFFFFF8);
      v65 = v17 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(v19, v20, (const void **)"operand", 7, (int)v17 + 1))return 0;
      ++v17;
      v18 += 32;
      if (v16 == v17)
      {
        v13 = v17 + 1;
        break;
      }
    }
  }
  v21 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  v23 = v22;
  if (v22 >= 2)
  {
    v66[0] = (const void **)"operand group starting at #";
    v67 = 259;
    mlir::OpState::emitOpError(this, v66, (uint64_t)v68);
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v68, &v65);
    v25 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v24, " requires 0 or 1 element, but found ");
    v64 = v23;
    v26 = (_QWORD *)mlir::InFlightDiagnostic::operator<<<unsigned long>(v25, &v64);
LABEL_104:
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v26);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v68);
    return v27;
  }
  if (v22
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(*this, (const void **)(*(_QWORD *)(*(_QWORD *)(v21 + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v13))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v62 = (uint64_t)(*this - 2);
  else
    v62 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v62, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v13;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  unint64_t v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  BOOL v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  const void **v55;
  uint64_t v56;
  __int16 v57;
  uint64_t OperandRange;
  const void **v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[3];
  void *v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE v66[96];
  void *v67;
  _QWORD *v68;
  void *__p;
  _QWORD **v70;
  char v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v62[0] = a2;
    v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
    if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
      || mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange)
      || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
    {
      return 1;
    }
    v10 = *a2;
    v42 = (void *)*((_QWORD *)*a2 + 17);
    if (v42 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v42 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_21;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_21;
  }
  v55 = a2;
  v56 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v59 = a2;
    v60 = v13;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v59);
    if (v14 >= 5)
      return 1;
  }
LABEL_21:
  v57 = 261;
  v55 = a3;
  v56 = a4;
  mlir::Operation::emitOpError(a1, &v55, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    v60 = (uint64_t)" #";
    v61 = 2;
    v15 = &v59;
    v16 = (char *)v63;
    if (v64 >= v65)
    {
      v45 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        v51 = (char *)&v59 - (_BYTE *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        v16 = (char *)v63;
        v15 = (const void ***)((char *)v63 + v51);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
        v15 = &v59;
        v16 = (char *)v63;
      }
    }
    v17 = &v16[24 * v64];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      v60 = a5;
      v20 = &v59;
      v21 = (char *)v63;
      if (v19 >= v65)
      {
        v46 = v19 + 1;
        v47 = (char *)v63 + 24 * v19 > (char *)&v59;
        if (v63 <= &v59 && v47)
        {
          v52 = (char *)&v59 - (_BYTE *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          v21 = (char *)v63;
          v20 = (const void ***)((char *)v63 + v52);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v46, 24);
          v20 = &v59;
          v21 = (char *)v63;
        }
      }
      v22 = &v21[24 * v64];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        v60 = (uint64_t)" must be unranked tensor of mps native type values or ranked tensor type with rank equal to or gr"
                       "eater than 5, but got ";
        v61 = 119;
        v25 = &v59;
        v26 = (char *)v63;
        if (v24 >= v65)
        {
          v48 = v24 + 1;
          v49 = (char *)v63 + 24 * v24 > (char *)&v59;
          if (v63 <= &v59 && v49)
          {
            v53 = (char *)&v59 - (_BYTE *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            v26 = (char *)v63;
            v25 = (const void ***)((char *)v63 + v53);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v48, 24);
            v25 = &v59;
            v26 = (char *)v63;
          }
        }
        v27 = &v26[24 * v64];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v64;
        if (v62[0])
        {
          v29 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          v30 = (char *)v63;
          if (v64 >= v65)
          {
            v50 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              v54 = (char *)&v59 - (_BYTE *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              v30 = (char *)v63;
              v29 = (const void ***)((char *)v63 + v54);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v50, 24);
              v29 = &v59;
              v30 = (char *)v63;
            }
          }
          v31 = &v30[24 * v64];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v64;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  if (v71)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v70;
      v36 = __p;
      if (v70 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v70 = v34;
      operator delete(v36);
    }
    v37 = v67;
    if (v67)
    {
      v38 = v68;
      v39 = v67;
      if (v68 != v67)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v67;
      }
      v68 = v37;
      operator delete(v39);
    }
    if (v63 != v66)
      free(v63);
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  const void ***v15;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  const void ***v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  const void ***v25;
  char *v26;
  char *v27;
  __int128 v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      goto LABEL_33;
    goto LABEL_3;
  }
  v61[0] = a2;
  v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
  if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    return 1;
  }
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
LABEL_3:
    v53 = a2;
    v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
    {
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 == 5)
      {
        v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
        v56[0] = a2;
        v56[1] = v14;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          return 1;
        }
      }
    }
  }
LABEL_33:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v15 = &v58;
    v16 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = (char *)v62;
        v15 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v15 = &v58;
        v16 = (char *)v62;
      }
    }
    v17 = &v16[24 * v63];
    v18 = *(_OWORD *)v15;
    *((_QWORD *)v17 + 2) = v15[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v20 = &v58;
      v21 = (char *)v62;
      if (v19 >= v64)
      {
        v44 = v19 + 1;
        v45 = (char *)v62 + 24 * v19 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = (char *)v62;
          v20 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v20 = &v58;
          v21 = (char *)v62;
        }
      }
      v22 = &v21[24 * v63];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of mps native type values or 5D tensor of mps native type values, but got ";
        v60 = 99;
        v25 = &v58;
        v26 = (char *)v62;
        if (v24 >= v64)
        {
          v46 = v24 + 1;
          v47 = (char *)v62 + 24 * v24 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = (char *)v62;
            v25 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v25 = &v58;
            v26 = (char *)v62;
          }
        }
        v27 = &v26[24 * v63];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v63;
        if (v61[0])
        {
          v29 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v30 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = (char *)v62;
              v29 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v29 = &v58;
              v30 = (char *)v62;
            }
          }
          v31 = &v30[24 * v63];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v63;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v33;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps15(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_10;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 1)
        goto LABEL_10;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
        goto LABEL_10;
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_10:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or 1D tensor of 32-bit signed integer values, but got ";
        v60 = 111;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::Conv3DOpGenericAdaptorBase::Conv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.conv_3d", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::Conv3DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[412];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a6, a7, a14);
  v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  v19 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);
  mlir::mps::Conv3DOp::build(a1, a2, a3, a4, a5, v17, v18, v19, a13, a14, a15);
}

void mlir::mps::Conv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v19;
  unsigned __int8 **AttributeUniquer;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::MLIRContext *v25;
  unsigned __int8 **v26;
  uint64_t v27;
  mlir::UnknownLoc *v28;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v31;
  mlir::MLIRContext *v32;
  int v33;
  int v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unint64_t v42[2];
  unint64_t v43[2];
  void *__src;
  uint64_t v45;
  _QWORD v46[3];

  v46[2] = *MEMORY[0x1E0C80C00];
  v39 = a4;
  v40 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v19 = *(mlir::MLIRContext **)a1;
  v41 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v45 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v41);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v21;
  v22 = *(mlir::MLIRContext **)a1;
  v41 = a10;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v45 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v24;
  v25 = *(mlir::MLIRContext **)a1;
  v41 = a11;
  v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v45 = (uint64_t)v25;
  v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v41);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v27;
  __src = v46;
  v45 = 0x200000000;
  v28 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v43, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v31 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v42, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DOp::inferReturnTypes(v28, v32, v33, v43[0], v43[1], Dictionary, v31, v34, v42[0], v42[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v35 = __src;
  v36 = v45;
  v37 = *(unsigned int *)(a2 + 72);
  v38 = v37 + v45;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v36)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v46)
    free(__src);
}

BOOL mlir::mps::Conv3DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD *)(v3 + 32);
          if (v8)
          {
            v9 = *(_QWORD **)(v3 + 40);
            if (v9)
            {
              v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = (_QWORD **)__p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_95:
              v54 = v17;
              operator delete(v19);
LABEL_96:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = (void *)*--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                operator delete[](v44);
            }
            while (v43 != v17);
LABEL_94:
            v19 = v53;
            goto LABEL_95;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = (_QWORD **)__p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_96;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_95;
            do
            {
              v39 = (void *)*--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                operator delete[](v38);
            }
            while (v37 != v17);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = (_QWORD **)__p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_96;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_95;
          do
          {
            v33 = (void *)*--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              operator delete[](v32);
          }
          while (v31 != v17);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = (_QWORD **)__p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_96;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_95;
        do
        {
          v27 = (void *)*--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            operator delete[](v26);
        }
        while (v25 != v17);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = (_QWORD **)__p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_96;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_95;
      do
      {
        v21 = (void *)*--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          operator delete[](v20);
      }
      while (v18 != v17);
      goto LABEL_94;
    }
  }
  return v13;
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 6uLL:
      if (memcmp(__s1, "groups", __n))
        return 0;
      return a2[3];
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[5];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[4];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[6];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::Conv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      result = memcmp(__s1, "groups", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[3] = v14;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v7[5] = v8;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[4] = v11;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v12 = a4;
            else
              v12 = 0;
            v7[6] = v12;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[2] = v13;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::Conv3DWeightsGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 5)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorB"
              "ase::Properties]";
        v15 = 122;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[414];
    return a1[32];
  }
  return result;
}

void mlir::mps::Conv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t v17;
  uint64_t v18;
  uint64_t v23;

  v17 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a7, a8, a14);
  v18 = mlir::mps::get5DElementsAttrFrom3DSpatialValues(a1, a9, a10, a14);
  v23 = mlir::mps::get5DElementsAttrFrom3DPaddingValues(a1, a11, a12, a14);
  mlir::mps::Conv3DWeightsGradientOp::build(a1, a2, a3, a4, a5, a6, v17, v18, v23, a13, a14, a15);
}

void mlir::mps::Conv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, unsigned int a12)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v19;
  unsigned __int8 **AttributeUniquer;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::MLIRContext *v25;
  unsigned __int8 **v26;
  uint64_t v27;
  mlir::UnknownLoc *v28;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v31;
  mlir::MLIRContext *v32;
  int v33;
  int v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int v42;
  unint64_t v43[2];
  void *v44[2];
  void *__src;
  uint64_t v46;
  _QWORD v47[3];

  v47[2] = *MEMORY[0x1E0C80C00];
  v40 = a4;
  v41 = a3;
  v39 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v40, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v39, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = IntegerAttr;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a8;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a9;
  v19 = *(mlir::MLIRContext **)a1;
  v42 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v46 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v42);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v21;
  v22 = *(mlir::MLIRContext **)a1;
  v42 = a11;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v46 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v24;
  v25 = *(mlir::MLIRContext **)a1;
  v42 = a12;
  v26 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v46 = (uint64_t)v25;
  v27 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v26, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v42);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::Conv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v27;
  __src = v47;
  v46 = 0x200000000;
  v28 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange((unint64_t *)v44, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v31 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v43, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Conv3DWeightsGradientOp::inferReturnTypes(v28, v32, v33, v44[0], (unint64_t)v44[1], Dictionary, v31, v34, v43[0], v43[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v35 = __src;
  v36 = v46;
  v37 = *(unsigned int *)(a2 + 72);
  v38 = v37 + v46;
  if (v38 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v38, 8);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v36)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v37), v35, 8 * v36);
    LODWORD(v37) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v37 + v36;
  if (__src != v47)
    free(__src);
}

BOOL mlir::mps::Conv3DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  const void **v7;
  uint64_t v8;
  _QWORD *v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  void *v26;
  void *v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  void *v32;
  void *v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  const char *v47;
  const void **v48[4];
  __int16 v49;
  _QWORD v50[3];
  void *v51;
  uint64_t v52;
  void *v53;
  _QWORD *v54;
  void *__p;
  _QWORD **v56;
  char v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD *)(v3 + 32);
          if (v8)
          {
            v9 = *(_QWORD **)(v3 + 40);
            if (v9)
            {
              v10 = *(_DWORD **)(v3 + 48);
              if (v10)
              {
                v50[0] = v2;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v7, (const void **)"groups", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v9, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps12(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps13(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v8, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps14(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50))return 0;
                v50[0] = *this;
                if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(v10, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps15(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps13(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(*this,
                                         (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                                         (const void **)"operand",
                                         7,
                                         2u))
                {
                  return 0;
                }
                if (*((_DWORD *)*this + 9))
                  v11 = (uint64_t)(*this - 2);
                else
                  v11 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps14(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
              }
              v47 = "requires attribute 'weights_layout'";
            }
            else
            {
              v47 = "requires attribute 'strides'";
            }
            v48[0] = (const void **)v47;
            v49 = 259;
            mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
            v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
            mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v50);
            return v13;
          }
          v48[0] = (const void **)"requires attribute 'padding_style'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v40 = (_QWORD **)__p;
            if (__p)
            {
              v41 = v56;
              v42 = __p;
              if (v56 != __p)
              {
                do
                  v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
                while (v41 != v40);
                v42 = __p;
              }
              v56 = v40;
              operator delete(v42);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v43 = v54;
            v19 = v53;
            if (v54 == v53)
            {
LABEL_96:
              v54 = v17;
              operator delete(v19);
LABEL_97:
              if (v51 != &v52)
                free(v51);
              return v13;
            }
            do
            {
              v45 = (void *)*--v43;
              v44 = v45;
              *v43 = 0;
              if (v45)
                operator delete[](v44);
            }
            while (v43 != v17);
LABEL_95:
            v19 = v53;
            goto LABEL_96;
          }
        }
        else
        {
          v48[0] = (const void **)"requires attribute 'groups'";
          v49 = 259;
          mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
          v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
          if (v50[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
          if (v57)
          {
            v34 = (_QWORD **)__p;
            if (__p)
            {
              v35 = v56;
              v36 = __p;
              if (v56 != __p)
              {
                do
                  v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
                while (v35 != v34);
                v36 = __p;
              }
              v56 = v34;
              operator delete(v36);
            }
            v17 = v53;
            if (!v53)
              goto LABEL_97;
            v37 = v54;
            v19 = v53;
            if (v54 == v53)
              goto LABEL_96;
            do
            {
              v39 = (void *)*--v37;
              v38 = v39;
              *v37 = 0;
              if (v39)
                operator delete[](v38);
            }
            while (v37 != v17);
            goto LABEL_95;
          }
        }
      }
      else
      {
        v48[0] = (const void **)"requires attribute 'explicit_padding'";
        v49 = 259;
        mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
        v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
        if (v50[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
        if (v57)
        {
          v28 = (_QWORD **)__p;
          if (__p)
          {
            v29 = v56;
            v30 = __p;
            if (v56 != __p)
            {
              do
                v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
              while (v29 != v28);
              v30 = __p;
            }
            v56 = v28;
            operator delete(v30);
          }
          v17 = v53;
          if (!v53)
            goto LABEL_97;
          v31 = v54;
          v19 = v53;
          if (v54 == v53)
            goto LABEL_96;
          do
          {
            v33 = (void *)*--v31;
            v32 = v33;
            *v31 = 0;
            if (v33)
              operator delete[](v32);
          }
          while (v31 != v17);
          goto LABEL_95;
        }
      }
    }
    else
    {
      v48[0] = (const void **)"requires attribute 'dilation_rates'";
      v49 = 259;
      mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
      v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
      if (v50[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
      if (v57)
      {
        v22 = (_QWORD **)__p;
        if (__p)
        {
          v23 = v56;
          v24 = __p;
          if (v56 != __p)
          {
            do
              v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
            while (v23 != v22);
            v24 = __p;
          }
          v56 = v22;
          operator delete(v24);
        }
        v17 = v53;
        if (!v53)
          goto LABEL_97;
        v25 = v54;
        v19 = v53;
        if (v54 == v53)
          goto LABEL_96;
        do
        {
          v27 = (void *)*--v25;
          v26 = v27;
          *v25 = 0;
          if (v27)
            operator delete[](v26);
        }
        while (v25 != v17);
        goto LABEL_95;
      }
    }
  }
  else
  {
    v48[0] = (const void **)"requires attribute 'data_layout'";
    v49 = 259;
    mlir::OpState::emitOpError(this, v48, (uint64_t)v50);
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
    if (v50[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
    if (v57)
    {
      v14 = (_QWORD **)__p;
      if (__p)
      {
        v15 = v56;
        v16 = __p;
        if (v56 != __p)
        {
          do
            v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
          while (v15 != v14);
          v16 = __p;
        }
        v56 = v14;
        operator delete(v16);
      }
      v17 = v53;
      if (!v53)
        goto LABEL_97;
      v18 = v54;
      v19 = v53;
      if (v54 == v53)
        goto LABEL_96;
      do
      {
        v21 = (void *)*--v18;
        v20 = v21;
        *v18 = 0;
        if (v21)
          operator delete[](v20);
      }
      while (v18 != v17);
      goto LABEL_95;
    }
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps16(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v13;
  _QWORD *ArgAttrsAttr;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  const void ***v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  const void ***v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t v28;
  const void ***v29;
  char *v30;
  char *v31;
  __int128 v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  _QWORD **v37;
  _QWORD **v38;
  void *v39;
  _QWORD *v40;
  _QWORD *v41;
  void *v42;
  void *v43;
  void *v44;
  unint64_t v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  BOOL v50;
  unint64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  const void **v56;
  uint64_t v57;
  __int16 v58;
  uint64_t OperandRange;
  const void **v60;
  uint64_t v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;
  uint64_t v74;

  v74 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
    v10 = *a2;
    v17 = (void *)*((_QWORD *)*a2 + 17);
    if (v17 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v17 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_17;
    }
  }
  else if (v11 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
         && v11 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_17;
  }
  v56 = a2;
  v57 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v56);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
  {
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v60 = a2;
    v61 = v13;
    ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v60);
    v73 = 5;
    if (v15 == 1 && *ArgAttrsAttr == v73)
      return 1;
  }
LABEL_17:
  v58 = 261;
  v56 = a3;
  v57 = a4;
  mlir::Operation::emitOpError(a1, &v56, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(v60) = 3;
    v61 = (uint64_t)" #";
    v62 = 2;
    v19 = &v60;
    v20 = (char *)v64;
    if (v65 >= v66)
    {
      v46 = v65 + 1;
      if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
      {
        v52 = (char *)&v60 - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        v20 = (char *)v64;
        v19 = (const void ***)((char *)v64 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v46, 24);
        v19 = &v60;
        v20 = (char *)v64;
      }
    }
    v21 = &v20[24 * v65];
    v22 = *(_OWORD *)v19;
    *((_QWORD *)v21 + 2) = v19[2];
    *(_OWORD *)v21 = v22;
    v23 = ++v65;
    if (v63[0])
    {
      LODWORD(v60) = 5;
      v61 = a5;
      v24 = &v60;
      v25 = (char *)v64;
      if (v23 >= v66)
      {
        v47 = v23 + 1;
        v48 = (char *)v64 + 24 * v23 > (char *)&v60;
        if (v64 <= &v60 && v48)
        {
          v53 = (char *)&v60 - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          v25 = (char *)v64;
          v24 = (const void ***)((char *)v64 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
          v24 = &v60;
          v25 = (char *)v64;
        }
      }
      v26 = &v25[24 * v65];
      v27 = *(_OWORD *)v24;
      *((_QWORD *)v26 + 2) = v24[2];
      *(_OWORD *)v26 = v27;
      v28 = ++v65;
      if (v63[0])
      {
        LODWORD(v60) = 3;
        v61 = (uint64_t)" must be unranked tensor of 32-bit signed integer values or static-shape defined tensor with shap"
                       "e equal to [5], but got ";
        v62 = 121;
        v29 = &v60;
        v30 = (char *)v64;
        if (v28 >= v66)
        {
          v49 = v28 + 1;
          v50 = (char *)v64 + 24 * v28 > (char *)&v60;
          if (v64 <= &v60 && v50)
          {
            v54 = (char *)&v60 - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            v30 = (char *)v64;
            v29 = (const void ***)((char *)v64 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
            v29 = &v60;
            v30 = (char *)v64;
          }
        }
        v31 = &v30[24 * v65];
        v32 = *(_OWORD *)v29;
        *((_QWORD *)v31 + 2) = v29[2];
        *(_OWORD *)v31 = v32;
        ++v65;
        if (v63[0])
        {
          v33 = &v60;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v60, (uint64_t)a2);
          v34 = (char *)v64;
          if (v65 >= v66)
          {
            v51 = v65 + 1;
            if (v64 <= &v60 && (char *)v64 + 24 * v65 > (char *)&v60)
            {
              v55 = (char *)&v60 - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              v34 = (char *)v64;
              v33 = (const void ***)((char *)v64 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v51, 24);
              v33 = &v60;
              v34 = (char *)v64;
            }
          }
          v35 = &v34[24 * v65];
          v36 = *(_OWORD *)v33;
          *((_QWORD *)v35 + 2) = v33[2];
          *(_OWORD *)v35 = v36;
          ++v65;
        }
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v37 = (_QWORD **)__p;
    if (__p)
    {
      v38 = v71;
      v39 = __p;
      if (v71 != __p)
      {
        do
          v38 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v38 - 1);
        while (v38 != v37);
        v39 = __p;
      }
      v71 = v37;
      operator delete(v39);
    }
    v40 = v68;
    if (v68)
    {
      v41 = v69;
      v42 = v68;
      if (v69 != v68)
      {
        do
        {
          v44 = (void *)*--v41;
          v43 = v44;
          *v41 = 0;
          if (v44)
            operator delete[](v43);
        }
        while (v41 != v40);
        v42 = v68;
      }
      v69 = v40;
      operator delete(v42);
    }
    if (v64 != v67)
      free(v64);
  }
  return v16;
}

uint64_t mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cos", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::CoshOpGenericAdaptorBase::CoshOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.cosh", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CostVolumeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t *v16;
  char *v17;
  char *v18;
  __int128 v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  _QWORD *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  int64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  uint64_t v69;
  uint64_t v70;
  const char *v71;
  uint64_t v72;
  _QWORD v73[3];
  void *v74;
  unsigned int v75;
  unsigned int v76;
  _BYTE v77[96];
  void *v78;
  _QWORD *v79;
  void *__p;
  _QWORD **v81;
  char v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v69 = v6;
  if (!v6)
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      v71 = "expected DictionaryAttr to set properties";
      v72 = 41;
      v28 = &v70;
      v29 = (char *)v74;
      if (v75 >= v76)
      {
        v59 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          v64 = (char *)&v70 - (_BYTE *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          v29 = (char *)v74;
          v28 = (uint64_t *)((char *)v74 + v64);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v59, 24);
          v28 = &v70;
          v29 = (char *)v74;
        }
      }
      v30 = &v29[24 * v75];
      v31 = *(_OWORD *)v28;
      *((_QWORD *)v30 + 2) = v28[2];
      *(_OWORD *)v30 = v31;
      ++v75;
      if (v73[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
    }
    if (!v82)
      return 0;
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v81;
      v34 = __p;
      if (v81 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v81 = v32;
      operator delete(v34);
    }
    v23 = v78;
    if (!v78)
      goto LABEL_64;
    v35 = v79;
    v25 = v78;
    if (v79 == v78)
    {
LABEL_63:
      v79 = v23;
      operator delete(v25);
LABEL_64:
      if (v74 != v77)
        free(v74);
      return 0;
    }
    do
    {
      v37 = (void *)*--v35;
      v36 = v37;
      *v35 = 0;
      if (v37)
        operator delete[](v36);
    }
    while (v35 != v23);
LABEL_62:
    v25 = v78;
    goto LABEL_63;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v69, "coord_is_x_only", 0xFuLL);
  if (!v8)
    goto LABEL_8;
  v9 = (uint64_t)v8;
  if (!mlir::BoolAttr::classof(v8))
  {
    a3(v73, a4);
    if (v73[0])
    {
      LODWORD(v70) = 3;
      v72 = 60;
      v38 = &v70;
      v39 = (char *)v74;
      if (v75 >= v76)
      {
        v60 = v75 + 1;
        if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
        {
          v65 = (char *)&v70 - (_BYTE *)v74;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          v39 = (char *)v74;
          v38 = (uint64_t *)((char *)v74 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v60, 24);
          v38 = &v70;
          v39 = (char *)v74;
        }
      }
      v40 = &v39[24 * v75];
      v41 = *(_OWORD *)v38;
      *((_QWORD *)v40 + 2) = v38[2];
      *(_OWORD *)v40 = v41;
      ++v75;
      if (v73[0])
      {
        v42 = &v70;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v9);
        v43 = (char *)v74;
        if (v75 >= v76)
        {
          v62 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            v67 = (char *)&v70 - (_BYTE *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            v43 = (char *)v74;
            v42 = (uint64_t *)((char *)v74 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v62, 24);
            v42 = &v70;
            v43 = (char *)v74;
          }
        }
        v44 = &v43[24 * v75];
        v45 = *(_OWORD *)v42;
        *((_QWORD *)v44 + 2) = v42[2];
        *(_OWORD *)v44 = v45;
        ++v75;
        if (v73[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
      }
    }
    if (!v82)
      return 0;
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v81;
      v48 = __p;
      if (v81 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v81 = v46;
      operator delete(v48);
    }
    v23 = v78;
    if (!v78)
      goto LABEL_64;
    v49 = v79;
    v25 = v78;
    if (v79 == v78)
      goto LABEL_63;
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v23);
    goto LABEL_62;
  }
  *a1 = v9;
LABEL_8:
  v10 = mlir::DictionaryAttr::get((uint64_t)&v69, "data_layout", 0xBuLL);
  if (v10)
  {
    v11 = v10;
    if (*(_UNKNOWN **)(*(_QWORD *)v10 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
    {
      a3(v73, a4);
      if (v73[0])
      {
        LODWORD(v70) = 3;
        v72 = 56;
        v12 = &v70;
        v13 = (char *)v74;
        if (v75 >= v76)
        {
          v61 = v75 + 1;
          if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
          {
            v66 = (char *)&v70 - (_BYTE *)v74;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            v13 = (char *)v74;
            v12 = (uint64_t *)((char *)v74 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v61, 24);
            v12 = &v70;
            v13 = (char *)v74;
          }
        }
        v14 = &v13[24 * v75];
        v15 = *(_OWORD *)v12;
        *((_QWORD *)v14 + 2) = v12[2];
        *(_OWORD *)v14 = v15;
        ++v75;
        if (v73[0])
        {
          v16 = &v70;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v70, v11);
          v17 = (char *)v74;
          if (v75 >= v76)
          {
            v63 = v75 + 1;
            if (v74 <= &v70 && (char *)v74 + 24 * v75 > (char *)&v70)
            {
              v68 = (char *)&v70 - (_BYTE *)v74;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              v17 = (char *)v74;
              v16 = (uint64_t *)((char *)v74 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v74, v77, v63, 24);
              v16 = &v70;
              v17 = (char *)v74;
            }
          }
          v18 = &v17[24 * v75];
          v19 = *(_OWORD *)v16;
          *((_QWORD *)v18 + 2) = v16[2];
          *(_OWORD *)v18 = v19;
          ++v75;
          if (v73[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v73);
        }
      }
      if (!v82)
        return 0;
      v20 = (_QWORD **)__p;
      if (__p)
      {
        v21 = v81;
        v22 = __p;
        if (v81 != __p)
        {
          do
            v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
          while (v21 != v20);
          v22 = __p;
        }
        v81 = v20;
        operator delete(v22);
      }
      v23 = v78;
      if (!v78)
        goto LABEL_64;
      v24 = v79;
      v25 = v78;
      if (v79 == v78)
        goto LABEL_63;
      do
      {
        v27 = (void *)*--v24;
        v26 = v27;
        *v24 = 0;
        if (v27)
          operator delete[](v26);
      }
      while (v24 != v23);
      goto LABEL_62;
    }
    a1[1] = v10;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v69, "normalize_coordinates", 0x15uLL);
  v70 = v52;
  if (!v52)
  {
LABEL_71:
    v54 = mlir::DictionaryAttr::get((uint64_t)&v69, "relative_coordinates", 0x14uLL);
    v70 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[3] = v54;
    }
    v55 = mlir::DictionaryAttr::get((uint64_t)&v69, "similarity_type", 0xFuLL);
    v70 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[4] = v55;
    }
    v56 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_height", 0xDuLL);
    v70 = v56;
    if (v56)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[5] = v56;
    }
    v57 = mlir::DictionaryAttr::get((uint64_t)&v69, "window_width", 0xCuLL);
    v70 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v73, a4);
        goto LABEL_86;
      }
      a1[6] = v57;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v73, a4);
LABEL_86:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v70);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v73);
  return 0;
}

uint64_t mlir::mps::CostVolumeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x1E0C80C00];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coord_is_x_only", 15, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"data_layout", 11, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"relative_coordinates", 20, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"similarity_type", 15, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_height", 13, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"window_width", 12, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CostVolumeOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "data_layout", __n))
        return 0;
      return a2[1];
    case 0xCuLL:
      if (memcmp(__s1, "window_width", __n))
        return 0;
      return a2[6];
    case 0xDuLL:
      if (memcmp(__s1, "window_height", __n))
        return 0;
      return a2[5];
    case 0xEuLL:
    case 0x10uLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x13uLL:
      return 0;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x73695F64726F6F63 && *(_QWORD *)(__s1 + 7) == 0x796C6E6F5F785F73)
        return *a2;
      if (memcmp(__s1, "similarity_type", __n))
        return 0;
      return a2[4];
    case 0x14uLL:
      if (memcmp(__s1, "relative_coordinates", __n))
        return 0;
      return a2[3];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CostVolumeOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, _QWORD *a4)
{
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  _QWORD *v13;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 0xBuLL:
      result = memcmp(__s1, "data_layout", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v12 = a4;
          else
            v12 = 0;
          v5[1] = v12;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0xCuLL:
      result = memcmp(__s1, "window_width", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v6 = a4;
          else
            v6 = 0;
          v5[6] = v6;
        }
        else
        {
          v5[6] = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "window_height", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          v5[5] = v7;
        }
        else
        {
          v5[5] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x73695F64726F6F63 && *(_QWORD *)(__s1 + 7) == 0x796C6E6F5F785F73)
      {
        if (a4)
        {
          result = mlir::BoolAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          *v5 = v13;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      else
      {
        result = memcmp(__s1, "similarity_type", a3);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
              v9 = a4;
            else
              v9 = 0;
            v5[4] = v9;
          }
          else
          {
            v5[4] = 0;
          }
        }
      }
      break;
    case 0x14uLL:
      result = memcmp(__s1, "relative_coordinates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v5[3] = v10;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0x15uLL:
      result = memcmp(__s1, "normalize_coordinates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v5[2] = v11;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CostVolumeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"coord_is_x_only", 15, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"relative_coordinates", 20, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"similarity_type", 15, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"window_height", 13, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"window_width", 12, v10);
}

BOOL mlir::mps::CostVolumeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  _QWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void **v13;
  const void **v14;
  _BOOL8 result;

  v8 = (_QWORD *)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v8, (const void **)"coord_is_x_only", (const char *)0xF, a3, a4))
  {
    v9 = (_DWORD *)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v9, (const void **)"data_layout", (const char *)0xB, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"relative_coordinates", (const char *)0x14, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v12, (const void **)"similarity_type", (const char *)0xF, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v13, (const void **)"window_height", (const char *)0xD, a3, a4))
            {
              v14 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v14, (const void **)"window_width", (const char *)0xC, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid SimilarityType";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::CostVolumeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::BoolAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[416];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SimilarityTypeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SimilarityTypeAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

BOOL mlir::mps::CostVolumeOp::getNormalizeCoordinates(mlir::mps::CostVolumeOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(_QWORD *)(v1 + 16) != 0;
}

void mlir::mps::CostVolumeOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, int a7, uint64_t a8, uint64_t a9, unsigned int a10, unsigned int a11, uint64_t a12)
{
  mlir::MLIRContext *v17;
  uint64_t UnitAttr;
  uint64_t v19;
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  uint64_t v22;
  uint64_t v23;
  mlir::MLIRContext *v24;
  unsigned __int8 **AttributeUniquer;
  uint64_t v26;
  mlir::MLIRContext *v27;
  unsigned __int8 **v28;
  uint64_t v29;
  mlir::UnknownLoc *v30;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unint64_t v45[2];
  unint64_t v46[2];
  void *__src;
  uint64_t v48;
  _QWORD v49[3];

  v49[2] = *MEMORY[0x1E0C80C00];
  v42 = a4;
  v43 = a3;
  v41 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v43, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v42, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v41, 1);
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v17);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 16) = UnitAttr;
  }
  if (a7)
  {
    v19 = mlir::Builder::getUnitAttr(a1, v17);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 24) = v19;
  }
  IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a8);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = IntegerAttr;
  v22 = mlir::Builder::getIntegerType((mlir::Builder *)a1, 0x40u, 0);
  v23 = mlir::Builder::getIntegerAttr((uint64_t)a1, v22, a9);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v23;
  v24 = *a1;
  v44 = a10;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v24);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v48 = (uint64_t)v24;
  v26 = mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v44);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v26;
  v27 = *a1;
  v44 = a11;
  v28 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v27);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v48 = (uint64_t)v27;
  v29 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v28, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v44);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v29;
  if (a12)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CostVolumeOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a12;
  __src = v49;
  v48 = 0x200000000;
  v30 = *a1;
  mlir::ValueRange::ValueRange(v46, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v33 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v45, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CostVolumeOp::inferReturnTypes(v30, v34, v35, v46[0], v46[1], Dictionary, v33, v36, v45[0], v45[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v37 = __src;
  v38 = v48;
  v39 = *(unsigned int *)(a2 + 72);
  v40 = v39 + v48;
  if (v40 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v40, 8);
    LODWORD(v39) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v38)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v39), v37, 8 * v38);
    LODWORD(v39) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v39 + v38;
  if (__src != v49)
    free(__src);
}

mlir::MLIRContext *mlir::mps::CostVolumeOp::populateDefaultProperties(uint64_t a1, _QWORD *a2)
{
  mlir::MLIRContext *result;
  uint64_t IntegerType;
  uint64_t v5;
  mlir::MLIRContext *v6;
  unsigned __int8 **v7;
  mlir::MLIRContext *v8;
  unsigned __int8 **AttributeUniquer;
  mlir::MLIRContext *v10;
  unsigned int v11;
  void *v12;
  mlir::MLIRContext *v13;

  v12 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v10 = result;
  if (a2[5])
  {
    if (a2[6])
      goto LABEL_3;
  }
  else
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
    result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, IntegerType, 1);
    a2[5] = result;
    if (a2[6])
    {
LABEL_3:
      if (a2[4])
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  v5 = mlir::Builder::getIntegerType((mlir::Builder *)&v10, 0x40u, 0);
  result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v10, v5, 1);
  a2[6] = result;
  if (a2[4])
  {
LABEL_4:
    if (a2[1])
      return result;
LABEL_9:
    v8 = v10;
    v11 = 0;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
    v13 = v8;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v11);
    a2[1] = result;
    return result;
  }
LABEL_8:
  v6 = v10;
  v11 = 0;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id;
  v13 = v6;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SimilarityTypeAttrStorage,mlir::mps::SimilarityType>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25SimilarityTypeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18SimilarityTypeAttrEJNS2_14SimilarityTypeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SimilarityTypeAttr,void>::id, &v11);
  a2[4] = result;
  if (!a2[1])
    goto LABEL_9;
  return result;
}

BOOL mlir::mps::CostVolumeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _DWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t *v14;

  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  v5 = *(_DWORD **)(v3 + 8);
  v6 = *(_QWORD *)(v3 + 16);
  v7 = *(_QWORD *)(v3 + 24);
  v8 = *(_QWORD *)(v3 + 32);
  v9 = *(const void ***)(v3 + 40);
  v10 = *(const void ***)(v3 + 48);
  v14 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"relative_coordinates", (const char *)0x14, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v9, (const void **)"window_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(v10, (const void **)"window_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps8(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(v8, (const void **)"similarity_type", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps16(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(v5, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps1(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (const void **)"coord_is_x_only", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v11 = (uint64_t)(*this - 2);
  else
    v11 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps17(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  const void ***v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  const void ***v30;
  char *v31;
  char *v32;
  __int128 v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53;
  uint64_t v54;
  __int16 v55;
  _QWORD v56[2];
  uint64_t OperandRange;
  const void **v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD v61[3];
  void *v62;
  unsigned int v63;
  unsigned int v64;
  _BYTE v65[96];
  void *v66;
  _QWORD *v67;
  void *__p;
  _QWORD **v69;
  char v70;
  uint64_t v71;

  v71 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v61[0] = a2;
    v61[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v61);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    v10 = *a2;
    if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_3:
      v53 = a2;
      v54 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
      if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v53))
        goto LABEL_14;
      v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v58 = a2;
      v59 = v12;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v58);
      if (v13 != 4)
        goto LABEL_14;
      v14 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v56[0] = a2;
      v56[1] = v14;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
      if (!mlir::Type::isF16((mlir::Type *)&OperandRange)
        && !mlir::Type::isF32((mlir::Type *)&OperandRange)
        && !mlir::Type::isBF16((mlir::Type *)&OperandRange))
      {
        goto LABEL_14;
      }
      return 1;
    }
  }
  else if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    goto LABEL_3;
  }
LABEL_14:
  v55 = 261;
  v53 = a3;
  v54 = a4;
  mlir::Operation::emitOpError(a1, &v53, (uint64_t)v61);
  if (v61[0])
  {
    LODWORD(v58) = 3;
    v59 = (uint64_t)" #";
    v60 = 2;
    v16 = &v58;
    v17 = (char *)v62;
    if (v63 >= v64)
    {
      v43 = v63 + 1;
      if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
      {
        v49 = (char *)&v58 - (_BYTE *)v62;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v17 = (char *)v62;
        v16 = (const void ***)((char *)v62 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v43, 24);
        v16 = &v58;
        v17 = (char *)v62;
      }
    }
    v18 = &v17[24 * v63];
    v19 = *(_OWORD *)v16;
    *((_QWORD *)v18 + 2) = v16[2];
    *(_OWORD *)v18 = v19;
    v20 = ++v63;
    if (v61[0])
    {
      LODWORD(v58) = 5;
      v59 = a5;
      v21 = &v58;
      v22 = (char *)v62;
      if (v20 >= v64)
      {
        v44 = v20 + 1;
        v45 = (char *)v62 + 24 * v20 > (char *)&v58;
        if (v62 <= &v58 && v45)
        {
          v50 = (char *)&v58 - (_BYTE *)v62;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v22 = (char *)v62;
          v21 = (const void ***)((char *)v62 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v44, 24);
          v21 = &v58;
          v22 = (char *)v62;
        }
      }
      v23 = &v22[24 * v63];
      v24 = *(_OWORD *)v21;
      *((_QWORD *)v23 + 2) = v21[2];
      *(_OWORD *)v23 = v24;
      v25 = ++v63;
      if (v61[0])
      {
        LODWORD(v58) = 3;
        v59 = (uint64_t)" must be unranked tensor of floating point values or 4D tensor of floating point values, but got ";
        v60 = 97;
        v26 = &v58;
        v27 = (char *)v62;
        if (v25 >= v64)
        {
          v46 = v25 + 1;
          v47 = (char *)v62 + 24 * v25 > (char *)&v58;
          if (v62 <= &v58 && v47)
          {
            v51 = (char *)&v58 - (_BYTE *)v62;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v27 = (char *)v62;
            v26 = (const void ***)((char *)v62 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v46, 24);
            v26 = &v58;
            v27 = (char *)v62;
          }
        }
        v28 = &v27[24 * v63];
        v29 = *(_OWORD *)v26;
        *((_QWORD *)v28 + 2) = v26[2];
        *(_OWORD *)v28 = v29;
        ++v63;
        if (v61[0])
        {
          v30 = &v58;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v58, (uint64_t)a2);
          v31 = (char *)v62;
          if (v63 >= v64)
          {
            v48 = v63 + 1;
            if (v62 <= &v58 && (char *)v62 + 24 * v63 > (char *)&v58)
            {
              v52 = (char *)&v58 - (_BYTE *)v62;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v31 = (char *)v62;
              v30 = (const void ***)((char *)v62 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v62, v65, v48, 24);
              v30 = &v58;
              v31 = (char *)v62;
            }
          }
          v32 = &v31[24 * v63];
          v33 = *(_OWORD *)v30;
          *((_QWORD *)v32 + 2) = v30[2];
          *(_OWORD *)v32 = v33;
          ++v63;
        }
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v61);
  if (v61[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v61);
  if (v70)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v69;
      v36 = __p;
      if (v69 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v69 = v34;
      operator delete(v36);
    }
    v37 = v66;
    if (v66)
    {
      v38 = v67;
      v39 = v66;
      if (v67 != v66)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v66;
      }
      v67 = v37;
      operator delete(v39);
    }
    if (v62 != v65)
      free(v62);
  }
  return v15;
}

uint64_t mlir::mps::detail::CreateComplexOpGenericAdaptorBase::CreateComplexOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.create_complex", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CreateComplexOp::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::Float32Type *v6;
  mlir::MLIRContext *Context;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  mlir::MLIRContext *v22[2];
  void *__src;
  uint64_t v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  v19 = a4;
  v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  __src = v25;
  v24 = 0x200000000;
  v6 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v22, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CreateComplexOp::inferReturnTypes(v6, v8, v9, v22[0], (uint64_t)v22[1], v10, v11, v12, v17, v18, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v13 = __src;
  v14 = v24;
  v15 = *(unsigned int *)(a2 + 72);
  v16 = v15 + v24;
  if (v16 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16, 8);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v14)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v15), v13, 8 * v14);
    LODWORD(v15) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v15 + v14;
  if (__src != v25)
    free(__src);
}

uint64_t mlir::mps::CreateComplexOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t ElementTypeOrSelf;
  uint64_t v5;
  uint64_t v6;
  _QWORD **v7;
  _QWORD **v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  void *v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD **v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))return 0;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24));
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 56)))
  {
    v5 = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 56));
    if (v5 == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24)))
      return 1;
  }
  v16 = (const void **)"failed to verify that all of {real, imag} have same element type";
  v17 = 259;
  mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
  v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
  if (v18[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
  if (v25)
  {
    v7 = (_QWORD **)__p;
    if (__p)
    {
      v8 = v24;
      v9 = __p;
      if (v24 != __p)
      {
        do
          v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
        while (v8 != v7);
        v9 = __p;
      }
      v24 = v7;
      operator delete(v9);
    }
    v10 = v21;
    if (v21)
    {
      v11 = v22;
      v12 = v21;
      if (v22 != v21)
      {
        do
        {
          v14 = (void *)*--v11;
          v13 = v14;
          *v11 = 0;
          if (v14)
            operator delete[](v13);
        }
        while (v11 != v10);
        v12 = v21;
      }
      v22 = v10;
      operator delete(v12);
    }
    if (v19 != &v20)
      free(v19);
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps18(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isF16((mlir::Type *)v51) || mlir::Type::isF32((mlir::Type *)v51))
      return 1;
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of 16-bit float or 32-bit float values, but got ";
        v55 = 64;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t OperandRange;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  uint64_t *v24;
  char *v25;
  char *v26;
  __int128 v27;
  uint64_t *v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  void *v40;
  uint64_t v41;
  unint64_t v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  BOOL v47;
  unint64_t v48;
  int64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  const void **v53[4];
  __int16 v54;
  uint64_t v55;
  uint64_t Value;
  uint64_t v57;
  const char *v58;
  uint64_t v59;
  _QWORD v60[3];
  void *v61;
  unsigned int v62;
  unsigned int v63;
  _BYTE v64[96];
  void *v65;
  _QWORD *v66;
  void *__p;
  _QWORD **v68;
  char v69;
  uint64_t v70;

  v70 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v60[0] = a2;
    v60[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60);
    if (*(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v41 = OperandRange;
      v57 = OperandRange;
      v53[0] = (const void **)mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF16((mlir::Type *)v53))
        return 1;
      v55 = v41;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v55);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v54 = 261;
  v53[0] = a3;
  v53[1] = a4;
  mlir::Operation::emitOpError(a1, v53, (uint64_t)v60);
  if (v60[0])
  {
    LODWORD(v57) = 3;
    v58 = " #";
    v59 = 2;
    v14 = &v57;
    v15 = (char *)v61;
    if (v62 >= v63)
    {
      v43 = v62 + 1;
      if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
      {
        v49 = (char *)&v57 - (_BYTE *)v61;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        v15 = (char *)v61;
        v14 = (uint64_t *)((char *)v61 + v49);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v43, 24);
        v14 = &v57;
        v15 = (char *)v61;
      }
    }
    v16 = &v15[24 * v62];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = v14[2];
    *(_OWORD *)v16 = v17;
    v18 = ++v62;
    if (v60[0])
    {
      LODWORD(v57) = 5;
      v58 = (const char *)a5;
      v19 = &v57;
      v20 = (char *)v61;
      if (v18 >= v63)
      {
        v44 = v18 + 1;
        v45 = (char *)v61 + 24 * v18 > (char *)&v57;
        if (v61 <= &v57 && v45)
        {
          v50 = (char *)&v57 - (_BYTE *)v61;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          v20 = (char *)v61;
          v19 = (uint64_t *)((char *)v61 + v50);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v44, 24);
          v19 = &v57;
          v20 = (char *)v61;
        }
      }
      v21 = &v20[24 * v62];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = v19[2];
      *(_OWORD *)v21 = v22;
      v23 = ++v62;
      if (v60[0])
      {
        LODWORD(v57) = 3;
        v58 = " must be tensor of complex values, but got ";
        v59 = 43;
        v24 = &v57;
        v25 = (char *)v61;
        if (v23 >= v63)
        {
          v46 = v23 + 1;
          v47 = (char *)v61 + 24 * v23 > (char *)&v57;
          if (v61 <= &v57 && v47)
          {
            v51 = (char *)&v57 - (_BYTE *)v61;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            v25 = (char *)v61;
            v24 = (uint64_t *)((char *)v61 + v51);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v46, 24);
            v24 = &v57;
            v25 = (char *)v61;
          }
        }
        v26 = &v25[24 * v62];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = v24[2];
        *(_OWORD *)v26 = v27;
        ++v62;
        if (v60[0])
        {
          v28 = &v57;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v57, a2);
          v29 = (char *)v61;
          if (v62 >= v63)
          {
            v48 = v62 + 1;
            if (v61 <= &v57 && (char *)v61 + 24 * v62 > (char *)&v57)
            {
              v52 = (char *)&v57 - (_BYTE *)v61;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              v29 = (char *)v61;
              v28 = (uint64_t *)((char *)v61 + v52);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v61, v64, v48, 24);
              v28 = &v57;
              v29 = (char *)v61;
            }
          }
          v30 = &v29[24 * v62];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          ++v62;
        }
      }
    }
  }
  v32 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v60);
  if (v60[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v60);
  if (v69)
  {
    v33 = (_QWORD **)__p;
    if (__p)
    {
      v34 = v68;
      v35 = __p;
      if (v68 != __p)
      {
        do
          v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
        while (v34 != v33);
        v35 = __p;
      }
      v68 = v33;
      operator delete(v35);
    }
    v36 = v65;
    if (v65)
    {
      v37 = v66;
      v38 = v65;
      if (v66 != v65)
      {
        do
        {
          v40 = (void *)*--v37;
          v39 = v40;
          *v37 = 0;
          if (v40)
            operator delete[](v39);
        }
        while (v37 != v36);
        v38 = v65;
      }
      v66 = v36;
      operator delete(v38);
    }
    if (v61 != v64)
      free(v61);
  }
  return v32;
}

uint64_t mlir::mps::CreateTextureTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD **v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "compressed", 0xAuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        v76 = 3;
        v78 = 55;
        v10 = &v76;
        v11 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v70 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v11 = (char *)v80;
            v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v10 = &v76;
            v11 = (char *)v80;
          }
        }
        v12 = &v11[24 * v81];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v81;
        if (v79[0])
        {
          v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          v15 = (char *)v80;
          if (v81 >= v82)
          {
            v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              v71 = (char *)&v76 - (_BYTE *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v15 = (char *)v80;
              v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v14 = &v76;
              v15 = (char *)v80;
            }
          }
          v16 = &v15[24 * v81];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v81;
          if (v79[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
      if (!v88)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v87;
        v20 = __p;
        if (v87 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v87 = v18;
        operator delete(v20);
      }
      v21 = v84;
      if (!v84)
        goto LABEL_80;
      v22 = v85;
      v23 = v84;
      if (v85 == v84)
        goto LABEL_79;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_format", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for pixel_format in DictionaryAttr to set Properties.";
      v78 = 72;
      v52 = &v76;
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v73 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 57;
    v38 = &v76;
    v39 = (char *)v80;
    if (v81 >= v82)
    {
      v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v72 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v39 = (char *)v80;
        v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v38 = &v76;
        v39 = (char *)v80;
      }
    }
    v40 = &v39[24 * v81];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v81;
    if (v79[0])
    {
      v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      v43 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v43 = (char *)v80;
          v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v42 = &v76;
          v43 = (char *)v80;
        }
      }
      v44 = &v43[24 * v81];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v87;
      v48 = __p;
      if (v87 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v87 = v46;
      operator delete(v48);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v49 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
LABEL_78:
    v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::CreateTextureTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"compressed", 10, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_format", 12, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid MetalPixelFormat";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties]";
        v15 = 120;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[418];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::MetalPixelFormatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MetalPixelFormatAttr]";
  v41 = 81;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::CreateTextureTensorOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, unsigned int a4, int a5)
{
  mlir::MLIRContext *v9;
  unsigned __int8 **AttributeUniquer;
  uint64_t v11;
  mlir::MLIRContext *v12;
  uint64_t UnitAttr;
  mlir::MLIRContext *Context;
  unsigned int v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  __int128 v23;
  void *__src;
  uint64_t v25;
  _BYTE v26[16];
  unsigned int v27[6];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  v9 = *a1;
  v27[0] = a4;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v9);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id;
  v25 = (uint64_t)v9;
  v11 = mlir::StorageUniquer::get<mlir::mps::detail::MetalPixelFormatAttrStorage,mlir::mps::MetalPixelFormat>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27MetalPixelFormatAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20MetalPixelFormatAttrEJNS2_16MetalPixelFormatEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id, v27);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v11;
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v12);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v26;
  v25 = 0x200000000;
  mlir::ValueRange::ValueRange((unint64_t *)&v23, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v22, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  *(_OWORD *)v27 = v23;
  if ((_DWORD)v25 != 1)
  {
    if (!(_DWORD)v25)
    {
      if (HIDWORD(v25))
      {
        v15 = 0;
LABEL_8:
        bzero((char *)__src + 8 * v15, 8 - 8 * v15);
        goto LABEL_9;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, 1uLL, 8);
      v15 = v25;
      if ((_DWORD)v25 != 1)
        goto LABEL_8;
    }
LABEL_9:
    LODWORD(v25) = 1;
  }
  v16 = mlir::ValueRange::dereference_iterator(v27, 0);
  *(_QWORD *)__src = *(_QWORD *)(v16 + 8) & 0xFFFFFFFFFFFFFFF8;
  v17 = __src;
  v18 = v25;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v25;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v26)
    free(__src);
}

BOOL mlir::mps::CreateTextureTensorOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t *v6;
  const void **v7;
  const void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD **v14;
  _QWORD **v15;
  void *v16;
  _QWORD *v17;
  _QWORD *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;
  const void ***v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t v27;
  const void ***v28;
  char *v29;
  char *v30;
  __int128 v31;
  uint64_t v32;
  const void ***v33;
  char *v34;
  char *v35;
  __int128 v36;
  const void ***v37;
  char *v38;
  char *v39;
  __int128 v40;
  char v41;
  _QWORD **v42;
  _QWORD **v43;
  void *v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  void *v48;
  void *v49;
  uint64_t v50;
  uint64_t NextResultAtOffset;
  unint64_t v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  BOOL v57;
  unint64_t v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  const void **v63;
  uint64_t v64;
  __int16 v65;
  _QWORD v66[2];
  uint64_t OperandRange;
  const void **v68;
  const char *v69;
  uint64_t v70;
  _QWORD v71[3];
  void *v72;
  unsigned int v73;
  unsigned int v74;
  _BYTE v75[96];
  void *v76;
  _QWORD *v77;
  void *__p;
  _QWORD **v79;
  char v80;
  uint64_t v81;

  v81 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = v3[1];
  if (v4)
  {
    v5 = *v3;
    v71[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(v4, (const void **)"pixel_format", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0;
    v71[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"compressed", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v71))return 0;
    v6 = *this;
    v7 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v8 = *v7;
    v9 = (void *)*((_QWORD *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      v22 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      v71[0] = v7;
      v71[1] = v22;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v71);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_85:
        if (*((_DWORD *)*this + 9))
          v50 = (uint64_t)(*this - 2);
        else
          v50 = 0;
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v50, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
      }
      v8 = *v7;
      if (*((_UNKNOWN **)*v7 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
        goto LABEL_53;
    }
    else if (v9 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
LABEL_53:
      v65 = 261;
      v63 = (const void **)"operand";
      v64 = 7;
      mlir::Operation::emitOpError(v6, &v63, (uint64_t)v71);
      if (v71[0])
      {
        LODWORD(v68) = 3;
        v69 = " #";
        v70 = 2;
        v23 = &v68;
        v24 = (char *)v72;
        if (v73 >= v74)
        {
          v53 = v73 + 1;
          if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
          {
            v59 = (char *)&v68 - (_BYTE *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            v24 = (char *)v72;
            v23 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v53, 24);
            v23 = &v68;
            v24 = (char *)v72;
          }
        }
        v25 = &v24[24 * v73];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = v23[2];
        *(_OWORD *)v25 = v26;
        v27 = ++v73;
        if (v71[0])
        {
          LODWORD(v68) = 5;
          v69 = 0;
          v28 = &v68;
          v29 = (char *)v72;
          if (v27 >= v74)
          {
            v54 = v27 + 1;
            v55 = (char *)v72 + 24 * v27 > (char *)&v68;
            if (v72 <= &v68 && v55)
            {
              v60 = (char *)&v68 - (_BYTE *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              v29 = (char *)v72;
              v28 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
              v28 = &v68;
              v29 = (char *)v72;
            }
          }
          v30 = &v29[24 * v73];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = v28[2];
          *(_OWORD *)v30 = v31;
          v32 = ++v73;
          if (v71[0])
          {
            LODWORD(v68) = 3;
            v69 = " must be unranked tensor of mps native type values or 4D tensor of mps native type values, but got ";
            v70 = 99;
            v33 = &v68;
            v34 = (char *)v72;
            if (v32 >= v74)
            {
              v56 = v32 + 1;
              v57 = (char *)v72 + 24 * v32 > (char *)&v68;
              if (v72 <= &v68 && v57)
              {
                v61 = (char *)&v68 - (_BYTE *)v72;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                v34 = (char *)v72;
                v33 = (const void ***)((char *)v72 + v61);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
                v33 = &v68;
                v34 = (char *)v72;
              }
            }
            v35 = &v34[24 * v73];
            v36 = *(_OWORD *)v33;
            *((_QWORD *)v35 + 2) = v33[2];
            *(_OWORD *)v35 = v36;
            ++v73;
            if (v71[0])
            {
              v37 = &v68;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)v7);
              v38 = (char *)v72;
              if (v73 >= v74)
              {
                v58 = v73 + 1;
                if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
                {
                  v62 = (char *)&v68 - (_BYTE *)v72;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  v38 = (char *)v72;
                  v37 = (const void ***)((char *)v72 + v62);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v58, 24);
                  v37 = &v68;
                  v38 = (char *)v72;
                }
              }
              v39 = &v38[24 * v73];
              v40 = *(_OWORD *)v37;
              *((_QWORD *)v39 + 2) = v37[2];
              *(_OWORD *)v39 = v40;
              ++v73;
            }
          }
        }
      }
      v41 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
      if (v71[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
      if (v80)
      {
        v42 = (_QWORD **)__p;
        if (__p)
        {
          v43 = v79;
          v44 = __p;
          if (v79 != __p)
          {
            do
              v43 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v43 - 1);
            while (v43 != v42);
            v44 = __p;
          }
          v79 = v42;
          operator delete(v44);
        }
        v45 = v76;
        if (v76)
        {
          v46 = v77;
          v47 = v76;
          if (v77 != v76)
          {
            do
            {
              v49 = (void *)*--v46;
              v48 = v49;
              *v46 = 0;
              if (v49)
                operator delete[](v48);
            }
            while (v46 != v45);
            v47 = v76;
          }
          v77 = v45;
          operator delete(v47);
        }
        if (v72 != v75)
          free(v72);
      }
      if (v41)
        goto LABEL_85;
      return 0;
    }
    v63 = v7;
    v64 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v63))
    {
      v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
      v68 = v7;
      v69 = (const char *)v10;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v68);
      if (v11 == 4)
      {
        v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v7 + 8);
        v66[0] = v7;
        v66[1] = v12;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_85;
        }
      }
    }
    goto LABEL_53;
  }
  v63 = (const void **)"requires attribute 'pixel_format'";
  v65 = 259;
  mlir::OpState::emitOpError(this, &v63, (uint64_t)v71);
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  if (v80)
  {
    v14 = (_QWORD **)__p;
    if (__p)
    {
      v15 = v79;
      v16 = __p;
      if (v79 != __p)
      {
        do
          v15 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v15 - 1);
        while (v15 != v14);
        v16 = __p;
      }
      v79 = v14;
      operator delete(v16);
    }
    v17 = v76;
    if (v76)
    {
      v18 = v77;
      v19 = v76;
      if (v77 != v76)
      {
        do
        {
          v21 = (void *)*--v18;
          v20 = v21;
          *v18 = 0;
          if (v21)
            operator delete[](v20);
        }
        while (v18 != v17);
        v19 = v76;
      }
      v77 = v17;
      operator delete(v19);
    }
    if (v72 != v75)
      free(v72);
  }
  return v13;
}

uint64_t mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.crop", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::CropOp::build(mlir::mps::ConstantOp *a1, uint64_t *a2, uint64_t a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  char *v9;
  char *v10;
  mlir::GenericProgramPoint *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  v13 = a5;
  v14 = a4;
  v12 = a6;
  v9 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v14) - 16;
  v10 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v13) - 16;
  v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v12);
  mlir::mps::CropOp::build((mlir::UnknownLoc **)a1, (uint64_t)a2, a3, (uint64_t)v9, (uint64_t)v10, (uint64_t)v11 - 16);
}

mlir::GenericProgramPoint *mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(mlir::mps::ConstantOp *a1, uint64_t a2, unsigned int *a3)
{
  uint64_t *Context;
  uint64_t v7;
  char v8;
  mlir::GenericProgramPoint *v9;
  mlir::GenericProgramPoint *v10;
  uint64_t v12;
  const char *v13;
  __int16 v14;
  uint64_t v15[4];
  __int16 v16;
  _QWORD v17[39];

  v17[38] = *MEMORY[0x1E0C80C00];
  v12 = a2;
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v7 = mlir::RegisteredOperationName::lookup((int8x16_t *)"mps.constant", (const unsigned __int8 *)0xC, Context);
  if (!v8)
  {
    v16 = 1283;
    v15[2] = (uint64_t)"mps.constant";
    v15[3] = 12;
          " the dialect. See also https://mlir.llvm.org/getting_started/Faq/#registered-loaded-dependent-whats-up-with-di"
          "alects-management";
    v14 = 259;
    llvm::operator+(v15, (uint64_t *)&v13, (uint64_t)v17);
    llvm::report_fatal_error((llvm::Twine *)v17, 1);
  }
  mlir::OperationState::OperationState(v17, a2, v7);
  mlir::mps::ConstantOp::build(a1, (mlir::OpBuilder *)v17, (mlir::OperationState *)*a3);
  v9 = mlir::OpBuilder::create(a1, (const mlir::OperationState *)v17);
  if (*(_UNKNOWN **)(*((_QWORD *)v9 + 6) + 16) == &mlir::detail::TypeIDResolver<mlir::mps::ConstantOp,void>::id)
    v10 = v9;
  else
    v10 = 0;
  mlir::OperationState::~OperationState((mlir::OperationState *)v17);
  return v10;
}

void mlir::mps::CropOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::UnknownLoc *v8;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  mlir::MLIRContext *v11;
  int v12;
  int v13;
  int v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  void *v24[2];
  void *__src;
  uint64_t v26;
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  v19 = a6;
  v20 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  __src = v27;
  v26 = 0x200000000;
  v8 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CropOp::inferReturnTypes(v8, v11, v12, v24[0], (unint64_t)v24[1], Dictionary, v13, v14, v23[0], v23[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v15 = __src;
  v16 = v26;
  v17 = *(unsigned int *)(a2 + 72);
  v18 = v17 + v26;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v16)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v27)
    free(__src);
}

void mlir::mps::CropOp::build(mlir::mps::ConstantOp *a1, uint64_t *a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6)
{
  char *v10;
  mlir::GenericProgramPoint *v11;
  unsigned int v12;
  unsigned int v13;

  v12 = a6;
  v13 = a5;
  v10 = (char *)mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v13) - 16;
  v11 = mlir::OpBuilder::create<mlir::mps::ConstantOp,int &>(a1, *a2, &v12);
  mlir::mps::CropOp::build((mlir::UnknownLoc **)a1, (uint64_t)a2, a3, a4, (uint64_t)v10, (uint64_t)v11 - 16);
}

uint64_t mlir::mps::CropOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t ElementTypeOrSelf;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD **v11;
  _QWORD **v12;
  void *v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  void *v18;
  void *v19;
  const void **v20;
  __int16 v21;
  _QWORD v22[3];
  void *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  void *__p;
  _QWORD **v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           3u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))return 0;
  ElementTypeOrSelf = mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24));
  if (*((_DWORD *)*this + 9))
    v5 = (uint64_t)(*this - 2);
  else
    v5 = 0;
  v6 = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  if (ElementTypeOrSelf == mlir::getElementTypeOrSelf(v6))
  {
    v7 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
    v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
    v9 = mlir::getElementTypeOrSelf(v8);
    if (v9 == mlir::getElementTypeOrSelf(*(_QWORD *)((*this)[9] + 24)))
      return 1;
  }
  v20 = (const void **)"failed to verify that all of {input, result} have same element type";
  v21 = 259;
  mlir::OpState::emitOpError(this, &v20, (uint64_t)v22);
  v10 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v22);
  if (v22[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v22);
  if (v29)
  {
    v11 = (_QWORD **)__p;
    if (__p)
    {
      v12 = v28;
      v13 = __p;
      if (v28 != __p)
      {
        do
          v12 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v12 - 1);
        while (v12 != v11);
        v13 = __p;
      }
      v28 = v11;
      operator delete(v13);
    }
    v14 = v25;
    if (v25)
    {
      v15 = v26;
      v16 = v25;
      if (v26 != v25)
      {
        do
        {
          v19 = (void *)*--v15;
          v18 = v19;
          *v15 = 0;
          if (v19)
            operator delete[](v18);
        }
        while (v15 != v14);
        v16 = v25;
      }
      v26 = v14;
      operator delete(v16);
    }
    if (v23 != &v24)
      free(v23);
  }
  return v10;
}

uint64_t mlir::mps::detail::CropResizeOpGenericAdaptorBase::CropResizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  uint64_t Context;
  unint64_t v13[3];
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v13, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  v10 = *(_OWORD *)(v5 + 32);
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(v5 + 48);
  *(_OWORD *)(a1 + 56) = v10;
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v13;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.crop_resize", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::CropResizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  char *v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  _QWORD v74[3];
  void *v75;
  unsigned int v76;
  unsigned int v77;
  _BYTE v78[96];
  void *v79;
  _QWORD *v80;
  void *__p;
  _QWORD **v82;
  char v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      v72 = "expected DictionaryAttr to set properties";
      v73 = 41;
      v26 = &v71;
      v27 = (char *)v75;
      if (v76 >= v77)
      {
        v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          v65 = (char *)&v71 - (_BYTE *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v27 = (char *)v75;
          v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v26 = &v71;
          v27 = (char *)v75;
        }
      }
      v28 = &v27[24 * v76];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v76;
      if (v74[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
    }
    if (!v83)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v82;
      v32 = __p;
      if (v82 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v82 = v30;
      operator delete(v32);
    }
    v21 = v79;
    if (!v79)
      goto LABEL_64;
    v33 = v80;
    v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78)
        free(v75);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v79;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "alignment_mode", 0xEuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 59;
        v10 = &v71;
        v11 = (char *)v75;
        if (v76 >= v77)
        {
          v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v66 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v11 = (char *)v75;
            v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v10 = &v71;
            v11 = (char *)v75;
          }
        }
        v12 = &v11[24 * v76];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v76;
        if (v74[0])
        {
          v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          v15 = (char *)v75;
          if (v76 >= v77)
          {
            v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v67 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v15 = (char *)v75;
              v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v14 = &v71;
              v15 = (char *)v75;
            }
          }
          v16 = &v15[24 * v76];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v82;
        v20 = __p;
        if (v82 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v82 = v18;
        operator delete(v20);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v22 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "coordinate_mode", 0xFuLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 60;
        v38 = &v71;
        v39 = (char *)v75;
        if (v76 >= v77)
        {
          v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v68 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v39 = (char *)v75;
            v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v38 = &v71;
            v39 = (char *)v75;
          }
        }
        v40 = &v39[24 * v76];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v76;
        if (v74[0])
        {
          v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          v43 = (char *)v75;
          if (v76 >= v77)
          {
            v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v69 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v43 = (char *)v75;
              v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v42 = &v71;
              v43 = (char *)v75;
            }
          }
          v44 = &v43[24 * v76];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v82;
        v48 = __p;
        if (v82 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v82 = v46;
        operator delete(v48);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v49 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "interpolation_mode", 0x12uLL);
  v71 = v52;
  if (!v52)
  {
LABEL_71:
    v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "normalize_coordinates", 0x15uLL);
    v71 = v54;
    if (v54)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[3] = v54;
    }
    v55 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_height", 0xDuLL);
    v71 = v55;
    if (v55)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v55 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
LABEL_86:
        v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v56);
        goto LABEL_87;
      }
      a1[4] = v55;
    }
    v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "resize_width", 0xCuLL);
    v71 = v57;
    if (v57)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_87;
      }
      a1[5] = v57;
    }
    v58 = mlir::DictionaryAttr::get((uint64_t)&v70, "spatial_scale", 0xDuLL);
    v71 = v58;
    if (v58)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
      {
        a3(v74, a4);
        goto LABEL_86;
      }
      a1[6] = v58;
    }
    return 1;
  }
  if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    a1[2] = v52;
    goto LABEL_71;
  }
  a3(v74, a4);
LABEL_87:
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
  return 0;
}

uint64_t mlir::mps::CropResizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  void *v45;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v48;
  void *v49;
  uint64_t v50;
  _QWORD v51[7];

  v51[6] = *MEMORY[0x1E0C80C00];
  v48 = a1;
  v49 = v51;
  v50 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v48, (uint64_t)"alignment_mode", 14, *a2);
  v5 = v4;
  v6 = v50;
  if (v50 >= HIDWORD(v50))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
    v6 = v50;
  }
  v7 = (uint64_t *)((char *)v49 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v50 + 1;
  LODWORD(v50) = v50 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"coordinate_mode", 15, v9);
    v12 = v11;
    v13 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v13 = v50;
    }
    v14 = (uint64_t *)((char *)v49 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"interpolation_mode", 18, v15);
    v18 = v17;
    v19 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v19 = v50;
    }
    v20 = (uint64_t *)((char *)v49 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"normalize_coordinates", 21, v21);
    v24 = v23;
    v25 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v25 = v50;
    }
    v26 = (uint64_t *)((char *)v49 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_height", 13, v27);
    v30 = v29;
    v31 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v31 = v50;
    }
    v32 = (uint64_t *)((char *)v49 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"resize_width", 12, v33);
    v36 = v35;
    v37 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v37 = v50;
    }
    v38 = (uint64_t *)((char *)v49 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v48, (uint64_t)"spatial_scale", 13, v39);
    v42 = v41;
    v43 = v50;
    if (v50 >= HIDWORD(v50))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v49, v51, v50 + 1, 16);
      v43 = v50;
    }
    v44 = (uint64_t *)((char *)v49 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    v8 = v50 + 1;
    LODWORD(v50) = v50 + 1;
  }
  v45 = v49;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v49 == v51)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v48, (mlir::MLIRContext *)v49, v8);
  v45 = v49;
  if (v49 != v51)
LABEL_32:
    free(v45);
  return DictionaryAttr;
}

uint64_t mlir::mps::CropResizeOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 0xCuLL:
      if (memcmp(__s1, "resize_width", __n))
        return 0;
      return a2[5];
    case 0xDuLL:
      if (!memcmp(__s1, "resize_height", __n))
        return a2[4];
      if (memcmp(__s1, "spatial_scale", __n))
        return 0;
      return a2[6];
    case 0xEuLL:
      if (*(_QWORD *)__s1 != 0x6E656D6E67696C61 || *(_QWORD *)(__s1 + 6) != 0x65646F6D5F746E65)
        return 0;
      return *a2;
    case 0xFuLL:
      if (memcmp(__s1, "coordinate_mode", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
    case 0x11uLL:
    case 0x13uLL:
    case 0x14uLL:
      return 0;
    case 0x12uLL:
      if (memcmp(__s1, "interpolation_mode", __n))
        return 0;
      return a2[2];
    case 0x15uLL:
      if (memcmp(__s1, "normalize_coordinates", __n))
        return 0;
      return a2[3];
    default:
      return 0;
  }
}

uint64_t mlir::mps::CropResizeOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 0xCuLL:
      result = memcmp(__s1, "resize_width", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          v7[5] = v14;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "resize_height", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "spatial_scale", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
              v8 = a4;
            else
              v8 = 0;
            v7[6] = v8;
          }
          else
          {
            v7[6] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          v15 = a4;
        else
          v15 = 0;
        v7[4] = v15;
      }
      else
      {
        v7[4] = 0;
      }
      break;
    case 0xEuLL:
      if (*(_QWORD *)__s1 == 0x6E656D6E67696C61 && *(_QWORD *)(__s1 + 6) == 0x65646F6D5F746E65)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xFuLL:
      result = memcmp(__s1, "coordinate_mode", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
            v11 = a4;
          else
            v11 = 0;
          v7[1] = v11;
        }
        else
        {
          v7[1] = 0;
        }
      }
      break;
    case 0x12uLL:
      result = memcmp(__s1, "interpolation_mode", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
            v12 = a4;
          else
            v12 = 0;
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0x15uLL:
      result = memcmp(__s1, "normalize_coordinates", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v13 = a4;
          else
            v13 = 0;
          v7[3] = v13;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::CropResizeOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"alignment_mode", 14, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"coordinate_mode", 15, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"interpolation_mode", 18, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"normalize_coordinates", 21, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_height", 13, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"resize_width", 12, v9);
  v10 = a2[6];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"spatial_scale", 13, v10);
}

BOOL mlir::mps::CropResizeOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void **v12;
  const void **v13;
  const void **v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v8, (const void **)"alignment_mode", (const char *)0xE, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v9, (const void **)"coordinate_mode", (const char *)0xF, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v10, (const void **)"interpolation_mode", (const char *)0x12, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"normalize_coordinates", (const char *)0x15, a3, a4))
        {
          v12 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v12, (const void **)"resize_height", (const char *)0xD, a3, a4))
          {
            v13 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v13, (const void **)"resize_width", (const char *)0xC, a3, a4))
            {
              v14 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v14, (const void **)"spatial_scale", (const char *)0xD, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CropResizeAlignmentMode";
        v31 = 61;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid CropResizeCoordinateMode";
        v31 = 62;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid sampling modes";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&Value, 32))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 32-bit unsigned integer attribute";
        v33 = 65;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = (void *)*--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isF32((mlir::Type *)&Value))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 32-bit float attribute";
        v33 = 54;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = (void *)*--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

BOOL mlir::mps::CropResizeOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(a1, v3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(a1, v3 + 1)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(a1, v3 + 2)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 4)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3 + 5)&& mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3 + 6) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x38uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    *((_QWORD *)v3 + 6) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[420];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeAlignmentModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeAlignmentModeAttr]";
  v41 = 88;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::CropResizeCoordinateModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::CropResizeCoordinateModeAttr]";
  v41 = 89;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::SamplingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SamplingModeAttr]";
  v41 = 77;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::FloatAttr]";
  v41 = 65;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void *mlir::mps::CropResizeOp::getResizeHeight(mlir::mps::CropResizeOp *this)
{
  unint64_t v1;
  uint64_t v3;
  void *__p;
  unsigned int v5;
  uint64_t v6;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  v6 = *(_QWORD *)(v1 + 32);
  mlir::IntegerAttr::getValue(&v6, (llvm::APInt *)&__p);
  if (v5 <= 0x40)
    return __p;
  v3 = *(_QWORD *)__p;
  operator delete[](__p);
  return (void *)v3;
}

llvm::detail::DoubleAPFloat *mlir::mps::CropResizeOp::getSpatialScale@<X0>(mlir::mps::CropResizeOp *this@<X0>, uint64_t a2@<X8>)
{
  unint64_t v2;
  uint64_t v4;

  v2 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = 0;
  v4 = *(_QWORD *)(v2 + 48);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v4, a2);
}

void mlir::mps::CropResizeOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, int a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  uint64_t v19;
  uint64_t v20;
  mlir::MLIRContext *v21;
  uint64_t UnitAttr;
  uint64_t F32Type;
  uint64_t FloatAttr;
  mlir::MLIRContext *v25;
  unsigned __int8 **AttributeUniquer;
  uint64_t v27;
  mlir::MLIRContext *v28;
  unsigned __int8 **v29;
  uint64_t v30;
  mlir::MLIRContext *v31;
  unsigned __int8 **v32;
  uint64_t v33;
  mlir::UnknownLoc *v34;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v37;
  mlir::MLIRContext *v38;
  int v39;
  int v40;
  void *v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unint64_t v48[2];
  unint64_t v49[2];
  void *__src;
  uint64_t v51;
  _QWORD v52[3];

  v52[2] = *MEMORY[0x1E0C80C00];
  v45 = a4;
  v46 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v46, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v45, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = IntegerAttr;
  v19 = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  v20 = mlir::Builder::getIntegerAttr((uint64_t)a1, v19, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v20;
  if (a7)
  {
    UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v21);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 24) = UnitAttr;
  }
  F32Type = mlir::Builder::getF32Type((mlir::Float32Type **)a1, v21);
  FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a8);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = FloatAttr;
  v25 = *(mlir::MLIRContext **)a1;
  v47 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v25);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v51 = (uint64_t)v25;
  v27 = mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v47);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v27;
  v28 = *(mlir::MLIRContext **)a1;
  v47 = a10;
  v29 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v28);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v51 = (uint64_t)v28;
  v30 = mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v29, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v47);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v30;
  v31 = *(mlir::MLIRContext **)a1;
  v47 = a11;
  v32 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v31);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
  v51 = (uint64_t)v31;
  v33 = mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v32, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v47);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CropResizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v33;
  __src = v52;
  v51 = 0x200000000;
  v34 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v49, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v37 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v48, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::CropResizeOp::inferReturnTypes(v34, v38, v39, v49[0], v49[1], Dictionary, v37, v40, v48[0], v48[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v41 = __src;
  v42 = v51;
  v43 = *(unsigned int *)(a2 + 72);
  v44 = v43 + v51;
  if (v44 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v44, 8);
    LODWORD(v43) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v42)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v43), v41, 8 * v42);
    LODWORD(v43) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v43 + v42;
  if (__src != v52)
    free(__src);
}

mlir::MLIRContext *mlir::mps::CropResizeOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  uint64_t IntegerType;
  uint64_t v6;
  uint64_t F32Type;
  mlir::MLIRContext *v8;
  unsigned __int8 **AttributeUniquer;
  mlir::MLIRContext *v10;
  unsigned __int8 **v11;
  mlir::MLIRContext *v12;
  unsigned __int8 **v13;
  mlir::MLIRContext *v14;
  unsigned int v15;
  void *v16;
  mlir::MLIRContext *v17;

  v16 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v16);
  v14 = result;
  if (a2[4])
  {
    if (a2[5])
      goto LABEL_3;
  }
  else
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
    result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, IntegerType, 1);
    a2[4] = result;
    if (a2[5])
    {
LABEL_3:
      if (a2[6])
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  v6 = mlir::Builder::getIntegerType((mlir::Builder *)&v14, 0x20u, 0);
  result = (mlir::MLIRContext *)mlir::Builder::getIntegerAttr((uint64_t)&v14, v6, 1);
  a2[5] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[2])
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  F32Type = mlir::Builder::getF32Type(&v14, v4);
  result = mlir::Builder::getFloatAttr(1.0, (uint64_t)&v14, F32Type);
  a2[6] = result;
  if (a2[2])
  {
LABEL_5:
    if (*a2)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  v8 = v14;
  v15 = 1;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  v16 = &mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id;
  v17 = v8;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::SamplingModeAttrStorage,mlir::mps::SamplingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23SamplingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16SamplingModeAttrEJNS2_12SamplingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SamplingModeAttr,void>::id, &v15);
  a2[2] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[1])
      return result;
LABEL_13:
    v12 = v14;
    v15 = 0;
    v13 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
    v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id;
    v17 = v12;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeCoordinateModeAttrStorage,mlir::mps::CropResizeCoordinateMode>(v13, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail35CropResizeCoordinateModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_28CropResizeCoordinateModeAttrEJNS2_24CropResizeCoordinateModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeCoordinateModeAttr,void>::id, &v15);
    a2[1] = result;
    return result;
  }
LABEL_12:
  v10 = v14;
  v15 = 0;
  v11 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v14);
  v16 = &mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id;
  v17 = v10;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::CropResizeAlignmentModeAttrStorage,mlir::mps::CropResizeAlignmentMode>(v11, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail34CropResizeAlignmentModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_27CropResizeAlignmentModeAttrEJNS2_23CropResizeAlignmentModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v16, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeAlignmentModeAttr,void>::id, &v15);
  *a2 = result;
  if (!a2[1])
    goto LABEL_13;
  return result;
}

BOOL mlir::mps::CropResizeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const void **v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  uint64_t NextResultAtOffset;
  uint64_t *v14;

  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v5 = *v3;
  v4 = v3[1];
  v6 = v3[2];
  v7 = v3[3];
  v8 = (const void **)v3[4];
  v9 = (const void **)v3[5];
  v10 = (const void **)v3[6];
  v14 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v8, (const void **)"resize_height", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (const void **)"resize_width", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"normalize_coordinates", (const char *)0x15, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v10, (const void **)"spatial_scale", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(v6, (const void **)"interpolation_mode", (const char *)0x12, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps21(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(v5, (const void **)"alignment_mode", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps22(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14))return 0;
  v14 = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(v4, (const void **)"coordinate_mode", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps23(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v14)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v11 = (uint64_t)(*this - 2);
  else
    v11 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  uint64_t v63;
  int v64;
  const char *v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD **v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v63 = v6;
  if (!v6)
  {
    a3(v67, a4);
    if (v67[0])
    {
      v64 = 3;
      v65 = "expected DictionaryAttr to set properties";
      v66 = 41;
      v26 = &v64;
      v27 = (char *)v68;
      if (v69 >= v70)
      {
        v53 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          v58 = (char *)&v64 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          v27 = (char *)v68;
          v26 = (int *)((char *)v68 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          v26 = &v64;
          v27 = (char *)v68;
        }
      }
      v28 = &v27[24 * v69];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v69;
      if (v67[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
    if (!v76)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v75;
      v32 = __p;
      if (v75 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v75 = v30;
      operator delete(v32);
    }
    v21 = v72;
    if (!v72)
      goto LABEL_64;
    v33 = v73;
    v23 = v72;
    if (v73 == v72)
      goto LABEL_63;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_62;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v63, "exclusive", 9uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v67, a4);
      if (v67[0])
      {
        v64 = 3;
        v66 = 54;
        v10 = &v64;
        v11 = (char *)v68;
        if (v69 >= v70)
        {
          v54 = v69 + 1;
          if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
          {
            v59 = (char *)&v64 - (_BYTE *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            v11 = (char *)v68;
            v10 = (int *)((char *)v68 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            v10 = &v64;
            v11 = (char *)v68;
          }
        }
        v12 = &v11[24 * v69];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v69;
        if (v67[0])
        {
          v14 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v9);
          v15 = (char *)v68;
          if (v69 >= v70)
          {
            v55 = v69 + 1;
            if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
            {
              v60 = (char *)&v64 - (_BYTE *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              v15 = (char *)v68;
              v14 = (int *)((char *)v68 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
              v14 = &v64;
              v15 = (char *)v68;
            }
          }
          v16 = &v15[24 * v69];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v69;
          if (v67[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
        }
      }
      if (!v76)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v75;
        v20 = __p;
        if (v75 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v75 = v18;
        operator delete(v20);
      }
      v21 = v72;
      if (!v72)
        goto LABEL_64;
      v22 = v73;
      v23 = v72;
      if (v73 == v72)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v63, "reverse", 7uLL);
  if (!v36)
    return 1;
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v67, a4);
  if (v67[0])
  {
    v64 = 3;
    v66 = 52;
    v38 = &v64;
    v39 = (char *)v68;
    if (v69 >= v70)
    {
      v56 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        v61 = (char *)&v64 - (_BYTE *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        v39 = (char *)v68;
        v38 = (int *)((char *)v68 + v61);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
        v38 = &v64;
        v39 = (char *)v68;
      }
    }
    v40 = &v39[24 * v69];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v69;
    if (v67[0])
    {
      v42 = &v64;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v37);
      v43 = (char *)v68;
      if (v69 >= v70)
      {
        v57 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          v62 = (char *)&v64 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          v43 = (char *)v68;
          v42 = (int *)((char *)v68 + v62);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          v42 = &v64;
          v43 = (char *)v68;
        }
      }
      v44 = &v43[24 * v69];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v69;
      if (v67[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
  }
  if (v76)
  {
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v75;
      v48 = __p;
      if (v75 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v75 = v46;
      operator delete(v48);
    }
    v21 = v72;
    if (!v72)
      goto LABEL_64;
    v49 = v73;
    v23 = v72;
    if (v73 == v72)
    {
LABEL_63:
      v73 = v21;
      operator delete(v23);
LABEL_64:
      if (v68 != v71)
        free(v68);
      return 0;
    }
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
LABEL_62:
    v23 = v72;
    goto LABEL_63;
  }
  return 0;
}

uint64_t mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"exclusive", 9, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"reverse", 7, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties]";
        v15 = 118;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[422];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeMaximumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext *Context;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *__src;
  uint64_t v27;
  _BYTE v28[16];
  _QWORD v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a6)
  {
    v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v12;
  }
  __src = v28;
  v27 = 0x200000000;
  v13 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    v15 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      v16 = v27;
    }
    *((_QWORD *)__src + v16) = v15;
    v17 = v27 + 1;
    LODWORD(v27) = v17;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v17 = v27;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76))
      goto LABEL_9;
  }
  if (v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28)
    free(__src);
}

BOOL mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t *v9;

  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  v5 = v3[1];
  v9 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"exclusive", (const char *)9, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9))return 0;
  v9 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"reverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v6 = (uint64_t)(*this - 2);
  else
    v6 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties]";
        v15 = 118;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[424];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeMinimumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext *Context;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *__src;
  uint64_t v27;
  _BYTE v28[16];
  _QWORD v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a6)
  {
    v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v12;
  }
  __src = v28;
  v27 = 0x200000000;
  v13 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    v15 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      v16 = v27;
    }
    *((_QWORD *)__src + v16) = v15;
    v17 = v27 + 1;
    LODWORD(v27) = v17;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v17 = v27;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76))
      goto LABEL_9;
  }
  if (v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28)
    free(__src);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties]";
        v15 = 118;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[426];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeProductOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext *Context;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *__src;
  uint64_t v27;
  _BYTE v28[16];
  _QWORD v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a6)
  {
    v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v12;
  }
  __src = v28;
  v27 = 0x200000000;
  v13 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    v15 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      v16 = v27;
    }
    *((_QWORD *)__src + v16) = v15;
    v17 = v27 + 1;
    LODWORD(v27) = v17;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v17 = v27;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76))
      goto LABEL_9;
  }
  if (v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28)
    free(__src);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties]";
        v15 = 114;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[428];
    return a1[32];
  }
  return result;
}

void mlir::mps::CumulativeSumOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  mlir::MLIRContext *v10;
  uint64_t UnitAttr;
  uint64_t v12;
  uint64_t v13;
  mlir::MLIRContext *Context;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  void *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  void *__src;
  uint64_t v27;
  _BYTE v28[16];
  _QWORD v29[3];

  v29[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a6)
  {
    v12 = mlir::Builder::getUnitAttr(a1, v10);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v12;
  }
  __src = v28;
  v27 = 0x200000000;
  v13 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v29[0] = v24;
  v29[1] = v25;
  if (v25)
  {
    v15 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v16 = v27;
    if (v27 >= HIDWORD(v27))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v28, v27 + 1, 8);
      v16 = v27;
    }
    *((_QWORD *)__src + v16) = v15;
    v17 = v27 + 1;
    LODWORD(v27) = v17;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v17;
    if (v20 > *(unsigned int *)(a2 + 76))
    {
LABEL_9:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
      LODWORD(v19) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v13, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v17 = v27;
    v18 = __src;
    v19 = *(unsigned int *)(a2 + 72);
    v20 = v19 + v27;
    if (v20 > *(unsigned int *)(a2 + 76))
      goto LABEL_9;
  }
  if (v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v18, 8 * v17);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v17;
  if (__src != v28)
    free(__src);
}

uint64_t mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.degamma", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::DepthToSpace2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.depth_to_space_2d", 21, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthToSpace2DOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  int *v48;
  char *v49;
  char *v50;
  __int128 v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD **v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_79;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_77;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "block_size", 0xAuLL);
  if (!v8)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for block_size in DictionaryAttr to set Properties.";
      v78 = 70;
      v36 = &v76;
      v37 = (char *)v80;
      if (v81 >= v82)
      {
        v65 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v71 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v37 = (char *)v80;
          v36 = (int *)((char *)v80 + v71);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
          v36 = &v76;
          v37 = (char *)v80;
        }
      }
      v38 = &v37[24 * v81];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v87;
      v42 = __p;
      if (v87 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v87 = v40;
      operator delete(v42);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_79;
    v43 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_77;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v78 = 55;
      v10 = &v76;
      v11 = (char *)v80;
      if (v81 >= v82)
      {
        v64 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v70 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v11 = (char *)v80;
          v10 = (int *)((char *)v80 + v70);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
          v10 = &v76;
          v11 = (char *)v80;
        }
      }
      v12 = &v11[24 * v81];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v81;
      if (v79[0])
      {
        v14 = &v76;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
        v15 = (char *)v80;
        if (v81 >= v82)
        {
          v66 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v72 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v15 = (char *)v80;
            v14 = (int *)((char *)v80 + v72);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
            v14 = &v76;
            v15 = (char *)v80;
          }
        }
        v16 = &v15[24 * v81];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        ++v81;
        if (v79[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
      }
    }
    if (!v88)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v87;
      v20 = __p;
      if (v87 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v87 = v18;
      operator delete(v20);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_79;
    v22 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_78;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_77;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v75, "pixel_shuffle", 0xDuLL);
  if (!v46)
    return 1;
  v47 = v46;
  if (*(_UNKNOWN **)(*(_QWORD *)v46 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    a1[1] = v46;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 58;
    v48 = &v76;
    v49 = (char *)v80;
    if (v81 >= v82)
    {
      v67 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v73 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v49 = (char *)v80;
        v48 = (int *)((char *)v80 + v73);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
        v48 = &v76;
        v49 = (char *)v80;
      }
    }
    v50 = &v49[24 * v81];
    v51 = *(_OWORD *)v48;
    *((_QWORD *)v50 + 2) = *((_QWORD *)v48 + 2);
    *(_OWORD *)v50 = v51;
    ++v81;
    if (v79[0])
    {
      v52 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v47);
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_79;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_78:
      v85 = v21;
      operator delete(v23);
LABEL_79:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
LABEL_77:
    v23 = v84;
    goto LABEL_78;
  }
  return 0;
}

uint64_t mlir::mps::DepthToSpace2DOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"block_size", 10, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"pixel_shuffle", 13, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties]";
        v15 = 115;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[430];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthToSpace2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, int a8)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v14;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v16;
  mlir::MLIRContext *v17;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[2];
  unint64_t v31[2];
  void *__src;
  uint64_t v33;
  _QWORD v34[3];

  v34[2] = *MEMORY[0x1E0C80C00];
  v28 = a4;
  v29 = a3;
  v26 = a6;
  v27 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v28, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a7);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = IntegerAttr;
  if (a8)
  {
    UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v14);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = UnitAttr;
  }
  __src = v34;
  v33 = 0x200000000;
  v16 = *(mlir::UnknownLoc **)a1;
  v17 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v31, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v20 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v30, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthToSpace2DOp::inferReturnTypes(v16, v17, 1, v31[0], v31[1], Dictionary, v20, v21, v30[0], v30[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v22 = __src;
  v23 = v33;
  v24 = *(unsigned int *)(a2 + 72);
  v25 = v24 + v33;
  if (v25 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v25, 8);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v23)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v24), v22, 8 * v23);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v24 + v23;
  if (__src != v34)
    free(__src);
}

BOOL mlir::mps::DepthToSpace2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD **v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(const void ***)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD *)(v3 + 8);
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"block_size", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"pixel_shuffle", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(
                            *this,
                            (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (const void **)"operand",
                            7,
                            1u)
      && mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 3u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'block_size'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v10 = (_QWORD **)__p;
      if (__p)
      {
        v11 = v26;
        v12 = __p;
        if (v26 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v26 = v10;
        operator delete(v12);
      }
      v13 = v23;
      if (v23)
      {
        v14 = v24;
        v15 = v23;
        if (v24 != v23)
        {
          do
          {
            v17 = (void *)*--v14;
            v16 = v17;
            *v14 = 0;
            if (v17)
              operator delete[](v16);
          }
          while (v14 != v13);
          v15 = v23;
        }
        v24 = v13;
        operator delete(v15);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  uint64_t *v62;
  char *v63;
  char *v64;
  __int128 v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD **v70;
  _QWORD **v71;
  void *v72;
  _QWORD *v73;
  void *v74;
  void *v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  __int128 v79;
  _QWORD **v80;
  _QWORD **v81;
  void *v82;
  _QWORD *v83;
  void *v84;
  void *v85;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  const char *v110;
  uint64_t v111;
  _QWORD v112[3];
  void *v113;
  unsigned int v114;
  unsigned int v115;
  _BYTE v116[96];
  void *v117;
  _QWORD *v118;
  void *__p;
  _QWORD **v120;
  char v121;
  uint64_t v122;

  v122 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v108 = v6;
  if (!v6)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected DictionaryAttr to set properties";
      v111 = 41;
      v26 = &v109;
      v27 = (char *)v113;
      if (v114 >= v115)
      {
        v91 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v99 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v27 = (char *)v113;
          v26 = (uint64_t *)((char *)v113 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v91, 24);
          v26 = &v109;
          v27 = (char *)v113;
        }
      }
      v28 = &v27[24 * v114];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v120;
      v32 = __p;
      if (v120 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v120 = v30;
      operator delete(v32);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v33 = v118;
    v23 = v117;
    if (v118 == v117)
    {
LABEL_116:
      v118 = v21;
      operator delete(v23);
LABEL_117:
      if (v113 != v116)
        free(v113);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_115:
    v23 = v117;
    goto LABEL_116;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v108, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v111 = 71;
      v36 = &v109;
      v37 = (char *)v113;
      if (v114 >= v115)
      {
        v93 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v101 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v37 = (char *)v113;
          v36 = (uint64_t *)((char *)v113 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v93, 24);
          v36 = &v109;
          v37 = (char *)v113;
        }
      }
      v38 = &v37[24 * v114];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = v36[2];
      *(_OWORD *)v38 = v39;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v120;
      v42 = __p;
      if (v120 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v120 = v40;
      operator delete(v42);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v43 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_116;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_115;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 56;
      v10 = &v109;
      v11 = (char *)v113;
      if (v114 >= v115)
      {
        v92 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v100 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v11 = (char *)v113;
          v10 = (uint64_t *)((char *)v113 + v100);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v92, 24);
          v10 = &v109;
          v11 = (char *)v113;
        }
      }
      v12 = &v11[24 * v114];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = v10[2];
      *(_OWORD *)v12 = v13;
      ++v114;
      if (v112[0])
      {
        v14 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v9);
        v15 = (char *)v113;
        if (v114 >= v115)
        {
          v94 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v102 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v15 = (char *)v113;
            v14 = (uint64_t *)((char *)v113 + v102);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v94, 24);
            v14 = &v109;
            v15 = (char *)v113;
          }
        }
        v16 = &v15[24 * v114];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v120;
      v20 = __p;
      if (v120 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v120 = v18;
      operator delete(v20);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v22 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_116;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_115;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v108, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v111 = 74;
      v52 = &v109;
      v53 = (char *)v113;
      if (v114 >= v115)
      {
        v95 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v103 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v53 = (char *)v113;
          v52 = (uint64_t *)((char *)v113 + v103);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v95, 24);
          v52 = &v109;
          v53 = (char *)v113;
        }
      }
      v54 = &v53[24 * v114];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v120;
      v58 = __p;
      if (v120 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v120 = v56;
      operator delete(v58);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v59 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_116;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_115;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v111 = 59;
      v62 = &v109;
      v63 = (char *)v113;
      if (v114 >= v115)
      {
        v96 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v104 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v63 = (char *)v113;
          v62 = (uint64_t *)((char *)v113 + v104);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v96, 24);
          v62 = &v109;
          v63 = (char *)v113;
        }
      }
      v64 = &v63[24 * v114];
      v65 = *(_OWORD *)v62;
      *((_QWORD *)v64 + 2) = v62[2];
      *(_OWORD *)v64 = v65;
      ++v114;
      if (v112[0])
      {
        v66 = &v109;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v109, v47);
        v67 = (char *)v113;
        if (v114 >= v115)
        {
          v97 = v114 + 1;
          if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
          {
            v105 = (char *)&v109 - (_BYTE *)v113;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v67 = (char *)v113;
            v66 = (uint64_t *)((char *)v113 + v105);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v97, 24);
            v66 = &v109;
            v67 = (char *)v113;
          }
        }
        v68 = &v67[24 * v114];
        v69 = *(_OWORD *)v66;
        *((_QWORD *)v68 + 2) = v66[2];
        *(_OWORD *)v68 = v69;
        ++v114;
        if (v112[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
      }
    }
    if (!v121)
      return 0;
    v70 = (_QWORD **)__p;
    if (__p)
    {
      v71 = v120;
      v72 = __p;
      if (v120 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v120 = v70;
      operator delete(v72);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v73 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_116;
    do
    {
      v75 = (void *)*--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        operator delete[](v74);
    }
    while (v73 != v21);
    goto LABEL_115;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v108, "explicit_padding", 0x10uLL);
  v107 = v48;
  if (!v48)
  {
    a3(v112, a4);
    if (v112[0])
    {
      LODWORD(v109) = 3;
      v110 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v111 = 76;
      v76 = &v109;
      v77 = (char *)v113;
      if (v114 >= v115)
      {
        v98 = v114 + 1;
        if (v113 <= &v109 && (char *)v113 + 24 * v114 > (char *)&v109)
        {
          v106 = (char *)&v109 - (_BYTE *)v113;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v77 = (char *)v113;
          v76 = (uint64_t *)((char *)v113 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v113, v116, v98, 24);
          v76 = &v109;
          v77 = (char *)v113;
        }
      }
      v78 = &v77[24 * v114];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = v76[2];
      *(_OWORD *)v78 = v79;
      ++v114;
      if (v112[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v112);
    }
    if (!v121)
      return 0;
    v80 = (_QWORD **)__p;
    if (__p)
    {
      v81 = v120;
      v82 = __p;
      if (v120 != __p)
      {
        do
          v81 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v81 - 1);
        while (v81 != v80);
        v82 = __p;
      }
      v120 = v80;
      operator delete(v82);
    }
    v21 = v117;
    if (!v117)
      goto LABEL_117;
    v83 = v118;
    v23 = v117;
    if (v118 == v117)
      goto LABEL_116;
    do
    {
      v85 = (void *)*--v83;
      v84 = v85;
      *v83 = 0;
      if (v85)
        operator delete[](v84);
    }
    while (v83 != v21);
    goto LABEL_115;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    v50 = mlir::DictionaryAttr::get((uint64_t)&v108, "padding_style", 0xDuLL);
    v109 = v50;
    if (v50)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)v50 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
      {
        a1[3] = v50;
        v88 = mlir::DictionaryAttr::get((uint64_t)&v108, "strides", 7uLL);
        v109 = v88;
        if (!v88)
        {
          a3(v112, a4);
          mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for strides in DictionaryAttr to set Properties.");
          goto LABEL_123;
        }
        v89 = v88;
        if ((mlir::DenseIntElementsAttr::classof(v88) & 1) != 0)
        {
          a1[4] = v89;
          v90 = mlir::DictionaryAttr::get((uint64_t)&v108, "weights_layout", 0xEuLL);
          v109 = v90;
          if (!v90)
          {
            a3(v112, a4);
            mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for weights_layout in DictionaryAttr to set Properties.");
            goto LABEL_123;
          }
          if (*(_UNKNOWN **)(*(_QWORD *)v90 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
          {
            a1[5] = v90;
            return 1;
          }
          a3(v112, a4);
        }
        else
        {
          a3(v112, a4);
        }
      }
      else
      {
        a3(v112, a4);
      }
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v51, &v109);
    }
    else
    {
      a3(v112, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v112, "expected key entry for padding_style in DictionaryAttr to set Properties.");
    }
LABEL_123:
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
    return 0;
  }
  a3(v112, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v87, &v107);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v112);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  void *v39;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v42;
  void *v43;
  uint64_t v44;
  _QWORD v45[7];

  v45[6] = *MEMORY[0x1E0C80C00];
  v42 = a1;
  v43 = v45;
  v44 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v42, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v44;
  if (v44 >= HIDWORD(v44))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
    v6 = v44;
  }
  v7 = (uint64_t *)((char *)v43 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v44 + 1;
  LODWORD(v44) = v44 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      v13 = v44;
    }
    v14 = (uint64_t *)((char *)v43 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      v19 = v44;
    }
    v20 = (uint64_t *)((char *)v43 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"padding_style", 13, v21);
    v24 = v23;
    v25 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      v25 = v44;
    }
    v26 = (uint64_t *)((char *)v43 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"strides", 7, v27);
    v30 = v29;
    v31 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      v31 = v44;
    }
    v32 = (uint64_t *)((char *)v43 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v42, (uint64_t)"weights_layout", 14, v33);
    v36 = v35;
    v37 = v44;
    if (v44 >= HIDWORD(v44))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v43, v45, v44 + 1, 16);
      v37 = v44;
    }
    v38 = (uint64_t *)((char *)v43 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    v8 = v44 + 1;
    LODWORD(v44) = v44 + 1;
  }
  v39 = v43;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v43 == v45)
      return DictionaryAttr;
    goto LABEL_28;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v42, (mlir::MLIRContext *)v43, v8);
  v39 = v43;
  if (v43 != v45)
LABEL_28:
    free(v39);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          *(_QWORD *)result = v9;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v11 = a4;
            else
              v11 = 0;
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v14 = a4;
        else
          v14 = 0;
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v12 = a4;
          else
            v12 = 0;
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"data_layout", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
  v9 = a2[5];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"weights_layout", 14, v9);
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  const void **v12;
  uint64_t v13;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (const void **)"padding_style", (const char *)0xD, a3, a4))
        {
          v12 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v12, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
          {
            v13 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v13, (const void **)"weights_layout", (const char *)0xE, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x30uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAd"
              "aptorBase::Properties]";
        v15 = 128;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[432];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv2DDataGradientOp::getPaddingStyle(mlir::mps::DepthwiseConv2DDataGradientOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(unsigned int *)(*(_QWORD *)(v1 + 24) + 8);
}

void mlir::mps::DepthwiseConv2DDataGradientOp::setStridesAttr(uint64_t *a1, uint64_t a2)
{
  mlir::Operation::setAttr(*a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(*a1 + 48) + 96) + 32), a2);
}

void mlir::mps::DepthwiseConv2DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  _OWORD *v18;
  uint64_t IntegerType;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v34[4];
  _OWORD v35[2];
  _OWORD v36[2];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v36[0] = xmmword_1812503B8;
  v36[1] = unk_1812503C8;
  v35[0] = xmmword_1812503B8;
  v35[1] = unk_1812503C8;
  memset(v34, 0, sizeof(v34));
  v18 = operator new(0x10uLL);
  *v18 = xmmword_181240890;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v20 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v18, 2, IntegerType, 0);
  v21 = operator new(8uLL);
  *v21 = 4;
  v22 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v23 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v21, 1, v22, 0);
  v24 = v23;
  if (v23)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v25, v36, 32, 8, 1, 0);
  if (v24)
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
  else
    v27 = 0;
  v28 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v27, v35, 32, 8, 1, 0);
  if (v20)
    v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  else
    v29 = 0;
  v30 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v29, v34, 64, 8, 1, 0);
  mlir::mps::DepthwiseConv2DDataGradientOp::build((mlir::MLIRContext **)a1, a2, a3, a4, a5, v26, v28, v30, a14, a15, a16);
  operator delete(v21);
  operator delete(v18);
}

void mlir::mps::DepthwiseConv2DDataGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  mlir::MLIRContext *v16;
  unsigned __int8 **AttributeUniquer;
  uint64_t v18;
  mlir::MLIRContext *v19;
  unsigned __int8 **v20;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::UnknownLoc *v25;
  mlir::MLIRContext *v26;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v29;
  int v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unint64_t v39[2];
  unint64_t v40[2];
  void *__src;
  uint64_t v42;
  _QWORD v43[3];

  v43[2] = *MEMORY[0x1E0C80C00];
  v36 = a4;
  v37 = a3;
  v35 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v16 = *a1;
  v38 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v42 = (uint64_t)v16;
  v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v38);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v18;
  v19 = *a1;
  v38 = a10;
  v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v42 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v21;
  v22 = *a1;
  v38 = a11;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v42 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v24;
  __src = v43;
  v42 = 0x200000000;
  v25 = *a1;
  v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v29 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DDataGradientOp::inferReturnTypes(v25, v26, 1, v40[0], v40[1], Dictionary, v29, v30, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v31 = __src;
  v32 = v42;
  v33 = *(unsigned int *)(a2 + 72);
  v34 = v33 + v42;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v32)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v43)
    free(__src);
}

BOOL mlir::mps::DepthwiseConv2DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  uint64_t v7;
  const void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t NextResultAtOffset;
  uint64_t v12;
  _QWORD **v13;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  void *v20;
  _QWORD **v21;
  _QWORD **v22;
  void *v23;
  _QWORD *v24;
  void *v25;
  void *v26;
  _QWORD **v27;
  _QWORD **v28;
  void *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  _QWORD **v39;
  _QWORD **v40;
  void *v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  const void **v46[4];
  __int16 v47;
  _QWORD v48[3];
  void *v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = v3[3];
        if (v7)
        {
          v8 = (const void **)v3[4];
          if (v8)
          {
            v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 2u))
              {
                if (*((_DWORD *)*this + 9))
                  v10 = (uint64_t)(*this - 2);
                else
                  v10 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (const void **)"requires attribute 'weights_layout'";
              v47 = 259;
              mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
              v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (const void **)"requires attribute 'strides'";
          v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          if (v55)
          {
            v39 = (_QWORD **)__p;
            if (__p)
            {
              v40 = v54;
              v41 = __p;
              if (v54 != __p)
              {
                do
                  v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                v41 = __p;
              }
              v54 = v39;
              operator delete(v41);
            }
            v16 = v51;
            if (!v51)
              goto LABEL_96;
            v42 = v52;
            v18 = v51;
            if (v52 == v51)
            {
LABEL_95:
              v52 = v16;
              operator delete(v18);
LABEL_96:
              if (v49 != &v50)
                free(v49);
              return v12;
            }
            do
            {
              v44 = (void *)*--v42;
              v43 = v44;
              *v42 = 0;
              if (v44)
                operator delete[](v43);
            }
            while (v42 != v16);
LABEL_94:
            v18 = v51;
            goto LABEL_95;
          }
        }
        else
        {
          v46[0] = (const void **)"requires attribute 'padding_style'";
          v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          if (v55)
          {
            v33 = (_QWORD **)__p;
            if (__p)
            {
              v34 = v54;
              v35 = __p;
              if (v54 != __p)
              {
                do
                  v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                v35 = __p;
              }
              v54 = v33;
              operator delete(v35);
            }
            v16 = v51;
            if (!v51)
              goto LABEL_96;
            v36 = v52;
            v18 = v51;
            if (v52 == v51)
              goto LABEL_95;
            do
            {
              v38 = (void *)*--v36;
              v37 = v38;
              *v36 = 0;
              if (v38)
                operator delete[](v37);
            }
            while (v36 != v16);
            goto LABEL_94;
          }
        }
      }
      else
      {
        v46[0] = (const void **)"requires attribute 'explicit_padding'";
        v47 = 259;
        mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
        v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        if (v55)
        {
          v27 = (_QWORD **)__p;
          if (__p)
          {
            v28 = v54;
            v29 = __p;
            if (v54 != __p)
            {
              do
                v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              v29 = __p;
            }
            v54 = v27;
            operator delete(v29);
          }
          v16 = v51;
          if (!v51)
            goto LABEL_96;
          v30 = v52;
          v18 = v51;
          if (v52 == v51)
            goto LABEL_95;
          do
          {
            v32 = (void *)*--v30;
            v31 = v32;
            *v30 = 0;
            if (v32)
              operator delete[](v31);
          }
          while (v30 != v16);
          goto LABEL_94;
        }
      }
    }
    else
    {
      v46[0] = (const void **)"requires attribute 'dilation_rates'";
      v47 = 259;
      mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
      v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      if (v55)
      {
        v21 = (_QWORD **)__p;
        if (__p)
        {
          v22 = v54;
          v23 = __p;
          if (v54 != __p)
          {
            do
              v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            v23 = __p;
          }
          v54 = v21;
          operator delete(v23);
        }
        v16 = v51;
        if (!v51)
          goto LABEL_96;
        v24 = v52;
        v18 = v51;
        if (v52 == v51)
          goto LABEL_95;
        do
        {
          v26 = (void *)*--v24;
          v25 = v26;
          *v24 = 0;
          if (v26)
            operator delete[](v25);
        }
        while (v24 != v16);
        goto LABEL_94;
      }
    }
  }
  else
  {
    v46[0] = (const void **)"requires attribute 'data_layout'";
    v47 = 259;
    mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    if (v55)
    {
      v13 = (_QWORD **)__p;
      if (__p)
      {
        v14 = v54;
        v15 = __p;
        if (v54 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v54 = v13;
        operator delete(v15);
      }
      v16 = v51;
      if (!v51)
        goto LABEL_96;
      v17 = v52;
      v18 = v51;
      if (v52 == v51)
        goto LABEL_95;
      do
      {
        v20 = (void *)*--v17;
        v19 = v20;
        *v17 = 0;
        if (v20)
          operator delete[](v19);
      }
      while (v17 != v16);
      goto LABEL_94;
    }
  }
  return v12;
}

uint64_t mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::DepthwiseConv2DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  __int128 *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (__int128 *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *v5;
  v9 = v5[1];
  *(_OWORD *)(a1 + 56) = v5[2];
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_2d", 21, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv2DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          *(_QWORD *)result = v9;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v11 = a4;
            else
              v11 = 0;
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v14 = a4;
        else
          v14 = 0;
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v12 = a4;
          else
            v12 = 0;
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x30uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties]";
        v15 = 116;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[434];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv2DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int a13, unsigned int a14, unsigned int a15)
{
  uint64_t IntegerType;
  _QWORD *v17;
  uint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v34;
  void *v35[2];
  _OWORD v36[7];
  void *v37;
  uint64_t v38;
  _BYTE v39[64];
  _BYTE *v40;
  uint64_t v41;
  _BYTE v42[32];
  _QWORD *v43;
  uint64_t v44;
  _QWORD v45[6];

  v45[4] = *MEMORY[0x1E0C80C00];
  v43 = v45;
  memset_pattern16(v45, &unk_181233190, 0x20uLL);
  v44 = 0x400000004;
  v40 = v42;
  memset_pattern16(v42, &unk_181233190, 0x20uLL);
  v41 = 0x400000004;
  v37 = v39;
  memset_pattern16(v39, &unk_181233190, 0x40uLL);
  v38 = 0x800000008;
  mlir::mps::buildConv2DDescriptor(a3, a4, 1, a5, a6, a7, a8, (uint64_t)v35, a10, a11, a12, a13, a14, a15, v45, (uint64_t)v42, (uint64_t)v39, 1);
  v35[0] = v36;
  v36[0] = xmmword_181240890;
  v35[1] = (void *)0x200000002;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v17 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v36, 2, IntegerType, 0);
  v34 = 4;
  v18 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v19 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)&v34, 1, v18, 0);
  v20 = v19;
  if (v19)
    v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v19 + 8);
  else
    v21 = 0;
  v22 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v21, v43, 8 * v44, 8, 1, 0);
  if (v20)
    v23 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  else
    v23 = 0;
  v24 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v23, v40, 8 * v41, 8, 1, 0);
  if (v17)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v17 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v17, v25, v37, 8 * v38, 8, 1, 0);
  mlir::mps::DepthwiseConv2DOp::build((mlir::MLIRContext **)a1, a2, a3, a4, v22, v24, v26, a13, a14, a15);
  if (v35[0] != v36)
    free(v35[0]);
  if (v37 != v39)
    free(v37);
  if (v40 != v42)
    free(v40);
  if (v43 != v45)
    free(v43);
}

void mlir::mps::DepthwiseConv2DOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, unsigned int a9, unsigned int a10)
{
  mlir::MLIRContext *v16;
  unsigned __int8 **AttributeUniquer;
  uint64_t v18;
  mlir::MLIRContext *v19;
  unsigned __int8 **v20;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::UnknownLoc *v25;
  mlir::MLIRContext *v26;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v29;
  int v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  unint64_t v38[2];
  unint64_t v39[2];
  void *__src;
  uint64_t v41;
  _QWORD v42[3];

  v42[2] = *MEMORY[0x1E0C80C00];
  v35 = a4;
  v36 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a5;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a7;
  v16 = *a1;
  v37 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v41 = (uint64_t)v16;
  v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v37);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v18;
  v19 = *a1;
  v37 = a9;
  v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v41 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v37);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v21;
  v22 = *a1;
  v37 = a10;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v41 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v37);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v24;
  __src = v42;
  v41 = 0x200000000;
  v25 = *a1;
  v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v39, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v29 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v38, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DOp::inferReturnTypes(v25, v26, 1, v39[0], v39[1], Dictionary, v29, v30, v38[0], v38[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v31 = __src;
  v32 = v41;
  v33 = *(unsigned int *)(a2 + 72);
  v34 = v33 + v41;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v32)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v42)
    free(__src);
}

BOOL mlir::mps::DepthwiseConv2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  uint64_t v7;
  const void **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t NextResultAtOffset;
  uint64_t v12;
  _QWORD **v13;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  void *v20;
  _QWORD **v21;
  _QWORD **v22;
  void *v23;
  _QWORD *v24;
  void *v25;
  void *v26;
  _QWORD **v27;
  _QWORD **v28;
  void *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  _QWORD **v39;
  _QWORD **v40;
  void *v41;
  _QWORD *v42;
  void *v43;
  void *v44;
  const void **v46[4];
  __int16 v47;
  _QWORD v48[3];
  void *v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v7 = v3[3];
        if (v7)
        {
          v8 = (const void **)v3[4];
          if (v8)
          {
            v9 = v3[5];
            if (v9)
            {
              v48[0] = v2;
              if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v8, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48)&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps9(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && (v48[0] = *this,
                    mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v7, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))&& (v48[0] = *this, mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v9, (const void **)"weights_layout", (const char *)0xE, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v48))
                && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
              {
                if (*((_DWORD *)*this + 9))
                  v10 = (uint64_t)(*this - 2);
                else
                  v10 = 0;
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 0);
                return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
              }
              else
              {
                return 0;
              }
            }
            else
            {
              v46[0] = (const void **)"requires attribute 'weights_layout'";
              v47 = 259;
              mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
              v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
              mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v48);
            }
            return v12;
          }
          v46[0] = (const void **)"requires attribute 'strides'";
          v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          if (v55)
          {
            v39 = (_QWORD **)__p;
            if (__p)
            {
              v40 = v54;
              v41 = __p;
              if (v54 != __p)
              {
                do
                  v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
                while (v40 != v39);
                v41 = __p;
              }
              v54 = v39;
              operator delete(v41);
            }
            v16 = v51;
            if (!v51)
              goto LABEL_95;
            v42 = v52;
            v18 = v51;
            if (v52 == v51)
            {
LABEL_94:
              v52 = v16;
              operator delete(v18);
LABEL_95:
              if (v49 != &v50)
                free(v49);
              return v12;
            }
            do
            {
              v44 = (void *)*--v42;
              v43 = v44;
              *v42 = 0;
              if (v44)
                operator delete[](v43);
            }
            while (v42 != v16);
LABEL_93:
            v18 = v51;
            goto LABEL_94;
          }
        }
        else
        {
          v46[0] = (const void **)"requires attribute 'padding_style'";
          v47 = 259;
          mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
          v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
          if (v48[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
          if (v55)
          {
            v33 = (_QWORD **)__p;
            if (__p)
            {
              v34 = v54;
              v35 = __p;
              if (v54 != __p)
              {
                do
                  v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
                while (v34 != v33);
                v35 = __p;
              }
              v54 = v33;
              operator delete(v35);
            }
            v16 = v51;
            if (!v51)
              goto LABEL_95;
            v36 = v52;
            v18 = v51;
            if (v52 == v51)
              goto LABEL_94;
            do
            {
              v38 = (void *)*--v36;
              v37 = v38;
              *v36 = 0;
              if (v38)
                operator delete[](v37);
            }
            while (v36 != v16);
            goto LABEL_93;
          }
        }
      }
      else
      {
        v46[0] = (const void **)"requires attribute 'explicit_padding'";
        v47 = 259;
        mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
        v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
        if (v48[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
        if (v55)
        {
          v27 = (_QWORD **)__p;
          if (__p)
          {
            v28 = v54;
            v29 = __p;
            if (v54 != __p)
            {
              do
                v28 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v28 - 1);
              while (v28 != v27);
              v29 = __p;
            }
            v54 = v27;
            operator delete(v29);
          }
          v16 = v51;
          if (!v51)
            goto LABEL_95;
          v30 = v52;
          v18 = v51;
          if (v52 == v51)
            goto LABEL_94;
          do
          {
            v32 = (void *)*--v30;
            v31 = v32;
            *v30 = 0;
            if (v32)
              operator delete[](v31);
          }
          while (v30 != v16);
          goto LABEL_93;
        }
      }
    }
    else
    {
      v46[0] = (const void **)"requires attribute 'dilation_rates'";
      v47 = 259;
      mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
      v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
      if (v48[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
      if (v55)
      {
        v21 = (_QWORD **)__p;
        if (__p)
        {
          v22 = v54;
          v23 = __p;
          if (v54 != __p)
          {
            do
              v22 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v22 - 1);
            while (v22 != v21);
            v23 = __p;
          }
          v54 = v21;
          operator delete(v23);
        }
        v16 = v51;
        if (!v51)
          goto LABEL_95;
        v24 = v52;
        v18 = v51;
        if (v52 == v51)
          goto LABEL_94;
        do
        {
          v26 = (void *)*--v24;
          v25 = v26;
          *v24 = 0;
          if (v26)
            operator delete[](v25);
        }
        while (v24 != v16);
        goto LABEL_93;
      }
    }
  }
  else
  {
    v46[0] = (const void **)"requires attribute 'data_layout'";
    v47 = 259;
    mlir::OpState::emitOpError(this, v46, (uint64_t)v48);
    v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v48);
    if (v48[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v48);
    if (v55)
    {
      v13 = (_QWORD **)__p;
      if (__p)
      {
        v14 = v54;
        v15 = __p;
        if (v54 != __p)
        {
          do
            v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
          while (v14 != v13);
          v15 = __p;
        }
        v54 = v13;
        operator delete(v15);
      }
      v16 = v51;
      if (!v51)
        goto LABEL_95;
      v17 = v52;
      v18 = v51;
      if (v52 == v51)
        goto LABEL_94;
      do
      {
        v20 = (void *)*--v17;
        v19 = v20;
        *v17 = 0;
        if (v20)
          operator delete[](v19);
      }
      while (v17 != v16);
      goto LABEL_93;
    }
  }
  return v12;
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (!memcmp(__s1, "dilation_rates", __n))
        return a2[1];
      if (memcmp(__s1, "weights_layout", __n))
        return 0;
      return a2[5];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv2DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, uint64_t a4)
{
  _QWORD *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v13 = a4;
          else
            v13 = 0;
          v7[4] = v13;
        }
        else
        {
          v7[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          *(_QWORD *)result = v9;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          v7[3] = v10;
        }
        else
        {
          v7[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "weights_layout", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
              v11 = a4;
            else
              v11 = 0;
            v7[5] = v11;
          }
          else
          {
            v7[5] = 0;
          }
        }
      }
      else if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v14 = a4;
        else
          v14 = 0;
        v7[1] = v14;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v12 = a4;
          else
            v12 = 0;
          v7[2] = v12;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

BOOL mlir::mps::DepthwiseConv2DWeightsGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3 + 5) != 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x30uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGeneri"
              "cAdaptorBase::Properties]";
        v15 = 131;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[436];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, unsigned int a14, unsigned int a15, unsigned int a16)
{
  _OWORD *v18;
  uint64_t IntegerType;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v34[4];
  _OWORD v35[2];
  _OWORD v36[2];
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v36[0] = xmmword_1812503B8;
  v36[1] = unk_1812503C8;
  v35[0] = xmmword_1812503B8;
  v35[1] = unk_1812503C8;
  memset(v34, 0, sizeof(v34));
  v18 = operator new(0x10uLL);
  *v18 = xmmword_181240890;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v20 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v18, 2, IntegerType, 0);
  v21 = operator new(8uLL);
  *v21 = 4;
  v22 = mlir::Builder::getIntegerType(a1, 0x40u, 0);
  v23 = (_QWORD *)mlir::RankedTensorType::get((uint64_t)v21, 1, v22, 0);
  v24 = v23;
  if (v23)
    v25 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v23 + 8);
  else
    v25 = 0;
  v26 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v25, v36, 32, 8, 1, 0);
  if (v24)
    v27 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v24 + 8);
  else
    v27 = 0;
  v28 = mlir::DenseElementsAttr::getFromRawBuffer(v24, v27, v35, 32, 8, 1, 0);
  if (v20)
    v29 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*v20 + 8);
  else
    v29 = 0;
  v30 = mlir::DenseElementsAttr::getFromRawBuffer(v20, v29, v34, 64, 8, 1, 0);
  mlir::mps::DepthwiseConv2DWeightsGradientOp::build((mlir::MLIRContext **)a1, a2, a3, a4, a5, v26, v28, v30, a14, a15, a16);
  operator delete(v21);
  operator delete(v18);
}

void mlir::mps::DepthwiseConv2DWeightsGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, unsigned int a10, unsigned int a11)
{
  mlir::MLIRContext *v16;
  unsigned __int8 **AttributeUniquer;
  uint64_t v18;
  mlir::MLIRContext *v19;
  unsigned __int8 **v20;
  uint64_t v21;
  mlir::MLIRContext *v22;
  unsigned __int8 **v23;
  uint64_t v24;
  mlir::UnknownLoc *v25;
  mlir::MLIRContext *v26;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v29;
  int v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unsigned int v38;
  unint64_t v39[2];
  unint64_t v40[2];
  void *__src;
  uint64_t v42;
  _QWORD v43[3];

  v43[2] = *MEMORY[0x1E0C80C00];
  v36 = a4;
  v37 = a3;
  v35 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v37, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v36, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v35, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v16 = *a1;
  v38 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v42 = (uint64_t)v16;
  v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v38);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v18;
  v19 = *a1;
  v38 = a10;
  v20 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v19);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v42 = (uint64_t)v19;
  v21 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v20, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v21;
  v22 = *a1;
  v38 = a11;
  v23 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v22);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v42 = (uint64_t)v22;
  v24 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(v23, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v38);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv2DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v24;
  __src = v43;
  v42 = 0x200000000;
  v25 = *a1;
  v26 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v40, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v29 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v39, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv2DWeightsGradientOp::inferReturnTypes(v25, v26, 1, v40[0], v40[1], Dictionary, v29, v30, v39[0], v39[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v31 = __src;
  v32 = v42;
  v33 = *(unsigned int *)(a2 + 72);
  v34 = v33 + v42;
  if (v34 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v34, 8);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v32)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v33), v31, 8 * v32);
    LODWORD(v33) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v33 + v32;
  if (__src != v43)
    free(__src);
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t *v52;
  char *v53;
  char *v54;
  __int128 v55;
  uint64_t *v56;
  char *v57;
  char *v58;
  __int128 v59;
  _QWORD **v60;
  _QWORD **v61;
  void *v62;
  _QWORD *v63;
  void *v64;
  void *v65;
  uint64_t *v66;
  char *v67;
  char *v68;
  __int128 v69;
  _QWORD **v70;
  _QWORD **v71;
  void *v72;
  _QWORD *v73;
  void *v74;
  void *v75;
  uint64_t *v76;
  char *v77;
  char *v78;
  __int128 v79;
  uint64_t *v80;
  char *v81;
  char *v82;
  __int128 v83;
  _QWORD **v84;
  _QWORD **v85;
  void *v86;
  _QWORD *v87;
  void *v88;
  void *v89;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  int64_t v102;
  int64_t v103;
  int64_t v104;
  int64_t v105;
  int64_t v106;
  int64_t v107;
  int64_t v108;
  int64_t v109;
  int64_t v110;
  uint64_t v111;
  uint64_t v112;
  const char *v113;
  uint64_t v114;
  _QWORD v115[3];
  void *v116;
  unsigned int v117;
  unsigned int v118;
  _BYTE v119[96];
  void *v120;
  _QWORD *v121;
  void *__p;
  _QWORD **v123;
  char v124;
  uint64_t v125;

  v125 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v111 = v6;
  if (!v6)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected DictionaryAttr to set properties";
      v114 = 41;
      v26 = &v112;
      v27 = (char *)v116;
      if (v117 >= v118)
      {
        v93 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v102 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          v27 = (char *)v116;
          v26 = (uint64_t *)((char *)v116 + v102);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v93, 24);
          v26 = &v112;
          v27 = (char *)v116;
        }
      }
      v28 = &v27[24 * v117];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v123;
      v32 = __p;
      if (v123 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v123 = v30;
      operator delete(v32);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_120;
    v33 = v121;
    v23 = v120;
    if (v121 == v120)
    {
LABEL_119:
      v121 = v21;
      operator delete(v23);
LABEL_120:
      if (v116 != v119)
        free(v116);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_118:
    v23 = v120;
    goto LABEL_119;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v111, "channelAxis", 0xBuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v115, a4);
      if (v115[0])
      {
        LODWORD(v112) = 3;
        v114 = 56;
        v10 = &v112;
        v11 = (char *)v116;
        if (v117 >= v118)
        {
          v94 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v103 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            v11 = (char *)v116;
            v10 = (uint64_t *)((char *)v116 + v103);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v94, 24);
            v10 = &v112;
            v11 = (char *)v116;
          }
        }
        v12 = &v11[24 * v117];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v117;
        if (v115[0])
        {
          v14 = &v112;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v9);
          v15 = (char *)v116;
          if (v117 >= v118)
          {
            v95 = v117 + 1;
            if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
            {
              v104 = (char *)&v112 - (_BYTE *)v116;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              v15 = (char *)v116;
              v14 = (uint64_t *)((char *)v116 + v104);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v95, 24);
              v14 = &v112;
              v15 = (char *)v116;
            }
          }
          v16 = &v15[24 * v117];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v117;
          if (v115[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
        }
      }
      if (!v124)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v123;
        v20 = __p;
        if (v123 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v123 = v18;
        operator delete(v20);
      }
      v21 = v120;
      if (!v120)
        goto LABEL_120;
      v22 = v121;
      v23 = v120;
      if (v121 == v120)
        goto LABEL_119;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_118;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v111, "dilation_rates", 0xEuLL);
  if (!v36)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v114 = 74;
      v42 = &v112;
      v43 = (char *)v116;
      if (v117 >= v118)
      {
        v96 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v105 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          v43 = (char *)v116;
          v42 = (uint64_t *)((char *)v116 + v105);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v96, 24);
          v42 = &v112;
          v43 = (char *)v116;
        }
      }
      v44 = &v43[24 * v117];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = v42[2];
      *(_OWORD *)v44 = v45;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v123;
      v48 = __p;
      if (v123 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v123 = v46;
      operator delete(v48);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_120;
    v49 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_119;
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
    goto LABEL_118;
  }
  v37 = v36;
  if ((mlir::DenseIntElementsAttr::classof(v36) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v114 = 59;
      v52 = &v112;
      v53 = (char *)v116;
      if (v117 >= v118)
      {
        v97 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v106 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          v53 = (char *)v116;
          v52 = (uint64_t *)((char *)v116 + v106);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v97, 24);
          v52 = &v112;
          v53 = (char *)v116;
        }
      }
      v54 = &v53[24 * v117];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = v52[2];
      *(_OWORD *)v54 = v55;
      ++v117;
      if (v115[0])
      {
        v56 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v37);
        v57 = (char *)v116;
        if (v117 >= v118)
        {
          v98 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v107 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            v57 = (char *)v116;
            v56 = (uint64_t *)((char *)v116 + v107);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v98, 24);
            v56 = &v112;
            v57 = (char *)v116;
          }
        }
        v58 = &v57[24 * v117];
        v59 = *(_OWORD *)v56;
        *((_QWORD *)v58 + 2) = v56[2];
        *(_OWORD *)v58 = v59;
        ++v117;
        if (v115[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124)
      return 0;
    v60 = (_QWORD **)__p;
    if (__p)
    {
      v61 = v123;
      v62 = __p;
      if (v123 != __p)
      {
        do
          v61 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v61 - 1);
        while (v61 != v60);
        v62 = __p;
      }
      v123 = v60;
      operator delete(v62);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_120;
    v63 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_119;
    do
    {
      v65 = (void *)*--v63;
      v64 = v65;
      *v63 = 0;
      if (v65)
        operator delete[](v64);
    }
    while (v63 != v21);
    goto LABEL_118;
  }
  a1[1] = v37;
  v38 = mlir::DictionaryAttr::get((uint64_t)&v111, "explicit_padding", 0x10uLL);
  if (!v38)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v113 = "expected key entry for explicit_padding in DictionaryAttr to set Properties.";
      v114 = 76;
      v66 = &v112;
      v67 = (char *)v116;
      if (v117 >= v118)
      {
        v99 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v108 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          v67 = (char *)v116;
          v66 = (uint64_t *)((char *)v116 + v108);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v99, 24);
          v66 = &v112;
          v67 = (char *)v116;
        }
      }
      v68 = &v67[24 * v117];
      v69 = *(_OWORD *)v66;
      *((_QWORD *)v68 + 2) = v66[2];
      *(_OWORD *)v68 = v69;
      ++v117;
      if (v115[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
    }
    if (!v124)
      return 0;
    v70 = (_QWORD **)__p;
    if (__p)
    {
      v71 = v123;
      v72 = __p;
      if (v123 != __p)
      {
        do
          v71 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v71 - 1);
        while (v71 != v70);
        v72 = __p;
      }
      v123 = v70;
      operator delete(v72);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_120;
    v73 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_119;
    do
    {
      v75 = (void *)*--v73;
      v74 = v75;
      *v73 = 0;
      if (v75)
        operator delete[](v74);
    }
    while (v73 != v21);
    goto LABEL_118;
  }
  v39 = v38;
  if ((mlir::DenseIntElementsAttr::classof(v38) & 1) == 0)
  {
    a3(v115, a4);
    if (v115[0])
    {
      LODWORD(v112) = 3;
      v114 = 61;
      v76 = &v112;
      v77 = (char *)v116;
      if (v117 >= v118)
      {
        v100 = v117 + 1;
        if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
        {
          v109 = (char *)&v112 - (_BYTE *)v116;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          v77 = (char *)v116;
          v76 = (uint64_t *)((char *)v116 + v109);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v100, 24);
          v76 = &v112;
          v77 = (char *)v116;
        }
      }
      v78 = &v77[24 * v117];
      v79 = *(_OWORD *)v76;
      *((_QWORD *)v78 + 2) = v76[2];
      *(_OWORD *)v78 = v79;
      ++v117;
      if (v115[0])
      {
        v80 = &v112;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v112, v39);
        v81 = (char *)v116;
        if (v117 >= v118)
        {
          v101 = v117 + 1;
          if (v116 <= &v112 && (char *)v116 + 24 * v117 > (char *)&v112)
          {
            v110 = (char *)&v112 - (_BYTE *)v116;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            v81 = (char *)v116;
            v80 = (uint64_t *)((char *)v116 + v110);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v116, v119, v101, 24);
            v80 = &v112;
            v81 = (char *)v116;
          }
        }
        v82 = &v81[24 * v117];
        v83 = *(_OWORD *)v80;
        *((_QWORD *)v82 + 2) = v80[2];
        *(_OWORD *)v82 = v83;
        ++v117;
        if (v115[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v115);
      }
    }
    if (!v124)
      return 0;
    v84 = (_QWORD **)__p;
    if (__p)
    {
      v85 = v123;
      v86 = __p;
      if (v123 != __p)
      {
        do
          v85 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v85 - 1);
        while (v85 != v84);
        v86 = __p;
      }
      v123 = v84;
      operator delete(v86);
    }
    v21 = v120;
    if (!v120)
      goto LABEL_120;
    v87 = v121;
    v23 = v120;
    if (v121 == v120)
      goto LABEL_119;
    do
    {
      v89 = (void *)*--v87;
      v88 = v89;
      *v87 = 0;
      if (v89)
        operator delete[](v88);
    }
    while (v87 != v21);
    goto LABEL_118;
  }
  a1[2] = v39;
  v40 = mlir::DictionaryAttr::get((uint64_t)&v111, "padding_style", 0xDuLL);
  v112 = v40;
  if (v40)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v40 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
    {
      a1[3] = v40;
      v91 = mlir::DictionaryAttr::get((uint64_t)&v111, "strides", 7uLL);
      v112 = v91;
      if (!v91)
      {
        a3(v115, a4);
        mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for strides in DictionaryAttr to set Properties.");
        goto LABEL_125;
      }
      v92 = v91;
      if ((mlir::DenseIntElementsAttr::classof(v91) & 1) != 0)
      {
        a1[4] = v92;
        return 1;
      }
      a3(v115, a4);
    }
    else
    {
      a3(v115, a4);
    }
    mlir::InFlightDiagnostic::append<mlir::Attribute>(v41, &v112);
  }
  else
  {
    a3(v115, a4);
    mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v115, "expected key entry for padding_style in DictionaryAttr to set Properties.");
  }
LABEL_125:
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v115);
  return 0;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  void *v33;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v36;
  void *v37;
  uint64_t v38;
  _QWORD v39[7];

  v39[6] = *MEMORY[0x1E0C80C00];
  v36 = a1;
  v37 = v39;
  v38 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v36, (uint64_t)"channelAxis", 11, *a2);
  v5 = v4;
  v6 = v38;
  if (v38 >= HIDWORD(v38))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
    v6 = v38;
  }
  v7 = (uint64_t *)((char *)v37 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v38 + 1;
  LODWORD(v38) = v38 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v13 = v38;
    }
    v14 = (uint64_t *)((char *)v37 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"explicit_padding", 16, v15);
    v18 = v17;
    v19 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v19 = v38;
    }
    v20 = (uint64_t *)((char *)v37 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"padding_style", 13, v21);
    v24 = v23;
    v25 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v25 = v38;
    }
    v26 = (uint64_t *)((char *)v37 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v36, (uint64_t)"strides", 7, v27);
    v30 = v29;
    v31 = v38;
    if (v38 >= HIDWORD(v38))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v39, v38 + 1, 16);
      v31 = v38;
    }
    v32 = (uint64_t *)((char *)v37 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    v8 = v38 + 1;
    LODWORD(v38) = v38 + 1;
  }
  v33 = v37;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v37 == v39)
      return DictionaryAttr;
    goto LABEL_24;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v36, (mlir::MLIRContext *)v37, v8);
  v33 = v37;
  if (v37 != v39)
LABEL_24:
    free(v33);
  return DictionaryAttr;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x416C656E6E616863 || *(_QWORD *)(__s1 + 3) != 0x736978416C656E6ELL)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x416C656E6E616863 && *(_QWORD *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"channelAxis", 11, *a2);
  v5 = a2[1];
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"dilation_rates", 14, v5);
  v6 = a2[2];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"explicit_padding", 16, v6);
  v7 = a2[3];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"padding_style", 13, v7);
  v8 = a2[4];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"strides", 7, v8);
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  const void **v8;
  const void **v9;
  const void **v10;
  uint64_t v11;
  const void **v12;
  _BOOL8 result;

  v8 = (const void **)mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v10, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v11, (const void **)"padding_style", (const char *)0xD, a3, a4))
        {
          v12 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v12, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
          {
            return 1;
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(const void **a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void ***v10;
  char *v11;
  char *v12;
  __int128 v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  unint64_t v27;
  unint64_t v28;
  int64_t v29;
  int64_t v30;
  const void **v31;
  const char *v32;
  uint64_t v33;
  __int16 v34;
  uint64_t Value;
  uint64_t v36;
  void *v37;
  unsigned int v38;
  unsigned int v39;
  _BYTE v40[96];
  void *v41;
  _QWORD *v42;
  void *__p;
  _QWORD **v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (*((_UNKNOWN **)*a1 + 17) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    v31 = a1;
    Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v31);
    if (mlir::Type::isSignedInteger((mlir::Type *)&Value, 32))
      return 1;
  }
  a4(&Value, a5);
  if (Value)
  {
    LODWORD(v31) = 3;
    v32 = "attribute '";
    v33 = 11;
    v10 = &v31;
    v11 = (char *)v37;
    if (v38 >= v39)
    {
      v27 = v38 + 1;
      if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
      {
        v29 = (char *)&v31 - (_BYTE *)v37;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v11 = (char *)v37;
        v10 = (const void ***)((char *)v37 + v29);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v27, 24);
        v10 = &v31;
        v11 = (char *)v37;
      }
    }
    v12 = &v11[24 * v38];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = v10[2];
    *(_OWORD *)v12 = v13;
    ++v38;
    if (Value)
    {
      v34 = 261;
      v31 = a2;
      v32 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v36, &v31);
      if (Value)
      {
        LODWORD(v31) = 3;
        v32 = "' failed to satisfy constraint: 32-bit signed integer attribute";
        v33 = 63;
        v14 = &v31;
        v15 = (char *)v37;
        if (v38 >= v39)
        {
          v28 = v38 + 1;
          if (v37 <= &v31 && (char *)v37 + 24 * v38 > (char *)&v31)
          {
            v30 = (char *)&v31 - (_BYTE *)v37;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v15 = (char *)v37;
            v14 = (const void ***)((char *)v37 + v30);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v37, v40, v28, 24);
            v14 = &v31;
            v15 = (char *)v37;
          }
        }
        v16 = &v15[24 * v38];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = v14[2];
        *(_OWORD *)v16 = v17;
        ++v38;
      }
    }
  }
  v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&Value);
  if (Value)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&Value);
  if (v45)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v44;
      v20 = __p;
      if (v44 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v44 = v18;
      operator delete(v20);
    }
    v21 = v41;
    if (v41)
    {
      v22 = v42;
      v23 = v41;
      if (v42 != v41)
      {
        do
        {
          v25 = (void *)*--v22;
          v24 = v25;
          *v22 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v22 != v21);
        v23 = v41;
      }
      v42 = v21;
      operator delete(v23);
    }
    if (v37 != v40)
      free(v37);
  }
  return v9;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  const void **v38;
  _QWORD v39[2];
  uint64_t OperandRange;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_9;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v41 = a1;
  v42 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v45 = v12;
  v46 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  v56 = 3;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = "attribute '";
    v43 = 11;
    v17 = &v41;
    v18 = (char *)v47;
    if (v48 >= v49)
    {
      v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v18 = (char *)v47;
        v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v17 = &v41;
        v18 = (char *)v47;
      }
    }
    v19 = &v18[24 * v48];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    ++v48;
    if (v45)
    {
      v44 = 261;
      v41 = a2;
      v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {3}";
        v43 = 68;
        v21 = &v41;
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v16;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  const void **v38;
  _QWORD v39[2];
  uint64_t OperandRange;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_9;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v41 = a1;
  v42 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v45 = v12;
  v46 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  v56 = 6;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = "attribute '";
    v43 = 11;
    v17 = &v41;
    v18 = (char *)v47;
    if (v48 >= v49)
    {
      v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v18 = (char *)v47;
        v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v17 = &v41;
        v18 = (char *)v47;
      }
    }
    v19 = &v18[24 * v48];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    ++v48;
    if (v45)
    {
      v44 = 261;
      v41 = a2;
      v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {6}";
        v43 = 68;
        v21 = &v41;
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v16;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAd"
              "aptorBase::Properties]";
        v15 = 128;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[438];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::DepthwiseConv3DDataGradientOp::getChannelAxis(mlir::mps::DepthwiseConv3DDataGradientOp *this)
{
  uint64_t v2;
  void *__p;
  unsigned int v4;
  uint64_t v5;

  v5 = *(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  mlir::IntegerAttr::getValue(&v5, (llvm::APInt *)&__p);
  if (v4 <= 0x40)
    return (uint64_t)((_QWORD)__p << -(uint64_t)v4) >> -(uint64_t)v4;
  v2 = *(_QWORD *)__p;
  operator delete[](__p);
  return v2;
}

void mlir::mps::DepthwiseConv3DDataGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  mlir::MLIRContext *v16;
  unsigned __int8 **AttributeUniquer;
  uint64_t v18;
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::UnknownLoc *v21;
  mlir::MLIRContext *v22;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v25;
  int v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unint64_t v35[2];
  unint64_t v36[2];
  void *__src;
  uint64_t v38;
  _QWORD v39[3];

  v39[2] = *MEMORY[0x1E0C80C00];
  v32 = a4;
  v33 = a3;
  v31 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v33, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  if (a5)
    mlir::OperationState::addOperands(a2, (uint64_t)&v31, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v16 = *(mlir::MLIRContext **)a1;
  v34 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v16);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v38 = (uint64_t)v16;
  v18 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v34);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v18;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a10);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = IntegerAttr;
  __src = v39;
  v38 = 0x200000000;
  v21 = *(mlir::UnknownLoc **)a1;
  v22 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v36, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v25 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v35, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DDataGradientOp::inferReturnTypes(v21, v22, 1, v36[0], v36[1], Dictionary, v25, v26, v35[0], v35[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v27 = __src;
  v28 = v38;
  v29 = *(unsigned int *)(a2 + 72);
  v30 = v29 + v38;
  if (v30 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v30, 8);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v28)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v29), v27, 8 * v28);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v29 + v28;
  if (__src != v39)
    free(__src);
}

BOOL mlir::mps::DepthwiseConv3DDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  const void **v4;
  const void **v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  uint64_t *v9;
  unint64_t v10;
  unsigned int v11;
  uint64_t ODSOperands;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v31;
  void *v32;
  void *v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  void *v38;
  void *v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t NextResultAtOffset;
  uint64_t v55;
  unsigned int v56;
  const void **v57[4];
  __int16 v58;
  _QWORD v59[3];
  void *v60;
  uint64_t v61;
  void *v62;
  _QWORD *v63;
  void *__p;
  _QWORD **v65;
  char v66;
  uint64_t v67;

  v67 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(const void ***)(v3 + 8);
  if (!v4)
  {
    v57[0] = (const void **)"requires attribute 'dilation_rates'";
    v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    if (!v66)
      return v25;
    v26 = (_QWORD **)__p;
    if (__p)
    {
      v27 = v65;
      v28 = __p;
      if (v65 != __p)
      {
        do
          v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
        while (v27 != v26);
        v28 = __p;
      }
      v65 = v26;
      operator delete(v28);
    }
    v29 = v62;
    if (v62)
    {
      v30 = v63;
      v31 = v62;
      if (v63 == v62)
        goto LABEL_78;
      do
      {
        v33 = (void *)*--v30;
        v32 = v33;
        *v30 = 0;
        if (v33)
          operator delete[](v32);
      }
      while (v30 != v29);
LABEL_77:
      v31 = v62;
LABEL_78:
      v63 = v29;
      operator delete(v31);
    }
LABEL_79:
    if (v60 != &v61)
      free(v60);
    return v25;
  }
  v5 = *(const void ***)(v3 + 16);
  if (!v5)
  {
    v57[0] = (const void **)"requires attribute 'explicit_padding'";
    v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    if (!v66)
      return v25;
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v65;
      v36 = __p;
      if (v65 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v65 = v34;
      operator delete(v36);
    }
    v29 = v62;
    if (v62)
    {
      v37 = v63;
      v31 = v62;
      if (v63 == v62)
        goto LABEL_78;
      do
      {
        v39 = (void *)*--v37;
        v38 = v39;
        *v37 = 0;
        if (v39)
          operator delete[](v38);
      }
      while (v37 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  v6 = *(_QWORD *)(v3 + 24);
  if (!v6)
  {
    v57[0] = (const void **)"requires attribute 'padding_style'";
    v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    if (!v66)
      return v25;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v65;
      v42 = __p;
      if (v65 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v65 = v40;
      operator delete(v42);
    }
    v29 = v62;
    if (v62)
    {
      v43 = v63;
      v31 = v62;
      if (v63 == v62)
        goto LABEL_78;
      do
      {
        v45 = (void *)*--v43;
        v44 = v45;
        *v43 = 0;
        if (v45)
          operator delete[](v44);
      }
      while (v43 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  v7 = *(const void ***)(v3 + 32);
  if (!v7)
  {
    v57[0] = (const void **)"requires attribute 'strides'";
    v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v59);
    if (v59[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    if (!v66)
      return v25;
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v65;
      v48 = __p;
      if (v65 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v65 = v46;
      operator delete(v48);
    }
    v29 = v62;
    if (v62)
    {
      v49 = v63;
      v31 = v62;
      if (v63 == v62)
        goto LABEL_78;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v29);
      goto LABEL_77;
    }
    goto LABEL_79;
  }
  v8 = *(const void ***)v3;
  v59[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0;
  v59[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0;
  v59[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0;
  v59[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0;
  v59[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v59))return 0;
  v9 = *this;
  v10 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v56 = 1;
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v9, v10, (const void **)"operand", (const void **)7, 0))return 0;
  v11 = 1;
  ODSOperands = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 1u);
  if (v13)
  {
    v14 = v13;
    v15 = 0;
    v16 = ODSOperands + 24;
    while (1)
    {
      v17 = *this;
      v18 = *(_QWORD *)(*(_QWORD *)v16 + 8) & 0xFFFFFFFFFFFFFFF8;
      v56 = v15 + 2;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v17, v18, (const void **)"operand", (const void **)7, (int)v15 + 1))return 0;
      ++v15;
      v16 += 32;
      if (v14 == v15)
      {
        v11 = v15 + 1;
        break;
      }
    }
  }
  v19 = mlir::tensor::UnPackOp::getODSOperands((mlir::tensor::UnPackOp *)this, 2u);
  v21 = v20;
  if (v20 >= 2)
  {
    v57[0] = (const void **)"operand group starting at #";
    v58 = 259;
    mlir::OpState::emitOpError(this, v57, (uint64_t)v59);
    v22 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v59, &v56);
    v23 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v22, " requires 0 or 1 element, but found ");
    v55 = v21;
    v24 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v23, &v55);
    v25 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v24);
    mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v59);
    return v25;
  }
  if (v20
    && !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)(v19 + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, v11))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v52 = (uint64_t)(*this - 2);
  else
    v52 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v52, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::DepthwiseConv3DOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t Context;
  unint64_t v12[3];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * ((v4 >> 23) & 1) + 64;
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v12, v7, v6);
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v5;
  v9 = *(_OWORD *)(v5 + 16);
  *(_QWORD *)(a1 + 56) = *(_QWORD *)(v5 + 32);
  *(_OWORD *)(a1 + 40) = v9;
  *(_OWORD *)(a1 + 24) = v8;
  *(_OWORD *)(a1 + 64) = *(_OWORD *)v12;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.depthwise_conv_3d", 21, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DepthwiseConv3DOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x416C656E6E616863 || *(_QWORD *)(__s1 + 3) != 0x736978416C656E6ELL)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x416C656E6E616863 && *(_QWORD *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties]";
        v15 = 116;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[440];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv3DOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8, int a9)
{
  mlir::MLIRContext *v15;
  unsigned __int8 **AttributeUniquer;
  uint64_t v17;
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::UnknownLoc *v20;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v23;
  mlir::MLIRContext *v24;
  int v25;
  int v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int v33;
  unint64_t v34[2];
  unint64_t v35[2];
  void *__src;
  uint64_t v37;
  _QWORD v38[3];

  v38[2] = *MEMORY[0x1E0C80C00];
  v31 = a4;
  v32 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v31, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a5;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a7;
  v15 = *(mlir::MLIRContext **)a1;
  v33 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v37 = (uint64_t)v15;
  v17 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v33);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v17;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a9);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>((_QWORD *)a2) = IntegerAttr;
  __src = v38;
  v37 = 0x200000000;
  v20 = *(mlir::UnknownLoc **)a1;
  mlir::ValueRange::ValueRange(v35, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v23 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v34, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DOp::inferReturnTypes(v20, v24, v25, v35[0], v35[1], Dictionary, v23, v26, v34[0], v34[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v27 = __src;
  v28 = v37;
  v29 = *(unsigned int *)(a2 + 72);
  v30 = v29 + v37;
  if (v30 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v30, 8);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v28)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v29), v27, 8 * v28);
    LODWORD(v29) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v29 + v28;
  if (__src != v38)
    free(__src);
}

BOOL mlir::mps::DepthwiseConv3DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  const void **v4;
  const void **v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  uint64_t v9;
  uint64_t NextResultAtOffset;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  const void **v39[4];
  __int16 v40;
  _QWORD v41[3];
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v45;
  void *__p;
  _QWORD **v47;
  char v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(const void ***)(v3 + 8);
  if (v4)
  {
    v5 = *(const void ***)(v3 + 16);
    if (v5)
    {
      v6 = *(_QWORD *)(v3 + 24);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 32);
        if (v7)
        {
          v8 = *(const void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
          {
            return 0;
          }
          if (*((_DWORD *)*this + 9))
            v9 = (uint64_t)(*this - 2);
          else
            v9 = 0;
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
        }
        v39[0] = (const void **)"requires attribute 'strides'";
        v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        if (v48)
        {
          v32 = (_QWORD **)__p;
          if (__p)
          {
            v33 = v47;
            v34 = __p;
            if (v47 != __p)
            {
              do
                v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              v34 = __p;
            }
            v47 = v32;
            operator delete(v34);
          }
          v15 = v44;
          if (!v44)
            goto LABEL_78;
          v35 = v45;
          v17 = v44;
          if (v45 == v44)
          {
LABEL_77:
            v45 = v15;
            operator delete(v17);
LABEL_78:
            if (v42 != &v43)
              free(v42);
            return v11;
          }
          do
          {
            v37 = (void *)*--v35;
            v36 = v37;
            *v35 = 0;
            if (v37)
              operator delete[](v36);
          }
          while (v35 != v15);
LABEL_76:
          v17 = v44;
          goto LABEL_77;
        }
      }
      else
      {
        v39[0] = (const void **)"requires attribute 'padding_style'";
        v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        if (v48)
        {
          v26 = (_QWORD **)__p;
          if (__p)
          {
            v27 = v47;
            v28 = __p;
            if (v47 != __p)
            {
              do
                v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              v28 = __p;
            }
            v47 = v26;
            operator delete(v28);
          }
          v15 = v44;
          if (!v44)
            goto LABEL_78;
          v29 = v45;
          v17 = v44;
          if (v45 == v44)
            goto LABEL_77;
          do
          {
            v31 = (void *)*--v29;
            v30 = v31;
            *v29 = 0;
            if (v31)
              operator delete[](v30);
          }
          while (v29 != v15);
          goto LABEL_76;
        }
      }
    }
    else
    {
      v39[0] = (const void **)"requires attribute 'explicit_padding'";
      v40 = 259;
      mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
      v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      if (v48)
      {
        v20 = (_QWORD **)__p;
        if (__p)
        {
          v21 = v47;
          v22 = __p;
          if (v47 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v47 = v20;
          operator delete(v22);
        }
        v15 = v44;
        if (!v44)
          goto LABEL_78;
        v23 = v45;
        v17 = v44;
        if (v45 == v44)
          goto LABEL_77;
        do
        {
          v25 = (void *)*--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v23 != v15);
        goto LABEL_76;
      }
    }
  }
  else
  {
    v39[0] = (const void **)"requires attribute 'dilation_rates'";
    v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    if (v48)
    {
      v12 = (_QWORD **)__p;
      if (__p)
      {
        v13 = v47;
        v14 = __p;
        if (v47 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v47 = v12;
        operator delete(v14);
      }
      v15 = v44;
      if (!v44)
        goto LABEL_78;
      v16 = v45;
      v17 = v44;
      if (v45 == v44)
        goto LABEL_77;
      do
      {
        v19 = (void *)*--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          operator delete[](v18);
      }
      while (v16 != v15);
      goto LABEL_76;
    }
  }
  return v11;
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x416C656E6E616863 || *(_QWORD *)(__s1 + 3) != 0x736978416C656E6ELL)
        return 0;
      return *a2;
    case 0xDuLL:
      if (memcmp(__s1, "padding_style", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::DepthwiseConv3DWeightsGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x416C656E6E616863 && *(_QWORD *)(__s1 + 3) == 0x736978416C656E6ELL)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xDuLL:
      result = memcmp(__s1, "padding_style", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGeneri"
              "cAdaptorBase::Properties]";
        v15 = 131;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[442];
    return a1[32];
  }
  return result;
}

void mlir::mps::DepthwiseConv3DWeightsGradientOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned int a9, int a10)
{
  mlir::MLIRContext *v15;
  unsigned __int8 **AttributeUniquer;
  uint64_t v17;
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  uint64_t v20;
  mlir::MLIRContext *Context;
  unint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int v35;
  unint64_t v36;
  unint64_t v37[2];
  void *__src;
  uint64_t v39;
  _QWORD v40[3];

  v40[2] = *MEMORY[0x1E0C80C00];
  v33 = a4;
  v34 = a3;
  v32 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v34, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v33, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v32, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a8;
  v15 = *(mlir::MLIRContext **)a1;
  v35 = a9;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id;
  v39 = (uint64_t)v15;
  v17 = mlir::StorageUniquer::get<mlir::mps::detail::PaddingStyleAttrStorage,mlir::mps::PaddingStyle>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail23PaddingStyleAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_16PaddingStyleAttrEJNS2_12PaddingStyleEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::PaddingStyleAttr,void>::id, &v35);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v17;
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 1);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a10);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = IntegerAttr;
  __src = v40;
  v39 = 0x200000000;
  v20 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v37, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v22 = mlir::ValueRange::ValueRange(&v36, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DepthwiseConv3DWeightsGradientOp::inferReturnTypes((uint64_t)v22, v20, 1, v37[0], v37[1], v23, v24, v25, v30, v31, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v26 = __src;
  v27 = v39;
  v28 = *(unsigned int *)(a2 + 72);
  v29 = v28 + v39;
  if (v29 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v29, 8);
    LODWORD(v28) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v27)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v28), v26, 8 * v27);
    LODWORD(v28) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v28 + v27;
  if (__src != v40)
    free(__src);
}

BOOL mlir::mps::DepthwiseConv3DWeightsGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  const void **v4;
  const void **v5;
  uint64_t v6;
  const void **v7;
  const void **v8;
  uint64_t v9;
  uint64_t NextResultAtOffset;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  const void **v39[4];
  __int16 v40;
  _QWORD v41[3];
  void *v42;
  uint64_t v43;
  void *v44;
  _QWORD *v45;
  void *__p;
  _QWORD **v47;
  char v48;
  uint64_t v49;

  v49 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(const void ***)(v3 + 8);
  if (v4)
  {
    v5 = *(const void ***)(v3 + 16);
    if (v5)
    {
      v6 = *(_QWORD *)(v3 + 24);
      if (v6)
      {
        v7 = *(const void ***)(v3 + 32);
        if (v7)
        {
          v8 = *(const void ***)v3;
          v41[0] = v2;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v7, (const void **)"strides", (const char *)7, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(v4, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps24(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(v5, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps25(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(v6, (const void **)"padding_style", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps10(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41))return 0;
          v41[0] = *this;
          if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v8, (const void **)"channelAxis", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v41)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this,
                                   *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8,
                                   (const void **)"operand",
                                   (const void **)7,
                                   2u))
          {
            return 0;
          }
          if (*((_DWORD *)*this + 9))
            v9 = (uint64_t)(*this - 2);
          else
            v9 = 0;
          NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
          return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
        }
        v39[0] = (const void **)"requires attribute 'strides'";
        v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        if (v48)
        {
          v32 = (_QWORD **)__p;
          if (__p)
          {
            v33 = v47;
            v34 = __p;
            if (v47 != __p)
            {
              do
                v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
              while (v33 != v32);
              v34 = __p;
            }
            v47 = v32;
            operator delete(v34);
          }
          v15 = v44;
          if (!v44)
            goto LABEL_79;
          v35 = v45;
          v17 = v44;
          if (v45 == v44)
          {
LABEL_78:
            v45 = v15;
            operator delete(v17);
LABEL_79:
            if (v42 != &v43)
              free(v42);
            return v11;
          }
          do
          {
            v37 = (void *)*--v35;
            v36 = v37;
            *v35 = 0;
            if (v37)
              operator delete[](v36);
          }
          while (v35 != v15);
LABEL_77:
          v17 = v44;
          goto LABEL_78;
        }
      }
      else
      {
        v39[0] = (const void **)"requires attribute 'padding_style'";
        v40 = 259;
        mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
        if (v41[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
        if (v48)
        {
          v26 = (_QWORD **)__p;
          if (__p)
          {
            v27 = v47;
            v28 = __p;
            if (v47 != __p)
            {
              do
                v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              v28 = __p;
            }
            v47 = v26;
            operator delete(v28);
          }
          v15 = v44;
          if (!v44)
            goto LABEL_79;
          v29 = v45;
          v17 = v44;
          if (v45 == v44)
            goto LABEL_78;
          do
          {
            v31 = (void *)*--v29;
            v30 = v31;
            *v29 = 0;
            if (v31)
              operator delete[](v30);
          }
          while (v29 != v15);
          goto LABEL_77;
        }
      }
    }
    else
    {
      v39[0] = (const void **)"requires attribute 'explicit_padding'";
      v40 = 259;
      mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
      v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
      if (v41[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
      if (v48)
      {
        v20 = (_QWORD **)__p;
        if (__p)
        {
          v21 = v47;
          v22 = __p;
          if (v47 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v47 = v20;
          operator delete(v22);
        }
        v15 = v44;
        if (!v44)
          goto LABEL_79;
        v23 = v45;
        v17 = v44;
        if (v45 == v44)
          goto LABEL_78;
        do
        {
          v25 = (void *)*--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v23 != v15);
        goto LABEL_77;
      }
    }
  }
  else
  {
    v39[0] = (const void **)"requires attribute 'dilation_rates'";
    v40 = 259;
    mlir::OpState::emitOpError(this, v39, (uint64_t)v41);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v41);
    if (v41[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v41);
    if (v48)
    {
      v12 = (_QWORD **)__p;
      if (__p)
      {
        v13 = v47;
        v14 = __p;
        if (v47 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v47 = v12;
        operator delete(v14);
      }
      v15 = v44;
      if (!v44)
        goto LABEL_79;
      v16 = v45;
      v17 = v44;
      if (v45 == v44)
        goto LABEL_78;
      do
      {
        v19 = (void *)*--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          operator delete[](v18);
      }
      while (v16 != v15);
      goto LABEL_77;
    }
  }
  return v11;
}

uint64_t mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::DequantizeLUTOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.dequantize_lut", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DequantizeLUTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "axis", 4uLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 49;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::DequantizeLUTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"axis", 4, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties]";
        v15 = 114;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[444];
    return a1[32];
  }
  return result;
}

void mlir::mps::DequantizeLUTOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::UnknownLoc *v8;
  mlir::MLIRContext *v9;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v12;
  int v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20[2];
  unint64_t v21[2];
  void *__src;
  uint64_t v23;
  _QWORD v24[3];

  v24[2] = *MEMORY[0x1E0C80C00];
  v18 = a4;
  v19 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  if (a5)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a5;
  __src = v24;
  v23 = 0x200000000;
  v8 = *a1;
  v9 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v12 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeLUTOp::inferReturnTypes(v8, v9, 1, v21[0], v21[1], Dictionary, v12, v13, v20[0], v20[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v14 = __src;
  v15 = v23;
  v16 = *(unsigned int *)(a2 + 72);
  v17 = v16 + v23;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v24)
    free(__src);
}

BOOL mlir::mps::DequantizeLUTOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  const void **v3;
  uint64_t *v4;
  unint64_t v5;
  void *v6;
  BOOL v7;
  uint64_t v8;
  int *v9;
  char *v10;
  char *v11;
  __int128 v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  int *v23;
  char *v24;
  char *v25;
  __int128 v26;
  char v27;
  _QWORD **v28;
  _QWORD **v29;
  void *v30;
  _QWORD *v31;
  _QWORD *v32;
  void *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t NextResultAtOffset;
  unint64_t v39;
  unint64_t v40;
  BOOL v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  int64_t v45;
  int64_t v46;
  int64_t v47;
  int64_t v48;
  const void **v49[4];
  __int16 v50;
  int v51;
  const char *v52;
  uint64_t v53;
  _QWORD v54[3];
  void *v55;
  unsigned int v56;
  unsigned int v57;
  _BYTE v58[96];
  void *v59;
  _QWORD *v60;
  void *__p;
  _QWORD **v62;
  char v63;
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v54[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v3, (const void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v54))return 0;
  v4 = *this;
  v5 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(void **)(*(_QWORD *)v5 + 136);
  v7 = v6 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v6 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v7
    || (v8 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v5 + 8),
        v54[0] = v5,
        v54[1] = v8,
        v49[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v54),
        !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 2))
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 4)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)v49, 8))
  {
    v50 = 261;
    v49[0] = (const void **)"operand";
    v49[1] = (const void **)7;
    mlir::Operation::emitOpError(v4, v49, (uint64_t)v54);
    if (v54[0])
    {
      v51 = 3;
      v52 = " #";
      v53 = 2;
      v9 = &v51;
      v10 = (char *)v55;
      if (v56 >= v57)
      {
        v39 = v56 + 1;
        if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
        {
          v45 = (char *)&v51 - (_BYTE *)v55;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          v10 = (char *)v55;
          v9 = (int *)((char *)v55 + v45);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v39, 24);
          v9 = &v51;
          v10 = (char *)v55;
        }
      }
      v11 = &v10[24 * v56];
      v12 = *(_OWORD *)v9;
      *((_QWORD *)v11 + 2) = *((_QWORD *)v9 + 2);
      *(_OWORD *)v11 = v12;
      v13 = ++v56;
      if (v54[0])
      {
        v51 = 5;
        v52 = 0;
        v14 = &v51;
        v15 = (char *)v55;
        if (v13 >= v57)
        {
          v40 = v13 + 1;
          v41 = (char *)v55 + 24 * v13 > (char *)&v51;
          if (v55 <= &v51 && v41)
          {
            v46 = (char *)&v51 - (_BYTE *)v55;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            v15 = (char *)v55;
            v14 = (int *)((char *)v55 + v46);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v40, 24);
            v14 = &v51;
            v15 = (char *)v55;
          }
        }
        v16 = &v15[24 * v56];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        v18 = ++v56;
        if (v54[0])
        {
          v51 = 3;
          v52 = " must be tensor of palette LUT index values, but got ";
          v53 = 53;
          v19 = &v51;
          v20 = (char *)v55;
          if (v18 >= v57)
          {
            v42 = v18 + 1;
            v43 = (char *)v55 + 24 * v18 > (char *)&v51;
            if (v55 <= &v51 && v43)
            {
              v47 = (char *)&v51 - (_BYTE *)v55;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              v20 = (char *)v55;
              v19 = (int *)((char *)v55 + v47);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v42, 24);
              v19 = &v51;
              v20 = (char *)v55;
            }
          }
          v21 = &v20[24 * v56];
          v22 = *(_OWORD *)v19;
          *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
          *(_OWORD *)v21 = v22;
          ++v56;
          if (v54[0])
          {
            v23 = &v51;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v51, v5);
            v24 = (char *)v55;
            if (v56 >= v57)
            {
              v44 = v56 + 1;
              if (v55 <= &v51 && (char *)v55 + 24 * v56 > (char *)&v51)
              {
                v48 = (char *)&v51 - (_BYTE *)v55;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                v24 = (char *)v55;
                v23 = (int *)((char *)v55 + v48);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v55, v58, v44, 24);
                v23 = &v51;
                v24 = (char *)v55;
              }
            }
            v25 = &v24[24 * v56];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = *((_QWORD *)v23 + 2);
            *(_OWORD *)v25 = v26;
            ++v56;
          }
        }
      }
    }
    v27 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v54);
    if (v54[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v54);
    if (v63)
    {
      v28 = (_QWORD **)__p;
      if (__p)
      {
        v29 = v62;
        v30 = __p;
        if (v62 != __p)
        {
          do
            v29 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v29 - 1);
          while (v29 != v28);
          v30 = __p;
        }
        v62 = v28;
        operator delete(v30);
      }
      v31 = v59;
      if (v59)
      {
        v32 = v60;
        v33 = v59;
        if (v60 != v59)
        {
          do
          {
            v35 = (void *)*--v32;
            v34 = v35;
            *v32 = 0;
            if (v35)
              operator delete[](v34);
          }
          while (v32 != v31);
          v33 = v59;
        }
        v60 = v31;
        operator delete(v33);
      }
      if (v55 != v58)
        free(v55);
    }
    if (!v27)
      return 0;
  }
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0;
  if (*((_DWORD *)*this + 9))
    v36 = (uint64_t)(*this - 2);
  else
    v36 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v36, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::DequantizeOpGenericAdaptorBase::DequantizeOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.dequantize", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DequantizeOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD **v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "axis", 4uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        v76 = 3;
        v78 = 49;
        v10 = &v76;
        v11 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v70 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v11 = (char *)v80;
            v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v10 = &v76;
            v11 = (char *)v80;
          }
        }
        v12 = &v11[24 * v81];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v81;
        if (v79[0])
        {
          v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          v15 = (char *)v80;
          if (v81 >= v82)
          {
            v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              v71 = (char *)&v76 - (_BYTE *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v15 = (char *)v80;
              v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v14 = &v76;
              v15 = (char *)v80;
            }
          }
          v16 = &v15[24 * v81];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v81;
          if (v79[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
      if (!v88)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v87;
        v20 = __p;
        if (v87 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v87 = v18;
        operator delete(v20);
      }
      v21 = v84;
      if (!v84)
        goto LABEL_80;
      v22 = v85;
      v23 = v84;
      if (v85 == v84)
        goto LABEL_79;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "dtype", 5uLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for dtype in DictionaryAttr to set Properties.";
      v78 = 65;
      v52 = &v76;
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v73 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 50;
    v38 = &v76;
    v39 = (char *)v80;
    if (v81 >= v82)
    {
      v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v72 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v39 = (char *)v80;
        v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v38 = &v76;
        v39 = (char *)v80;
      }
    }
    v40 = &v39[24 * v81];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v81;
    if (v79[0])
    {
      v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      v43 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v43 = (char *)v80;
          v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v42 = &v76;
          v43 = (char *)v80;
        }
      }
      v44 = &v43[24 * v81];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v87;
      v48 = __p;
      if (v87 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v87 = v46;
      operator delete(v48);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v49 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
LABEL_78:
    v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::DequantizeOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"axis", 4, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"dtype", 5, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties]";
        v15 = 111;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[446];
    return a1[32];
  }
  return result;
}

void mlir::mps::DequantizeOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  mlir::UnknownLoc *v13;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v16;
  mlir::MLIRContext *v17;
  int v18;
  int v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28[2];
  unint64_t v29[2];
  void *__src;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v26 = a4;
  v27 = a3;
  v24 = a6;
  v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  v12 = mlir::TypeAttr::get(a7);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v12;
  if (a8)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a8;
  __src = v32;
  v31 = 0x200000000;
  v13 = *a1;
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v16 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeOp::inferReturnTypes(v13, v17, v18, v29[0], v29[1], Dictionary, v16, v19, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v20 = __src;
  v21 = v31;
  v22 = *(unsigned int *)(a2 + 72);
  v23 = v22 + v31;
  if (v23 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v23, 8);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v21)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v22), v20, 8 * v21);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v22 + v21;
  if (__src != v32)
    free(__src);
}

{
  mlir::UnknownLoc *v12;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v15;
  mlir::MLIRContext *v16;
  int v17;
  int v18;
  void *v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27[2];
  unint64_t v28[2];
  void *__src;
  uint64_t v30;
  _QWORD v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  v25 = a4;
  v26 = a3;
  v23 = a6;
  v24 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  if (a8)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a8;
  __src = v31;
  v30 = 0x200000000;
  v12 = *a1;
  mlir::ValueRange::ValueRange(v28, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v15 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v27, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DequantizeOp::inferReturnTypes(v12, v16, v17, v28[0], v28[1], Dictionary, v15, v18, v27[0], v27[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v19 = __src;
  v20 = v30;
  v21 = *(unsigned int *)(a2 + 72);
  v22 = v21 + v30;
  if (v22 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v22, 8);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v20)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v21), v19, 8 * v20);
    LODWORD(v21) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v21 + v20;
  if (__src != v31)
    free(__src);
}

void mlir::mps::DequantizeOp::build(mlir::Float32Type **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14;
  mlir::GenericProgramPoint *v15;
  int v16;

  v14 = *a2;
  v16 = 0;
  v15 = mlir::OpBuilder::create<mlir::mps::ConstantOp,float>(a1, v14, (float *)&v16);
  mlir::mps::DequantizeOp::build(a1, (uint64_t)a2, a3, a4, a5, (uint64_t)v15 - 16, a6, a7);
}

BOOL mlir::mps::DequantizeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;
  const void **v5;
  uint64_t *v6;
  const void **v7;
  const void *v8;
  void *v9;
  uint64_t v11;
  BOOL v12;
  uint64_t *v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  uint64_t *v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  uint64_t *v23;
  char *v24;
  char *v25;
  __int128 v26;
  uint64_t *v27;
  char *v28;
  char *v29;
  __int128 v30;
  char v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  _QWORD **v41;
  _QWORD **v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  void *v47;
  void *v48;
  uint64_t *v49;
  unint64_t v50;
  void *v51;
  uint64_t v53;
  uint64_t *p_OperandRange;
  char *v55;
  char *v56;
  __int128 v57;
  uint64_t v58;
  uint64_t *v59;
  char *v60;
  char *v61;
  __int128 v62;
  uint64_t v63;
  uint64_t *v64;
  char *v65;
  char *v66;
  __int128 v67;
  uint64_t *v68;
  char *v69;
  char *v70;
  __int128 v71;
  char v72;
  _QWORD **v73;
  _QWORD **v74;
  void *v75;
  _QWORD *v76;
  _QWORD *v77;
  void *v78;
  void *v79;
  void *v80;
  uint64_t v81;
  uint64_t NextResultAtOffset;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  BOOL v87;
  unint64_t v88;
  BOOL v89;
  unint64_t v90;
  BOOL v91;
  unint64_t v92;
  BOOL v93;
  unint64_t v94;
  unint64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  int64_t v102;
  int64_t v103;
  const void **v104;
  uint64_t v105;
  __int16 v106;
  uint64_t OperandRange;
  const char *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  void *v112;
  unsigned int v113;
  unsigned int v114;
  _BYTE v115[96];
  void *v116;
  _QWORD *v117;
  void *__p;
  _QWORD **v119;
  char v120;
  uint64_t v121;

  v121 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD *)(v3 + 8);
  if (v4)
  {
    v5 = *(const void ***)v3;
    v110 = (unint64_t)v2;
    if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v4, (const void **)"dtype", (const char *)5, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0;
    v110 = (unint64_t)*this;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v5, (const void **)"axis", (const char *)4, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v110))return 0;
    v6 = *this;
    v7 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v8 = *v7;
    v9 = (void *)*((_QWORD *)*v7 + 17);
    if (v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8);
      v110 = (unint64_t)v7;
      v111 = v11;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
      if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
        || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
        || mlir::Type::isF16((mlir::Type *)&OperandRange)
        || mlir::Type::isF32((mlir::Type *)&OperandRange)
        || mlir::Type::isBF16((mlir::Type *)&OperandRange)
        || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
      {
LABEL_89:
        if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
        {
          v49 = *this;
          v50 = *(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8;
          v51 = *(void **)(*(_QWORD *)v50 + 136);
          if (v51 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
            || v51 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
          {
            v53 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*(_QWORD *)v50 + 8);
            v110 = v50;
            v111 = v53;
            v104 = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v110);
            if (mlir::Type::isSignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isSignedInteger((mlir::Type *)&v104, 32)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 1)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 2)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 4)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 8)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 16)
              || mlir::Type::isUnsignedInteger((mlir::Type *)&v104, 32)
              || *((_UNKNOWN **)*v104 + 17) == &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
            {
              goto LABEL_176;
            }
          }
          v106 = 261;
          v104 = (const void **)"operand";
          v105 = 7;
          mlir::Operation::emitOpError(v49, &v104, (uint64_t)&v110);
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            v108 = " #";
            v109 = 2;
            p_OperandRange = &OperandRange;
            v55 = (char *)v112;
            if (v113 >= v114)
            {
              v84 = v113 + 1;
              if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
              {
                v96 = (char *)&OperandRange - (_BYTE *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                v55 = (char *)v112;
                p_OperandRange = (uint64_t *)((char *)v112 + v96);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v84, 24);
                p_OperandRange = &OperandRange;
                v55 = (char *)v112;
              }
            }
            v56 = &v55[24 * v113];
            v57 = *(_OWORD *)p_OperandRange;
            *((_QWORD *)v56 + 2) = p_OperandRange[2];
            *(_OWORD *)v56 = v57;
            v58 = ++v113;
            if (v110)
            {
              LODWORD(OperandRange) = 5;
              v108 = (const char *)2;
              v59 = &OperandRange;
              v60 = (char *)v112;
              if (v58 >= v114)
              {
                v86 = v58 + 1;
                v87 = (char *)v112 + 24 * v58 > (char *)&OperandRange;
                if (v112 <= &OperandRange && v87)
                {
                  v98 = (char *)&OperandRange - (_BYTE *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  v60 = (char *)v112;
                  v59 = (uint64_t *)((char *)v112 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v86, 24);
                  v59 = &OperandRange;
                  v60 = (char *)v112;
                }
              }
              v61 = &v60[24 * v113];
              v62 = *(_OWORD *)v59;
              *((_QWORD *)v61 + 2) = v59[2];
              *(_OWORD *)v61 = v62;
              v63 = ++v113;
              if (v110)
              {
                LODWORD(OperandRange) = 3;
                v108 = " must be tensor of quantized values, but got ";
                v109 = 45;
                v64 = &OperandRange;
                v65 = (char *)v112;
                if (v63 >= v114)
                {
                  v90 = v63 + 1;
                  v91 = (char *)v112 + 24 * v63 > (char *)&OperandRange;
                  if (v112 <= &OperandRange && v91)
                  {
                    v100 = (char *)&OperandRange - (_BYTE *)v112;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    v65 = (char *)v112;
                    v64 = (uint64_t *)((char *)v112 + v100);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v90, 24);
                    v64 = &OperandRange;
                    v65 = (char *)v112;
                  }
                }
                v66 = &v65[24 * v113];
                v67 = *(_OWORD *)v64;
                *((_QWORD *)v66 + 2) = v64[2];
                *(_OWORD *)v66 = v67;
                ++v113;
                if (v110)
                {
                  v68 = &OperandRange;
                  mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, v50);
                  v69 = (char *)v112;
                  if (v113 >= v114)
                  {
                    v94 = v113 + 1;
                    if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                    {
                      v102 = (char *)&OperandRange - (_BYTE *)v112;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      v69 = (char *)v112;
                      v68 = (uint64_t *)((char *)v112 + v102);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v94, 24);
                      v68 = &OperandRange;
                      v69 = (char *)v112;
                    }
                  }
                  v70 = &v69[24 * v113];
                  v71 = *(_OWORD *)v68;
                  *((_QWORD *)v70 + 2) = v68[2];
                  *(_OWORD *)v70 = v71;
                  ++v113;
                }
              }
            }
          }
          v72 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
          if (v110)
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
          if (v120)
          {
            v73 = (_QWORD **)__p;
            if (__p)
            {
              v74 = v119;
              v75 = __p;
              if (v119 != __p)
              {
                do
                  v74 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v74 - 1);
                while (v74 != v73);
                v75 = __p;
              }
              v119 = v73;
              operator delete(v75);
            }
            v76 = v116;
            if (v116)
            {
              v77 = v117;
              v78 = v116;
              if (v117 != v116)
              {
                do
                {
                  v80 = (void *)*--v77;
                  v79 = v80;
                  *v77 = 0;
                  if (v80)
                    operator delete[](v79);
                }
                while (v77 != v76);
                v78 = v116;
              }
              v117 = v76;
              operator delete(v78);
            }
            if (v112 != v115)
              free(v112);
          }
          if (v72)
          {
LABEL_176:
            if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 3u))
            {
              if (*((_DWORD *)*this + 9))
                v81 = (uint64_t)(*this - 2);
              else
                v81 = 0;
              NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v81, 0);
              return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
            }
          }
        }
        return 0;
      }
      v8 = *v7;
      v9 = (void *)*((_QWORD *)*v7 + 17);
    }
    v12 = v9 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
       || v9 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    if (!v12
      || (v104 = v7,
          v105 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v8 + 8),
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v104),
          !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 2))
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 1)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 2)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 4)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
      && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
      && *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::mps::NF4Type,void>::id)
    {
      v106 = 261;
      v104 = (const void **)"operand";
      v105 = 7;
      mlir::Operation::emitOpError(v6, &v104, (uint64_t)&v110);
      if (v110)
      {
        LODWORD(OperandRange) = 3;
        v108 = " #";
        v109 = 2;
        v13 = &OperandRange;
        v14 = (char *)v112;
        if (v113 >= v114)
        {
          v85 = v113 + 1;
          if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
          {
            v97 = (char *)&OperandRange - (_BYTE *)v112;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            v14 = (char *)v112;
            v13 = (uint64_t *)((char *)v112 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v85, 24);
            v13 = &OperandRange;
            v14 = (char *)v112;
          }
        }
        v15 = &v14[24 * v113];
        v16 = *(_OWORD *)v13;
        *((_QWORD *)v15 + 2) = v13[2];
        *(_OWORD *)v15 = v16;
        v17 = ++v113;
        if (v110)
        {
          LODWORD(OperandRange) = 5;
          v108 = 0;
          v18 = &OperandRange;
          v19 = (char *)v112;
          if (v17 >= v114)
          {
            v88 = v17 + 1;
            v89 = (char *)v112 + 24 * v17 > (char *)&OperandRange;
            if (v112 <= &OperandRange && v89)
            {
              v99 = (char *)&OperandRange - (_BYTE *)v112;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              v19 = (char *)v112;
              v18 = (uint64_t *)((char *)v112 + v99);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v88, 24);
              v18 = &OperandRange;
              v19 = (char *)v112;
            }
          }
          v20 = &v19[24 * v113];
          v21 = *(_OWORD *)v18;
          *((_QWORD *)v20 + 2) = v18[2];
          *(_OWORD *)v20 = v21;
          v22 = ++v113;
          if (v110)
          {
            LODWORD(OperandRange) = 3;
            v108 = " must be tensor of mps native type values or tensor of quantized values, but got ";
            v109 = 81;
            v23 = &OperandRange;
            v24 = (char *)v112;
            if (v22 >= v114)
            {
              v92 = v22 + 1;
              v93 = (char *)v112 + 24 * v22 > (char *)&OperandRange;
              if (v112 <= &OperandRange && v93)
              {
                v101 = (char *)&OperandRange - (_BYTE *)v112;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                v24 = (char *)v112;
                v23 = (uint64_t *)((char *)v112 + v101);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v92, 24);
                v23 = &OperandRange;
                v24 = (char *)v112;
              }
            }
            v25 = &v24[24 * v113];
            v26 = *(_OWORD *)v23;
            *((_QWORD *)v25 + 2) = v23[2];
            *(_OWORD *)v25 = v26;
            ++v113;
            if (v110)
            {
              v27 = &OperandRange;
              mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)v7);
              v28 = (char *)v112;
              if (v113 >= v114)
              {
                v95 = v113 + 1;
                if (v112 <= &OperandRange && (char *)v112 + 24 * v113 > (char *)&OperandRange)
                {
                  v103 = (char *)&OperandRange - (_BYTE *)v112;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  v28 = (char *)v112;
                  v27 = (uint64_t *)((char *)v112 + v103);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v112, v115, v95, 24);
                  v27 = &OperandRange;
                  v28 = (char *)v112;
                }
              }
              v29 = &v28[24 * v113];
              v30 = *(_OWORD *)v27;
              *((_QWORD *)v29 + 2) = v27[2];
              *(_OWORD *)v29 = v30;
              ++v113;
            }
          }
        }
      }
      v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
      if (v110)
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
      if (v120)
      {
        v32 = (_QWORD **)__p;
        if (__p)
        {
          v33 = v119;
          v34 = __p;
          if (v119 != __p)
          {
            do
              v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
            while (v33 != v32);
            v34 = __p;
          }
          v119 = v32;
          operator delete(v34);
        }
        v35 = v116;
        if (v116)
        {
          v36 = v117;
          v37 = v116;
          if (v117 != v116)
          {
            do
            {
              v39 = (void *)*--v36;
              v38 = v39;
              *v36 = 0;
              if (v39)
                operator delete[](v38);
            }
            while (v36 != v35);
            v37 = v116;
          }
          v117 = v35;
          operator delete(v37);
        }
        if (v112 != v115)
          free(v112);
      }
      if (!v31)
        return 0;
    }
    goto LABEL_89;
  }
  v104 = (const void **)"requires attribute 'dtype'";
  v106 = 259;
  mlir::OpState::emitOpError(this, &v104, (uint64_t)&v110);
  v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v110);
  if (v110)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v110);
  if (v120)
  {
    v41 = (_QWORD **)__p;
    if (__p)
    {
      v42 = v119;
      v43 = __p;
      if (v119 != __p)
      {
        do
          v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
        while (v42 != v41);
        v43 = __p;
      }
      v119 = v41;
      operator delete(v43);
    }
    v44 = v116;
    if (v116)
    {
      v45 = v117;
      v46 = v116;
      if (v117 != v116)
      {
        do
        {
          v48 = (void *)*--v45;
          v47 = v48;
          *v45 = 0;
          if (v48)
            operator delete[](v47);
        }
        while (v45 != v44);
        v46 = v116;
      }
      v117 = v44;
      operator delete(v46);
    }
    if (v112 != v115)
      free(v112);
  }
  return v40;
}

uint64_t mlir::mps::detail::DimensionSizeOpGenericAdaptorBase::DimensionSizeOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.dimension_size", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::DimensionSizeOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20[2];
  void *__src;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v17 = a4;
  v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  v22 = 0x200000000;
  v5 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v7 = mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DimensionSizeOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v11 = __src;
  v12 = v22;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23)
    free(__src);
}

BOOL mlir::mps::DimensionSizeOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isSignedInteger((mlir::Type *)v51, 32) || mlir::Type::isSignedInteger((mlir::Type *)v51, 64))
      return 1;
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of mps index type values, but got ";
        v55 = 50;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.dirac", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.divide", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::DynamicShapeCastOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "unranked", 8uLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 53;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::DynamicShapeCastOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"unranked", 8, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties]";
        v15 = 117;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[448];
    return a1[32];
  }
  return result;
}

void mlir::mps::DynamicShapeCastOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  mlir::MLIRContext *v9;
  uint64_t UnitAttr;
  mlir::Float32Type *v11;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v14;
  mlir::MLIRContext *v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24[2];
  void *v25[2];
  void *__src;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v22 = a4;
  v23 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  if (a4)
    mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  if (a5)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v28;
  v27 = 0x200000000;
  v11 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v25, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v14 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::DynamicShapeCastOp::inferReturnTypes(v11, v15, v16, v25[0], (uint64_t)v25[1], Dictionary, v14, v17, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v18 = __src;
  v19 = v27;
  v20 = *(unsigned int *)(a2 + 72);
  v21 = v20 + v27;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v19)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v28)
    free(__src);
}

BOOL mlir::mps::DynamicShapeCastOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  char *v8;
  char *v9;
  __int128 v10;
  uint64_t v11;
  int *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  int *v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  _QWORD **v22;
  _QWORD **v23;
  void *v24;
  _QWORD *v25;
  _QWORD *v26;
  void *v27;
  void *v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t NextResultAtOffset;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  unint64_t v40;
  BOOL v41;
  int64_t v42;
  int64_t v43;
  int64_t v44;
  const void **v45;
  __int16 v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  _QWORD v50[3];
  void *v51;
  unsigned int v52;
  unsigned int v53;
  _BYTE v54[96];
  void *v55;
  _QWORD *v56;
  void *__p;
  _QWORD **v58;
  char v59;
  uint64_t v60;

  v60 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v50[0] = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"unranked", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v50)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
  {
    return 0;
  }
  v4 = *this;
  if ((*((_BYTE *)*this + 46) & 0x80) == 0)
  {
    v6 = -1;
    goto LABEL_5;
  }
  v5 = *((unsigned int *)v4 + 17);
  v6 = v5 - 1;
  if ((unint64_t)(v5 - 1) <= 1)
  {
    if (v5 == 1)
    {
LABEL_31:
      v32 = *((_DWORD *)v4 + 9);
      v33 = v4 - 2;
      if (v32)
        v34 = (uint64_t)v33;
      else
        v34 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v34, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    v30 = v4[9] + 56;
    v31 = 1;
    while (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)v30 + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, v31))
    {
      ++v31;
      v30 += 32;
      if (v5 == v31)
      {
        v4 = *this;
        goto LABEL_31;
      }
    }
    return 0;
  }
LABEL_5:
  v45 = (const void **)"operand group starting at #";
  v46 = 259;
  mlir::OpState::emitOpError(this, &v45, (uint64_t)v50);
  if (v50[0])
  {
    v47 = 5;
    v48 = 1;
    v7 = &v47;
    v8 = (char *)v51;
    if (v52 >= v53)
    {
      v37 = v52 + 1;
      if (v51 <= &v47 && (char *)v51 + 24 * v52 > (char *)&v47)
      {
        v42 = (char *)&v47 - (_BYTE *)v51;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        v8 = (char *)v51;
        v7 = (int *)((char *)v51 + v42);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v37, 24);
        v7 = &v47;
        v8 = (char *)v51;
      }
    }
    v9 = &v8[24 * v52];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = *((_QWORD *)v7 + 2);
    *(_OWORD *)v9 = v10;
    v11 = ++v52;
    if (v50[0])
    {
      v47 = 3;
      v48 = (uint64_t)" requires 0 or 1 element, but found ";
      v49 = 36;
      v12 = &v47;
      v13 = (char *)v51;
      if (v11 >= v53)
      {
        v38 = v11 + 1;
        v39 = (char *)v51 + 24 * v11 > (char *)&v47;
        if (v51 <= &v47 && v39)
        {
          v43 = (char *)&v47 - (_BYTE *)v51;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          v13 = (char *)v51;
          v12 = (int *)((char *)v51 + v43);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v38, 24);
          v12 = &v47;
          v13 = (char *)v51;
        }
      }
      v14 = &v13[24 * v52];
      v15 = *(_OWORD *)v12;
      *((_QWORD *)v14 + 2) = *((_QWORD *)v12 + 2);
      *(_OWORD *)v14 = v15;
      v16 = ++v52;
      if (v50[0])
      {
        v47 = 5;
        v48 = v6;
        v17 = &v47;
        v18 = (char *)v51;
        if (v16 >= v53)
        {
          v40 = v16 + 1;
          v41 = (char *)v51 + 24 * v16 > (char *)&v47;
          if (v51 <= &v47 && v41)
          {
            v44 = (char *)&v47 - (_BYTE *)v51;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            v18 = (char *)v51;
            v17 = (int *)((char *)v51 + v44);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v54, v40, 24);
            v17 = &v47;
            v18 = (char *)v51;
          }
        }
        v19 = &v18[24 * v52];
        v20 = *(_OWORD *)v17;
        *((_QWORD *)v19 + 2) = *((_QWORD *)v17 + 2);
        *(_OWORD *)v19 = v20;
        ++v52;
      }
    }
  }
  v21 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v50);
  if (v50[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v50);
  if (v59)
  {
    v22 = (_QWORD **)__p;
    if (__p)
    {
      v23 = v58;
      v24 = __p;
      if (v58 != __p)
      {
        do
          v23 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v23 - 1);
        while (v23 != v22);
        v24 = __p;
      }
      v58 = v22;
      operator delete(v24);
    }
    v25 = v55;
    if (v55)
    {
      v26 = v56;
      v27 = v55;
      if (v56 != v55)
      {
        do
        {
          v29 = (void *)*--v26;
          v28 = v29;
          *v26 = 0;
          if (v29)
            operator delete[](v28);
        }
        while (v26 != v25);
        v27 = v55;
      }
      v56 = v25;
      operator delete(v27);
    }
    if (v51 != v54)
      free(v51);
  }
  return v21;
}

uint64_t mlir::mps::detail::EluOpGenericAdaptorBase::EluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.elu", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.equal", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::EqualToOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14[2];
  void *__src;
  uint64_t v16;
  _QWORD v17[3];

  v17[2] = *MEMORY[0x1E0C80C00];
  v11 = a4;
  v12 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v12, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v17;
  v16 = 0x200000000;
  v5 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v14, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v13, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v7 = __src;
  v8 = v16;
  v9 = *(unsigned int *)(a2 + 72);
  v10 = v9 + v16;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v8)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v17)
    free(__src);
}

BOOL mlir::mps::EqualToOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps25(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  BOOL v12;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  v12 = v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
     || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
  if (!v12
    || (v56[0] = a2,
        v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8),
        v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56),
        v13 = 1,
        !mlir::Type::isSignlessInteger((mlir::Type *)v51, 1)))
  {
    v52 = 261;
    v51[0] = a3;
    v51[1] = a4;
    mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
    if (v56[0])
    {
      v53 = 3;
      v54 = " #";
      v55 = 2;
      v14 = &v53;
      v15 = (char *)v57;
      if (v58 >= v59)
      {
        v41 = v58 + 1;
        if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
        {
          v47 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          v15 = (char *)v57;
          v14 = (int *)((char *)v57 + v47);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
          v14 = &v53;
          v15 = (char *)v57;
        }
      }
      v16 = &v15[24 * v58];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      v18 = ++v58;
      if (v56[0])
      {
        v53 = 5;
        v54 = (const char *)a5;
        v19 = &v53;
        v20 = (char *)v57;
        if (v18 >= v59)
        {
          v42 = v18 + 1;
          v43 = (char *)v57 + 24 * v18 > (char *)&v53;
          if (v57 <= &v53 && v43)
          {
            v48 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            v20 = (char *)v57;
            v19 = (int *)((char *)v57 + v48);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
            v19 = &v53;
            v20 = (char *)v57;
          }
        }
        v21 = &v20[24 * v58];
        v22 = *(_OWORD *)v19;
        *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
        *(_OWORD *)v21 = v22;
        v23 = ++v58;
        if (v56[0])
        {
          v53 = 3;
          v54 = " must be tensor of 1-bit signless integer values, but got ";
          v55 = 58;
          v24 = &v53;
          v25 = (char *)v57;
          if (v23 >= v59)
          {
            v44 = v23 + 1;
            v45 = (char *)v57 + 24 * v23 > (char *)&v53;
            if (v57 <= &v53 && v45)
            {
              v49 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              v25 = (char *)v57;
              v24 = (int *)((char *)v57 + v49);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
              v24 = &v53;
              v25 = (char *)v57;
            }
          }
          v26 = &v25[24 * v58];
          v27 = *(_OWORD *)v24;
          *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
          *(_OWORD *)v26 = v27;
          ++v58;
          if (v56[0])
          {
            v28 = &v53;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
            v29 = (char *)v57;
            if (v58 >= v59)
            {
              v46 = v58 + 1;
              if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
              {
                v50 = (char *)&v53 - (_BYTE *)v57;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                v29 = (char *)v57;
                v28 = (int *)((char *)v57 + v50);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
                v28 = &v53;
                v29 = (char *)v57;
              }
            }
            v30 = &v29[24 * v58];
            v31 = *(_OWORD *)v28;
            *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
            *(_OWORD *)v30 = v31;
            ++v58;
          }
        }
      }
    }
    v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
    if (v56[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
    if (v65)
    {
      v32 = (_QWORD **)__p;
      if (__p)
      {
        v33 = v64;
        v34 = __p;
        if (v64 != __p)
        {
          do
            v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          v34 = __p;
        }
        v64 = v32;
        operator delete(v34);
      }
      v35 = v61;
      if (v61)
      {
        v36 = v62;
        v37 = v61;
        if (v62 != v61)
        {
          do
          {
            v39 = (void *)*--v36;
            v38 = v39;
            *v36 = 0;
            if (v39)
              operator delete[](v38);
          }
          while (v36 != v35);
          v37 = v61;
        }
        v62 = v35;
        operator delete(v37);
      }
      if (v57 != v60)
        free(v57);
    }
  }
  return v13;
}

uint64_t mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.erf", 7, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.expand_dims", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ExpandDimsOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20[2];
  void *__src;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v17 = a4;
  v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  v22 = 0x200000000;
  v5 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v7 = mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ExpandDimsOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v11 = __src;
  v12 = v22;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23)
    free(__src);
}

uint64_t mlir::mps::detail::ExponentBase10OpGenericAdaptorBase::ExponentBase10OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_10", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent_base_2", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.exponent", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::FastFourierTransformOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD **v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "inverse", 7uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        v76 = 3;
        v78 = 52;
        v10 = &v76;
        v11 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v70 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v11 = (char *)v80;
            v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v10 = &v76;
            v11 = (char *)v80;
          }
        }
        v12 = &v11[24 * v81];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v81;
        if (v79[0])
        {
          v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          v15 = (char *)v80;
          if (v81 >= v82)
          {
            v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              v71 = (char *)&v76 - (_BYTE *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v15 = (char *)v80;
              v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v14 = &v76;
              v15 = (char *)v80;
            }
          }
          v16 = &v15[24 * v81];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v81;
          if (v79[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
      if (!v88)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v87;
        v20 = __p;
        if (v87 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v87 = v18;
        operator delete(v20);
      }
      v21 = v84;
      if (!v84)
        goto LABEL_80;
      v22 = v85;
      v23 = v84;
      if (v85 == v84)
        goto LABEL_79;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "scaling_mode", 0xCuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      v78 = 72;
      v52 = &v76;
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v73 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 57;
    v38 = &v76;
    v39 = (char *)v80;
    if (v81 >= v82)
    {
      v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v72 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v39 = (char *)v80;
        v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v38 = &v76;
        v39 = (char *)v80;
      }
    }
    v40 = &v39[24 * v81];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v81;
    if (v79[0])
    {
      v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      v43 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v43 = (char *)v80;
          v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v42 = &v76;
          v43 = (char *)v80;
        }
      }
      v44 = &v43[24 * v81];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v87;
      v48 = __p;
      if (v87 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v87 = v46;
      operator delete(v48);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v49 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
LABEL_78:
    v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::FastFourierTransformOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"inverse", 7, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"scaling_mode", 12, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid FFT scaling mode";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties]";
        v15 = 121;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[450];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::FFTScalingModeAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::FastFourierTransformOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  mlir::MLIRContext *v10;
  unsigned __int8 **AttributeUniquer;
  uint64_t v12;
  mlir::MLIRContext *v13;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v15;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v18;
  mlir::MLIRContext *v19;
  int v20;
  int v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29[2];
  unint64_t v30[2];
  void *__src;
  uint64_t v32;
  _QWORD v33[3];

  v33[2] = *MEMORY[0x1E0C80C00];
  v26 = a4;
  v27 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  v10 = *a1;
  v28 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v10);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v32 = (uint64_t)v10;
  v12 = mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v28);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v12;
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v13);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v33;
  v32 = 0x200000000;
  v15 = *a1;
  mlir::ValueRange::ValueRange(v30, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v18 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::FastFourierTransformOp::inferReturnTypes(v15, v19, v20, v30[0], v30[1], Dictionary, v18, v21, v29[0], v29[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v22 = __src;
  v23 = v32;
  v24 = *(unsigned int *)(a2 + 72);
  v25 = v24 + v32;
  if (v25 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v25, 8);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v23)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v24), v22, 8 * v23);
    LODWORD(v24) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v24 + v23;
  if (__src != v33)
    free(__src);
}

BOOL mlir::mps::FastFourierTransformOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD **v9;
  _QWORD **v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  void *v15;
  void *v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD **v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = v3[1];
  if (v4)
  {
    v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (const void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(
                            *this,
                            (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8),
                            (const void **)"operand",
                            7,
                            1u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'scaling_mode'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v9 = (_QWORD **)__p;
      if (__p)
      {
        v10 = v26;
        v11 = __p;
        if (v26 != __p)
        {
          do
            v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          v11 = __p;
        }
        v26 = v9;
        operator delete(v11);
      }
      v12 = v23;
      if (v23)
      {
        v13 = v24;
        v14 = v23;
        if (v24 != v23)
        {
          do
          {
            v16 = (void *)*--v13;
            v15 = v16;
            *v13 = 0;
            if (v16)
              operator delete[](v15);
          }
          while (v13 != v12);
          v14 = v23;
        }
        v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  void *v11;
  uint64_t v14;
  uint64_t *p_OperandRange;
  char *v16;
  char *v17;
  __int128 v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  __int128 v23;
  uint64_t v24;
  uint64_t *v25;
  char *v26;
  char *v27;
  __int128 v28;
  uint64_t *v29;
  char *v30;
  char *v31;
  __int128 v32;
  uint64_t v33;
  _QWORD **v34;
  _QWORD **v35;
  void *v36;
  _QWORD *v37;
  _QWORD *v38;
  void *v39;
  void *v40;
  void *v41;
  uint64_t v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  uint64_t v57;
  uint64_t Value;
  uint64_t v59;
  uint64_t OperandRange;
  const char *v61;
  uint64_t v62;
  _QWORD v63[3];
  void *v64;
  unsigned int v65;
  unsigned int v66;
  _BYTE v67[96];
  void *v68;
  _QWORD *v69;
  void *__p;
  _QWORD **v71;
  char v72;
  uint64_t v73;

  v73 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  v11 = (void *)*((_QWORD *)*a2 + 17);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v63[0] = a2;
    v63[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v63);
    if (mlir::Type::isF16((mlir::Type *)&OperandRange)
      || mlir::Type::isF32((mlir::Type *)&OperandRange)
      || mlir::Type::isBF16((mlir::Type *)&OperandRange))
    {
      return 1;
    }
    v10 = *a2;
    v11 = (void *)*((_QWORD *)*a2 + 17);
  }
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v54 = a2;
    v55 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
    v14 = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v54);
    if (*(_UNKNOWN **)(*(_QWORD *)v14 + 136) == &mlir::detail::TypeIDResolver<mlir::ComplexType,void>::id)
    {
      v42 = v14;
      v59 = v14;
      OperandRange = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v59);
      if (mlir::Type::isF16((mlir::Type *)&OperandRange))
        return 1;
      v57 = v42;
      Value = mlir::AffineMapAttr::getValue((mlir::AffineMapAttr *)&v57);
      if (mlir::Type::isF32((mlir::Type *)&Value))
        return 1;
    }
  }
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v63);
  if (v63[0])
  {
    LODWORD(OperandRange) = 3;
    v61 = " #";
    v62 = 2;
    p_OperandRange = &OperandRange;
    v16 = (char *)v64;
    if (v65 >= v66)
    {
      v44 = v65 + 1;
      if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
      {
        v50 = (char *)&OperandRange - (_BYTE *)v64;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        v16 = (char *)v64;
        p_OperandRange = (uint64_t *)((char *)v64 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v44, 24);
        p_OperandRange = &OperandRange;
        v16 = (char *)v64;
      }
    }
    v17 = &v16[24 * v65];
    v18 = *(_OWORD *)p_OperandRange;
    *((_QWORD *)v17 + 2) = p_OperandRange[2];
    *(_OWORD *)v17 = v18;
    v19 = ++v65;
    if (v63[0])
    {
      LODWORD(OperandRange) = 5;
      v61 = (const char *)a5;
      v20 = &OperandRange;
      v21 = (char *)v64;
      if (v19 >= v66)
      {
        v45 = v19 + 1;
        v46 = (char *)v64 + 24 * v19 > (char *)&OperandRange;
        if (v64 <= &OperandRange && v46)
        {
          v51 = (char *)&OperandRange - (_BYTE *)v64;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v21 = (char *)v64;
          v20 = (uint64_t *)((char *)v64 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v45, 24);
          v20 = &OperandRange;
          v21 = (char *)v64;
        }
      }
      v22 = &v21[24 * v65];
      v23 = *(_OWORD *)v20;
      *((_QWORD *)v22 + 2) = v20[2];
      *(_OWORD *)v22 = v23;
      v24 = ++v65;
      if (v63[0])
      {
        LODWORD(OperandRange) = 3;
        v61 = " must be tensor of floating point values or tensor of complex values, but got ";
        v62 = 78;
        v25 = &OperandRange;
        v26 = (char *)v64;
        if (v24 >= v66)
        {
          v47 = v24 + 1;
          v48 = (char *)v64 + 24 * v24 > (char *)&OperandRange;
          if (v64 <= &OperandRange && v48)
          {
            v52 = (char *)&OperandRange - (_BYTE *)v64;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v26 = (char *)v64;
            v25 = (uint64_t *)((char *)v64 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v47, 24);
            v25 = &OperandRange;
            v26 = (char *)v64;
          }
        }
        v27 = &v26[24 * v65];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = v25[2];
        *(_OWORD *)v27 = v28;
        ++v65;
        if (v63[0])
        {
          v29 = &OperandRange;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&OperandRange, (uint64_t)a2);
          v30 = (char *)v64;
          if (v65 >= v66)
          {
            v49 = v65 + 1;
            if (v64 <= &OperandRange && (char *)v64 + 24 * v65 > (char *)&OperandRange)
            {
              v53 = (char *)&OperandRange - (_BYTE *)v64;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v30 = (char *)v64;
              v29 = (uint64_t *)((char *)v64 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v64, v67, v49, 24);
              v29 = &OperandRange;
              v30 = (char *)v64;
            }
          }
          v31 = &v30[24 * v65];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = v29[2];
          *(_OWORD *)v31 = v32;
          ++v65;
        }
      }
    }
  }
  v33 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v63);
  if (v63[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v63);
  if (v72)
  {
    v34 = (_QWORD **)__p;
    if (__p)
    {
      v35 = v71;
      v36 = __p;
      if (v71 != __p)
      {
        do
          v35 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v35 - 1);
        while (v35 != v34);
        v36 = __p;
      }
      v71 = v34;
      operator delete(v36);
    }
    v37 = v68;
    if (v68)
    {
      v38 = v69;
      v39 = v68;
      if (v69 != v68)
      {
        do
        {
          v41 = (void *)*--v38;
          v40 = v41;
          *v38 = 0;
          if (v41)
            operator delete[](v40);
        }
        while (v38 != v37);
        v39 = v68;
      }
      v69 = v37;
      operator delete(v39);
    }
    if (v64 != v67)
      free(v64);
  }
  return v33;
}

uint64_t mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.flatten_2d", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::Flatten2DOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  unint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20[2];
  void *__src;
  uint64_t v22;
  _QWORD v23[3];

  v23[2] = *MEMORY[0x1E0C80C00];
  v17 = a4;
  v18 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  __src = v23;
  v22 = 0x200000000;
  v5 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v7 = mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::Flatten2DOp::inferReturnTypes((uint64_t)v7, v5, 1, v20[0], v20[1], v8, v9, v10, v15, v16, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v11 = __src;
  v12 = v22;
  v13 = *(unsigned int *)(a2 + 72);
  v14 = v13 + v22;
  if (v14 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v11, 8 * v12);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v12;
  if (__src != v23)
    free(__src);
}

BOOL mlir::mps::Flatten2DOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps0(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.floor_divide", 16, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

BOOL mlir::mps::FloorDivideOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;

  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v2 = (uint64_t)(*this - 2);
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.floor", 9, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GRUGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v5;
  uint64_t NextResultAtOffset;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t result;
  uint64_t v18;

  if (*(_DWORD *)(*a1 + 36))
    v5 = *a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36))
    v7 = *a1 - 16;
  else
    v7 = 0;
  v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36))
    v10 = *a1 - 16;
  else
    v10 = 0;
  v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  v13 = *a1;
  v14 = *(_DWORD *)(*a1 + 36);
  v15 = v13 - 16;
  if (v14)
    v16 = v15;
  else
    v16 = 0;
  result = mlir::detail::OpResultImpl::getNextResultAtOffset(v16, 3);
  if (v14 != 3)
  {
    v18 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v18, "gradient_bias", 13);
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSResults(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  int v2;
  unsigned int v3;
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  unsigned int v9;
  int32x4_t v10;
  int v11;
  uint64_t result;

  if (a2)
  {
    if (a2 >= 8)
    {
      v4 = (int32x4_t)xmmword_181235170;
      v3 = a2 & 0xFFFFFFF8;
      v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = -1;
      v7.i64[1] = -1;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      v9 = a2 & 0xFFFFFFF8;
      v10 = 0uLL;
      do
      {
        v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        v10 = vsubq_s32(v10, vceqq_s32(v4, v7));
        v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2)
        goto LABEL_11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
    }
    do
    {
      if (v3 == 3)
        ++v2;
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    v2 = 0;
  }
LABEL_11:
  v11 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v11)
    result = *(_QWORD *)this - 16;
  else
    result = 0;
  if (a2 + (v11 - 4) * v2)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v11 - 4) * v2);
  return result;
}

uint64_t mlir::mps::GRUGradientOp::getODSOperands(mlir::mps::GRUGradientOp *this, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  uint64_t v9;
  int32x4_t v10;
  uint64_t v11;
  int *v12;
  int v13;

  v2 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v3 = *(_QWORD *)this + 16 * ((v2 >> 23) & 1) + 64;
  else
    v3 = 0;
  if (!a2)
  {
    v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    v4 = a2 & 0xFFFFFFF8;
    v7 = (int32x4_t *)(v3 + 64);
    v8 = 0uLL;
    v9 = v4;
    v10 = 0uLL;
    do
    {
      v8 = vaddq_s32(v7[-1], v8);
      v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2)
      goto LABEL_13;
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  v11 = a2 - v4;
  v12 = (int *)(v3 + 4 * v4 + 48);
  do
  {
    v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0)
    return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * v6;
  else
    return 32 * v6;
}

uint64_t mlir::mps::GRUGradientOp::getGradientInputState(mlir::mps::GRUGradientOp *this)
{
  uint64_t v1;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v1 = *(_QWORD *)this - 16;
  else
    v1 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 2);
  return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
}

uint64_t mlir::mps::GRUGradientOp::getGradientBias(mlir::mps::GRUGradientOp *this)
{
  int v1;
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;

  v1 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v1)
    v2 = *(_QWORD *)this - 16;
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 3);
  v4 = 0;
  if (v1 != 3)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  return v4;
}

BOOL mlir::mps::GRUGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  _QWORD v74[3];
  void *v75;
  unsigned int v76;
  unsigned int v77;
  _BYTE v78[96];
  void *v79;
  _QWORD *v80;
  void *__p;
  _QWORD **v82;
  char v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      v72 = "expected DictionaryAttr to set properties";
      v73 = 41;
      v26 = &v71;
      v27 = (char *)v75;
      if (v76 >= v77)
      {
        v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          v65 = (char *)&v71 - (_BYTE *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v27 = (char *)v75;
          v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v26 = &v71;
          v27 = (char *)v75;
        }
      }
      v28 = &v27[24 * v76];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v76;
      if (v74[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
    }
    if (!v83)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v82;
      v32 = __p;
      if (v82 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v82 = v30;
      operator delete(v32);
    }
    v21 = v79;
    if (!v79)
      goto LABEL_64;
    v33 = v80;
    v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78)
        free(v75);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v79;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "flip_z", 6uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 51;
        v10 = &v71;
        v11 = (char *)v75;
        if (v76 >= v77)
        {
          v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v66 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v11 = (char *)v75;
            v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v10 = &v71;
            v11 = (char *)v75;
          }
        }
        v12 = &v11[24 * v76];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v76;
        if (v74[0])
        {
          v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          v15 = (char *)v75;
          if (v76 >= v77)
          {
            v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v67 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v15 = (char *)v75;
              v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v14 = &v71;
              v15 = (char *)v75;
            }
          }
          v16 = &v15[24 * v76];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v82;
        v20 = __p;
        if (v82 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v82 = v18;
        operator delete(v20);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v22 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 56;
        v38 = &v71;
        v39 = (char *)v75;
        if (v76 >= v77)
        {
          v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v68 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v39 = (char *)v75;
            v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v38 = &v71;
            v39 = (char *)v75;
          }
        }
        v40 = &v39[24 * v76];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v76;
        if (v74[0])
        {
          v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          v43 = (char *)v75;
          if (v76 >= v77)
          {
            v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v69 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v43 = (char *)v75;
              v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v42 = &v71;
              v43 = (char *)v75;
            }
          }
          v44 = &v43[24 * v76];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v82;
        v48 = __p;
        if (v82 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v82 = v46;
        operator delete(v48);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v49 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v53);
      goto LABEL_83;
    }
    a1[2] = v52;
  }
  v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "reset_after", 0xBuLL);
  v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[3] = v54;
  }
  v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "rgate_activation", 0x10uLL);
  v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  v59 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    v59 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)7, v59, a3, a4) != 0;
}

uint64_t mlir::mps::GRUGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  BOOL v45;
  uint64_t v46;
  uint64_t DictionaryAttr;
  void *v48;
  mlir::DictionaryAttr *v50;
  void *v51;
  uint64_t v52;
  _QWORD v53[7];

  v53[6] = *MEMORY[0x1E0C80C00];
  v50 = a1;
  v51 = v53;
  v52 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"flip_z", 6, *a2);
    v6 = v5;
    v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v7 = v52;
    }
    v8 = (uint64_t *)((char *)v51 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v9);
    v12 = v11;
    v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v13 = v52;
    }
    v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v15);
    v18 = v17;
    v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v19 = v52;
    }
    v20 = (uint64_t *)((char *)v51 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"reset_after", 11, v21);
    v24 = v23;
    v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v25 = v52;
    }
    v26 = (uint64_t *)((char *)v51 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"rgate_activation", 16, v27);
    v30 = v29;
    v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v31 = v52;
    }
    v32 = (uint64_t *)((char *)v51 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    v36 = v35;
    v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v37 = v52;
    }
    v38 = (uint64_t *)((char *)v51 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
  v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  v42 = v41;
  v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    v43 = v52;
  }
  v44 = (uint64_t *)((char *)v51 + 16 * v43);
  *v44 = v40;
  v44[1] = v42;
  v45 = __CFADD__((_DWORD)v52, 1);
  v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    DictionaryAttr = 0;
    v48 = v51;
    if (v51 == v53)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (mlir::MLIRContext *)v51, v46);
  v48 = v51;
  if (v51 != v53)
LABEL_32:
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUGradientOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v29;
  int v30;
  unint64_t v31;
  int v32;
  int v33;
  unint64_t v34;
  int v35;
  int v36;
  unint64_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  unint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t *v64;
  unint64_t *v65;
  unint64_t *v66;
  unint64_t *v67;
  unint64_t *v68;
  unint64_t *v69;
  unint64_t *v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  _OWORD v85[4];
  _OWORD v86[3];
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v64 = a1;
    v71 = *a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v29;
    a1 = v64;
    v1 = v71;
    if (v30)
    {
      v31 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v31 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v31;
      a1 = v64;
      v1 = v71;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = v3[19];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v65 = a1;
    v72 = v1;
    v52 = a1[1];
    v57 = v3[19];
    v5 = v52;
    v4 = v57;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v32;
    a1 = v65;
    v1 = v72;
    if (v33)
    {
      v34 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v34 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v34;
      v5 = v52;
      v4 = v57;
      a1 = v65;
      v1 = v72;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v5);
  v8 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v5) ^ HIDWORD(v5));
  v84 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v66 = a1;
    v73 = v1;
    v53 = a1[2];
    v58 = v4;
    v9 = v53;
    v4 = v58;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v35;
    a1 = v66;
    v1 = v73;
    if (v36)
    {
      v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v37 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      v9 = v53;
      v4 = v58;
      a1 = v66;
      v1 = v73;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v9) ^ HIDWORD(v9));
  v83 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v67 = a1;
    v74 = v1;
    v54 = a1[3];
    v59 = v4;
    v12 = v54;
    v4 = v59;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v39 = v38;
    a1 = v67;
    v1 = v74;
    if (v39)
    {
      v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v40 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      v12 = v54;
      v4 = v59;
      a1 = v67;
      v1 = v74;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v82 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v68 = a1;
    v75 = v1;
    v55 = a1[4];
    v60 = v4;
    v15 = v55;
    v4 = v60;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v42 = v41;
    a1 = v68;
    v1 = v75;
    if (v42)
    {
      v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v43 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      v15 = v55;
      v4 = v60;
      a1 = v68;
      v1 = v75;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v81 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v69 = a1;
    v76 = v1;
    v56 = a1[5];
    v61 = v4;
    v18 = v56;
    v4 = v61;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v69;
    v1 = v76;
    if (v45)
    {
      v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v46 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      v18 = v56;
      v4 = v61;
      a1 = v69;
      v1 = v76;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v18) ^ HIDWORD(v18));
  v80 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  if ((v19 & 1) == 0)
  {
    v70 = a1;
    v77 = v1;
    v62 = v4;
    v1 = v77;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v48 = v47;
    v4 = v62;
    a1 = v70;
    if (v48)
    {
      v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v49 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      v4 = v62;
      a1 = v70;
      v1 = v77;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v21 = v3[19];
  v22 = a1[7];
  v23 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  v24 = __ROR8__(0xB492B66FBE98F273 * a1[6] - v22, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v23 ^ v21, 30);
  v25 = v21 + __ROR8__(v22 ^ 0xC949D7C7509E6557, 20) - 0x4B6D499041670D8DLL * a1[6] - v23 + 28;
  v79 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69
        * (v25 ^ ((0x9DDFEA08EB382D69 * (v24 ^ v25)) >> 47) ^ (0x9DDFEA08EB382D69 * (v24 ^ v25)))) ^ ((0x9DDFEA08EB382D69 * (v25 ^ ((0x9DDFEA08EB382D69 * (v24 ^ v25)) >> 47) ^ (0x9DDFEA08EB382D69 * (v24 ^ v25)))) >> 47));
  v87 = 0;
  memset(v86, 0, sizeof(v86));
  memset(v85, 0, sizeof(v85));
  if ((v25 & 1) == 0)
  {
    v78 = v1;
    v63 = v4;
    v4 = v63;
    v1 = v78;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v50)
    {
      v51 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v51 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v51;
      v4 = v63;
      v1 = v78;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v26 = HIDWORD(v1);
  v27 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v88 = v3[19];
  *(_QWORD *)&v85[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v26 ^ (v27 >> 47) ^ v27)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v26 ^ (v27 >> 47) ^ v27)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v85, 0, (_QWORD *)v85 + 1, (char *)v86, (uint64_t *)&v84, (uint64_t *)&v83, (uint64_t *)&v82, (uint64_t *)&v81, (uint64_t *)&v80, (uint64_t *)&v79);
}

uint64_t mlir::mps::GRUGradientOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, _WORD *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327)
        goto LABEL_20;
      return *a2;
    case 7uLL:
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_20;
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n))
          goto LABEL_20;
        result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        result = a2[4];
      }
      else if (*(_QWORD *)__s1 == 0x63615F657461677ALL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
      {
        result = a2[5];
      }
      else
      {
LABEL_20:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_20;
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_20;
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUGradientOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          *(_QWORD *)result = v14;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xBuLL:
      result = memcmp(__s1, "gate_layout", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "reset_after", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
              v9 = a4;
            else
              v9 = 0;
            v7[3] = v9;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "ogate_activation", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "rgate_activation", __n);
        if ((_DWORD)result)
        {
          if (*(_QWORD *)__s1 == 0x63615F657461677ALL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                v11 = a4;
              else
                v11 = 0;
              v7[5] = v11;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v17 = a4;
          else
            v17 = 0;
          v7[4] = v17;
        }
        else
        {
          v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
          v16 = a4;
        else
          v16 = 0;
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!(_DWORD)result)
        goto LABEL_29;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!(_DWORD)result)
      {
LABEL_29:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v12 = (_DWORD)result ? a4 : 0;
          v18 = v12;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 7)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13)
                result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v13);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  v8 = a2[3];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  v9 = a2[4];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  v10 = a2[5];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 7);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::GRUGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"flip_z", (const char *)6, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (const void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"reset_after", (const char *)0xB, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            v13 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid GRU gate layout";
        v31 = 53;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid RNN activation";
        v31 = 52;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::GRUGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v7[4];
  __int16 v8;
  uint64_t v9;
  _QWORD v10[25];

  v10[24] = *MEMORY[0x1E0C80C00];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 8)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      v8 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5)
      memmove(v3 + 6, v4, 4 * v5);
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 5))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 6);
    return mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x50uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *(_OWORD *)((char *)v3 + 60) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties]";
        v15 = 112;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[452];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::GRUGateLayoutAttr]";
  v41 = 78;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::RNNActivationAttr]";
  v41 = 78;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*a1 + 40))(*a1) < 6)
    return 1;
  else
    return mlir::DialectBytecodeReader::readSparseArray<int>(*a1, (_DWORD *)a1[1], (const char *)7);
}

uint64_t mlir::mps::GRUGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 48, 7);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 24));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 32));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 40));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 48), 7);
  return result;
}

void mlir::mps::GRUGradientOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, char a11, char a12, uint64_t a13, uint64_t a14, _BOOL8 a15)
{
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  uint64_t v22;
  __int128 v23;
  mlir::MLIRContext *v24;
  unsigned __int8 **AttributeUniquer;
  uint64_t v26;
  mlir::MLIRContext *v27;
  unsigned __int8 **v28;
  uint64_t v29;
  mlir::MLIRContext *v30;
  unsigned __int8 **v31;
  uint64_t v32;
  mlir::MLIRContext *v33;
  unsigned __int8 **v34;
  uint64_t v35;
  mlir::MLIRContext *v36;
  uint64_t UnitAttr;
  uint64_t v38;
  uint64_t v39;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v42;
  unint64_t *v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  _BOOL8 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  unint64_t v57[2];
  unint64_t v58[2];
  void *__src;
  uint64_t v60;
  _QWORD v61[4];

  v19 = a15;
  v61[2] = *MEMORY[0x1E0C80C00];
  v54 = a4;
  v55 = a3;
  v52 = a6;
  v53 = a5;
  v50 = a14;
  v51 = a13;
  v49 = a15;
  mlir::OperationState::addOperands(a2, (uint64_t)&v55, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v54, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v53, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v52, 1);
  if (a13)
    mlir::OperationState::addOperands(a2, (uint64_t)&v51, 1);
  if (a14)
    mlir::OperationState::addOperands(a2, (uint64_t)&v50, 1);
  if (a15)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v49, 1);
    v19 = v49;
  }
  v20 = v51 != 0;
  v21 = v50 != 0;
  v22 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)&v23 = 0x100000001;
  *((_QWORD *)&v23 + 1) = 0x100000001;
  *(_OWORD *)(v22 + 48) = v23;
  *(_DWORD *)(v22 + 64) = v20;
  *(_DWORD *)(v22 + 68) = v21;
  *(_DWORD *)(v22 + 72) = v19;
  v24 = *a1;
  v56 = a7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v24);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v24;
  v26 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v26;
  v27 = *a1;
  v56 = a8;
  v28 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v27);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v27;
  v29 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v28, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v29;
  v30 = *a1;
  v56 = a9;
  v31 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v30);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v30;
  v32 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v31, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v32;
  v33 = *a1;
  v56 = a10;
  v34 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v33);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v60 = (uint64_t)v33;
  v35 = mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v34, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v35;
  if (a11)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v36);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 24) = UnitAttr;
  }
  if (a12)
  {
    v38 = mlir::Builder::getUnitAttr(a1, v36);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v38;
  }
  __src = v61;
  v60 = 0x200000000;
  v39 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v58, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v42 = *(__int128 **)(a2 + 256);
  v43 = mlir::ValueRange::ValueRange(v57, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GRUGradientOp::inferReturnTypes((uint64_t)v43, v39, 1, v58[0], v58[1], Dictionary, v42, v44, v57[0], v57[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v45 = __src;
  v46 = v60;
  v47 = *(unsigned int *)(a2 + 72);
  v48 = v47 + v60;
  if (v48 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v48, 8);
    LODWORD(v47) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v46)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v47), v45, 8 * v46);
    LODWORD(v47) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v47 + v46;
  if (__src != v61)
    free(__src);
}

mlir::MLIRContext *mlir::mps::GRUGradientOp::populateDefaultProperties(uint64_t a1, _QWORD *a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  unsigned __int8 **AttributeUniquer;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  unsigned int v9;
  void *v10;
  mlir::MLIRContext *v11;

  v10 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  v4 = result;
  if (a2[5])
  {
    if (a2[4])
      goto LABEL_3;
  }
  else
  {
    v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v11 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[5] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2])
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  v9 = 3;
  v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v11 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1])
      return result;
LABEL_9:
    v9 = 0;
    v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    v11 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  v9 = 2;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v11 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1])
    goto LABEL_9;
  return result;
}

uint64_t mlir::mps::GRUGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t ODSOperands;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  unint64_t v50;
  unsigned int v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  unint64_t v60;
  unsigned int v61;
  uint64_t ODSResults;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t NextResultAtOffset;
  uint64_t *v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t *v76;
  unint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v92;
  const void **v93[4];
  __int16 v94;
  unsigned int v95;
  _QWORD v96[25];

  v96[24] = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  v5 = v3[1];
  v7 = v3[2];
  v6 = v3[3];
  v9 = v3[4];
  v8 = v3[5];
  v96[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v96[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v96[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v96[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v96[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v96[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v96))return 0;
  v95 = 0;
  v10 = *((unsigned int *)*this + 11);
  v11 = (uint64_t)&(*this)[2 * ((v10 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v11 = 0;
  v12 = *(unsigned int *)(v11 + 48);
  if ((v10 & 0x800000) != 0)
  {
    v13 = (*this)[9];
    if ((_DWORD)v12)
      goto LABEL_14;
  }
  else
  {
    v13 = 0;
    if ((_DWORD)v12)
    {
LABEL_14:
      v14 = v13 + 24;
      do
      {
        v15 = *this;
        v16 = *(_QWORD *)(*(_QWORD *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
        v17 = v95++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v15, v16, (const void **)"operand", (const void **)7, v17))return 0;
        v14 += 32;
      }
      while (--v12);
    }
  }
  ODSOperands = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 1u);
  if (v19)
  {
    v20 = v19;
    v21 = ODSOperands + 24;
    do
    {
      v22 = *this;
      v23 = *(_QWORD *)(*(_QWORD *)v21 + 8) & 0xFFFFFFFFFFFFFFF8;
      v24 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v22, v23, (const void **)"operand", (const void **)7, v24))return 0;
      v21 += 32;
    }
    while (--v20);
  }
  v25 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 2u);
  if (v26)
  {
    v27 = v26;
    v28 = v25 + 24;
    do
    {
      v29 = *this;
      v30 = *(_QWORD *)(*(_QWORD *)v28 + 8) & 0xFFFFFFFFFFFFFFF8;
      v31 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v29, v30, (const void **)"operand", (const void **)7, v31))return 0;
      v28 += 32;
    }
    while (--v27);
  }
  v32 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 3u);
  if (v33)
  {
    v34 = v33;
    v35 = v32 + 24;
    do
    {
      v36 = *this;
      v37 = *(_QWORD *)(*(_QWORD *)v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      v38 = v95++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38))return 0;
      v35 += 32;
    }
    while (--v34);
  }
  v39 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 4u);
  v41 = v40;
  if (v40 >= 2)
    goto LABEL_36;
  if (v40)
  {
    v42 = *(_QWORD *)(v39 + 24);
    v43 = *this;
    v44 = *(_QWORD *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8;
    v45 = v95++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v43, v44, (const void **)"operand", (const void **)7, v45))return 0;
  }
  v46 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 5u);
  v41 = v47;
  if (v47 < 2)
  {
    if (!v47
      || (v48 = *(_QWORD *)(v46 + 24),
          v49 = *this,
          v50 = *(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8,
          v51 = v95,
          ++v95,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (const void **)"operand", (const void **)7, v51)))
    {
      v52 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 6u);
      v41 = v53;
      if (v53 >= 2)
        goto LABEL_36;
      if (!v53
        || (v58 = *(_QWORD *)(v52 + 24),
            v59 = *this,
            v60 = *(_QWORD *)(v58 + 8) & 0xFFFFFFFFFFFFFFF8,
            v61 = v95,
            ++v95,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v59, v60, (const void **)"operand", (const void **)7, v61)))
      {
        v95 = 0;
        ODSResults = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 0);
        if (v63)
        {
          v64 = ODSResults;
          v65 = v63;
          v66 = 0;
          while (1)
          {
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v64, v66);
            v68 = *this;
            v69 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            v95 = v66 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v68, v69, (const void **)"result", (const void **)6, v66))break;
            if (v65 == ++v66)
              goto LABEL_46;
          }
        }
        else
        {
          LODWORD(v66) = 0;
LABEL_46:
          v70 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 1u);
          if (v71)
          {
            v72 = v70;
            v73 = v71;
            v74 = 0;
            while (1)
            {
              v75 = mlir::detail::OpResultImpl::getNextResultAtOffset(v72, v74);
              v76 = *this;
              v77 = *(_QWORD *)(v75 + 8) & 0xFFFFFFFFFFFFFFF8;
              v95 = v66 + v74 + 1;
              if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v76, v77, (const void **)"result", (const void **)6, (int)v66 + (int)v74))break;
              if (v73 == ++v74)
              {
                LODWORD(v66) = v66 + v74;
                goto LABEL_51;
              }
            }
          }
          else
          {
LABEL_51:
            v78 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 2u);
            if (v79)
            {
              v80 = v78;
              v81 = v79;
              v82 = 0;
              while (1)
              {
                v83 = mlir::detail::OpResultImpl::getNextResultAtOffset(v80, v82);
                v84 = *this;
                v85 = *(_QWORD *)(v83 + 8) & 0xFFFFFFFFFFFFFFF8;
                v95 = v66 + v82 + 1;
                if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v84, v85, (const void **)"result", (const void **)6, (int)v66 + (int)v82))break;
                if (v81 == ++v82)
                {
                  LODWORD(v66) = v66 + v82;
                  goto LABEL_56;
                }
              }
            }
            else
            {
LABEL_56:
              v86 = mlir::mps::GRUGradientOp::getODSResults((mlir::mps::GRUGradientOp *)this, 3u);
              v88 = v87;
              if (v87 >= 2)
              {
                v93[0] = (const void **)"result group starting at #";
                v94 = 259;
                mlir::OpState::emitOpError(this, v93, (uint64_t)v96);
                v89 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
                v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v89, " requires 0 or 1 element, but found ");
                v92 = v88;
                goto LABEL_37;
              }
              if (!v87)
                return 1;
              v90 = mlir::detail::OpResultImpl::getNextResultAtOffset(v86, 0);
              if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(v90 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v66))return 1;
            }
          }
        }
      }
    }
    return 0;
  }
LABEL_36:
  v93[0] = (const void **)"operand group starting at #";
  v94 = 259;
  mlir::OpState::emitOpError(this, v93, (uint64_t)v96);
  v54 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v96, &v95);
  v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v54, " requires 0 or 1 element, but found ");
  v92 = v41;
LABEL_37:
  v56 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v55, &v92);
  v57 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v56);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v96);
  return v57;
}

uint64_t mlir::mps::GRUOp::getODSResults(mlir::mps::GRUOp *this, unsigned int a2)
{
  int v2;
  unsigned int v3;
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  unsigned int v8;
  int32x4_t v9;
  int v10;
  uint64_t result;

  if (a2)
  {
    if (a2 >= 8)
    {
      v4 = (int32x4_t)xmmword_181235170;
      v3 = a2 & 0xFFFFFFF8;
      v5 = 0uLL;
      v6.i64[0] = 0x300000003;
      v6.i64[1] = 0x300000003;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      v8 = a2 & 0xFFFFFFF8;
      v9 = 0uLL;
      do
      {
        v5 = vsubq_s32(v5, vtstq_s32(v4, v4));
        v9 = vsubq_s32(v9, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32(v4, v6)));
        v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2)
        goto LABEL_11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
    }
    do
    {
      if (v3)
        ++v2;
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    v2 = 0;
  }
LABEL_11:
  v10 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v10)
    result = *(_QWORD *)this - 16;
  else
    result = 0;
  if (a2 + (v10 - 2) * v2)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 2) * v2);
  return result;
}

uint64_t mlir::mps::GRUOp::getODSOperands(mlir::mps::GRUOp *this, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  int32x4_t *v7;
  int32x4_t v8;
  uint64_t v9;
  int32x4_t v10;
  uint64_t v11;
  int *v12;
  int v13;

  v2 = *(unsigned int *)(*(_QWORD *)this + 44);
  if (HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v3 = *(_QWORD *)this + 16 * ((v2 >> 23) & 1) + 64;
  else
    v3 = 0;
  if (!a2)
  {
    v6 = 0;
    goto LABEL_14;
  }
  if (a2 >= 8)
  {
    v4 = a2 & 0xFFFFFFF8;
    v7 = (int32x4_t *)(v3 + 72);
    v8 = 0uLL;
    v9 = v4;
    v10 = 0uLL;
    do
    {
      v8 = vaddq_s32(v7[-1], v8);
      v10 = vaddq_s32(*v7, v10);
      v7 += 2;
      v9 -= 8;
    }
    while (v9);
    v5 = vaddvq_s32(vaddq_s32(v10, v8));
    if (v4 == a2)
      goto LABEL_13;
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  v11 = a2 - v4;
  v12 = (int *)(v3 + 4 * v4 + 56);
  do
  {
    v13 = *v12++;
    v5 += v13;
    --v11;
  }
  while (v11);
LABEL_13:
  v6 = v5;
LABEL_14:
  if ((v2 & 0x800000) != 0)
    return *(_QWORD *)(*(_QWORD *)this + 72) + 32 * v6;
  else
    return 32 * v6;
}

uint64_t mlir::mps::GRUOp::getTrainingState(mlir::mps::GRUOp *this)
{
  int v1;
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;

  v1 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v1)
    v2 = *(_QWORD *)this - 16;
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 1);
  v4 = 0;
  if (v1 != 1)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  return v4;
}

BOOL mlir::mps::GRUOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  _QWORD v75[3];
  void *v76;
  unsigned int v77;
  unsigned int v78;
  _BYTE v79[96];
  void *v80;
  _QWORD *v81;
  void *__p;
  _QWORD **v83;
  char v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v71 = v6;
  if (!v6)
  {
    a3(v75, a4);
    if (v75[0])
    {
      LODWORD(v72) = 3;
      v73 = "expected DictionaryAttr to set properties";
      v74 = 41;
      v26 = &v72;
      v27 = (char *)v76;
      if (v77 >= v78)
      {
        v61 = v77 + 1;
        if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
        {
          v66 = (char *)&v72 - (_BYTE *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          v27 = (char *)v76;
          v26 = (uint64_t *)((char *)v76 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          v26 = &v72;
          v27 = (char *)v76;
        }
      }
      v28 = &v27[24 * v77];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v77;
      if (v75[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
    }
    if (!v84)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v83;
      v32 = __p;
      if (v83 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v83 = v30;
      operator delete(v32);
    }
    v21 = v80;
    if (!v80)
      goto LABEL_64;
    v33 = v81;
    v23 = v80;
    if (v81 == v80)
    {
LABEL_63:
      v81 = v21;
      operator delete(v23);
LABEL_64:
      if (v76 != v79)
        free(v76);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v80;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v71, "flip_z", 6uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        v74 = 51;
        v10 = &v72;
        v11 = (char *)v76;
        if (v77 >= v78)
        {
          v62 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            v67 = (char *)&v72 - (_BYTE *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            v11 = (char *)v76;
            v10 = (uint64_t *)((char *)v76 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            v10 = &v72;
            v11 = (char *)v76;
          }
        }
        v12 = &v11[24 * v77];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v77;
        if (v75[0])
        {
          v14 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v9);
          v15 = (char *)v76;
          if (v77 >= v78)
          {
            v63 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              v68 = (char *)&v72 - (_BYTE *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              v15 = (char *)v76;
              v14 = (uint64_t *)((char *)v76 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              v14 = &v72;
              v15 = (char *)v76;
            }
          }
          v16 = &v15[24 * v77];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v77;
          if (v75[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
        }
      }
      if (!v84)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v83;
        v20 = __p;
        if (v83 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v83 = v18;
        operator delete(v20);
      }
      v21 = v80;
      if (!v80)
        goto LABEL_64;
      v22 = v81;
      v23 = v80;
      if (v81 == v80)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v71, "gate_layout", 0xBuLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        v74 = 56;
        v38 = &v72;
        v39 = (char *)v76;
        if (v77 >= v78)
        {
          v64 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            v69 = (char *)&v72 - (_BYTE *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v39 = (char *)v76;
            v38 = (uint64_t *)((char *)v76 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v38 = &v72;
            v39 = (char *)v76;
          }
        }
        v40 = &v39[24 * v77];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v77;
        if (v75[0])
        {
          v42 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v37);
          v43 = (char *)v76;
          if (v77 >= v78)
          {
            v65 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              v70 = (char *)&v72 - (_BYTE *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              v43 = (char *)v76;
              v42 = (uint64_t *)((char *)v76 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              v42 = &v72;
              v43 = (char *)v76;
            }
          }
          v44 = &v43[24 * v77];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v77;
          if (v75[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
        }
      }
      if (!v84)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v83;
        v48 = __p;
        if (v83 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v83 = v46;
        operator delete(v48);
      }
      v21 = v80;
      if (!v80)
        goto LABEL_64;
      v49 = v81;
      v23 = v80;
      if (v81 == v80)
        goto LABEL_63;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v71, "ogate_activation", 0x10uLL);
  v72 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
LABEL_86:
      v55 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, v53);
      goto LABEL_87;
    }
    a1[2] = v52;
  }
  v54 = mlir::DictionaryAttr::get((uint64_t)&v71, "reset_after", 0xBuLL);
  v72 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
LABEL_87:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v55, &v72);
LABEL_88:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v75);
      return 0;
    }
    a1[3] = v54;
  }
  v56 = mlir::DictionaryAttr::get((uint64_t)&v71, "rgate_activation", 0x10uLL);
  v72 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[4] = v56;
  }
  v57 = mlir::DictionaryAttr::get((uint64_t)&v71, "training", 8uLL);
  v72 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_87;
    }
    a1[5] = v57;
  }
  v58 = mlir::DictionaryAttr::get((uint64_t)&v71, "zgate_activation", 0x10uLL);
  v72 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[6] = v58;
  }
  v60 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v71, "operandSegmentSizes", 0x13uLL);
  if (!v60)
  {
    v60 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v71, "operand_segment_sizes", 0x15uLL);
    if (!v60)
    {
      a3(v75, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_88;
    }
  }
  return mlir::convertFromAttribute(a1 + 7, (const char *)5, v60, a3, a4) != 0;
}

uint64_t mlir::mps::GRUOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t *v50;
  BOOL v51;
  uint64_t v52;
  uint64_t DictionaryAttr;
  void *v54;
  mlir::DictionaryAttr *v56;
  void *v57;
  uint64_t v58;
  _QWORD v59[7];

  v59[6] = *MEMORY[0x1E0C80C00];
  v56 = a1;
  v57 = v59;
  v58 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v56, (uint64_t)"flip_z", 6, *a2);
    v6 = v5;
    v7 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v7 = v58;
    }
    v8 = (uint64_t *)((char *)v57 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v58) = v58 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"gate_layout", 11, v9);
    v12 = v11;
    v13 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v13 = v58;
    }
    v14 = (uint64_t *)((char *)v57 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v58) = v58 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"ogate_activation", 16, v15);
    v18 = v17;
    v19 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v19 = v58;
    }
    v20 = (uint64_t *)((char *)v57 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v58) = v58 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"reset_after", 11, v21);
    v24 = v23;
    v25 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v25 = v58;
    }
    v26 = (uint64_t *)((char *)v57 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    LODWORD(v58) = v58 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"rgate_activation", 16, v27);
    v30 = v29;
    v31 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v31 = v58;
    }
    v32 = (uint64_t *)((char *)v57 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    LODWORD(v58) = v58 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"training", 8, v33);
    v36 = v35;
    v37 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v37 = v58;
    }
    v38 = (uint64_t *)((char *)v57 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    LODWORD(v58) = v58 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"zgate_activation", 16, v39);
    v42 = v41;
    v43 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v43 = v58;
    }
    v44 = (uint64_t *)((char *)v57 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    LODWORD(v58) = v58 + 1;
  }
  v45 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
  v46 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"operandSegmentSizes", 19, v45);
  v48 = v47;
  v49 = v58;
  if (v58 >= HIDWORD(v58))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
    v49 = v58;
  }
  v50 = (uint64_t *)((char *)v57 + 16 * v49);
  *v50 = v46;
  v50[1] = v48;
  v51 = __CFADD__((_DWORD)v58, 1);
  v52 = (v58 + 1);
  LODWORD(v58) = v58 + 1;
  if (v51)
  {
    DictionaryAttr = 0;
    v54 = v57;
    if (v57 == v59)
      return DictionaryAttr;
    goto LABEL_36;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v56, (mlir::MLIRContext *)v57, v52);
  v54 = v57;
  if (v57 != v59)
LABEL_36:
    free(v54);
  return DictionaryAttr;
}

unint64_t mlir::mps::GRUOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v35;
  int v36;
  unint64_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  unint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  int v50;
  int v51;
  unint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  int v56;
  int v57;
  unint64_t v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t *v89;
  unint64_t *v90;
  unint64_t *v91;
  unint64_t *v92;
  unint64_t *v93;
  unint64_t *v94;
  unint64_t *v95;
  unint64_t *v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  __int128 v112;
  _OWORD v113[3];
  _OWORD v114[3];
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v89 = a1;
    v97 = *a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v35;
    a1 = v89;
    v1 = v97;
    if (v36)
    {
      v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v37 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      a1 = v89;
      v1 = v97;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = v3[19];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v90 = a1;
    v98 = v1;
    v73 = v3[19];
    v81 = a1[1];
    v4 = v73;
    v5 = v81;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v39 = v38;
    a1 = v90;
    v1 = v98;
    if (v39)
    {
      v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v40 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      v4 = v73;
      v5 = v81;
      a1 = v90;
      v1 = v98;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = v3[19];
  v8 = a1[2];
  if ((v9 & 1) == 0)
  {
    v91 = a1;
    v99 = v1;
    v74 = v4;
    v82 = v5;
    v61 = a1[2];
    v66 = v3[19];
    v8 = v61;
    v7 = v66;
    v4 = v74;
    v5 = v82;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v42 = v41;
    a1 = v91;
    v1 = v99;
    if (v42)
    {
      v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v43 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      v8 = v61;
      v7 = v66;
      v4 = v74;
      v5 = v82;
      a1 = v91;
      v1 = v99;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v8);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v8) ^ HIDWORD(v8));
  v111 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v92 = a1;
    v100 = v1;
    v75 = v4;
    v83 = v5;
    v62 = a1[3];
    v67 = v7;
    v12 = v62;
    v7 = v67;
    v4 = v75;
    v5 = v83;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v92;
    v1 = v100;
    if (v45)
    {
      v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v46 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      v12 = v62;
      v7 = v67;
      v4 = v75;
      v5 = v83;
      a1 = v92;
      v1 = v100;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v110 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v93 = a1;
    v101 = v1;
    v76 = v4;
    v84 = v5;
    v63 = a1[4];
    v68 = v7;
    v15 = v63;
    v7 = v68;
    v4 = v76;
    v5 = v84;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v48 = v47;
    a1 = v93;
    v1 = v101;
    if (v48)
    {
      v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v49 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      v15 = v63;
      v7 = v68;
      v4 = v76;
      v5 = v84;
      a1 = v93;
      v1 = v101;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v109 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v94 = a1;
    v102 = v1;
    v77 = v4;
    v85 = v5;
    v64 = a1[5];
    v69 = v7;
    v18 = v64;
    v7 = v69;
    v4 = v77;
    v5 = v85;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v51 = v50;
    a1 = v94;
    v1 = v102;
    if (v51)
    {
      v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v52 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      v18 = v64;
      v7 = v69;
      v4 = v77;
      v5 = v85;
      a1 = v94;
      v1 = v102;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v18) ^ HIDWORD(v18));
  v108 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  v21 = a1[6];
  if ((v19 & 1) == 0)
  {
    v95 = a1;
    v103 = v1;
    v78 = v4;
    v86 = v5;
    v65 = a1[6];
    v70 = v7;
    v21 = v65;
    v7 = v70;
    v4 = v78;
    v5 = v86;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    a1 = v95;
    v1 = v103;
    if (v54)
    {
      v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v55 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      v21 = v65;
      v7 = v70;
      v4 = v78;
      v5 = v86;
      a1 = v95;
      v1 = v103;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v22 = HIDWORD(v21);
  v23 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v21) ^ HIDWORD(v21));
  v107 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  if ((v22 & 1) == 0)
  {
    v96 = a1;
    v104 = v1;
    v79 = v4;
    v87 = v5;
    v71 = v7;
    v7 = v71;
    v4 = v79;
    v1 = v104;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v57 = v56;
    v5 = v87;
    a1 = v96;
    if (v57)
    {
      v58 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v58 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v58;
      v7 = v71;
      v4 = v79;
      v5 = v87;
      a1 = v96;
      v1 = v104;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v24 = v3[19];
  v25 = 0xB492B66FBE98F273 * a1[7];
  v26 = a1[8];
  v27 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 68);
  v28 = __ROR8__(v25 - v26, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 60)
      + __ROR8__(v27 ^ v24, 30);
  v29 = v24 + __ROR8__(v26 ^ 0xC949D7C7509E6557, 20) + v25 - v27 + 20;
  v106 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v29 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v29)))) ^ ((0x9DDFEA08EB382D69 * (v29 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v29)))) >> 47));
  v115 = 0;
  memset(v114, 0, sizeof(v114));
  memset(v113, 0, sizeof(v113));
  v112 = 0u;
  if ((v29 & 1) == 0)
  {
    v105 = v1;
    v80 = v4;
    v88 = v5;
    v72 = v7;
    v7 = v72;
    v4 = v80;
    v5 = v88;
    v1 = v105;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v59)
    {
      v60 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v60 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v60;
      v7 = v72;
      v4 = v80;
      v5 = v88;
      v1 = v105;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v30 = 0x9DDFEA08EB382D69 * ((v7 + 8 * v5) ^ HIDWORD(v5));
  v31 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ (v30 >> 47) ^ v30);
  v32 = HIDWORD(v1);
  v33 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v116 = v3[19];
  *(_QWORD *)&v112 = 0x9DDFEA08EB382D69
                   * ((0x9DDFEA08EB382D69 * (v32 ^ (v33 >> 47) ^ v33)) ^ ((0x9DDFEA08EB382D69
                                                                           * (v32 ^ (v33 >> 47) ^ v33)) >> 47));
  *((_QWORD *)&v112 + 1) = 0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)&v112, 0, v113, (char *)v114, (uint64_t *)&v111, (uint64_t *)&v110, (uint64_t *)&v109, (uint64_t *)&v108, (uint64_t *)&v107, (uint64_t *)&v106);
}

uint64_t mlir::mps::GRUOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, _WORD *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 != 1885957222 || __s1[2] != 31327)
        goto LABEL_18;
      return *a2;
    case 7uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0xFuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_18;
    case 8uLL:
      if (memcmp(__s1, "training", __n))
        goto LABEL_18;
      return a2[5];
    case 0xBuLL:
      if (!memcmp(__s1, "gate_layout", __n))
      {
        result = a2[1];
      }
      else
      {
        if (memcmp(__s1, "reset_after", __n))
          goto LABEL_18;
        result = a2[3];
      }
      break;
    case 0x10uLL:
      if (!memcmp(__s1, "ogate_activation", __n))
      {
        result = a2[2];
      }
      else if (!memcmp(__s1, "rgate_activation", __n))
      {
        result = a2[4];
      }
      else if (!memcmp(__s1, "zgate_activation", __n))
      {
        result = a2[6];
      }
      else
      {
LABEL_18:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_18;
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_18;
      return mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::GRUOp::setInherentAttr(uint64_t result, _WORD *__s1, size_t __n, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 6uLL:
      if (*(_DWORD *)__s1 == 1885957222 && __s1[2] == 31327)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v14 = a4;
          else
            v14 = 0;
          *(_QWORD *)result = v14;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 8uLL:
      result = memcmp(__s1, "training", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          v7[5] = v9;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      result = memcmp(__s1, "gate_layout", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "reset_after", __n);
        if (!(_DWORD)result)
        {
          if (a4)
          {
            if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
              v10 = a4;
            else
              v10 = 0;
            v7[3] = v10;
          }
          else
          {
            v7[3] = 0;
          }
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id)
          v15 = a4;
        else
          v15 = 0;
        v7[1] = v15;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "ogate_activation", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "rgate_activation", __n);
        if ((_DWORD)result)
        {
          result = memcmp(__s1, "zgate_activation", __n);
          if (!(_DWORD)result)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                v11 = a4;
              else
                v11 = 0;
              v7[6] = v11;
            }
            else
            {
              v7[6] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v17 = a4;
          else
            v17 = 0;
          v7[4] = v17;
        }
        else
        {
          v7[4] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
          v16 = a4;
        else
          v16 = 0;
        v7[2] = v16;
      }
      else
      {
        v7[2] = 0;
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!(_DWORD)result)
        goto LABEL_31;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!(_DWORD)result)
      {
LABEL_31:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v12 = (_DWORD)result ? a4 : 0;
          v18 = v12;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v18);
            if (result == 5)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v18);
              if (v13)
                result = (uint64_t)memmove(v7 + 7, (const void *)result, 4 * v13);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::GRUOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"flip_z", 6, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v7);
  v8 = a2[3];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"reset_after", 11, v8);
  v9 = a2[4];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"rgate_activation", 16, v9);
  v10 = a2[5];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v10);
  v11 = a2[6];
  if (v11)
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v11);
  v12 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 5);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v12);
}

BOOL mlir::mps::GRUOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"flip_z", (const char *)6, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v9, (const void **)"gate_layout", (const char *)0xB, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v11, (const void **)"reset_after", (const char *)0xB, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"rgate_activation", (const char *)0x10, a3, a4))
          {
            v13 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v13, (const void **)"training", (const char *)8, a3, a4))
            {
              v14 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v14, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::GRUOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v7[4];
  __int16 v8;
  uint64_t v9;
  _QWORD v10[25];

  v10[24] = *MEMORY[0x1E0C80C00];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::GRUGateLayoutAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 2))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 6)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      v8 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5)
      memmove(v3 + 7, v4, 4 * v5);
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 3)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 5)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 6))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 7);
    return mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x50uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    *(_OWORD *)((char *)v3 + 60) = 0u;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GRUOpGenericAdaptorBase::Properties]";
        v15 = 104;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[454];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::GRUOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*a1 + 40))(*a1) < 6)
    return 1;
  else
    return mlir::DialectBytecodeReader::readSparseArray<int>(*a1, (_DWORD *)a1[1], (const char *)5);
}

uint64_t mlir::mps::GRUOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 16));
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 56, 5);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 24));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 32));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 40));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 48));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 56), 5);
  return result;
}

BOOL mlir::mps::GRUOp::getTraining(mlir::mps::GRUOp *this)
{
  unint64_t v1;

  v1 = *(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64;
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v1 = 0;
  return *(_QWORD *)(v1 + 40) != 0;
}

void mlir::mps::GRUOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, char a9, char a10, unsigned __int8 a11, uint64_t a12, uint64_t a13, _BOOL8 a14)
{
  _BOOL4 v19;
  _BOOL4 v20;
  _BOOL4 v21;
  uint64_t v22;
  mlir::MLIRContext *v23;
  unsigned __int8 **AttributeUniquer;
  uint64_t v25;
  mlir::MLIRContext *v26;
  unsigned __int8 **v27;
  uint64_t v28;
  mlir::MLIRContext *v29;
  unsigned __int8 **v30;
  uint64_t v31;
  mlir::MLIRContext *v32;
  unsigned __int8 **v33;
  uint64_t v34;
  mlir::MLIRContext *v35;
  int v36;
  uint64_t v37;
  mlir::UnknownLoc *v38;
  mlir::MLIRContext *v39;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v42;
  int v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t UnitAttr;
  uint64_t v49;
  _BOOL8 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int v56;
  unint64_t v57[2];
  unint64_t v58[2];
  void *__src;
  uint64_t v60;
  _QWORD v61[4];

  v19 = a14;
  v61[2] = *MEMORY[0x1E0C80C00];
  v54 = a4;
  v55 = a3;
  v52 = a13;
  v53 = a12;
  v51 = a14;
  mlir::OperationState::addOperands(a2, (uint64_t)&v55, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v54, 1);
  if (a12)
    mlir::OperationState::addOperands(a2, (uint64_t)&v53, 1);
  if (a13)
    mlir::OperationState::addOperands(a2, (uint64_t)&v52, 1);
  if (a14)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v51, 1);
    v19 = v51;
  }
  v20 = v53 != 0;
  v21 = v52 != 0;
  v22 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)(v22 + 56) = 0x100000001;
  *(_DWORD *)(v22 + 64) = v20;
  *(_DWORD *)(v22 + 68) = v21;
  *(_DWORD *)(v22 + 72) = v19;
  v23 = *a1;
  v56 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v23);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v23;
  v25 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v25;
  v26 = *a1;
  v56 = a6;
  v27 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v26;
  v28 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v27, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v28;
  v29 = *a1;
  v56 = a7;
  v30 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v29);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v60 = (uint64_t)v29;
  v31 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v30, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v31;
  v32 = *a1;
  v56 = a8;
  v33 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v32);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
  v60 = (uint64_t)v32;
  v34 = mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v33, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v56);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v34;
  if (a9)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v35);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 40) = UnitAttr;
    v36 = a11;
    if (!a10)
    {
LABEL_9:
      if (!v36)
        goto LABEL_11;
      goto LABEL_10;
    }
  }
  else
  {
    v36 = a11;
    if (!a10)
      goto LABEL_9;
  }
  v49 = mlir::Builder::getUnitAttr(a1, v35);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v49;
  if (v36)
  {
LABEL_10:
    v37 = mlir::Builder::getUnitAttr(a1, v35);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GRUOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v37;
  }
LABEL_11:
  __src = v61;
  v60 = 0x200000000;
  v38 = *a1;
  v39 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v58, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v42 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v57, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GRUOp::inferReturnTypes(v38, v39, 1, v58[0], v58[1], Dictionary, v42, v43, v57[0], v57[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v44 = __src;
  v45 = v60;
  v46 = *(unsigned int *)(a2 + 72);
  v47 = v46 + v60;
  if (v47 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v47, 8);
    LODWORD(v46) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v45)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v46), v44, 8 * v45);
    LODWORD(v46) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v46 + v45;
  if (__src != v61)
    free(__src);
}

mlir::MLIRContext *mlir::mps::GRUOp::populateDefaultProperties(uint64_t a1, _QWORD *a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  unsigned __int8 **AttributeUniquer;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  unsigned int v9;
  void *v10;
  mlir::MLIRContext *v11;

  v10 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
  v4 = result;
  if (a2[6])
  {
    if (a2[4])
      goto LABEL_3;
  }
  else
  {
    v9 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v11 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
    a2[6] = result;
    if (a2[4])
    {
LABEL_3:
      if (a2[2])
        goto LABEL_4;
      goto LABEL_8;
    }
  }
  v9 = 3;
  v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v11 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[4] = result;
  if (a2[2])
  {
LABEL_4:
    if (a2[1])
      return result;
LABEL_9:
    v9 = 0;
    v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    v10 = &mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id;
    v11 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::GRUGateLayoutAttrStorage,mlir::mps::GRUGateLayout>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24GRUGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17GRUGateLayoutAttrEJNS2_13GRUGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGateLayoutAttr,void>::id, &v9);
    a2[1] = result;
    return result;
  }
LABEL_8:
  v9 = 2;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v10 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v11 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v10, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v9);
  a2[2] = result;
  if (!a2[1])
    goto LABEL_9;
  return result;
}

uint64_t mlir::mps::GRUOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t ODSOperands;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t *v46;
  unint64_t v47;
  unsigned int v48;
  uint64_t ODSResults;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t NextResultAtOffset;
  uint64_t *v55;
  unint64_t v56;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v63;
  const void **v64[4];
  __int16 v65;
  unsigned int v66;
  _QWORD v67[25];

  v67[24] = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  v5 = v3[1];
  v7 = v3[2];
  v6 = v3[3];
  v9 = v3[4];
  v8 = v3[5];
  v10 = v3[6];
  v67[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"rgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v7, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(v5, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps29(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"training", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"reset_after", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v67[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v4, (const void **)"flip_z", (const char *)6, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v67))return 0;
  v66 = 0;
  v11 = *((unsigned int *)*this + 11);
  v12 = (uint64_t)&(*this)[2 * ((v11 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v12 = 0;
  v13 = *(unsigned int *)(v12 + 56);
  if ((v11 & 0x800000) != 0)
  {
    v14 = (*this)[9];
    if ((_DWORD)v13)
      goto LABEL_15;
  }
  else
  {
    v14 = 0;
    if ((_DWORD)v13)
    {
LABEL_15:
      v15 = v14 + 24;
      do
      {
        v16 = *this;
        v17 = *(_QWORD *)(*(_QWORD *)v15 + 8) & 0xFFFFFFFFFFFFFFF8;
        v18 = v66++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v16, v17, (const void **)"operand", (const void **)7, v18))return 0;
        v15 += 32;
      }
      while (--v13);
    }
  }
  ODSOperands = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 1u);
  if (v20)
  {
    v21 = v20;
    v22 = ODSOperands + 24;
    do
    {
      v23 = *this;
      v24 = *(_QWORD *)(*(_QWORD *)v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      v25 = v66++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v23, v24, (const void **)"operand", (const void **)7, v25))return 0;
      v22 += 32;
    }
    while (--v21);
  }
  v26 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 2u);
  v28 = v27;
  if (v27 >= 2)
    goto LABEL_29;
  if (v27)
  {
    v29 = *(_QWORD *)(v26 + 24);
    v30 = *this;
    v31 = *(_QWORD *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
    v32 = v66++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v30, v31, (const void **)"operand", (const void **)7, v32))return 0;
  }
  v33 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 3u);
  v28 = v34;
  if (v34 < 2)
  {
    if (!v34
      || (v35 = *(_QWORD *)(v33 + 24),
          v36 = *this,
          v37 = *(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8,
          v38 = v66,
          ++v66,
          mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38)))
    {
      v39 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 4u);
      v28 = v40;
      if (v40 >= 2)
        goto LABEL_29;
      if (!v40
        || (v45 = *(_QWORD *)(v39 + 24),
            v46 = *this,
            v47 = *(_QWORD *)(v45 + 8) & 0xFFFFFFFFFFFFFFF8,
            v48 = v66,
            ++v66,
            mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v46, v47, (const void **)"operand", (const void **)7, v48)))
      {
        v66 = 0;
        ODSResults = mlir::mps::GRUOp::getODSResults((mlir::mps::GRUOp *)this, 0);
        if (v50)
        {
          v51 = ODSResults;
          v52 = v50;
          v53 = 0;
          while (1)
          {
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v51, v53);
            v55 = *this;
            v56 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
            v66 = v53 + 1;
            if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v55, v56, (const void **)"result", (const void **)6, v53))break;
            if (v52 == ++v53)
              goto LABEL_39;
          }
        }
        else
        {
          LODWORD(v53) = 0;
LABEL_39:
          v57 = mlir::mps::GRUOp::getODSResults((mlir::mps::GRUOp *)this, 1u);
          v59 = v58;
          if (v58 >= 2)
          {
            v64[0] = (const void **)"result group starting at #";
            v65 = 259;
            mlir::OpState::emitOpError(this, v64, (uint64_t)v67);
            v60 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
            v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v60, " requires 0 or 1 element, but found ");
            v63 = v59;
            goto LABEL_30;
          }
          if (!v58)
            return 1;
          v61 = mlir::detail::OpResultImpl::getNextResultAtOffset(v57, 0);
          if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(v61 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v53))return 1;
        }
      }
    }
    return 0;
  }
LABEL_29:
  v64[0] = (const void **)"operand group starting at #";
  v65 = 259;
  mlir::OpState::emitOpError(this, v64, (uint64_t)v67);
  v41 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v67, &v66);
  v42 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v41, " requires 0 or 1 element, but found ");
  v63 = v28;
LABEL_30:
  v43 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v42, &v63);
  v44 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v43);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v67);
  return v44;
}

uint64_t mlir::mps::GatherAlongAxisOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "allow_negative_indices", 0x16uLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 67;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::GatherAlongAxisOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"allow_negative_indices", 22, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties]";
        v15 = 116;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[456];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherAlongAxisOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v8;
  mlir::MLIRContext *Context;
  unint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24[2];
  void *__src;
  uint64_t v26;
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  v20 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  if (a6)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a6;
  __src = v27;
  v26 = 0x200000000;
  v8 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v24, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v10 = mlir::ValueRange::ValueRange(&v23, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherAlongAxisOp::inferReturnTypes((uint64_t)v10, v8, 1, v24[0], v24[1], v11, v12, v13, v18, v19, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v14 = __src;
  v15 = v26;
  v16 = *(unsigned int *)(a2 + 72);
  v17 = v16 + v26;
  if (v17 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v17, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v16), v14, 8 * v15);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v16 + v15;
  if (__src != v27)
    free(__src);
}

void mlir::mps::GatherAlongAxisOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6)
{
  mlir::MLIRContext *v9;
  uint64_t UnitAttr;
  uint64_t v11;
  mlir::MLIRContext *Context;
  unint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27[2];
  void *__src;
  uint64_t v29;
  _QWORD v30[3];

  v30[2] = *MEMORY[0x1E0C80C00];
  v24 = a4;
  v25 = a3;
  v23 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v9);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v30;
  v29 = 0x200000000;
  v11 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v27, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v13 = mlir::ValueRange::ValueRange(&v26, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherAlongAxisOp::inferReturnTypes((uint64_t)v13, v11, 1, v27[0], v27[1], v14, v15, v16, v21, v22, (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v17 = __src;
  v18 = v29;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v29;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v30)
    free(__src);
}

BOOL mlir::mps::GatherAlongAxisOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v3, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this,
                           (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8),
                           (const void **)"operand",
                           7,
                           2u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::GatherNDOpGenericAdaptorBase::GatherNDOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.gather_nd", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GatherNDOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  int *v52;
  char *v53;
  char *v54;
  __int128 v55;
  _QWORD **v56;
  _QWORD **v57;
  void *v58;
  _QWORD *v59;
  void *v60;
  void *v61;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  int64_t v69;
  int64_t v70;
  int64_t v71;
  int64_t v72;
  int64_t v73;
  int64_t v74;
  uint64_t v75;
  int v76;
  const char *v77;
  uint64_t v78;
  _QWORD v79[3];
  void *v80;
  unsigned int v81;
  unsigned int v82;
  _BYTE v83[96];
  void *v84;
  _QWORD *v85;
  void *__p;
  _QWORD **v87;
  char v88;
  uint64_t v89;

  v89 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v75 = v6;
  if (!v6)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected DictionaryAttr to set properties";
      v78 = 41;
      v26 = &v76;
      v27 = (char *)v80;
      if (v81 >= v82)
      {
        v63 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v69 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v27 = (char *)v80;
          v26 = (int *)((char *)v80 + v69);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v63, 24);
          v26 = &v76;
          v27 = (char *)v80;
        }
      }
      v28 = &v27[24 * v81];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v87;
      v32 = __p;
      if (v87 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v87 = v30;
      operator delete(v32);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v33 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_78;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v75, "allow_negative_indices", 0x16uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v79, a4);
      if (v79[0])
      {
        v76 = 3;
        v78 = 67;
        v10 = &v76;
        v11 = (char *)v80;
        if (v81 >= v82)
        {
          v64 = v81 + 1;
          if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
          {
            v70 = (char *)&v76 - (_BYTE *)v80;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v11 = (char *)v80;
            v10 = (int *)((char *)v80 + v70);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v64, 24);
            v10 = &v76;
            v11 = (char *)v80;
          }
        }
        v12 = &v11[24 * v81];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v81;
        if (v79[0])
        {
          v14 = &v76;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v9);
          v15 = (char *)v80;
          if (v81 >= v82)
          {
            v65 = v81 + 1;
            if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
            {
              v71 = (char *)&v76 - (_BYTE *)v80;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v15 = (char *)v80;
              v14 = (int *)((char *)v80 + v71);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v65, 24);
              v14 = &v76;
              v15 = (char *)v80;
            }
          }
          v16 = &v15[24 * v81];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v81;
          if (v79[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
        }
      }
      if (!v88)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v87;
        v20 = __p;
        if (v87 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v87 = v18;
        operator delete(v20);
      }
      v21 = v84;
      if (!v84)
        goto LABEL_80;
      v22 = v85;
      v23 = v84;
      if (v85 == v84)
        goto LABEL_79;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_78;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v75, "batch_dims", 0xAuLL);
  if (!v36)
  {
    a3(v79, a4);
    if (v79[0])
    {
      v76 = 3;
      v77 = "expected key entry for batch_dims in DictionaryAttr to set Properties.";
      v78 = 70;
      v52 = &v76;
      v53 = (char *)v80;
      if (v81 >= v82)
      {
        v67 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v73 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v53 = (char *)v80;
          v52 = (int *)((char *)v80 + v73);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v67, 24);
          v52 = &v76;
          v53 = (char *)v80;
        }
      }
      v54 = &v53[24 * v81];
      v55 = *(_OWORD *)v52;
      *((_QWORD *)v54 + 2) = *((_QWORD *)v52 + 2);
      *(_OWORD *)v54 = v55;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
    if (!v88)
      return 0;
    v56 = (_QWORD **)__p;
    if (__p)
    {
      v57 = v87;
      v58 = __p;
      if (v87 != __p)
      {
        do
          v57 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v57 - 1);
        while (v57 != v56);
        v58 = __p;
      }
      v87 = v56;
      operator delete(v58);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v59 = v85;
    v23 = v84;
    if (v85 == v84)
      goto LABEL_79;
    do
    {
      v61 = (void *)*--v59;
      v60 = v61;
      *v59 = 0;
      if (v61)
        operator delete[](v60);
    }
    while (v59 != v21);
    goto LABEL_78;
  }
  v37 = v36;
  if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
  {
    a1[1] = v36;
    return 1;
  }
  a3(v79, a4);
  if (v79[0])
  {
    v76 = 3;
    v78 = 55;
    v38 = &v76;
    v39 = (char *)v80;
    if (v81 >= v82)
    {
      v66 = v81 + 1;
      if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
      {
        v72 = (char *)&v76 - (_BYTE *)v80;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v39 = (char *)v80;
        v38 = (int *)((char *)v80 + v72);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v66, 24);
        v38 = &v76;
        v39 = (char *)v80;
      }
    }
    v40 = &v39[24 * v81];
    v41 = *(_OWORD *)v38;
    *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
    *(_OWORD *)v40 = v41;
    ++v81;
    if (v79[0])
    {
      v42 = &v76;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v76, v37);
      v43 = (char *)v80;
      if (v81 >= v82)
      {
        v68 = v81 + 1;
        if (v80 <= &v76 && (char *)v80 + 24 * v81 > (char *)&v76)
        {
          v74 = (char *)&v76 - (_BYTE *)v80;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v43 = (char *)v80;
          v42 = (int *)((char *)v80 + v74);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v80, v83, v68, 24);
          v42 = &v76;
          v43 = (char *)v80;
        }
      }
      v44 = &v43[24 * v81];
      v45 = *(_OWORD *)v42;
      *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
      *(_OWORD *)v44 = v45;
      ++v81;
      if (v79[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v79);
    }
  }
  if (v88)
  {
    v46 = (_QWORD **)__p;
    if (__p)
    {
      v47 = v87;
      v48 = __p;
      if (v87 != __p)
      {
        do
          v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
        while (v47 != v46);
        v48 = __p;
      }
      v87 = v46;
      operator delete(v48);
    }
    v21 = v84;
    if (!v84)
      goto LABEL_80;
    v49 = v85;
    v23 = v84;
    if (v85 == v84)
    {
LABEL_79:
      v85 = v21;
      operator delete(v23);
LABEL_80:
      if (v80 != v83)
        free(v80);
      return 0;
    }
    do
    {
      v51 = (void *)*--v49;
      v50 = v51;
      *v49 = 0;
      if (v51)
        operator delete[](v50);
    }
    while (v49 != v21);
LABEL_78:
    v23 = v84;
    goto LABEL_79;
  }
  return 0;
}

uint64_t mlir::mps::GatherNDOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"allow_negative_indices", 22, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"batch_dims", 10, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties]";
        v15 = 109;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[458];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherNDOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::UnknownLoc *v10;
  mlir::MLIRContext *v11;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22[2];
  unint64_t v23[2];
  void *__src;
  uint64_t v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  v20 = a4;
  v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a5;
  if (a6)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a6;
  __src = v26;
  v25 = 0x200000000;
  v10 = *a1;
  v11 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v14 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherNDOp::inferReturnTypes(v10, v11, 1, v23[0], v23[1], Dictionary, v14, v15, v22[0], v22[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v16 = __src;
  v17 = v25;
  v18 = *(unsigned int *)(a2 + 72);
  v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26)
    free(__src);
}

void mlir::mps::GatherNDOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v12;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v14;
  mlir::MLIRContext *v15;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v18;
  int v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[2];
  unint64_t v27[2];
  void *__src;
  uint64_t v29;
  _QWORD v30[3];

  v30[2] = *MEMORY[0x1E0C80C00];
  v24 = a4;
  v25 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v24, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a5);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = IntegerAttr;
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v12);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v30;
  v29 = 0x200000000;
  v14 = *(mlir::UnknownLoc **)a1;
  v15 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v27, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v18 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v26, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherNDOp::inferReturnTypes(v14, v15, 1, v27[0], v27[1], Dictionary, v18, v19, v26[0], v26[1], &__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v20 = __src;
  v21 = v29;
  v22 = *(unsigned int *)(a2 + 72);
  v23 = v22 + v29;
  if (v23 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v23, 8);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v21)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v22), v20, 8 * v21);
    LODWORD(v22) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v22 + v21;
  if (__src != v30)
    free(__src);
}

BOOL mlir::mps::GatherNDOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD **v9;
  _QWORD **v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  void *v15;
  void *v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD **v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (const void **)v3[1];
  if (v4)
  {
    v5 = *v3;
    v20[0] = v2;
    if (mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)&& (v20[0] = *this, mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(
                            *this,
                            *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8,
                            (const void **)"operand",
                            (const void **)7,
                            1u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'batch_dims'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v9 = (_QWORD **)__p;
      if (__p)
      {
        v10 = v26;
        v11 = __p;
        if (v26 != __p)
        {
          do
            v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          v11 = __p;
        }
        v26 = v9;
        operator delete(v11);
      }
      v12 = v23;
      if (v23)
      {
        v13 = v24;
        v14 = v23;
        if (v24 != v23)
        {
          do
          {
            v16 = (void *)*--v13;
            v15 = v16;
            *v13 = 0;
            if (v16)
              operator delete[](v15);
          }
          while (v13 != v12);
          v14 = v23;
        }
        v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

uint64_t mlir::mps::detail::GatherOpGenericAdaptorBase::GatherOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.gather", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::GatherOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[460];
    return a1[32];
  }
  return result;
}

void mlir::mps::GatherOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  mlir::UnknownLoc *v11;
  mlir::MLIRContext *v12;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v15;
  int v16;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24[2];
  unint64_t v25[2];
  void *__src;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v22 = a4;
  v23 = a3;
  v21 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a6;
  if (a7)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a7;
  __src = v28;
  v27 = 0x200000000;
  v11 = *a1;
  v12 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v25, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v15 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherOp::inferReturnTypes(v11, v12, 1, v25[0], v25[1], Dictionary, v15, v16, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v17 = __src;
  v18 = v27;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v27;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v28)
    free(__src);
}

void mlir::mps::GatherOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, unsigned int a6, int a7)
{
  uint64_t IntegerType;
  uint64_t IntegerAttr;
  mlir::MLIRContext *v13;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v15;
  mlir::MLIRContext *v16;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28[2];
  unint64_t v29[2];
  void *__src;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v26 = a4;
  v27 = a3;
  v25 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v27, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  IntegerType = mlir::Builder::getIntegerType(a1, 0x20u, 0);
  IntegerAttr = mlir::Builder::getIntegerAttr((uint64_t)a1, IntegerType, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = IntegerAttr;
  if (a7)
  {
    UnitAttr = mlir::Builder::getUnitAttr((mlir::UnitAttr **)a1, v13);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  __src = v32;
  v31 = 0x200000000;
  v15 = *(mlir::UnknownLoc **)a1;
  v16 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v19 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GatherOp::inferReturnTypes(v15, v16, 1, v29[0], v29[1], Dictionary, v19, v20, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v21 = __src;
  v22 = v31;
  v23 = *(unsigned int *)(a2 + 72);
  v24 = v23 + v31;
  if (v24 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v24, 8);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v22)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v23), v21, 8 * v22);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v23 + v22;
  if (__src != v32)
    free(__src);
}

BOOL mlir::mps::GatherOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  const void **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t v8;
  _QWORD **v9;
  _QWORD **v10;
  void *v11;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  void *v15;
  void *v16;
  const void **v18;
  __int16 v19;
  _QWORD v20[3];
  void *v21;
  uint64_t v22;
  void *v23;
  _QWORD *v24;
  void *__p;
  _QWORD **v26;
  char v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = (const void **)v3[1];
  if (v4)
  {
    v5 = *v3;
    v20[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v4, (const void **)"batch_dims", (const char *)0xA, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20))return 0;
    v20[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"allow_negative_indices", (const char *)0x16, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v20)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))
    {
      return 0;
    }
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps7(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))return 0;
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
    {
      if (*((_DWORD *)*this + 9))
        v6 = (uint64_t)(*this - 2);
      else
        v6 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v18 = (const void **)"requires attribute 'batch_dims'";
    v19 = 259;
    mlir::OpState::emitOpError(this, &v18, (uint64_t)v20);
    v8 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v20);
    if (v20[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v20);
    if (v27)
    {
      v9 = (_QWORD **)__p;
      if (__p)
      {
        v10 = v26;
        v11 = __p;
        if (v26 != __p)
        {
          do
            v10 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v10 - 1);
          while (v10 != v9);
          v11 = __p;
        }
        v26 = v9;
        operator delete(v11);
      }
      v12 = v23;
      if (v23)
      {
        v13 = v24;
        v14 = v23;
        if (v24 != v23)
        {
          do
          {
            v16 = (void *)*--v13;
            v15 = v16;
            *v13 = 0;
            if (v16)
              operator delete[](v15);
          }
          while (v13 != v12);
          v14 = v23;
        }
        v24 = v12;
        operator delete(v14);
      }
      if (v21 != &v22)
        free(v21);
    }
  }
  return v8;
}

uint64_t mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.gelu", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::GetCoordOpAdaptor::GetCoordOpAdaptor(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t Context;
  __int128 v13;
  __int128 v14;
  unint64_t v15[3];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  if ((*(_BYTE *)(a2 + 46) & 0x80) != 0)
  {
    v4 = *(_QWORD *)(a2 + 72);
    v5 = *(unsigned int *)(a2 + 68);
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  mlir::ValueRange::ValueRange((unint64_t *)&v14, v4, v5);
  v6 = *(_QWORD *)(a2 + 56);
  v7 = *(unsigned int *)(a2 + 44);
  v8 = (_QWORD *)(a2 + 16 * ((v7 >> 23) & 1) + 64);
  v9 = v7 & 0x7FFFFF;
  if ((v7 & 0x7FFFFF) != 0)
  {
    v10 = (((unint64_t)v8 + ((v7 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v10 = 0;
    v9 = 0;
  }
  v13 = v14;
  mlir::ValueRange::ValueRange(v15, v10, v9);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v6;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v8;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v15;
  if (v6)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.get_coordinates", 19, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  *(_OWORD *)(a1 + 48) = v13;
  return a1;
}

uint64_t mlir::mps::GetCoordOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "result_type", 0xBuLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 56;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::GetCoordOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"result_type", 11, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

void mlir::mps::GetCoordOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::mps::GetCoordOp::build(a1, a2, a3, a4, 0);
}

void mlir::mps::GetCoordOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21[2];
  _QWORD *v22[2];
  void *__src;
  uint64_t v24;
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  v19 = a4;
  v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  if (a5)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GetCoordOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a5;
  __src = v25;
  v24 = 0x200000000;
  v8 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v22, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v11 = *(_QWORD **)(a2 + 256);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::GetCoordOp::inferReturnTypes(v8, v12, v13, v22[0], (uint64_t)v22[1], Dictionary, v11, v14, v21[0], v21[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v15 = __src;
  v16 = v24;
  v17 = *(unsigned int *)(a2 + 72);
  v18 = v17 + v24;
  if (v18 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v16)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v15, 8 * v16);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v16;
  if (__src != v25)
    free(__src);
}

BOOL mlir::mps::GetCoordOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"result_type", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps2(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps24(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.greater", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.greater_equal", 17, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties]";
        v15 = 116;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[462];
    return a1[32];
  }
  return result;
}

void mlir::mps::HammingDistanceOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v8;
  mlir::UnknownLoc *v9;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  uint64_t *v12;
  mlir::MLIRContext *v13;
  int v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22[2];
  unint64_t v23[2];
  void *__src;
  uint64_t v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  v20 = a4;
  v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  v8 = mlir::TypeAttr::get(a5);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v8;
  __src = v26;
  v25 = 0x200000000;
  v9 = *a1;
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v12 = *(uint64_t **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::HammingDistanceOp::inferReturnTypes(v9, v13, v14, v23[0], v23[1], Dictionary, v12, v15, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v16 = __src;
  v17 = v25;
  v18 = *(unsigned int *)(a2 + 72);
  v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26)
    free(__src);
}

BOOL mlir::mps::HammingDistanceOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t v6;
  _QWORD **v7;
  _QWORD **v8;
  void *v9;
  _QWORD *v10;
  _QWORD *v11;
  void *v12;
  void *v13;
  void *v14;
  const void **v16;
  __int16 v17;
  _QWORD v18[3];
  void *v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  void *__p;
  _QWORD **v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v18[0] = v2;
    if (mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v3, (const void **)"resultElementType", (const char *)0x11, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps4(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v18)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
    {
      if (*((_DWORD *)*this + 9))
        v4 = (uint64_t)(*this - 2);
      else
        v4 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v16 = (const void **)"requires attribute 'resultElementType'";
    v17 = 259;
    mlir::OpState::emitOpError(this, &v16, (uint64_t)v18);
    v6 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v18);
    if (v18[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v18);
    if (v25)
    {
      v7 = (_QWORD **)__p;
      if (__p)
      {
        v8 = v24;
        v9 = __p;
        if (v24 != __p)
        {
          do
            v8 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v8 - 1);
          while (v8 != v7);
          v9 = __p;
        }
        v24 = v7;
        operator delete(v9);
      }
      v10 = v21;
      if (v21)
      {
        v11 = v22;
        v12 = v21;
        if (v22 != v21)
        {
          do
          {
            v14 = (void *)*--v11;
            v13 = v14;
            *v11 = 0;
            if (v14)
              operator delete[](v13);
          }
          while (v11 != v10);
          v12 = v21;
        }
        v22 = v10;
        operator delete(v12);
      }
      if (v19 != &v20)
        free(v19);
    }
  }
  return v6;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps27(uint64_t *a1, uint64_t a2, const void **a3, const void **a4, unsigned int a5)
{
  uint64_t v10;
  void *v11;
  uint64_t v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  uint64_t v18;
  int *v19;
  char *v20;
  char *v21;
  __int128 v22;
  uint64_t v23;
  int *v24;
  char *v25;
  char *v26;
  __int128 v27;
  int *v28;
  char *v29;
  char *v30;
  __int128 v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51[4];
  __int16 v52;
  int v53;
  const char *v54;
  uint64_t v55;
  _QWORD v56[3];
  void *v57;
  unsigned int v58;
  unsigned int v59;
  _BYTE v60[96];
  void *v61;
  _QWORD *v62;
  void *__p;
  _QWORD **v64;
  char v65;
  uint64_t v66;

  v66 = *MEMORY[0x1E0C80C00];
  v10 = *(_QWORD *)a2;
  v11 = *(void **)(*(_QWORD *)a2 + 136);
  if (v11 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v11 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v56[0] = a2;
    v56[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(v10 + 8);
    v51[0] = (const void **)mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v56);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)v51, 32))
      return 1;
  }
  v52 = 261;
  v51[0] = a3;
  v51[1] = a4;
  mlir::Operation::emitOpError(a1, v51, (uint64_t)v56);
  if (v56[0])
  {
    v53 = 3;
    v54 = " #";
    v55 = 2;
    v14 = &v53;
    v15 = (char *)v57;
    if (v58 >= v59)
    {
      v41 = v58 + 1;
      if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
      {
        v47 = (char *)&v53 - (_BYTE *)v57;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v15 = (char *)v57;
        v14 = (int *)((char *)v57 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v41, 24);
        v14 = &v53;
        v15 = (char *)v57;
      }
    }
    v16 = &v15[24 * v58];
    v17 = *(_OWORD *)v14;
    *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
    *(_OWORD *)v16 = v17;
    v18 = ++v58;
    if (v56[0])
    {
      v53 = 5;
      v54 = (const char *)a5;
      v19 = &v53;
      v20 = (char *)v57;
      if (v18 >= v59)
      {
        v42 = v18 + 1;
        v43 = (char *)v57 + 24 * v18 > (char *)&v53;
        if (v57 <= &v53 && v43)
        {
          v48 = (char *)&v53 - (_BYTE *)v57;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v20 = (char *)v57;
          v19 = (int *)((char *)v57 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v42, 24);
          v19 = &v53;
          v20 = (char *)v57;
        }
      }
      v21 = &v20[24 * v58];
      v22 = *(_OWORD *)v19;
      *((_QWORD *)v21 + 2) = *((_QWORD *)v19 + 2);
      *(_OWORD *)v21 = v22;
      v23 = ++v58;
      if (v56[0])
      {
        v53 = 3;
        v54 = " must be tensor of 32-bit unsigned integer values, but got ";
        v55 = 59;
        v24 = &v53;
        v25 = (char *)v57;
        if (v23 >= v59)
        {
          v44 = v23 + 1;
          v45 = (char *)v57 + 24 * v23 > (char *)&v53;
          if (v57 <= &v53 && v45)
          {
            v49 = (char *)&v53 - (_BYTE *)v57;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v25 = (char *)v57;
            v24 = (int *)((char *)v57 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v44, 24);
            v24 = &v53;
            v25 = (char *)v57;
          }
        }
        v26 = &v25[24 * v58];
        v27 = *(_OWORD *)v24;
        *((_QWORD *)v26 + 2) = *((_QWORD *)v24 + 2);
        *(_OWORD *)v26 = v27;
        ++v58;
        if (v56[0])
        {
          v28 = &v53;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v53, a2);
          v29 = (char *)v57;
          if (v58 >= v59)
          {
            v46 = v58 + 1;
            if (v57 <= &v53 && (char *)v57 + 24 * v58 > (char *)&v53)
            {
              v50 = (char *)&v53 - (_BYTE *)v57;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v29 = (char *)v57;
              v28 = (int *)((char *)v57 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v60, v46, 24);
              v28 = &v53;
              v29 = (char *)v57;
            }
          }
          v30 = &v29[24 * v58];
          v31 = *(_OWORD *)v28;
          *((_QWORD *)v30 + 2) = *((_QWORD *)v28 + 2);
          *(_OWORD *)v30 = v31;
          ++v58;
        }
      }
    }
  }
  v13 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v56);
  if (v56[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v56);
  if (v65)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v64;
      v34 = __p;
      if (v64 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v64 = v32;
      operator delete(v34);
    }
    v35 = v61;
    if (v61)
    {
      v36 = v62;
      v37 = v61;
      if (v62 != v61)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v61;
      }
      v62 = v35;
      operator delete(v37);
    }
    if (v57 != v60)
      free(v57);
  }
  return v13;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  int *v38;
  char *v39;
  char *v40;
  __int128 v41;
  int *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  int *v54;
  char *v55;
  char *v56;
  __int128 v57;
  int *v58;
  char *v59;
  char *v60;
  __int128 v61;
  _QWORD **v62;
  _QWORD **v63;
  void *v64;
  _QWORD *v65;
  void *v66;
  void *v67;
  int *v68;
  char *v69;
  char *v70;
  __int128 v71;
  _QWORD **v72;
  _QWORD **v73;
  void *v74;
  _QWORD *v75;
  void *v76;
  void *v77;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  int64_t v87;
  int64_t v88;
  int64_t v89;
  int64_t v90;
  int64_t v91;
  int64_t v92;
  int64_t v93;
  int64_t v94;
  uint64_t v95;
  int v96;
  const char *v97;
  uint64_t v98;
  _QWORD v99[3];
  void *v100;
  unsigned int v101;
  unsigned int v102;
  _BYTE v103[96];
  void *v104;
  _QWORD *v105;
  void *__p;
  _QWORD **v107;
  char v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v95 = v6;
  if (!v6)
  {
    a3(v99, a4);
    if (v99[0])
    {
      v96 = 3;
      v97 = "expected DictionaryAttr to set properties";
      v98 = 41;
      v26 = &v96;
      v27 = (char *)v100;
      if (v101 >= v102)
      {
        v79 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          v87 = (char *)&v96 - (_BYTE *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          v27 = (char *)v100;
          v26 = (int *)((char *)v100 + v87);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v79, 24);
          v26 = &v96;
          v27 = (char *)v100;
        }
      }
      v28 = &v27[24 * v101];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v101;
      if (v99[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
    }
    if (!v108)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v107;
      v32 = __p;
      if (v107 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v107 = v30;
      operator delete(v32);
    }
    v21 = v104;
    if (!v104)
      goto LABEL_101;
    v33 = v105;
    v23 = v104;
    if (v105 == v104)
      goto LABEL_100;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_99;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v95, "inverse", 7uLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        v96 = 3;
        v98 = 52;
        v10 = &v96;
        v11 = (char *)v100;
        if (v101 >= v102)
        {
          v80 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            v88 = (char *)&v96 - (_BYTE *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            v11 = (char *)v100;
            v10 = (int *)((char *)v100 + v88);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v80, 24);
            v10 = &v96;
            v11 = (char *)v100;
          }
        }
        v12 = &v11[24 * v101];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
        *(_OWORD *)v12 = v13;
        ++v101;
        if (v99[0])
        {
          v14 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v9);
          v15 = (char *)v100;
          if (v101 >= v102)
          {
            v81 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              v89 = (char *)&v96 - (_BYTE *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              v15 = (char *)v100;
              v14 = (int *)((char *)v100 + v89);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v81, 24);
              v14 = &v96;
              v15 = (char *)v100;
            }
          }
          v16 = &v15[24 * v101];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
          *(_OWORD *)v16 = v17;
          ++v101;
          if (v99[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
        }
      }
      if (!v108)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v107;
        v20 = __p;
        if (v107 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v107 = v18;
        operator delete(v20);
      }
      v21 = v104;
      if (!v104)
        goto LABEL_101;
      v22 = v105;
      v23 = v104;
      if (v105 == v104)
        goto LABEL_100;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_99;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v95, "round_to_odd", 0xCuLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v99, a4);
      if (v99[0])
      {
        v96 = 3;
        v98 = 57;
        v38 = &v96;
        v39 = (char *)v100;
        if (v101 >= v102)
        {
          v82 = v101 + 1;
          if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
          {
            v90 = (char *)&v96 - (_BYTE *)v100;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            v39 = (char *)v100;
            v38 = (int *)((char *)v100 + v90);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v82, 24);
            v38 = &v96;
            v39 = (char *)v100;
          }
        }
        v40 = &v39[24 * v101];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = *((_QWORD *)v38 + 2);
        *(_OWORD *)v40 = v41;
        ++v101;
        if (v99[0])
        {
          v42 = &v96;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v37);
          v43 = (char *)v100;
          if (v101 >= v102)
          {
            v83 = v101 + 1;
            if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
            {
              v91 = (char *)&v96 - (_BYTE *)v100;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              v43 = (char *)v100;
              v42 = (int *)((char *)v100 + v91);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v83, 24);
              v42 = &v96;
              v43 = (char *)v100;
            }
          }
          v44 = &v43[24 * v101];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = *((_QWORD *)v42 + 2);
          *(_OWORD *)v44 = v45;
          ++v101;
          if (v99[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
        }
      }
      if (!v108)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v107;
        v48 = __p;
        if (v107 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v107 = v46;
        operator delete(v48);
      }
      v21 = v104;
      if (!v104)
        goto LABEL_101;
      v49 = v105;
      v23 = v104;
      if (v105 == v104)
        goto LABEL_100;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_99;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v95, "scaling_mode", 0xCuLL);
  if (!v52)
  {
    a3(v99, a4);
    if (v99[0])
    {
      v96 = 3;
      v97 = "expected key entry for scaling_mode in DictionaryAttr to set Properties.";
      v98 = 72;
      v68 = &v96;
      v69 = (char *)v100;
      if (v101 >= v102)
      {
        v85 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          v93 = (char *)&v96 - (_BYTE *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          v69 = (char *)v100;
          v68 = (int *)((char *)v100 + v93);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v85, 24);
          v68 = &v96;
          v69 = (char *)v100;
        }
      }
      v70 = &v69[24 * v101];
      v71 = *(_OWORD *)v68;
      *((_QWORD *)v70 + 2) = *((_QWORD *)v68 + 2);
      *(_OWORD *)v70 = v71;
      ++v101;
      if (v99[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
    }
    if (!v108)
      return 0;
    v72 = (_QWORD **)__p;
    if (__p)
    {
      v73 = v107;
      v74 = __p;
      if (v107 != __p)
      {
        do
          v73 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v73 - 1);
        while (v73 != v72);
        v74 = __p;
      }
      v107 = v72;
      operator delete(v74);
    }
    v21 = v104;
    if (!v104)
      goto LABEL_101;
    v75 = v105;
    v23 = v104;
    if (v105 == v104)
      goto LABEL_100;
    do
    {
      v77 = (void *)*--v75;
      v76 = v77;
      *v75 = 0;
      if (v77)
        operator delete[](v76);
    }
    while (v75 != v21);
    goto LABEL_99;
  }
  v53 = v52;
  if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
  {
    a1[2] = v52;
    return 1;
  }
  a3(v99, a4);
  if (v99[0])
  {
    v96 = 3;
    v98 = 57;
    v54 = &v96;
    v55 = (char *)v100;
    if (v101 >= v102)
    {
      v84 = v101 + 1;
      if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
      {
        v92 = (char *)&v96 - (_BYTE *)v100;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        v55 = (char *)v100;
        v54 = (int *)((char *)v100 + v92);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v84, 24);
        v54 = &v96;
        v55 = (char *)v100;
      }
    }
    v56 = &v55[24 * v101];
    v57 = *(_OWORD *)v54;
    *((_QWORD *)v56 + 2) = *((_QWORD *)v54 + 2);
    *(_OWORD *)v56 = v57;
    ++v101;
    if (v99[0])
    {
      v58 = &v96;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v96, v53);
      v59 = (char *)v100;
      if (v101 >= v102)
      {
        v86 = v101 + 1;
        if (v100 <= &v96 && (char *)v100 + 24 * v101 > (char *)&v96)
        {
          v94 = (char *)&v96 - (_BYTE *)v100;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          v59 = (char *)v100;
          v58 = (int *)((char *)v100 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v100, v103, v86, 24);
          v58 = &v96;
          v59 = (char *)v100;
        }
      }
      v60 = &v59[24 * v101];
      v61 = *(_OWORD *)v58;
      *((_QWORD *)v60 + 2) = *((_QWORD *)v58 + 2);
      *(_OWORD *)v60 = v61;
      ++v101;
      if (v99[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v99);
    }
  }
  if (v108)
  {
    v62 = (_QWORD **)__p;
    if (__p)
    {
      v63 = v107;
      v64 = __p;
      if (v107 != __p)
      {
        do
          v63 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v63 - 1);
        while (v63 != v62);
        v64 = __p;
      }
      v107 = v62;
      operator delete(v64);
    }
    v21 = v104;
    if (!v104)
      goto LABEL_101;
    v65 = v105;
    v23 = v104;
    if (v105 == v104)
    {
LABEL_100:
      v105 = v21;
      operator delete(v23);
LABEL_101:
      if (v100 != v103)
        free(v100);
      return 0;
    }
    do
    {
      v67 = (void *)*--v65;
      v66 = v67;
      *v65 = 0;
      if (v67)
        operator delete[](v66);
    }
    while (v65 != v21);
LABEL_99:
    v23 = v104;
    goto LABEL_100;
  }
  return 0;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  void *v21;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[7];

  v27[6] = *MEMORY[0x1E0C80C00];
  v24 = a1;
  v25 = v27;
  v26 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"inverse", 7, *a2);
  v5 = v4;
  v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    v6 = v26;
  }
  v7 = (uint64_t *)((char *)v25 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"round_to_odd", 12, v9);
    v12 = v11;
    v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v13 = v26;
    }
    v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"scaling_mode", 12, v15);
    v18 = v17;
    v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v19 = v26;
    }
    v20 = (uint64_t *)((char *)v25 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  v21 = v25;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v25 == v27)
      return DictionaryAttr;
    goto LABEL_16;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (mlir::MLIRContext *)v25, v8);
  v21 = v25;
  if (v25 != v27)
LABEL_16:
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::HermiteanToRealFFTOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v6 = result;
  if (a3 == 12)
  {
    result = memcmp(__s1, "round_to_odd", 0xCuLL);
    if ((_DWORD)result)
    {
      if (*(_QWORD *)__s1 == 0x5F676E696C616373 && *((_DWORD *)__s1 + 2) == 1701080941)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          *(_QWORD *)(v6 + 16) = v9;
        }
        else
        {
          *(_QWORD *)(v6 + 16) = 0;
        }
      }
    }
    else if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *(_QWORD *)(v6 + 8) = v11;
    }
    else
    {
      *(_QWORD *)(v6 + 8) = 0;
    }
  }
  else if (a3 == 7 && *(_DWORD *)__s1 == 1702260329 && *(_DWORD *)(__s1 + 3) == 1702064741)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v10 = a4;
      else
        v10 = 0;
      *(_QWORD *)result = v10;
    }
    else
    {
      *(_QWORD *)result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"inverse", (const char *)7, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"round_to_odd", (const char *)0xC, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v10, (const void **)"scaling_mode", (const char *)0xC, a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x18uLL);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties]";
        v15 = 119;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[464];
    return a1[32];
  }
  return result;
}

void mlir::mps::HermiteanToRealFFTOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, int a6, int a7)
{
  mlir::MLIRContext *v12;
  unsigned __int8 **AttributeUniquer;
  uint64_t v14;
  mlir::MLIRContext *v15;
  uint64_t UnitAttr;
  uint64_t v17;
  mlir::UnknownLoc *v18;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v21;
  mlir::MLIRContext *v22;
  int v23;
  int v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unint64_t v32[2];
  unint64_t v33[2];
  void *__src;
  uint64_t v35;
  _QWORD v36[3];

  v36[2] = *MEMORY[0x1E0C80C00];
  v29 = a4;
  v30 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v30, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  v12 = *a1;
  v31 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v12);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id;
  v35 = (uint64_t)v12;
  v14 = mlir::StorageUniquer::get<mlir::mps::detail::FFTScalingModeAttrStorage,mlir::mps::FFTScalingMode>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25FFTScalingModeAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18FFTScalingModeAttrEJNS2_14FFTScalingModeEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id, &v31);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v14;
  if (a6)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v15);
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((_QWORD *)a2) = UnitAttr;
  }
  if (a7)
  {
    v17 = mlir::Builder::getUnitAttr(a1, v15);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = v17;
  }
  __src = v36;
  v35 = 0x200000000;
  v18 = *a1;
  mlir::ValueRange::ValueRange(v33, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v21 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v32, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(v18, v22, v23, v33[0], v33[1], Dictionary, v21, v24, v32[0], v32[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v25 = __src;
  v26 = v35;
  v27 = *(unsigned int *)(a2 + 72);
  v28 = v27 + v35;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v26)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v36)
    free(__src);
}

BOOL mlir::mps::HermiteanToRealFFTOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t NextResultAtOffset;
  uint64_t v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  const void **v19;
  __int16 v20;
  _QWORD v21[3];
  void *v22;
  uint64_t v23;
  void *v24;
  _QWORD *v25;
  void *__p;
  _QWORD **v27;
  char v28;
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = v3[2];
  if (v4)
  {
    v6 = *v3;
    v5 = v3[1];
    v21[0] = v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v4, (const void **)"scaling_mode", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0;
    v21[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v6, (const void **)"inverse", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0;
    v21[0] = *this;
    if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v5, (const void **)"round_to_odd", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v21))return 0;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps19(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
    if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
    {
      if (*((_DWORD *)*this + 9))
        v7 = (uint64_t)(*this - 2);
      else
        v7 = 0;
      NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
      return mlir::mps::__mlir_ods_local_type_constraint_MPSOps5(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v19 = (const void **)"requires attribute 'scaling_mode'";
    v20 = 259;
    mlir::OpState::emitOpError(this, &v19, (uint64_t)v21);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v21);
    if (v21[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v21);
    if (v28)
    {
      v10 = (_QWORD **)__p;
      if (__p)
      {
        v11 = v27;
        v12 = __p;
        if (v27 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v27 = v10;
        operator delete(v12);
      }
      v13 = v24;
      if (v24)
      {
        v14 = v25;
        v15 = v24;
        if (v25 != v24)
        {
          do
          {
            v17 = (void *)*--v14;
            v16 = v17;
            *v14 = 0;
            if (v17)
              operator delete[](v16);
          }
          while (v14 != v13);
          v15 = v24;
        }
        v25 = v13;
        operator delete(v15);
      }
      if (v22 != &v23)
        free(v22);
    }
  }
  return v9;
}

uint64_t mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.identity", 12, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::ImToColOp::getInherentAttr(int a1, _QWORD *a2, char *__s1, size_t __n)
{
  switch(__n)
  {
    case 7uLL:
      if (memcmp(__s1, "strides", __n))
        return 0;
      return a2[4];
    case 8uLL:
    case 9uLL:
    case 0xAuLL:
    case 0xDuLL:
    case 0xFuLL:
      return 0;
    case 0xBuLL:
      if (*(_QWORD *)__s1 != 0x79616C5F61746164 || *(_QWORD *)(__s1 + 3) != 0x74756F79616C5F61)
        return 0;
      return *a2;
    case 0xCuLL:
      if (memcmp(__s1, "kernel_sizes", __n))
        return 0;
      return a2[3];
    case 0xEuLL:
      if (memcmp(__s1, "dilation_rates", __n))
        return 0;
      return a2[1];
    case 0x10uLL:
      if (memcmp(__s1, "explicit_padding", __n))
        return 0;
      return a2[2];
    default:
      return 0;
  }
}

uint64_t mlir::mps::ImToColOp::setInherentAttr(uint64_t result, char *__s1, size_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = (_QWORD *)result;
  switch(a3)
  {
    case 7uLL:
      result = memcmp(__s1, "strides", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v11 = a4;
          else
            v11 = 0;
          v5[4] = v11;
        }
        else
        {
          v5[4] = 0;
        }
      }
      break;
    case 0xBuLL:
      if (*(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
            v7 = a4;
          else
            v7 = 0;
          *(_QWORD *)result = v7;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0xCuLL:
      result = memcmp(__s1, "kernel_sizes", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v8 = a4;
          else
            v8 = 0;
          v5[3] = v8;
        }
        else
        {
          v5[3] = 0;
        }
      }
      break;
    case 0xEuLL:
      result = memcmp(__s1, "dilation_rates", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v9 = a4;
          else
            v9 = 0;
          v5[1] = v9;
        }
        else
        {
          v5[1] = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "explicit_padding", a3);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          result = mlir::DenseIntElementsAttr::classof(a4);
          if ((_DWORD)result)
            v10 = a4;
          else
            v10 = 0;
          v5[2] = v10;
        }
        else
        {
          v5[2] = 0;
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x28uLL);
    *v3 = 0u;
    v3[1] = 0u;
    *((_QWORD *)v3 + 4) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties]";
        v15 = 108;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[466];
    return a1[32];
  }
  return result;
}

void mlir::mps::ImToColOp::build(mlir::Builder *a1, uint64_t a2, uint64_t a3, __int128 *a4, uint64_t a5, __int128 *a6, uint64_t a7, uint64_t a8, __int128 *a9, uint64_t a10, uint64_t *a11, uint64_t a12, unsigned int a13)
{
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t FormattedPaddingImToCol;

  v16 = mlir::mps::get2DElementsForImToCol(a1, a4);
  v17 = mlir::mps::get2DElementsForImToCol(a1, a6);
  v18 = mlir::mps::get2DElementsForImToCol(a1, a9);
  FormattedPaddingImToCol = mlir::mps::getFormattedPaddingImToCol(a1, a11, a12, a13);
  mlir::mps::ImToColOp::build((mlir::MLIRContext **)a1, a2, a3, v16, v17, v18, FormattedPaddingImToCol, a13);
}

void mlir::mps::ImToColOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  mlir::MLIRContext *v15;
  unsigned __int8 **AttributeUniquer;
  uint64_t v17;
  mlir::UnknownLoc *v18;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v21;
  mlir::MLIRContext *v22;
  int v23;
  int v24;
  void *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unint64_t v31[2];
  unint64_t v32[2];
  void *__src;
  uint64_t v34;
  _QWORD v35[3];

  v35[2] = *MEMORY[0x1E0C80C00];
  v29 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v29, 1);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = a4;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = a5;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a7;
  v15 = *a1;
  v30 = a8;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v15);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v34 = (uint64_t)v15;
  v17 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v30);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v17;
  __src = v35;
  v34 = 0x200000000;
  v18 = *a1;
  mlir::ValueRange::ValueRange(v32, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v21 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v31, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ImToColOp::inferReturnTypes(v18, v22, v23, v32[0], v32[1], Dictionary, v21, v24, v31[0], v31[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v25 = __src;
  v26 = v34;
  v27 = *(unsigned int *)(a2 + 72);
  v28 = v27 + v34;
  if (v28 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v28, 8);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v26)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v27), v25, 8 * v26);
    LODWORD(v27) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v27 + v26;
  if (__src != v35)
    free(__src);
}

BOOL mlir::mps::ImToColOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _DWORD *v4;
  _QWORD *v5;
  const void **v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t NextResultAtOffset;
  uint64_t v11;
  _QWORD **v12;
  _QWORD **v13;
  void *v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  void *v19;
  _QWORD **v20;
  _QWORD **v21;
  void *v22;
  _QWORD *v23;
  void *v24;
  void *v25;
  _QWORD **v26;
  _QWORD **v27;
  void *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  void *v36;
  void *v37;
  _QWORD **v38;
  _QWORD **v39;
  void *v40;
  _QWORD *v41;
  void *v42;
  void *v43;
  const void **v45[4];
  __int16 v46;
  _QWORD v47[3];
  void *v48;
  uint64_t v49;
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_DWORD **)v3;
  if (*(_QWORD *)v3)
  {
    v5 = *(_QWORD **)(v3 + 8);
    if (v5)
    {
      v6 = *(const void ***)(v3 + 16);
      if (v6)
      {
        v7 = *(_QWORD **)(v3 + 24);
        if (v7)
        {
          v8 = *(_QWORD **)(v3 + 32);
          if (v8)
          {
            v47[0] = v2;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v7, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v8, (const void **)"strides", (const char *)7, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(const void ***__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps5(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(v6, (const void **)"explicit_padding", (const char *)0x10, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps6(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47))return 0;
            v47[0] = *this;
            if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps7(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v47)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps10(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0))
            {
              return 0;
            }
            if (*((_DWORD *)*this + 9))
              v9 = (uint64_t)(*this - 2);
            else
              v9 = 0;
            NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v9, 0);
            return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
          }
          v45[0] = (const void **)"requires attribute 'strides'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v38 = (_QWORD **)__p;
            if (__p)
            {
              v39 = v53;
              v40 = __p;
              if (v53 != __p)
              {
                do
                  v39 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v39 - 1);
                while (v39 != v38);
                v40 = __p;
              }
              v53 = v38;
              operator delete(v40);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_92;
            v41 = v51;
            v17 = v50;
            if (v51 == v50)
            {
LABEL_91:
              v51 = v15;
              operator delete(v17);
LABEL_92:
              if (v48 != &v49)
                free(v48);
              return v11;
            }
            do
            {
              v43 = (void *)*--v41;
              v42 = v43;
              *v41 = 0;
              if (v43)
                operator delete[](v42);
            }
            while (v41 != v15);
LABEL_90:
            v17 = v50;
            goto LABEL_91;
          }
        }
        else
        {
          v45[0] = (const void **)"requires attribute 'kernel_sizes'";
          v46 = 259;
          mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
          v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
          if (v47[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
          if (v54)
          {
            v32 = (_QWORD **)__p;
            if (__p)
            {
              v33 = v53;
              v34 = __p;
              if (v53 != __p)
              {
                do
                  v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
                while (v33 != v32);
                v34 = __p;
              }
              v53 = v32;
              operator delete(v34);
            }
            v15 = v50;
            if (!v50)
              goto LABEL_92;
            v35 = v51;
            v17 = v50;
            if (v51 == v50)
              goto LABEL_91;
            do
            {
              v37 = (void *)*--v35;
              v36 = v37;
              *v35 = 0;
              if (v37)
                operator delete[](v36);
            }
            while (v35 != v15);
            goto LABEL_90;
          }
        }
      }
      else
      {
        v45[0] = (const void **)"requires attribute 'explicit_padding'";
        v46 = 259;
        mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
        v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
        if (v47[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
        if (v54)
        {
          v26 = (_QWORD **)__p;
          if (__p)
          {
            v27 = v53;
            v28 = __p;
            if (v53 != __p)
            {
              do
                v27 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v27 - 1);
              while (v27 != v26);
              v28 = __p;
            }
            v53 = v26;
            operator delete(v28);
          }
          v15 = v50;
          if (!v50)
            goto LABEL_92;
          v29 = v51;
          v17 = v50;
          if (v51 == v50)
            goto LABEL_91;
          do
          {
            v31 = (void *)*--v29;
            v30 = v31;
            *v29 = 0;
            if (v31)
              operator delete[](v30);
          }
          while (v29 != v15);
          goto LABEL_90;
        }
      }
    }
    else
    {
      v45[0] = (const void **)"requires attribute 'dilation_rates'";
      v46 = 259;
      mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
      v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
      if (v54)
      {
        v20 = (_QWORD **)__p;
        if (__p)
        {
          v21 = v53;
          v22 = __p;
          if (v53 != __p)
          {
            do
              v21 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v21 - 1);
            while (v21 != v20);
            v22 = __p;
          }
          v53 = v20;
          operator delete(v22);
        }
        v15 = v50;
        if (!v50)
          goto LABEL_92;
        v23 = v51;
        v17 = v50;
        if (v51 == v50)
          goto LABEL_91;
        do
        {
          v25 = (void *)*--v23;
          v24 = v25;
          *v23 = 0;
          if (v25)
            operator delete[](v24);
        }
        while (v23 != v15);
        goto LABEL_90;
      }
    }
  }
  else
  {
    v45[0] = (const void **)"requires attribute 'data_layout'";
    v46 = 259;
    mlir::OpState::emitOpError(this, v45, (uint64_t)v47);
    v11 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v47);
    if (v47[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    if (v54)
    {
      v12 = (_QWORD **)__p;
      if (__p)
      {
        v13 = v53;
        v14 = __p;
        if (v53 != __p)
        {
          do
            v13 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v13 - 1);
          while (v13 != v12);
          v14 = __p;
        }
        v53 = v12;
        operator delete(v14);
      }
      v15 = v50;
      if (!v50)
        goto LABEL_92;
      v16 = v51;
      v17 = v50;
      if (v51 == v50)
        goto LABEL_91;
      do
      {
        v19 = (void *)*--v16;
        v18 = v19;
        *v16 = 0;
        if (v19)
          operator delete[](v18);
      }
      while (v16 != v15);
      goto LABEL_90;
    }
  }
  return v11;
}

uint64_t mlir::mps::detail::ImaginaryPartOpGenericAdaptorBase::ImaginaryPartOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.imaginary_part", 18, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::ImaginaryPartOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3)
{
  mlir::UnknownLoc *v5;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  mlir::MLIRContext *v8;
  int v9;
  int v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17[2];
  unint64_t v18[2];
  void *__src;
  uint64_t v20;
  _QWORD v21[3];

  v21[2] = *MEMORY[0x1E0C80C00];
  v16 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  __src = v21;
  v20 = 0x200000000;
  v5 = *a1;
  mlir::ValueRange::ValueRange(v18, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(v17, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::ImaginaryPartOp::inferReturnTypes(v5, v8, v9, v18[0], v18[1], Dictionary, v10, v11, v17[0], v17[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v12 = __src;
  v13 = v20;
  v14 = *(unsigned int *)(a2 + 72);
  v15 = v14 + v20;
  if (v15 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v15, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v13)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v14), v12, 8 * v13);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v13;
  if (__src != v21)
    free(__src);
}

uint64_t mlir::mps::detail::InitRandomPhiloxStateOpGenericAdaptorBase::InitRandomPhiloxStateOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.init_random_philox_state", 28, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::InitRandomPhiloxStateOp::build(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v7;
  mlir::MLIRContext *Context;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  void *__src;
  uint64_t v21;
  _BYTE v22[16];
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v16 = a4;
  v17 = a3;
  v15 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v22;
  v21 = 0x200000000;
  v7 = *a1;
  mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v18, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v23[0] = 7;
  v9 = mlir::IntegerType::get(v7, 0x20u, 1u);
  v10 = mlir::RankedTensorType::get((uint64_t)v23, 1, v9, 0);
  v11 = v21;
  if (v21 >= HIDWORD(v21))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v22, v21 + 1, 8);
    v11 = v21;
  }
  *((_QWORD *)__src + v11) = v10;
  LODWORD(v21) = v21 + 1;
  v12 = v21;
  v13 = __src;
  v14 = *(unsigned int *)(a2 + 72);
  if (v14 + (unint64_t)v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14 + v21, 8);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  if (v12)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v14), v13, 8 * v12);
    LODWORD(v14) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v14 + v12;
  if (__src != v22)
    free(__src);
}

BOOL mlir::mps::InitRandomPhiloxStateOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t *v4;
  const void **v5;
  const void *v6;
  void *v7;
  uint64_t v9;
  _QWORD *ArgAttrsAttr;
  uint64_t v11;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  const void ***v23;
  char *v24;
  char *v25;
  __int128 v26;
  const void ***v27;
  char *v28;
  char *v29;
  __int128 v30;
  char v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  unint64_t v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;
  int64_t v47;
  int64_t v48;
  int64_t v49;
  int64_t v50;
  const void **v51;
  uint64_t v52;
  __int16 v53;
  uint64_t OperandRange;
  const void **v55;
  const char *v56;
  uint64_t v57;
  _QWORD v58[3];
  void *v59;
  unsigned int v60;
  unsigned int v61;
  _BYTE v62[96];
  void *v63;
  _QWORD *v64;
  void *__p;
  _QWORD **v66;
  char v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u))
  {
    return 0;
  }
  v2 = *((_DWORD *)*this + 9) ? (uint64_t)(*this - 2) : 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 0);
  v4 = *this;
  v5 = (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
  v6 = *v5;
  v7 = (void *)*((_QWORD *)*v5 + 17);
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v58[0] = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
    v58[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v58);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
      v51 = v5;
      v52 = v9;
      ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v51);
      v68 = 7;
      if (v11 == 1 && *ArgAttrsAttr == v68)
        return 1;
    }
  }
  if (*((_UNKNOWN **)*v5 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v12 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
    v55 = v5;
    v56 = (const char *)v12;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v55);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32))
      return 1;
  }
  v53 = 261;
  v51 = (const void **)"result";
  v52 = 6;
  mlir::Operation::emitOpError(v4, &v51, (uint64_t)v58);
  if (v58[0])
  {
    LODWORD(v55) = 3;
    v56 = " #";
    v57 = 2;
    v13 = &v55;
    v14 = (char *)v59;
    if (v60 >= v61)
    {
      v41 = v60 + 1;
      if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
      {
        v47 = (char *)&v55 - (_BYTE *)v59;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        v14 = (char *)v59;
        v13 = (const void ***)((char *)v59 + v47);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v41, 24);
        v13 = &v55;
        v14 = (char *)v59;
      }
    }
    v15 = &v14[24 * v60];
    v16 = *(_OWORD *)v13;
    *((_QWORD *)v15 + 2) = v13[2];
    *(_OWORD *)v15 = v16;
    v17 = ++v60;
    if (v58[0])
    {
      LODWORD(v55) = 5;
      v56 = 0;
      v18 = &v55;
      v19 = (char *)v59;
      if (v17 >= v61)
      {
        v42 = v17 + 1;
        v43 = (char *)v59 + 24 * v17 > (char *)&v55;
        if (v59 <= &v55 && v43)
        {
          v48 = (char *)&v55 - (_BYTE *)v59;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          v19 = (char *)v59;
          v18 = (const void ***)((char *)v59 + v48);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v42, 24);
          v18 = &v55;
          v19 = (char *)v59;
        }
      }
      v20 = &v19[24 * v60];
      v21 = *(_OWORD *)v18;
      *((_QWORD *)v20 + 2) = v18[2];
      *(_OWORD *)v20 = v21;
      v22 = ++v60;
      if (v58[0])
      {
        LODWORD(v55) = 3;
        v56 = " must be static-shape defined tensor with shape equal to [7] or unranked tensor of 32-bit signed integer values, but got ";
        v57 = 121;
        v23 = &v55;
        v24 = (char *)v59;
        if (v22 >= v61)
        {
          v44 = v22 + 1;
          v45 = (char *)v59 + 24 * v22 > (char *)&v55;
          if (v59 <= &v55 && v45)
          {
            v49 = (char *)&v55 - (_BYTE *)v59;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            v24 = (char *)v59;
            v23 = (const void ***)((char *)v59 + v49);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v44, 24);
            v23 = &v55;
            v24 = (char *)v59;
          }
        }
        v25 = &v24[24 * v60];
        v26 = *(_OWORD *)v23;
        *((_QWORD *)v25 + 2) = v23[2];
        *(_OWORD *)v25 = v26;
        ++v60;
        if (v58[0])
        {
          v27 = &v55;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v55, (uint64_t)v5);
          v28 = (char *)v59;
          if (v60 >= v61)
          {
            v46 = v60 + 1;
            if (v59 <= &v55 && (char *)v59 + 24 * v60 > (char *)&v55)
            {
              v50 = (char *)&v55 - (_BYTE *)v59;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              v28 = (char *)v59;
              v27 = (const void ***)((char *)v59 + v50);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v59, v62, v46, 24);
              v27 = &v55;
              v28 = (char *)v59;
            }
          }
          v29 = &v28[24 * v60];
          v30 = *(_OWORD *)v27;
          *((_QWORD *)v29 + 2) = v27[2];
          *(_OWORD *)v29 = v30;
          ++v60;
        }
      }
    }
  }
  v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v58);
  if (v58[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v58);
  if (v67)
  {
    v32 = (_QWORD **)__p;
    if (__p)
    {
      v33 = v66;
      v34 = __p;
      if (v66 != __p)
      {
        do
          v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
        while (v33 != v32);
        v34 = __p;
      }
      v66 = v32;
      operator delete(v34);
    }
    v35 = v63;
    if (v63)
    {
      v36 = v64;
      v37 = v63;
      if (v64 != v63)
      {
        do
        {
          v39 = (void *)*--v36;
          v38 = v39;
          *v36 = 0;
          if (v39)
            operator delete[](v38);
        }
        while (v36 != v35);
        v37 = v63;
      }
      v64 = v35;
      operator delete(v37);
    }
    if (v59 != v62)
      free(v59);
  }
  return v31 != 0;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps28(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  _QWORD *v10;
  int ArgOperands;
  uint64_t v12;
  void *v13;
  uint64_t v15;
  uint64_t v16;
  _QWORD *ArgAttrsAttr;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  uint64_t v25;
  const void ***v26;
  char *v27;
  char *v28;
  __int128 v29;
  uint64_t v30;
  const void ***v31;
  char *v32;
  char *v33;
  __int128 v34;
  const void ***v35;
  char *v36;
  char *v37;
  __int128 v38;
  _QWORD **v39;
  _QWORD **v40;
  void *v41;
  _QWORD *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  void *v46;
  uint64_t v48;
  void *v49;
  unint64_t v51;
  unint64_t v52;
  BOOL v53;
  unint64_t v54;
  BOOL v55;
  unint64_t v56;
  int64_t v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  const void **v61;
  uint64_t v62;
  __int16 v63;
  _QWORD v64[2];
  _QWORD v65[2];
  _QWORD v66[2];
  uint64_t OperandRange;
  const void **v68;
  uint64_t v69;
  uint64_t v70;
  _QWORD v71[3];
  void *v72;
  unsigned int v73;
  unsigned int v74;
  _BYTE v75[96];
  void *v76;
  _QWORD *v77;
  void *__p;
  _QWORD **v79;
  char v80;
  uint64_t v81;
  uint64_t v82;

  v82 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_4;
  v71[0] = a2;
  v71[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v71);
  v10 = *a2;
  if (!ArgOperands
    || (v61 = a2,
        v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1)),
        mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v61),
        v10 = *a2,
        v12))
  {
LABEL_4:
    v13 = (void *)v10[17];
    if (v13 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
      && v13 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      goto LABEL_12;
    }
    goto LABEL_9;
  }
  v48 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
  v68 = a2;
  v69 = v48;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v68);
  if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    return 1;
  v10 = *a2;
  v49 = (void *)*((_QWORD *)*a2 + 17);
  if (v49 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v49 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
LABEL_9:
    v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v10 + 1));
    v66[0] = a2;
    v66[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v66);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
    {
      v16 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
      v65[0] = a2;
      v65[1] = v16;
      ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v65);
      v81 = 1;
      if (v18 == 1 && *ArgAttrsAttr == v81)
        return 1;
    }
  }
LABEL_12:
  if (*((_UNKNOWN **)*a2 + 17) == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    v19 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v64[0] = a2;
    v64[1] = v19;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v64);
    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
  v63 = 261;
  v61 = a3;
  v62 = a4;
  mlir::Operation::emitOpError(a1, &v61, (uint64_t)v71);
  if (v71[0])
  {
    LODWORD(v68) = 3;
    v69 = (uint64_t)" #";
    v70 = 2;
    v21 = &v68;
    v22 = (char *)v72;
    if (v73 >= v74)
    {
      v51 = v73 + 1;
      if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
      {
        v57 = (char *)&v68 - (_BYTE *)v72;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v22 = (char *)v72;
        v21 = (const void ***)((char *)v72 + v57);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v51, 24);
        v21 = &v68;
        v22 = (char *)v72;
      }
    }
    v23 = &v22[24 * v73];
    v24 = *(_OWORD *)v21;
    *((_QWORD *)v23 + 2) = v21[2];
    *(_OWORD *)v23 = v24;
    v25 = ++v73;
    if (v71[0])
    {
      LODWORD(v68) = 5;
      v69 = a5;
      v26 = &v68;
      v27 = (char *)v72;
      if (v25 >= v74)
      {
        v52 = v25 + 1;
        v53 = (char *)v72 + 24 * v25 > (char *)&v68;
        if (v72 <= &v68 && v53)
        {
          v58 = (char *)&v68 - (_BYTE *)v72;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v27 = (char *)v72;
          v26 = (const void ***)((char *)v72 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v52, 24);
          v26 = &v68;
          v27 = (char *)v72;
        }
      }
      v28 = &v27[24 * v73];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      v30 = ++v73;
      if (v71[0])
      {
        LODWORD(v68) = 3;
        v69 = (uint64_t)" must be 0D tensor of 64-bit signed integer values or static-shape defined tensor with shape equa"
                       "l to [1] or unranked tensor of 64-bit signed integer values, but got ";
        v70 = 166;
        v31 = &v68;
        v32 = (char *)v72;
        if (v30 >= v74)
        {
          v54 = v30 + 1;
          v55 = (char *)v72 + 24 * v30 > (char *)&v68;
          if (v72 <= &v68 && v55)
          {
            v59 = (char *)&v68 - (_BYTE *)v72;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v32 = (char *)v72;
            v31 = (const void ***)((char *)v72 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v54, 24);
            v31 = &v68;
            v32 = (char *)v72;
          }
        }
        v33 = &v32[24 * v73];
        v34 = *(_OWORD *)v31;
        *((_QWORD *)v33 + 2) = v31[2];
        *(_OWORD *)v33 = v34;
        ++v73;
        if (v71[0])
        {
          v35 = &v68;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v68, (uint64_t)a2);
          v36 = (char *)v72;
          if (v73 >= v74)
          {
            v56 = v73 + 1;
            if (v72 <= &v68 && (char *)v72 + 24 * v73 > (char *)&v68)
            {
              v60 = (char *)&v68 - (_BYTE *)v72;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v36 = (char *)v72;
              v35 = (const void ***)((char *)v72 + v60);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v72, v75, v56, 24);
              v35 = &v68;
              v36 = (char *)v72;
            }
          }
          v37 = &v36[24 * v73];
          v38 = *(_OWORD *)v35;
          *((_QWORD *)v37 + 2) = v35[2];
          *(_OWORD *)v37 = v38;
          ++v73;
        }
      }
    }
  }
  v20 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v71);
  if (v71[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v71);
  if (v80)
  {
    v39 = (_QWORD **)__p;
    if (__p)
    {
      v40 = v79;
      v41 = __p;
      if (v79 != __p)
      {
        do
          v40 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v40 - 1);
        while (v40 != v39);
        v41 = __p;
      }
      v79 = v39;
      operator delete(v41);
    }
    v42 = v76;
    if (v76)
    {
      v43 = v77;
      v44 = v76;
      if (v77 != v76)
      {
        do
        {
          v46 = (void *)*--v43;
          v45 = v46;
          *v43 = 0;
          if (v46)
            operator delete[](v45);
        }
        while (v43 != v42);
        v44 = v76;
      }
      v77 = v42;
      operator delete(v44);
    }
    if (v72 != v75)
      free(v72);
  }
  return v20;
}

uint64_t mlir::mps::detail::InstanceNormOpGenericAdaptorBase::InstanceNormOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  v5 = (_QWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)v5 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8) + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)v10;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.instance_norm", 17, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

llvm::detail::DoubleAPFloat *mlir::mps::detail::InstanceNormOpGenericAdaptorBase::getEpsilon@<X0>(mlir::mps::detail::InstanceNormOpGenericAdaptorBase *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;

  v3 = *((_QWORD *)this + 3);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

uint64_t mlir::mps::InstanceNormOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int64_t v40;
  int64_t v41;
  int64_t v42;
  uint64_t v43;
  int v44;
  const char *v45;
  uint64_t v46;
  _QWORD v47[3];
  void *v48;
  unsigned int v49;
  unsigned int v50;
  _BYTE v51[96];
  void *v52;
  _QWORD *v53;
  void *__p;
  _QWORD **v55;
  char v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v43 = v6;
  if (!v6)
  {
    a3(v47, a4);
    if (v47[0])
    {
      v44 = 3;
      v45 = "expected DictionaryAttr to set properties";
      v46 = 41;
      v26 = &v44;
      v27 = (char *)v48;
      if (v49 >= v50)
      {
        v37 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v40 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v27 = (char *)v48;
          v26 = (int *)((char *)v48 + v40);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v37, 24);
          v26 = &v44;
          v27 = (char *)v48;
        }
      }
      v28 = &v27[24 * v49];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
    if (!v56)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v55;
      v32 = __p;
      if (v55 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v55 = v30;
      operator delete(v32);
    }
    v21 = v52;
    if (!v52)
      goto LABEL_43;
    v33 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_41;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v43, "epsilon", 7uLL);
  if (!v8)
    return 1;
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v47, a4);
  if (v47[0])
  {
    v44 = 3;
    v46 = 52;
    v10 = &v44;
    v11 = (char *)v48;
    if (v49 >= v50)
    {
      v38 = v49 + 1;
      if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
      {
        v41 = (char *)&v44 - (_BYTE *)v48;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v11 = (char *)v48;
        v10 = (int *)((char *)v48 + v41);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v38, 24);
        v10 = &v44;
        v11 = (char *)v48;
      }
    }
    v12 = &v11[24 * v49];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v49;
    if (v47[0])
    {
      v14 = &v44;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v44, v9);
      v15 = (char *)v48;
      if (v49 >= v50)
      {
        v39 = v49 + 1;
        if (v48 <= &v44 && (char *)v48 + 24 * v49 > (char *)&v44)
        {
          v42 = (char *)&v44 - (_BYTE *)v48;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v15 = (char *)v48;
          v14 = (int *)((char *)v48 + v42);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v48, v51, v39, 24);
          v14 = &v44;
          v15 = (char *)v48;
        }
      }
      v16 = &v15[24 * v49];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v49;
      if (v47[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v47);
    }
  }
  if (!v56)
    return 0;
  v18 = (_QWORD **)__p;
  if (__p)
  {
    v19 = v55;
    v20 = __p;
    if (v55 != __p)
    {
      do
        v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
      while (v19 != v18);
      v20 = __p;
    }
    v55 = v18;
    operator delete(v20);
  }
  v21 = v52;
  if (v52)
  {
    v22 = v53;
    v23 = v52;
    if (v53 == v52)
      goto LABEL_42;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_41:
    v23 = v52;
LABEL_42:
    v53 = v21;
    operator delete(v23);
  }
LABEL_43:
  if (v48 != v51)
    free(v48);
  return 0;
}

uint64_t mlir::mps::InstanceNormOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"epsilon", 7, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties]";
        v15 = 113;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[468];
    return a1[32];
  }
  return result;
}

llvm::detail::DoubleAPFloat *mlir::mps::InstanceNormOp::getEpsilon@<X0>(mlir::mps::InstanceNormOp *this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)this + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)this + 44) >> 23) & 1) + 64);
  return mlir::FloatAttr::getValue((mlir::FloatAttr *)&v3, a2);
}

void mlir::mps::InstanceNormOp::build(mlir::Float32Type **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::MLIRContext *v8;
  uint64_t F32Type;
  uint64_t FloatAttr;
  uint64_t v11;
  mlir::MLIRContext *Context;
  unint64_t v13;
  unsigned int v14;
  unsigned int v15;
  void *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *__src;
  uint64_t v25;
  _BYTE v26[16];
  _QWORD v27[3];

  v27[2] = *MEMORY[0x1E0C80C00];
  v19 = a4;
  v20 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v19, 1);
  F32Type = mlir::Builder::getF32Type(a1, v8);
  FloatAttr = mlir::Builder::getFloatAttr((uint64_t)a1, F32Type, a5);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>((_QWORD *)a2) = FloatAttr;
  __src = v26;
  v25 = 0x200000000;
  v11 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v22, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v21, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v27[0] = v22;
  v27[1] = v23;
  if (v23)
  {
    v13 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v14 = v25;
    if (v25 >= HIDWORD(v25))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v26, v25 + 1, 8);
      v14 = v25;
    }
    *((_QWORD *)__src + v14) = v13;
    v15 = v25 + 1;
    LODWORD(v25) = v15;
    v16 = __src;
    v17 = *(unsigned int *)(a2 + 72);
    v18 = v17 + v15;
    if (v18 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v18, 8);
      LODWORD(v17) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v11, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v15 = v25;
    v16 = __src;
    v17 = *(unsigned int *)(a2 + 72);
    v18 = v17 + v25;
    if (v18 > *(unsigned int *)(a2 + 76))
      goto LABEL_5;
  }
  if (v15)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v17), v16, 8 * v15);
    LODWORD(v17) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v17 + v15;
  if (__src != v26)
    free(__src);
}

BOOL mlir::mps::InstanceNormOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  const void **v3;
  uint64_t v4;
  uint64_t NextResultAtOffset;
  uint64_t *v7;

  v2 = *this;
  v3 = (const void **)(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  v7 = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v3, (const void **)"epsilon", (const char *)7, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v7)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v4 = (uint64_t)(*this - 2);
  else
    v4 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v4, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::detail::IsFiniteOpGenericAdaptorBase::IsFiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.is_finite", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::IsFiniteOp::build(uint64_t *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  mlir::MLIRContext *Context;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13[2];
  void *__src;
  uint64_t v15;
  _QWORD v16[3];

  v16[2] = *MEMORY[0x1E0C80C00];
  v11 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v11, 1);
  __src = v16;
  v15 = 0x200000000;
  v5 = *a1;
  mlir::ValueRange::ValueRange(v13, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v12, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v7 = __src;
  v8 = v15;
  v9 = *(unsigned int *)(a2 + 72);
  v10 = v9 + v15;
  if (v10 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v10, 8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v8)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v9), v7, 8 * v8);
    LODWORD(v9) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v9 + v8;
  if (__src != v16)
    free(__src);
}

uint64_t mlir::mps::detail::IsInfiniteOpGenericAdaptorBase::IsInfiniteOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.is_infinite", 15, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::IsNaNOpGenericAdaptorBase::IsNaNOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.is_nan", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::LPNormOpGenericAdaptorBase::LPNormOpGenericAdaptorBase(uint64_t a1, unsigned int *a2)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary((mlir::Operation *)a2);
  v5 = a2[11];
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)&a2[4 * ((v5 >> 23) & 1) + 17] + ((v5 >> 21) & 0x7F8) + 3) & 0xFFFFFFFFFFFFFFF8)
       + 32 * a2[10];
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.lp_norm", 11, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

void mlir::mps::LPNormOp::build(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v7;
  mlir::MLIRContext *Context;
  unint64_t v9;
  unsigned int v10;
  unsigned int v11;
  void *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *__src;
  uint64_t v23;
  _BYTE v24[16];
  _QWORD v25[3];

  v25[2] = *MEMORY[0x1E0C80C00];
  v17 = a4;
  v18 = a3;
  v15 = a6;
  v16 = a5;
  mlir::OperationState::addOperands(a2, (uint64_t)&v18, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v16, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v15, 1);
  __src = v24;
  v23 = 0x200000000;
  v7 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(&v20, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v19, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v25[0] = v20;
  v25[1] = v21;
  if (v21)
  {
    v9 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v25, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v10 = v23;
    if (v23 >= HIDWORD(v23))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&__src, v24, v23 + 1, 8);
      v10 = v23;
    }
    *((_QWORD *)__src + v10) = v9;
    v11 = v23 + 1;
    LODWORD(v23) = v11;
    v12 = __src;
    v13 = *(unsigned int *)(a2 + 72);
    v14 = v13 + v11;
    if (v14 > *(unsigned int *)(a2 + 76))
    {
LABEL_5:
      llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v14, 8);
      LODWORD(v13) = *(_DWORD *)(a2 + 72);
    }
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(v7, 1, "invalid number of operands"))
      llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
    v11 = v23;
    v12 = __src;
    v13 = *(unsigned int *)(a2 + 72);
    v14 = v13 + v23;
    if (v14 > *(unsigned int *)(a2 + 76))
      goto LABEL_5;
  }
  if (v11)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v13), v12, 8 * v11);
    LODWORD(v13) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v13 + v11;
  if (__src != v24)
    free(__src);
}

BOOL mlir::mps::LPNormOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  const void **v3;
  _QWORD *v4;
  int ArgOperands;
  uint64_t v6;
  void *v7;
  uint64_t v9;
  uint64_t v10;
  _QWORD *ArgAttrsAttr;
  uint64_t v12;
  const void ***v13;
  char *v14;
  char *v15;
  __int128 v16;
  uint64_t v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  const void ***v23;
  char *v24;
  char *v25;
  __int128 v26;
  const void ***v27;
  char *v28;
  char *v29;
  __int128 v30;
  char v31;
  _QWORD **v32;
  _QWORD **v33;
  void *v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t NextResultAtOffset;
  uint64_t v44;
  void *v45;
  unint64_t v47;
  unint64_t v48;
  BOOL v49;
  unint64_t v50;
  BOOL v51;
  unint64_t v52;
  int64_t v53;
  int64_t v54;
  int64_t v55;
  int64_t v56;
  const void **v57;
  uint64_t v58;
  __int16 v59;
  _QWORD v60[2];
  _QWORD v61[2];
  _QWORD v62[2];
  uint64_t OperandRange;
  const void **v64;
  uint64_t v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD **v75;
  char v76;
  uint64_t v77;
  uint64_t v78;

  v78 = *MEMORY[0x1E0C80C00];
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0))return 0;
  v2 = *this;
  v3 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8);
  v4 = *v3;
  if (*((_UNKNOWN **)*v3 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
  {
    v67[0] = *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
    v67[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
    ArgOperands = mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v67);
    v4 = *v3;
    if (ArgOperands)
    {
      v57 = v3;
      v58 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v57);
      v4 = *v3;
      if (!v6)
      {
        v44 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        v64 = v3;
        v65 = v44;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v64);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          goto LABEL_68;
        }
        v4 = *v3;
        v45 = (void *)*((_QWORD *)*v3 + 17);
        if (v45 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
          && v45 != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
        {
          goto LABEL_25;
        }
LABEL_10:
        v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)(v4 + 1));
        v62[0] = v3;
        v62[1] = v9;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v62);
        if (mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
          || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
          || mlir::Type::isF16((mlir::Type *)&OperandRange)
          || mlir::Type::isF32((mlir::Type *)&OperandRange)
          || mlir::Type::isBF16((mlir::Type *)&OperandRange)
          || *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) == &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
        {
          v10 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8);
          v61[0] = v3;
          v61[1] = v10;
          ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)v61);
          v77 = 1;
          if (v12 == 1 && *ArgAttrsAttr == v77)
            goto LABEL_68;
        }
        goto LABEL_25;
      }
    }
  }
  v7 = (void *)v4[17];
  if (v7 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id
    || v7 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
  {
    goto LABEL_10;
  }
LABEL_25:
  if (*((_UNKNOWN **)*v3 + 17) != &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id
    || (v40 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v3 + 8),
        v60[0] = v3,
        v60[1] = v40,
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v60),
        !mlir::Type::isSignlessInteger((mlir::Type *)&OperandRange, 1))
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    && !mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64)
    && !mlir::Type::isF16((mlir::Type *)&OperandRange)
    && !mlir::Type::isF32((mlir::Type *)&OperandRange)
    && !mlir::Type::isBF16((mlir::Type *)&OperandRange)
    && *(_UNKNOWN **)(*(_QWORD *)OperandRange + 136) != &mlir::detail::TypeIDResolver<mlir::IndexType,void>::id)
  {
    v59 = 261;
    v57 = (const void **)"operand";
    v58 = 7;
    mlir::Operation::emitOpError(v2, &v57, (uint64_t)v67);
    if (v67[0])
    {
      LODWORD(v64) = 3;
      v65 = (uint64_t)" #";
      v66 = 2;
      v13 = &v64;
      v14 = (char *)v68;
      if (v69 >= v70)
      {
        v47 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          v53 = (char *)&v64 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          v14 = (char *)v68;
          v13 = (const void ***)((char *)v68 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v47, 24);
          v13 = &v64;
          v14 = (char *)v68;
        }
      }
      v15 = &v14[24 * v69];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = v13[2];
      *(_OWORD *)v15 = v16;
      v17 = ++v69;
      if (v67[0])
      {
        LODWORD(v64) = 5;
        v65 = 1;
        v18 = &v64;
        v19 = (char *)v68;
        if (v17 >= v70)
        {
          v48 = v17 + 1;
          v49 = (char *)v68 + 24 * v17 > (char *)&v64;
          if (v68 <= &v64 && v49)
          {
            v54 = (char *)&v64 - (_BYTE *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            v19 = (char *)v68;
            v18 = (const void ***)((char *)v68 + v54);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v48, 24);
            v18 = &v64;
            v19 = (char *)v68;
          }
        }
        v20 = &v19[24 * v69];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        v22 = ++v69;
        if (v67[0])
        {
          LODWORD(v64) = 3;
          v65 = (uint64_t)" must be 0D tensor of mps native type values or static-shape defined tensor with shape equal to"
                         " [1] or unranked tensor of mps native type values, but got ";
          v66 = 154;
          v23 = &v64;
          v24 = (char *)v68;
          if (v22 >= v70)
          {
            v50 = v22 + 1;
            v51 = (char *)v68 + 24 * v22 > (char *)&v64;
            if (v68 <= &v64 && v51)
            {
              v55 = (char *)&v64 - (_BYTE *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              v24 = (char *)v68;
              v23 = (const void ***)((char *)v68 + v55);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v50, 24);
              v23 = &v64;
              v24 = (char *)v68;
            }
          }
          v25 = &v24[24 * v69];
          v26 = *(_OWORD *)v23;
          *((_QWORD *)v25 + 2) = v23[2];
          *(_OWORD *)v25 = v26;
          ++v69;
          if (v67[0])
          {
            v27 = &v64;
            mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, (uint64_t)v3);
            v28 = (char *)v68;
            if (v69 >= v70)
            {
              v52 = v69 + 1;
              if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
              {
                v56 = (char *)&v64 - (_BYTE *)v68;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                v28 = (char *)v68;
                v27 = (const void ***)((char *)v68 + v56);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v52, 24);
                v27 = &v64;
                v28 = (char *)v68;
              }
            }
            v29 = &v28[24 * v69];
            v30 = *(_OWORD *)v27;
            *((_QWORD *)v29 + 2) = v27[2];
            *(_OWORD *)v29 = v30;
            ++v69;
          }
        }
      }
    }
    v31 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v67);
    if (v67[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    if (v76)
    {
      v32 = (_QWORD **)__p;
      if (__p)
      {
        v33 = v75;
        v34 = __p;
        if (v75 != __p)
        {
          do
            v33 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v33 - 1);
          while (v33 != v32);
          v34 = __p;
        }
        v75 = v32;
        operator delete(v34);
      }
      v35 = v72;
      if (v72)
      {
        v36 = v73;
        v37 = v72;
        if (v73 != v72)
        {
          do
          {
            v39 = (void *)*--v36;
            v38 = v39;
            *v36 = 0;
            if (v39)
              operator delete[](v38);
          }
          while (v36 != v35);
          v37 = v72;
        }
        v73 = v35;
        operator delete(v37);
      }
      if (v68 != v71)
        free(v68);
    }
    if (!v31)
      return 0;
  }
LABEL_68:
  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps3(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 88) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 2u)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 120) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 3u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v41 = (uint64_t)(*this - 2);
  else
    v41 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v41, 0);
  return mlir::tensor::__mlir_ods_local_type_constraint_TensorOps0(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
}

uint64_t mlir::mps::LSTMGradientOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v5;
  uint64_t NextResultAtOffset;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t result;
  uint64_t v21;

  if (*(_DWORD *)(*a1 + 36))
    v5 = *a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "gradient_output_sequence", 24);
  if (*(_DWORD *)(*a1 + 36))
    v7 = *a1 - 16;
  else
    v7 = 0;
  v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "gradient_recurrent_weight", 25);
  if (*(_DWORD *)(*a1 + 36))
    v10 = *a1 - 16;
  else
    v10 = 0;
  v11 = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 2);
  v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(v11, 0);
  a2(a3, v12, "gradient_input_state", 20);
  if (*(_DWORD *)(*a1 + 36))
    v13 = *a1 - 16;
  else
    v13 = 0;
  v14 = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 3);
  v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(v14, 0);
  a2(a3, v15, "gradient_input_cell", 19);
  v16 = *a1;
  v17 = *(_DWORD *)(*a1 + 36);
  v18 = v16 - 16;
  if (v17)
    v19 = v18;
  else
    v19 = 0;
  result = mlir::detail::OpResultImpl::getNextResultAtOffset(v19, 4);
  if (v17 != 4)
  {
    v21 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v21, "gradient_peephole", 17);
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getODSResults(mlir::mps::LSTMGradientOp *this, unsigned int a2)
{
  int v2;
  unsigned int v3;
  int32x4_t v4;
  int32x4_t v5;
  int32x4_t v6;
  int32x4_t v7;
  unsigned int v8;
  int32x4_t v9;
  int v10;
  uint64_t result;

  if (a2)
  {
    if (a2 >= 8)
    {
      v4 = (int32x4_t)xmmword_181235170;
      v3 = a2 & 0xFFFFFFF8;
      v5 = 0uLL;
      v6.i64[0] = 0x400000004;
      v6.i64[1] = 0x400000004;
      v7.i64[0] = 0x800000008;
      v7.i64[1] = 0x800000008;
      v8 = a2 & 0xFFFFFFF8;
      v9 = 0uLL;
      do
      {
        v5 = vsubq_s32(v5, vceqq_s32(v4, v6));
        v9 = vsubq_s32(v9, vceqzq_s32(v4));
        v4 = vaddq_s32(v4, v7);
        v8 -= 8;
      }
      while (v8);
      v2 = vaddvq_s32(vaddq_s32(v9, v5));
      if (v3 == a2)
        goto LABEL_11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
    }
    do
    {
      if (v3 == 4)
        ++v2;
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    v2 = 0;
  }
LABEL_11:
  v10 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v10)
    result = *(_QWORD *)this - 16;
  else
    result = 0;
  if (a2 + (v10 - 5) * v2)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v10 - 5) * v2);
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::getCellClip(mlir::mps::LSTMGradientOp *this)
{
  unint64_t v1;
  _DWORD *v2;
  int v3;
  uint64_t v4;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  v2 = (_DWORD *)(*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = 0;
  v3 = v2[20];
  if ((v1 & 0x800000) != 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)this + 72);
    if (v3)
      return *(_QWORD *)(v4
                       + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14] + v2[13] + v2[12])
                       + 24);
  }
  else
  {
    v4 = 0;
    if (v3)
      return *(_QWORD *)(v4
                       + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14] + v2[13] + v2[12])
                       + 24);
  }
  return 0;
}

uint64_t mlir::mps::LSTMGradientOp::getGradientInputCell(mlir::mps::LSTMGradientOp *this)
{
  uint64_t v1;
  uint64_t NextResultAtOffset;

  if (*(_DWORD *)(*(_QWORD *)this + 36))
    v1 = *(_QWORD *)this - 16;
  else
    v1 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v1, 3);
  return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
}

uint64_t mlir::mps::LSTMGradientOp::getGradientPeephole(mlir::mps::LSTMGradientOp *this)
{
  int v1;
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;

  v1 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v1)
    v2 = *(_QWORD *)this - 16;
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 4);
  v4 = 0;
  if (v1 != 4)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  return v4;
}

BOOL mlir::mps::LSTMGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  int64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  uint64_t v70;
  uint64_t v71;
  const char *v72;
  uint64_t v73;
  _QWORD v74[3];
  void *v75;
  unsigned int v76;
  unsigned int v77;
  _BYTE v78[96];
  void *v79;
  _QWORD *v80;
  void *__p;
  _QWORD **v82;
  char v83;
  uint64_t v84;

  v84 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v70 = v6;
  if (!v6)
  {
    a3(v74, a4);
    if (v74[0])
    {
      LODWORD(v71) = 3;
      v72 = "expected DictionaryAttr to set properties";
      v73 = 41;
      v26 = &v71;
      v27 = (char *)v75;
      if (v76 >= v77)
      {
        v60 = v76 + 1;
        if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
        {
          v65 = (char *)&v71 - (_BYTE *)v75;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v27 = (char *)v75;
          v26 = (uint64_t *)((char *)v75 + v65);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v60, 24);
          v26 = &v71;
          v27 = (char *)v75;
        }
      }
      v28 = &v27[24 * v76];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v76;
      if (v74[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
    }
    if (!v83)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v82;
      v32 = __p;
      if (v82 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v82 = v30;
      operator delete(v32);
    }
    v21 = v79;
    if (!v79)
      goto LABEL_64;
    v33 = v80;
    v23 = v79;
    if (v80 == v79)
    {
LABEL_63:
      v80 = v21;
      operator delete(v23);
LABEL_64:
      if (v75 != v78)
        free(v75);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v79;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v70, "cell_activation", 0xFuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 60;
        v10 = &v71;
        v11 = (char *)v75;
        if (v76 >= v77)
        {
          v61 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v66 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v11 = (char *)v75;
            v10 = (uint64_t *)((char *)v75 + v66);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v61, 24);
            v10 = &v71;
            v11 = (char *)v75;
          }
        }
        v12 = &v11[24 * v76];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v76;
        if (v74[0])
        {
          v14 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v9);
          v15 = (char *)v75;
          if (v76 >= v77)
          {
            v62 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v67 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v15 = (char *)v75;
              v14 = (uint64_t *)((char *)v75 + v67);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v62, 24);
              v14 = &v71;
              v15 = (char *)v75;
            }
          }
          v16 = &v15[24 * v76];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v82;
        v20 = __p;
        if (v82 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v82 = v18;
        operator delete(v20);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v22 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v70, "fgate_activation", 0x10uLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      if (v74[0])
      {
        LODWORD(v71) = 3;
        v73 = 61;
        v38 = &v71;
        v39 = (char *)v75;
        if (v76 >= v77)
        {
          v63 = v76 + 1;
          if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
          {
            v68 = (char *)&v71 - (_BYTE *)v75;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v39 = (char *)v75;
            v38 = (uint64_t *)((char *)v75 + v68);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v63, 24);
            v38 = &v71;
            v39 = (char *)v75;
          }
        }
        v40 = &v39[24 * v76];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v76;
        if (v74[0])
        {
          v42 = &v71;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v71, v37);
          v43 = (char *)v75;
          if (v76 >= v77)
          {
            v64 = v76 + 1;
            if (v75 <= &v71 && (char *)v75 + 24 * v76 > (char *)&v71)
            {
              v69 = (char *)&v71 - (_BYTE *)v75;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v43 = (char *)v75;
              v42 = (uint64_t *)((char *)v75 + v69);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v75, v78, v64, 24);
              v42 = &v71;
              v43 = (char *)v75;
            }
          }
          v44 = &v43[24 * v76];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v76;
          if (v74[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v74);
        }
      }
      if (!v83)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v82;
        v48 = __p;
        if (v82 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v82 = v46;
        operator delete(v48);
      }
      v21 = v79;
      if (!v79)
        goto LABEL_64;
      v49 = v80;
      v23 = v79;
      if (v80 == v79)
        goto LABEL_63;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v70, "gate_layout", 0xBuLL);
  v71 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    {
      a3(v74, a4);
LABEL_83:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v71);
LABEL_84:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v74);
      return 0;
    }
    a1[2] = v52;
  }
  v54 = mlir::DictionaryAttr::get((uint64_t)&v70, "igate_activation", 0x10uLL);
  v71 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
LABEL_82:
      v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, v55);
      goto LABEL_83;
    }
    a1[3] = v54;
  }
  v56 = mlir::DictionaryAttr::get((uint64_t)&v70, "ogate_activation", 0x10uLL);
  v71 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[4] = v56;
  }
  v57 = mlir::DictionaryAttr::get((uint64_t)&v70, "zgate_activation", 0x10uLL);
  v71 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v74, a4);
      goto LABEL_82;
    }
    a1[5] = v57;
  }
  v59 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v70, "operandSegmentSizes", 0x13uLL);
  if (!v59)
  {
    v59 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v70, "operand_segment_sizes", 0x15uLL);
    if (!v59)
    {
      a3(v74, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v74, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_84;
    }
  }
  return mlir::convertFromAttribute(a1 + 6, (const char *)0xA, v59, a3, a4) != 0;
}

uint64_t mlir::mps::LSTMGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  BOOL v45;
  uint64_t v46;
  uint64_t DictionaryAttr;
  void *v48;
  mlir::DictionaryAttr *v50;
  void *v51;
  uint64_t v52;
  _QWORD v53[7];

  v53[6] = *MEMORY[0x1E0C80C00];
  v50 = a1;
  v51 = v53;
  v52 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v50, (uint64_t)"cell_activation", 15, *a2);
    v6 = v5;
    v7 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v7 = v52;
    }
    v8 = (uint64_t *)((char *)v51 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v52) = v52 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"fgate_activation", 16, v9);
    v12 = v11;
    v13 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v13 = v52;
    }
    v14 = (uint64_t *)((char *)v51 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v52) = v52 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"gate_layout", 11, v15);
    v18 = v17;
    v19 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v19 = v52;
    }
    v20 = (uint64_t *)((char *)v51 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v52) = v52 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"igate_activation", 16, v21);
    v24 = v23;
    v25 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v25 = v52;
    }
    v26 = (uint64_t *)((char *)v51 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    LODWORD(v52) = v52 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"ogate_activation", 16, v27);
    v30 = v29;
    v31 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v31 = v52;
    }
    v32 = (uint64_t *)((char *)v51 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    LODWORD(v52) = v52 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"zgate_activation", 16, v33);
    v36 = v35;
    v37 = v52;
    if (v52 >= HIDWORD(v52))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
      v37 = v52;
    }
    v38 = (uint64_t *)((char *)v51 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    LODWORD(v52) = v52 + 1;
  }
  v39 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
  v40 = mlir::Builder::getNamedAttr(&v50, (uint64_t)"operandSegmentSizes", 19, v39);
  v42 = v41;
  v43 = v52;
  if (v52 >= HIDWORD(v52))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v51, v53, v52 + 1, 16);
    v43 = v52;
  }
  v44 = (uint64_t *)((char *)v51 + 16 * v43);
  *v44 = v40;
  v44[1] = v42;
  v45 = __CFADD__((_DWORD)v52, 1);
  v46 = (v52 + 1);
  LODWORD(v52) = v52 + 1;
  if (v45)
  {
    DictionaryAttr = 0;
    v48 = v51;
    if (v51 == v53)
      return DictionaryAttr;
    goto LABEL_32;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v50, (mlir::MLIRContext *)v51, v46);
  v48 = v51;
  if (v51 != v53)
LABEL_32:
    free(v48);
  return DictionaryAttr;
}

unint64_t mlir::mps::LSTMGradientOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  int v43;
  int v44;
  unint64_t v45;
  int v46;
  int v47;
  unint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  int v52;
  int v53;
  unint64_t v54;
  int v55;
  int v56;
  unint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t *v78;
  unint64_t *v79;
  unint64_t *v80;
  unint64_t *v81;
  unint64_t *v82;
  unint64_t *v83;
  unint64_t *v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  _OWORD v99[4];
  _OWORD v100[3];
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;

  v103 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v78 = a1;
    v85 = *a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v44 = v43;
    a1 = v78;
    v1 = v85;
    if (v44)
    {
      v45 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v45 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v45;
      a1 = v78;
      v1 = v85;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = v3[19];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v79 = a1;
    v86 = v1;
    v66 = a1[1];
    v71 = v3[19];
    v5 = v66;
    v4 = v71;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v47 = v46;
    a1 = v79;
    v1 = v86;
    if (v47)
    {
      v48 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v48 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v48;
      v5 = v66;
      v4 = v71;
      a1 = v79;
      v1 = v86;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = HIDWORD(v5);
  v8 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v5) ^ HIDWORD(v5));
  v98 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) ^ ((0x9DDFEA08EB382D69 * (v7 ^ (v8 >> 47) ^ v8)) >> 47));
  v9 = a1[2];
  if ((v7 & 1) == 0)
  {
    v80 = a1;
    v87 = v1;
    v67 = a1[2];
    v72 = v4;
    v9 = v67;
    v4 = v72;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    a1 = v80;
    v1 = v87;
    if (v50)
    {
      v51 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v51 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v51;
      v9 = v67;
      v4 = v72;
      a1 = v80;
      v1 = v87;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v9);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v9) ^ HIDWORD(v9));
  v97 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v81 = a1;
    v88 = v1;
    v68 = a1[3];
    v73 = v4;
    v12 = v68;
    v4 = v73;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v53 = v52;
    a1 = v81;
    v1 = v88;
    if (v53)
    {
      v54 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v54 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v54;
      v12 = v68;
      v4 = v73;
      a1 = v81;
      v1 = v88;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v96 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v82 = a1;
    v89 = v1;
    v69 = a1[4];
    v74 = v4;
    v15 = v69;
    v4 = v74;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v56 = v55;
    a1 = v82;
    v1 = v89;
    if (v56)
    {
      v57 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v57 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v57;
      v15 = v69;
      v4 = v74;
      a1 = v82;
      v1 = v89;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v95 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v83 = a1;
    v90 = v1;
    v70 = a1[5];
    v75 = v4;
    v18 = v70;
    v4 = v75;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v59 = v58;
    a1 = v83;
    v1 = v90;
    if (v59)
    {
      v60 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v60 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v60;
      v18 = v70;
      v4 = v75;
      a1 = v83;
      v1 = v90;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v18) ^ HIDWORD(v18));
  v94 = 0x9DDFEA08EB382D69
      * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  if ((v19 & 1) == 0)
  {
    v84 = a1;
    v91 = v1;
    v76 = v4;
    v1 = v91;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v62 = v61;
    v4 = v76;
    a1 = v84;
    if (v62)
    {
      v63 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v63 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v63;
      v4 = v76;
      a1 = v84;
      v1 = v91;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v21 = a1[7];
  v22 = a1[8];
  v23 = a1[9];
  v24 = a1[6] - 0x3C5A37A36834CED9 * v23 - 0x6E18B188484051E8;
  v25 = __ROR8__(v24 + v23, 52);
  v26 = v24 + v21;
  v27 = __ROR8__(v26, 7);
  v28 = v26 + v22;
  v29 = v27 + __ROR8__(a1[6] - 0x3C5A37A36834CED9 * v23 - 0x6E18B188484051E8, 37) + v25;
  v30 = v22 + v21;
  v31 = a1[10];
  v32 = __ROR8__(v30 + v31, 52);
  v33 = v29 + __ROR8__(v28, 31);
  v34 = __ROR8__(v30, 37);
  v35 = v30 + v22;
  v36 = __ROR8__(v35, 7);
  v37 = v35 + v23;
  v38 = v28 + v23 + v34 + v32 + v36 + __ROR8__(v37, 31);
  v39 = ((0xC3A5C85C97CB3127
        * ((0xC3A5C85C97CB3127 * (v37 + v31 + v33) - 0x651E95C4D06FBFB1 * v38) ^ ((0xC3A5C85C97CB3127
                                                                                     * (v37 + v31 + v33)
                                                                                     - 0x651E95C4D06FBFB1 * v38) >> 47))) ^ v3[19])
      + v33;
  v93 = 0x9AE16A3B2F90404FLL * (v39 ^ (v39 >> 47));
  v101 = 0;
  memset(v100, 0, sizeof(v100));
  memset(v99, 0, sizeof(v99));
  if ((v39 & 1) == 0)
  {
    v92 = v1;
    v77 = v4;
    v4 = v77;
    v1 = v92;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v64)
    {
      v65 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v65 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v65;
      v4 = v77;
      v1 = v92;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v40 = HIDWORD(v1);
  v41 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v102 = v3[19];
  *(_QWORD *)&v99[0] = 0x9DDFEA08EB382D69
                     * ((0x9DDFEA08EB382D69 * (v40 ^ (v41 >> 47) ^ v41)) ^ ((0x9DDFEA08EB382D69
                                                                             * (v40 ^ (v41 >> 47) ^ v41)) >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)v99, 0, (_QWORD *)v99 + 1, (char *)v100, (uint64_t *)&v98, (uint64_t *)&v97, (uint64_t *)&v96, (uint64_t *)&v95, (uint64_t *)&v94, (uint64_t *)&v93);
}

uint64_t mlir::mps::LSTMGradientOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, char *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 0xBuLL:
      if (memcmp(__s1, "gate_layout", __n))
        goto LABEL_23;
      return a2[2];
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_23;
    case 0xFuLL:
      if (*(_QWORD *)__s1 != 0x7463615F6C6C6563 || *(_QWORD *)(__s1 + 7) != 0x6E6F697461766974)
        goto LABEL_23;
      return *a2;
    case 0x10uLL:
      if (!memcmp(__s1, "fgate_activation", __n))
      {
        result = a2[1];
      }
      else if (!memcmp(__s1, "igate_activation", __n))
      {
        result = a2[3];
      }
      else if (*(_QWORD *)__s1 == 0x63615F657461676FLL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
      {
        result = a2[4];
      }
      else if (*(_QWORD *)__s1 == 0x63615F657461677ALL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
      {
        result = a2[5];
      }
      else
      {
LABEL_23:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_23;
      goto LABEL_25;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_23;
LABEL_25:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v9;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 0xBuLL:
      result = memcmp(__s1, "gate_layout", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
            v15 = a4;
          else
            v15 = 0;
          v7[2] = v15;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x7463615F6C6C6563 && *(_QWORD *)(__s1 + 7) == 0x6E6F697461766974)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v9 = a4;
          else
            v9 = 0;
          *(_QWORD *)result = v9;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "fgate_activation", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "igate_activation", __n);
        if ((_DWORD)result)
        {
          if (*(_QWORD *)__s1 == 0x63615F657461676FLL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                v18 = a4;
              else
                v18 = 0;
              v7[4] = v18;
            }
            else
            {
              v7[4] = 0;
            }
          }
          else if (*(_QWORD *)__s1 == 0x63615F657461677ALL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                v12 = a4;
              else
                v12 = 0;
              v7[5] = v12;
            }
            else
            {
              v7[5] = 0;
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v17 = a4;
          else
            v17 = 0;
          v7[3] = v17;
        }
        else
        {
          v7[3] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
          v16 = a4;
        else
          v16 = 0;
        v7[1] = v16;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!(_DWORD)result)
        goto LABEL_33;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!(_DWORD)result)
      {
LABEL_33:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v13 = (_DWORD)result ? a4 : 0;
          v19 = v13;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v19);
            if (result == 10)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v19);
              if (v14)
                result = (uint64_t)memmove(v7 + 6, (const void *)result, 4 * v14);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::LSTMGradientOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"cell_activation", 15, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"fgate_activation", 16, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v7);
  v8 = a2[3];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"igate_activation", 16, v8);
  v9 = a2[4];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v9);
  v10 = a2[5];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v10);
  v11 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 6), 10);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v11);
}

BOOL mlir::mps::LSTMGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"cell_activation", (const char *)0xF, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"fgate_activation", (const char *)0x10, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v10, (const void **)"gate_layout", (const char *)0xB, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v11, (const void **)"igate_activation", (const char *)0x10, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
          {
            v13 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v13, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
            {
              return 1;
            }
          }
        }
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid LSTM gate layout";
        v31 = 54;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

BOOL mlir::mps::LSTMGradientOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v7[4];
  __int16 v8;
  uint64_t v9;
  _QWORD v10[25];

  v10[24] = *MEMORY[0x1E0C80C00];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(a1, v3 + 2)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 11)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      v8 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5)
      memmove(v3 + 6, v4, 4 * v5);
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 5))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 6);
    return mlir::mps::LSTMGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x58uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *((_QWORD *)v3 + 10) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties]";
        v15 = 113;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[470];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 56))(a1, &v39))
    return 0;
  v4 = v39;
  if (!v39)
    return 1;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::LSTMGateLayoutAttr]";
  v41 = 79;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

uint64_t mlir::mps::LSTMGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(uint64_t *a1)
{
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)*a1 + 40))(*a1) < 6)
    return 1;
  else
    return mlir::DialectBytecodeReader::readSparseArray<int>(*a1, (_DWORD *)a1[1], (const char *)0xA);
}

uint64_t mlir::mps::LSTMGradientOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 16));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 24));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 32));
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 48, 10);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 40));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 48), 10);
  return result;
}

void mlir::mps::LSTMGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, unsigned int a11, unsigned int a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, _BOOL8 a18)
{
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  _BOOL4 v25;
  uint64_t v26;
  __int128 v27;
  mlir::MLIRContext *v28;
  unsigned __int8 **AttributeUniquer;
  uint64_t v30;
  mlir::MLIRContext *v31;
  unsigned __int8 **v32;
  uint64_t v33;
  mlir::MLIRContext *v34;
  unsigned __int8 **v35;
  uint64_t v36;
  mlir::MLIRContext *v37;
  unsigned __int8 **v38;
  uint64_t v39;
  mlir::MLIRContext *v40;
  unsigned __int8 **v41;
  uint64_t v42;
  mlir::MLIRContext *v43;
  unsigned __int8 **v44;
  uint64_t v45;
  uint64_t v46;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v49;
  unint64_t *v50;
  uint64_t v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  unint64_t v68[2];
  unint64_t v69[2];
  _QWORD *v70;
  uint64_t v71;
  _QWORD v72[4];

  v20 = a18;
  v72[2] = *MEMORY[0x1E0C80C00];
  v65 = a4;
  v66 = a3;
  v63 = a6;
  v64 = a5;
  v61 = a14;
  v62 = a13;
  v59 = a16;
  v60 = a15;
  v57 = a18;
  v58 = a17;
  mlir::OperationState::addOperands(a2, (uint64_t)&v66, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v65, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v64, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v63, 1);
  if (a13)
    mlir::OperationState::addOperands(a2, (uint64_t)&v62, 1);
  if (a14)
    mlir::OperationState::addOperands(a2, (uint64_t)&v61, 1);
  if (a15)
    mlir::OperationState::addOperands(a2, (uint64_t)&v60, 1);
  if (a16)
    mlir::OperationState::addOperands(a2, (uint64_t)&v59, 1);
  if (a17)
    mlir::OperationState::addOperands(a2, (uint64_t)&v58, 1);
  if (a18)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v57, 1);
    v20 = v57;
  }
  v21 = v62 != 0;
  v22 = v61 != 0;
  v23 = v60 != 0;
  v24 = v59 != 0;
  v25 = v58 != 0;
  v26 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)&v27 = 0x100000001;
  *((_QWORD *)&v27 + 1) = 0x100000001;
  *(_OWORD *)(v26 + 48) = v27;
  *(_DWORD *)(v26 + 64) = v21;
  *(_DWORD *)(v26 + 68) = v22;
  *(_DWORD *)(v26 + 72) = v23;
  *(_DWORD *)(v26 + 76) = v24;
  *(_DWORD *)(v26 + 80) = v25;
  *(_DWORD *)(v26 + 84) = v20;
  v28 = *a1;
  v67 = a7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v28);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v71 = (uint64_t)v28;
  v30 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v67);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v30;
  v31 = *a1;
  v67 = a8;
  v32 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v31);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v71 = (uint64_t)v31;
  v33 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v32, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v67);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v33;
  v34 = *a1;
  v67 = a9;
  v35 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v34);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v71 = (uint64_t)v34;
  v36 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v35, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v67);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 40) = v36;
  v37 = *a1;
  v67 = a10;
  v38 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v37);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v71 = (uint64_t)v37;
  v39 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v38, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v67);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v39;
  v40 = *a1;
  v67 = a11;
  v41 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v40);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v71 = (uint64_t)v40;
  v42 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v41, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v67);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v42;
  v43 = *a1;
  v67 = a12;
  v44 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v43);
  v70 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v71 = (uint64_t)v43;
  v45 = mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v44, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v70, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v67);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v45;
  v70 = v72;
  v71 = 0x200000000;
  v46 = *(_QWORD *)a2;
  mlir::ValueRange::ValueRange(v69, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v49 = *(__int128 **)(a2 + 256);
  v50 = mlir::ValueRange::ValueRange(v68, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::LSTMGradientOp::inferReturnTypes((uint64_t)v50, v46, 1, v69[0], v69[1], Dictionary, v49, v51, v68[0], v68[1], (uint64_t)&v70))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v52 = v70;
  v53 = v71;
  v54 = *(unsigned int *)(a2 + 72);
  if (v54 + (unint64_t)v71 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v54 + v71, 8);
    LODWORD(v54) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v53)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v54), v52, 8 * v53);
    LODWORD(v54) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v54 + v53;
  if (v70 != v72)
    free(v70);
}

mlir::MLIRContext *mlir::mps::LSTMGradientOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  unsigned __int8 **AttributeUniquer;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  unsigned __int8 **v10;
  unsigned int v11;
  void *v12;
  mlir::MLIRContext *v13;

  v12 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v4 = result;
  if (a2[3])
  {
    if (a2[1])
      goto LABEL_3;
  }
  else
  {
    v11 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v13 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
    a2[3] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[5])
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  v11 = 3;
  v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[1] = result;
  if (a2[5])
  {
LABEL_4:
    if (a2[4])
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  v11 = 2;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[5] = result;
  if (a2[4])
  {
LABEL_5:
    if (*a2)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  v11 = 3;
  v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[4] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[2])
      return result;
LABEL_13:
    v11 = 0;
    v10 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
    v13 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v10, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v11);
    a2[2] = result;
    return result;
  }
LABEL_12:
  v11 = 2;
  v9 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v9, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  *a2 = result;
  if (!a2[2])
    goto LABEL_13;
  return result;
}

uint64_t mlir::mps::LSTMGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t ODSOperands;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  unint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t *v43;
  unint64_t v44;
  unsigned int v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t *v49;
  unint64_t v50;
  unsigned int v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t *v55;
  unint64_t v56;
  unsigned int v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  uint64_t *v61;
  unint64_t v62;
  unsigned int v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t *v67;
  const void **v68;
  unsigned int v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t *v77;
  unint64_t v78;
  unsigned int v79;
  uint64_t ODSResults;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t NextResultAtOffset;
  uint64_t *v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t *v94;
  unint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t *v102;
  unint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v118;
  const void **v119[4];
  __int16 v120;
  unsigned int v121;
  _QWORD v122[25];

  v122[24] = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  v5 = v3[1];
  v7 = v3[2];
  v6 = v3[3];
  v8 = v3[4];
  v9 = v3[5];
  v122[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v6, (const void **)"igate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v122[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v5, (const void **)"fgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v122[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v122[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v122[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v4, (const void **)"cell_activation", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v122[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v7, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v122))return 0;
  v121 = 0;
  v10 = *((unsigned int *)*this + 11);
  v11 = (uint64_t)&(*this)[2 * ((v10 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v11 = 0;
  v12 = *(unsigned int *)(v11 + 48);
  if ((v10 & 0x800000) != 0)
  {
    v13 = (*this)[9];
    if ((_DWORD)v12)
      goto LABEL_14;
  }
  else
  {
    v13 = 0;
    if ((_DWORD)v12)
    {
LABEL_14:
      v14 = v13 + 24;
      do
      {
        v15 = *this;
        v16 = *(_QWORD *)(*(_QWORD *)v14 + 8) & 0xFFFFFFFFFFFFFFF8;
        v17 = v121++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v15, v16, (const void **)"operand", (const void **)7, v17))return 0;
        v14 += 32;
      }
      while (--v12);
    }
  }
  ODSOperands = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 1u);
  if (v19)
  {
    v20 = v19;
    v21 = ODSOperands + 24;
    do
    {
      v22 = *this;
      v23 = *(_QWORD *)(*(_QWORD *)v21 + 8) & 0xFFFFFFFFFFFFFFF8;
      v24 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v22, v23, (const void **)"operand", (const void **)7, v24))return 0;
      v21 += 32;
    }
    while (--v20);
  }
  v25 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 2u);
  if (v26)
  {
    v27 = v26;
    v28 = v25 + 24;
    do
    {
      v29 = *this;
      v30 = *(_QWORD *)(*(_QWORD *)v28 + 8) & 0xFFFFFFFFFFFFFFF8;
      v31 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v29, v30, (const void **)"operand", (const void **)7, v31))return 0;
      v28 += 32;
    }
    while (--v27);
  }
  v32 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 3u);
  if (v33)
  {
    v34 = v33;
    v35 = v32 + 24;
    do
    {
      v36 = *this;
      v37 = *(_QWORD *)(*(_QWORD *)v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      v38 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38))return 0;
      v35 += 32;
    }
    while (--v34);
  }
  v39 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 4u);
  v41 = v40;
  if (v40 >= 2)
    goto LABEL_45;
  if (v40)
  {
    v42 = *(_QWORD *)(v39 + 24);
    v43 = *this;
    v44 = *(_QWORD *)(v42 + 8) & 0xFFFFFFFFFFFFFFF8;
    v45 = v121++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v43, v44, (const void **)"operand", (const void **)7, v45))return 0;
  }
  v46 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 5u);
  v41 = v47;
  if (v47 < 2)
  {
    if (v47)
    {
      v48 = *(_QWORD *)(v46 + 24);
      v49 = *this;
      v50 = *(_QWORD *)(v48 + 8) & 0xFFFFFFFFFFFFFFF8;
      v51 = v121++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v49, v50, (const void **)"operand", (const void **)7, v51))return 0;
    }
    v52 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 6u);
    v41 = v53;
    if (v53 < 2)
    {
      if (v53)
      {
        v54 = *(_QWORD *)(v52 + 24);
        v55 = *this;
        v56 = *(_QWORD *)(v54 + 8) & 0xFFFFFFFFFFFFFFF8;
        v57 = v121++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v55, v56, (const void **)"operand", (const void **)7, v57))return 0;
      }
      v58 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 7u);
      v41 = v59;
      if (v59 < 2)
      {
        if (v59)
        {
          v60 = *(_QWORD *)(v58 + 24);
          v61 = *this;
          v62 = *(_QWORD *)(v60 + 8) & 0xFFFFFFFFFFFFFFF8;
          v63 = v121++;
          if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v61, v62, (const void **)"operand", (const void **)7, v63))return 0;
        }
        v64 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 8u);
        v41 = v65;
        if (v65 < 2)
        {
          if (!v65
            || (v66 = *(_QWORD *)(v64 + 24),
                v67 = *this,
                v68 = (const void **)(*(_QWORD *)(v66 + 8) & 0xFFFFFFFFFFFFFFF8),
                v69 = v121,
                ++v121,
                mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(v67, v68, (const void **)"operand", 7, v69)))
          {
            v70 = mlir::mps::GRUGradientOp::getODSOperands((mlir::mps::GRUGradientOp *)this, 9u);
            v41 = v71;
            if (v71 >= 2)
              goto LABEL_45;
            if (!v71
              || (v76 = *(_QWORD *)(v70 + 24),
                  v77 = *this,
                  v78 = *(_QWORD *)(v76 + 8) & 0xFFFFFFFFFFFFFFF8,
                  v79 = v121,
                  ++v121,
                  mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v77, v78, (const void **)"operand", (const void **)7, v79)))
            {
              v121 = 0;
              ODSResults = mlir::mps::LSTMGradientOp::getODSResults((mlir::mps::LSTMGradientOp *)this, 0);
              if (v81)
              {
                v82 = ODSResults;
                v83 = v81;
                v84 = 0;
                while (1)
                {
                  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v82, v84);
                  v86 = *this;
                  v87 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
                  v121 = v84 + 1;
                  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v86, v87, (const void **)"result", (const void **)6, v84))break;
                  if (v83 == ++v84)
                    goto LABEL_57;
                }
              }
              else
              {
                LODWORD(v84) = 0;
LABEL_57:
                v88 = mlir::mps::LSTMGradientOp::getODSResults((mlir::mps::LSTMGradientOp *)this, 1u);
                if (v89)
                {
                  v90 = v88;
                  v91 = v89;
                  v92 = 0;
                  while (1)
                  {
                    v93 = mlir::detail::OpResultImpl::getNextResultAtOffset(v90, v92);
                    v94 = *this;
                    v95 = *(_QWORD *)(v93 + 8) & 0xFFFFFFFFFFFFFFF8;
                    v121 = v84 + v92 + 1;
                    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v94, v95, (const void **)"result", (const void **)6, (int)v84 + (int)v92))break;
                    if (v91 == ++v92)
                    {
                      LODWORD(v84) = v84 + v92;
                      goto LABEL_62;
                    }
                  }
                }
                else
                {
LABEL_62:
                  v96 = mlir::mps::LSTMGradientOp::getODSResults((mlir::mps::LSTMGradientOp *)this, 2u);
                  if (v97)
                  {
                    v98 = v96;
                    v99 = v97;
                    v100 = 0;
                    while (1)
                    {
                      v101 = mlir::detail::OpResultImpl::getNextResultAtOffset(v98, v100);
                      v102 = *this;
                      v103 = *(_QWORD *)(v101 + 8) & 0xFFFFFFFFFFFFFFF8;
                      v121 = v84 + v100 + 1;
                      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v102, v103, (const void **)"result", (const void **)6, (int)v84 + (int)v100))break;
                      if (v99 == ++v100)
                      {
                        LODWORD(v84) = v84 + v100;
                        goto LABEL_67;
                      }
                    }
                  }
                  else
                  {
LABEL_67:
                    v104 = mlir::mps::LSTMGradientOp::getODSResults((mlir::mps::LSTMGradientOp *)this, 3u);
                    if (v105)
                    {
                      v106 = v104;
                      v107 = v105;
                      v108 = 0;
                      while (1)
                      {
                        v109 = mlir::detail::OpResultImpl::getNextResultAtOffset(v106, v108);
                        v110 = *this;
                        v111 = *(_QWORD *)(v109 + 8) & 0xFFFFFFFFFFFFFFF8;
                        v121 = v84 + v108 + 1;
                        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v110, v111, (const void **)"result", (const void **)6, (int)v84 + (int)v108))break;
                        if (v107 == ++v108)
                        {
                          LODWORD(v84) = v84 + v108;
                          goto LABEL_72;
                        }
                      }
                    }
                    else
                    {
LABEL_72:
                      v112 = mlir::mps::LSTMGradientOp::getODSResults((mlir::mps::LSTMGradientOp *)this, 4u);
                      v114 = v113;
                      if (v113 >= 2)
                      {
                        v119[0] = (const void **)"result group starting at #";
                        v120 = 259;
                        mlir::OpState::emitOpError(this, v119, (uint64_t)v122);
                        v115 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v122, &v121);
                        v73 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v115, " requires 0 or 1 element, but found ");
                        v118 = v114;
                        goto LABEL_46;
                      }
                      if (!v113)
                        return 1;
                      v116 = mlir::detail::OpResultImpl::getNextResultAtOffset(v112, 0);
                      if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(v116 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v84))return 1;
                    }
                  }
                }
              }
            }
          }
          return 0;
        }
      }
    }
  }
LABEL_45:
  v119[0] = (const void **)"operand group starting at #";
  v120 = 259;
  mlir::OpState::emitOpError(this, v119, (uint64_t)v122);
  v72 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v122, &v121);
  v73 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v72, " requires 0 or 1 element, but found ");
  v118 = v41;
LABEL_46:
  v74 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v73, &v118);
  v75 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v74);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v122);
  return v75;
}

uint64_t mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(uint64_t *a1, const void **a2, const void **a3, uint64_t a4, unsigned int a5)
{
  const void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  const void ***v27;
  char *v28;
  char *v29;
  __int128 v30;
  const void ***v31;
  char *v32;
  char *v33;
  __int128 v34;
  _QWORD **v35;
  _QWORD **v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  void *v41;
  void *v42;
  unint64_t v44;
  unint64_t v45;
  BOOL v46;
  unint64_t v47;
  BOOL v48;
  unint64_t v49;
  int64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  const void **v54;
  uint64_t v55;
  __int16 v56;
  _QWORD v57[2];
  uint64_t OperandRange;
  const void **v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD v62[3];
  void *v63;
  unsigned int v64;
  unsigned int v65;
  _BYTE v66[96];
  void *v67;
  _QWORD *v68;
  void *__p;
  _QWORD **v70;
  char v71;
  uint64_t v72;

  v72 = *MEMORY[0x1E0C80C00];
  v10 = *a2;
  if (*((_UNKNOWN **)*a2 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    goto LABEL_17;
  v62[0] = a2;
  v62[1] = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v10 + 8);
  if (!mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)v62))
    goto LABEL_17;
  v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
  v54 = a2;
  v55 = v11;
  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v54);
  if (v12)
  {
    v13 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
    v59 = a2;
    v60 = v13;
    mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v59);
    if (v14 != 1)
      goto LABEL_17;
  }
  v15 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*a2 + 8);
  v57[0] = a2;
  v57[1] = v15;
  OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v57);
  if (mlir::Type::isF16((mlir::Type *)&OperandRange)
    || mlir::Type::isF32((mlir::Type *)&OperandRange)
    || mlir::Type::isBF16((mlir::Type *)&OperandRange)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 8)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 16)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 32)
    || mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
  {
    return 1;
  }
LABEL_17:
  v56 = 261;
  v54 = a3;
  v55 = a4;
  mlir::Operation::emitOpError(a1, &v54, (uint64_t)v62);
  if (v62[0])
  {
    LODWORD(v59) = 3;
    v60 = (uint64_t)" #";
    v61 = 2;
    v17 = &v59;
    v18 = (char *)v63;
    if (v64 >= v65)
    {
      v44 = v64 + 1;
      if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
      {
        v50 = (char *)&v59 - (_BYTE *)v63;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v44, 24);
        v18 = (char *)v63;
        v17 = (const void ***)((char *)v63 + v50);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v44, 24);
        v17 = &v59;
        v18 = (char *)v63;
      }
    }
    v19 = &v18[24 * v64];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    v21 = ++v64;
    if (v62[0])
    {
      LODWORD(v59) = 5;
      v60 = a5;
      v22 = &v59;
      v23 = (char *)v63;
      if (v21 >= v65)
      {
        v45 = v21 + 1;
        v46 = (char *)v63 + 24 * v21 > (char *)&v59;
        if (v63 <= &v59 && v46)
        {
          v51 = (char *)&v59 - (_BYTE *)v63;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
          v23 = (char *)v63;
          v22 = (const void ***)((char *)v63 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v45, 24);
          v22 = &v59;
          v23 = (char *)v63;
        }
      }
      v24 = &v23[24 * v64];
      v25 = *(_OWORD *)v22;
      *((_QWORD *)v24 + 2) = v22[2];
      *(_OWORD *)v24 = v25;
      v26 = ++v64;
      if (v62[0])
      {
        LODWORD(v59) = 3;
        v60 = (uint64_t)" must be 0D/1D tensor of floating point or int values, but got ";
        v61 = 63;
        v27 = &v59;
        v28 = (char *)v63;
        if (v26 >= v65)
        {
          v47 = v26 + 1;
          v48 = (char *)v63 + 24 * v26 > (char *)&v59;
          if (v63 <= &v59 && v48)
          {
            v52 = (char *)&v59 - (_BYTE *)v63;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v47, 24);
            v28 = (char *)v63;
            v27 = (const void ***)((char *)v63 + v52);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v47, 24);
            v27 = &v59;
            v28 = (char *)v63;
          }
        }
        v29 = &v28[24 * v64];
        v30 = *(_OWORD *)v27;
        *((_QWORD *)v29 + 2) = v27[2];
        *(_OWORD *)v29 = v30;
        ++v64;
        if (v62[0])
        {
          v31 = &v59;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v59, (uint64_t)a2);
          v32 = (char *)v63;
          if (v64 >= v65)
          {
            v49 = v64 + 1;
            if (v63 <= &v59 && (char *)v63 + 24 * v64 > (char *)&v59)
            {
              v53 = (char *)&v59 - (_BYTE *)v63;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v49, 24);
              v32 = (char *)v63;
              v31 = (const void ***)((char *)v63 + v53);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v63, v66, v49, 24);
              v31 = &v59;
              v32 = (char *)v63;
            }
          }
          v33 = &v32[24 * v64];
          v34 = *(_OWORD *)v31;
          *((_QWORD *)v33 + 2) = v31[2];
          *(_OWORD *)v33 = v34;
          ++v64;
        }
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v62);
  if (v62[0])
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v62);
  if (v71)
  {
    v35 = (_QWORD **)__p;
    if (__p)
    {
      v36 = v70;
      v37 = __p;
      if (v70 != __p)
      {
        do
          v36 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v36 - 1);
        while (v36 != v35);
        v37 = __p;
      }
      v70 = v35;
      operator delete(v37);
    }
    v38 = v67;
    if (v67)
    {
      v39 = v68;
      v40 = v67;
      if (v68 != v67)
      {
        do
        {
          v42 = (void *)*--v39;
          v41 = v42;
          *v39 = 0;
          if (v42)
            operator delete[](v41);
        }
        while (v39 != v38);
        v40 = v67;
      }
      v68 = v38;
      operator delete(v40);
    }
    if (v63 != v66)
      free(v63);
  }
  return v16;
}

uint64_t mlir::mps::LSTMOp::getAsmResultNames(uint64_t *a1, void (*a2)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a3)
{
  uint64_t v5;
  uint64_t NextResultAtOffset;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t result;
  uint64_t v15;

  if (*(_DWORD *)(*a1 + 36))
    v5 = *a1 - 16;
  else
    v5 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v5, 0);
  a2(a3, NextResultAtOffset, "result", 6);
  if (*(_DWORD *)(*a1 + 36))
    v7 = *a1 - 16;
  else
    v7 = 0;
  v8 = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 1);
  v9 = mlir::detail::OpResultImpl::getNextResultAtOffset(v8, 0);
  a2(a3, v9, "output_cell", 11);
  v10 = *a1;
  v11 = *(_DWORD *)(*a1 + 36);
  v12 = v10 - 16;
  if (v11)
    v13 = v12;
  else
    v13 = 0;
  result = mlir::detail::OpResultImpl::getNextResultAtOffset(v13, 2);
  if (v11 != 2)
  {
    v15 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a2)(a3, v15, "training_state", 14);
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::getODSResults(mlir::mps::LSTMOp *this, unsigned int a2)
{
  int v2;
  unsigned int v3;
  int32x4_t v4;
  int32x4_t v5;
  uint32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  unsigned int v9;
  int32x4_t v10;
  int v11;
  uint64_t result;

  if (a2)
  {
    if (a2 >= 8)
    {
      v4 = (int32x4_t)xmmword_181235170;
      v3 = a2 & 0xFFFFFFF8;
      v5 = 0uLL;
      v6.i64[0] = 0x100000001;
      v6.i64[1] = 0x100000001;
      v7.i64[0] = 0x300000003;
      v7.i64[1] = 0x300000003;
      v8.i64[0] = 0x800000008;
      v8.i64[1] = 0x800000008;
      v9 = a2 & 0xFFFFFFF8;
      v10 = 0uLL;
      do
      {
        v5 = vsubq_s32(v5, (int32x4_t)vcgtq_u32((uint32x4_t)v4, v6));
        v10 = vsubq_s32(v10, (int32x4_t)vmvnq_s8((int8x16_t)vceqq_s32((int32x4_t)(*(_OWORD *)&v4 & __PAIR128__(0xFFFFFFFEFFFFFFFELL, 0xFFFFFFFEFFFFFFFELL)), v7)));
        v4 = vaddq_s32(v4, v8);
        v9 -= 8;
      }
      while (v9);
      v2 = vaddvq_s32(vaddq_s32(v10, v5));
      if (v3 == a2)
        goto LABEL_11;
    }
    else
    {
      v2 = 0;
      v3 = 0;
    }
    do
    {
      if (v3 > 1)
        ++v2;
      ++v3;
    }
    while (a2 != v3);
  }
  else
  {
    v2 = 0;
  }
LABEL_11:
  v11 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v11)
    result = *(_QWORD *)this - 16;
  else
    result = 0;
  if (a2 + (v11 - 3) * v2)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(result, a2 + (v11 - 3) * v2);
  return result;
}

uint64_t mlir::mps::LSTMOp::getCellClip(mlir::mps::LSTMOp *this)
{
  unint64_t v1;
  _DWORD *v2;
  int v3;
  uint64_t v4;

  v1 = *(unsigned int *)(*(_QWORD *)this + 44);
  v2 = (_DWORD *)(*(_QWORD *)this + 16 * ((v1 >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(*(_QWORD *)this + 44)))
    v2 = 0;
  v3 = v2[20];
  if ((v1 & 0x800000) != 0)
  {
    v4 = *(_QWORD *)(*(_QWORD *)this + 72);
    if (v3)
      return *(_QWORD *)(v4 + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14]) + 24);
  }
  else
  {
    v4 = 0;
    if (v3)
      return *(_QWORD *)(v4 + 32 * (v2[19] + v2[18] + v2[17] + v2[16] + v2[15] + v2[14]) + 24);
  }
  return 0;
}

uint64_t mlir::mps::LSTMOp::getTrainingState(mlir::mps::LSTMOp *this)
{
  int v1;
  uint64_t v2;
  uint64_t NextResultAtOffset;
  uint64_t v4;

  v1 = *(_DWORD *)(*(_QWORD *)this + 36);
  if (v1)
    v2 = *(_QWORD *)this - 16;
  else
    v2 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v2, 2);
  v4 = 0;
  if (v1 != 2)
    return mlir::detail::OpResultImpl::getNextResultAtOffset(NextResultAtOffset, 0);
  return v4;
}

BOOL mlir::mps::LSTMOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  char *v11;
  char *v12;
  __int128 v13;
  uint64_t *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  uint64_t *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  char *v39;
  char *v40;
  __int128 v41;
  uint64_t *v42;
  char *v43;
  char *v44;
  __int128 v45;
  _QWORD **v46;
  _QWORD **v47;
  void *v48;
  _QWORD *v49;
  void *v50;
  void *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  int64_t v66;
  int64_t v67;
  int64_t v68;
  int64_t v69;
  int64_t v70;
  uint64_t v71;
  uint64_t v72;
  const char *v73;
  uint64_t v74;
  _QWORD v75[3];
  void *v76;
  unsigned int v77;
  unsigned int v78;
  _BYTE v79[96];
  void *v80;
  _QWORD *v81;
  void *__p;
  _QWORD **v83;
  char v84;
  uint64_t v85;

  v85 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v71 = v6;
  if (!v6)
  {
    a3(v75, a4);
    if (v75[0])
    {
      LODWORD(v72) = 3;
      v73 = "expected DictionaryAttr to set properties";
      v74 = 41;
      v26 = &v72;
      v27 = (char *)v76;
      if (v77 >= v78)
      {
        v61 = v77 + 1;
        if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
        {
          v66 = (char *)&v72 - (_BYTE *)v76;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          v27 = (char *)v76;
          v26 = (uint64_t *)((char *)v76 + v66);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v61, 24);
          v26 = &v72;
          v27 = (char *)v76;
        }
      }
      v28 = &v27[24 * v77];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = v26[2];
      *(_OWORD *)v28 = v29;
      ++v77;
      if (v75[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
    }
    if (!v84)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v83;
      v32 = __p;
      if (v83 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v83 = v30;
      operator delete(v32);
    }
    v21 = v80;
    if (!v80)
      goto LABEL_64;
    v33 = v81;
    v23 = v80;
    if (v81 == v80)
    {
LABEL_63:
      v81 = v21;
      operator delete(v23);
LABEL_64:
      if (v76 != v79)
        free(v76);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_62:
    v23 = v80;
    goto LABEL_63;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v71, "cell_activation", 0xFuLL);
  if (v8)
  {
    v9 = v8;
    if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        v74 = 60;
        v10 = &v72;
        v11 = (char *)v76;
        if (v77 >= v78)
        {
          v62 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            v67 = (char *)&v72 - (_BYTE *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            v11 = (char *)v76;
            v10 = (uint64_t *)((char *)v76 + v67);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v62, 24);
            v10 = &v72;
            v11 = (char *)v76;
          }
        }
        v12 = &v11[24 * v77];
        v13 = *(_OWORD *)v10;
        *((_QWORD *)v12 + 2) = v10[2];
        *(_OWORD *)v12 = v13;
        ++v77;
        if (v75[0])
        {
          v14 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v9);
          v15 = (char *)v76;
          if (v77 >= v78)
          {
            v63 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              v68 = (char *)&v72 - (_BYTE *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              v15 = (char *)v76;
              v14 = (uint64_t *)((char *)v76 + v68);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v63, 24);
              v14 = &v72;
              v15 = (char *)v76;
            }
          }
          v16 = &v15[24 * v77];
          v17 = *(_OWORD *)v14;
          *((_QWORD *)v16 + 2) = v14[2];
          *(_OWORD *)v16 = v17;
          ++v77;
          if (v75[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
        }
      }
      if (!v84)
        return 0;
      v18 = (_QWORD **)__p;
      if (__p)
      {
        v19 = v83;
        v20 = __p;
        if (v83 != __p)
        {
          do
            v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
          while (v19 != v18);
          v20 = __p;
        }
        v83 = v18;
        operator delete(v20);
      }
      v21 = v80;
      if (!v80)
        goto LABEL_64;
      v22 = v81;
      v23 = v80;
      if (v81 == v80)
        goto LABEL_63;
      do
      {
        v25 = (void *)*--v22;
        v24 = v25;
        *v22 = 0;
        if (v25)
          operator delete[](v24);
      }
      while (v22 != v21);
      goto LABEL_62;
    }
    *a1 = v8;
  }
  v36 = mlir::DictionaryAttr::get((uint64_t)&v71, "fgate_activation", 0x10uLL);
  if (v36)
  {
    v37 = v36;
    if (*(_UNKNOWN **)(*(_QWORD *)v36 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      if (v75[0])
      {
        LODWORD(v72) = 3;
        v74 = 61;
        v38 = &v72;
        v39 = (char *)v76;
        if (v77 >= v78)
        {
          v64 = v77 + 1;
          if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
          {
            v69 = (char *)&v72 - (_BYTE *)v76;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v39 = (char *)v76;
            v38 = (uint64_t *)((char *)v76 + v69);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v64, 24);
            v38 = &v72;
            v39 = (char *)v76;
          }
        }
        v40 = &v39[24 * v77];
        v41 = *(_OWORD *)v38;
        *((_QWORD *)v40 + 2) = v38[2];
        *(_OWORD *)v40 = v41;
        ++v77;
        if (v75[0])
        {
          v42 = &v72;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v72, v37);
          v43 = (char *)v76;
          if (v77 >= v78)
          {
            v65 = v77 + 1;
            if (v76 <= &v72 && (char *)v76 + 24 * v77 > (char *)&v72)
            {
              v70 = (char *)&v72 - (_BYTE *)v76;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              v43 = (char *)v76;
              v42 = (uint64_t *)((char *)v76 + v70);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v76, v79, v65, 24);
              v42 = &v72;
              v43 = (char *)v76;
            }
          }
          v44 = &v43[24 * v77];
          v45 = *(_OWORD *)v42;
          *((_QWORD *)v44 + 2) = v42[2];
          *(_OWORD *)v44 = v45;
          ++v77;
          if (v75[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v75);
        }
      }
      if (!v84)
        return 0;
      v46 = (_QWORD **)__p;
      if (__p)
      {
        v47 = v83;
        v48 = __p;
        if (v83 != __p)
        {
          do
            v47 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v47 - 1);
          while (v47 != v46);
          v48 = __p;
        }
        v83 = v46;
        operator delete(v48);
      }
      v21 = v80;
      if (!v80)
        goto LABEL_64;
      v49 = v81;
      v23 = v80;
      if (v81 == v80)
        goto LABEL_63;
      do
      {
        v51 = (void *)*--v49;
        v50 = v51;
        *v49 = 0;
        if (v51)
          operator delete[](v50);
      }
      while (v49 != v21);
      goto LABEL_62;
    }
    a1[1] = v36;
  }
  v52 = mlir::DictionaryAttr::get((uint64_t)&v71, "gate_layout", 0xBuLL);
  v72 = v52;
  if (v52)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v52 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
    {
      a3(v75, a4);
LABEL_87:
      mlir::InFlightDiagnostic::append<mlir::Attribute>(v53, &v72);
LABEL_88:
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v75);
      return 0;
    }
    a1[2] = v52;
  }
  v54 = mlir::DictionaryAttr::get((uint64_t)&v71, "igate_activation", 0x10uLL);
  v72 = v54;
  if (v54)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v54 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
LABEL_86:
      v53 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, v55);
      goto LABEL_87;
    }
    a1[3] = v54;
  }
  v56 = mlir::DictionaryAttr::get((uint64_t)&v71, "ogate_activation", 0x10uLL);
  v72 = v56;
  if (v56)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v56 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[4] = v56;
  }
  v57 = mlir::DictionaryAttr::get((uint64_t)&v71, "training", 8uLL);
  v72 = v57;
  if (v57)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v57 + 136) != &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_87;
    }
    a1[5] = v57;
  }
  v58 = mlir::DictionaryAttr::get((uint64_t)&v71, "zgate_activation", 0x10uLL);
  v72 = v58;
  if (v58)
  {
    if (*(_UNKNOWN **)(*(_QWORD *)v58 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
    {
      a3(v75, a4);
      goto LABEL_86;
    }
    a1[6] = v58;
  }
  v60 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v71, "operandSegmentSizes", 0x13uLL);
  if (!v60)
  {
    v60 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v71, "operand_segment_sizes", 0x15uLL);
    if (!v60)
    {
      a3(v75, a4);
      mlir::InFlightDiagnostic::operator<<<char const(&)[44]>((uint64_t)v75, "expected key entry for operandSegmentSizes in DictionaryAttr to set Properties.");
      goto LABEL_88;
    }
  }
  return mlir::convertFromAttribute(a1 + 7, (const char *)7, v60, a3, a4) != 0;
}

uint64_t mlir::mps::LSTMOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  unsigned int v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int v49;
  uint64_t *v50;
  BOOL v51;
  uint64_t v52;
  uint64_t DictionaryAttr;
  void *v54;
  mlir::DictionaryAttr *v56;
  void *v57;
  uint64_t v58;
  _QWORD v59[7];

  v59[6] = *MEMORY[0x1E0C80C00];
  v56 = a1;
  v57 = v59;
  v58 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v56, (uint64_t)"cell_activation", 15, *a2);
    v6 = v5;
    v7 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v7 = v58;
    }
    v8 = (uint64_t *)((char *)v57 + 16 * v7);
    *v8 = NamedAttr;
    v8[1] = v6;
    LODWORD(v58) = v58 + 1;
  }
  v9 = a2[1];
  if (v9)
  {
    v10 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"fgate_activation", 16, v9);
    v12 = v11;
    v13 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v13 = v58;
    }
    v14 = (uint64_t *)((char *)v57 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    LODWORD(v58) = v58 + 1;
  }
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"gate_layout", 11, v15);
    v18 = v17;
    v19 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v19 = v58;
    }
    v20 = (uint64_t *)((char *)v57 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    LODWORD(v58) = v58 + 1;
  }
  v21 = a2[3];
  if (v21)
  {
    v22 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"igate_activation", 16, v21);
    v24 = v23;
    v25 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v25 = v58;
    }
    v26 = (uint64_t *)((char *)v57 + 16 * v25);
    *v26 = v22;
    v26[1] = v24;
    LODWORD(v58) = v58 + 1;
  }
  v27 = a2[4];
  if (v27)
  {
    v28 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"ogate_activation", 16, v27);
    v30 = v29;
    v31 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v31 = v58;
    }
    v32 = (uint64_t *)((char *)v57 + 16 * v31);
    *v32 = v28;
    v32[1] = v30;
    LODWORD(v58) = v58 + 1;
  }
  v33 = a2[5];
  if (v33)
  {
    v34 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"training", 8, v33);
    v36 = v35;
    v37 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v37 = v58;
    }
    v38 = (uint64_t *)((char *)v57 + 16 * v37);
    *v38 = v34;
    v38[1] = v36;
    LODWORD(v58) = v58 + 1;
  }
  v39 = a2[6];
  if (v39)
  {
    v40 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"zgate_activation", 16, v39);
    v42 = v41;
    v43 = v58;
    if (v58 >= HIDWORD(v58))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
      v43 = v58;
    }
    v44 = (uint64_t *)((char *)v57 + 16 * v43);
    *v44 = v40;
    v44[1] = v42;
    LODWORD(v58) = v58 + 1;
  }
  v45 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);
  v46 = mlir::Builder::getNamedAttr(&v56, (uint64_t)"operandSegmentSizes", 19, v45);
  v48 = v47;
  v49 = v58;
  if (v58 >= HIDWORD(v58))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v57, v59, v58 + 1, 16);
    v49 = v58;
  }
  v50 = (uint64_t *)((char *)v57 + 16 * v49);
  *v50 = v46;
  v50[1] = v48;
  v51 = __CFADD__((_DWORD)v58, 1);
  v52 = (v58 + 1);
  LODWORD(v58) = v58 + 1;
  if (v51)
  {
    DictionaryAttr = 0;
    v54 = v57;
    if (v57 == v59)
      return DictionaryAttr;
    goto LABEL_36;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v56, (mlir::MLIRContext *)v57, v52);
  v54 = v57;
  if (v57 != v59)
LABEL_36:
    free(v54);
  return DictionaryAttr;
}

unint64_t mlir::mps::LSTMOp::computePropertiesHash(unint64_t *a1)
{
  unint64_t v1;
  unsigned __int8 v2;
  uint64_t *v3;
  uint64_t v4;
  unint64_t v5;
  unsigned __int8 v6;
  uint64_t v7;
  unint64_t v8;
  unsigned __int8 v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  int v35;
  int v36;
  unint64_t v37;
  int v38;
  int v39;
  unint64_t v40;
  int v41;
  int v42;
  unint64_t v43;
  int v44;
  int v45;
  unint64_t v46;
  int v47;
  int v48;
  unint64_t v49;
  int v50;
  int v51;
  unint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  int v56;
  int v57;
  unint64_t v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t *v89;
  unint64_t *v90;
  unint64_t *v91;
  unint64_t *v92;
  unint64_t *v93;
  unint64_t *v94;
  unint64_t *v95;
  unint64_t *v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  __int128 v112;
  _OWORD v113[3];
  _OWORD v114[3];
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  v1 = *a1;
  v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v2 & 1) == 0)
  {
    v89 = a1;
    v97 = *a1;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v35;
    a1 = v89;
    v1 = v97;
    if (v36)
    {
      v37 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v37 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v37;
      a1 = v89;
      v1 = v97;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v4 = v3[19];
  v5 = a1[1];
  if ((v6 & 1) == 0)
  {
    v90 = a1;
    v98 = v1;
    v73 = v3[19];
    v81 = a1[1];
    v4 = v73;
    v5 = v81;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v39 = v38;
    a1 = v90;
    v1 = v98;
    if (v39)
    {
      v40 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v40 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v40;
      v4 = v73;
      v5 = v81;
      a1 = v90;
      v1 = v98;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v7 = v3[19];
  v8 = a1[2];
  if ((v9 & 1) == 0)
  {
    v91 = a1;
    v99 = v1;
    v74 = v4;
    v82 = v5;
    v61 = a1[2];
    v66 = v3[19];
    v8 = v61;
    v7 = v66;
    v4 = v74;
    v5 = v82;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v42 = v41;
    a1 = v91;
    v1 = v99;
    if (v42)
    {
      v43 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v43 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v43;
      v8 = v61;
      v7 = v66;
      v4 = v74;
      v5 = v82;
      a1 = v91;
      v1 = v99;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v10 = HIDWORD(v8);
  v11 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v8) ^ HIDWORD(v8));
  v111 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) ^ ((0x9DDFEA08EB382D69 * (v10 ^ (v11 >> 47) ^ v11)) >> 47));
  v12 = a1[3];
  if ((v10 & 1) == 0)
  {
    v92 = a1;
    v100 = v1;
    v75 = v4;
    v83 = v5;
    v62 = a1[3];
    v67 = v7;
    v12 = v62;
    v7 = v67;
    v4 = v75;
    v5 = v83;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v92;
    v1 = v100;
    if (v45)
    {
      v46 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v46 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v46;
      v12 = v62;
      v7 = v67;
      v4 = v75;
      v5 = v83;
      a1 = v92;
      v1 = v100;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v13 = HIDWORD(v12);
  v14 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v12) ^ HIDWORD(v12));
  v110 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) ^ ((0x9DDFEA08EB382D69 * (v13 ^ (v14 >> 47) ^ v14)) >> 47));
  v15 = a1[4];
  if ((v13 & 1) == 0)
  {
    v93 = a1;
    v101 = v1;
    v76 = v4;
    v84 = v5;
    v63 = a1[4];
    v68 = v7;
    v15 = v63;
    v7 = v68;
    v4 = v76;
    v5 = v84;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v48 = v47;
    a1 = v93;
    v1 = v101;
    if (v48)
    {
      v49 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v49 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v49;
      v15 = v63;
      v7 = v68;
      v4 = v76;
      v5 = v84;
      a1 = v93;
      v1 = v101;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v16 = HIDWORD(v15);
  v17 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v15) ^ HIDWORD(v15));
  v109 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) ^ ((0x9DDFEA08EB382D69 * (v16 ^ (v17 >> 47) ^ v17)) >> 47));
  v18 = a1[5];
  if ((v16 & 1) == 0)
  {
    v94 = a1;
    v102 = v1;
    v77 = v4;
    v85 = v5;
    v64 = a1[5];
    v69 = v7;
    v18 = v64;
    v7 = v69;
    v4 = v77;
    v5 = v85;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v51 = v50;
    a1 = v94;
    v1 = v102;
    if (v51)
    {
      v52 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v52 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v52;
      v18 = v64;
      v7 = v69;
      v4 = v77;
      v5 = v85;
      a1 = v94;
      v1 = v102;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v19 = HIDWORD(v18);
  v20 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v18) ^ HIDWORD(v18));
  v108 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) ^ ((0x9DDFEA08EB382D69 * (v19 ^ (v20 >> 47) ^ v20)) >> 47));
  v21 = a1[6];
  if ((v19 & 1) == 0)
  {
    v95 = a1;
    v103 = v1;
    v78 = v4;
    v86 = v5;
    v65 = a1[6];
    v70 = v7;
    v21 = v65;
    v7 = v70;
    v4 = v78;
    v5 = v86;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    a1 = v95;
    v1 = v103;
    if (v54)
    {
      v55 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v55 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v55;
      v21 = v65;
      v7 = v70;
      v4 = v78;
      v5 = v86;
      a1 = v95;
      v1 = v103;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v22 = HIDWORD(v21);
  v23 = 0x9DDFEA08EB382D69 * ((v3[19] + 8 * v21) ^ HIDWORD(v21));
  v107 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) ^ ((0x9DDFEA08EB382D69 * (v22 ^ (v23 >> 47) ^ v23)) >> 47));
  if ((v22 & 1) == 0)
  {
    v96 = a1;
    v104 = v1;
    v79 = v4;
    v87 = v5;
    v71 = v7;
    v7 = v71;
    v4 = v79;
    v1 = v104;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v57 = v56;
    v5 = v87;
    a1 = v96;
    if (v57)
    {
      v58 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v58 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v58;
      v7 = v71;
      v4 = v79;
      v5 = v87;
      a1 = v96;
      v1 = v104;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v24 = v3[19];
  v25 = a1[8];
  v26 = 0xB492B66FBE98F273 * a1[7];
  v27 = 0x9AE16A3B2F90404FLL * *(unint64_t *)((char *)a1 + 76);
  v28 = __ROR8__(v26 - v25, 43)
      - 0x3C5A37A36834CED9 * *(unint64_t *)((char *)a1 + 68)
      + __ROR8__(v27 ^ v24, 30);
  v29 = v24 + __ROR8__(v25 ^ 0xC949D7C7509E6557, 20) + v26 - v27 + 28;
  v106 = 0x9DDFEA08EB382D69
       * ((0x9DDFEA08EB382D69
         * (v29 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v29)))) ^ ((0x9DDFEA08EB382D69 * (v29 ^ ((0x9DDFEA08EB382D69 * (v28 ^ v29)) >> 47) ^ (0x9DDFEA08EB382D69 * (v28 ^ v29)))) >> 47));
  v115 = 0;
  memset(v114, 0, sizeof(v114));
  memset(v113, 0, sizeof(v113));
  v112 = 0u;
  if ((v29 & 1) == 0)
  {
    v105 = v1;
    v80 = v4;
    v88 = v5;
    v72 = v7;
    v7 = v72;
    v4 = v80;
    v5 = v88;
    v1 = v105;
    v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    if (v59)
    {
      v60 = llvm::hashing::detail::fixed_seed_override;
      if (!llvm::hashing::detail::fixed_seed_override)
        v60 = 0xFF51AFD7ED558CCDLL;
      llvm::hashing::detail::get_execution_seed(void)::seed = v60;
      v7 = v72;
      v4 = v80;
      v5 = v88;
      v1 = v105;
      v3 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    }
  }
  v30 = 0x9DDFEA08EB382D69 * ((v7 + 8 * v5) ^ HIDWORD(v5));
  v31 = 0x9DDFEA08EB382D69 * (HIDWORD(v5) ^ (v30 >> 47) ^ v30);
  v32 = HIDWORD(v1);
  v33 = 0x9DDFEA08EB382D69 * ((v4 + 8 * v1) ^ HIDWORD(v1));
  v116 = v3[19];
  *(_QWORD *)&v112 = 0x9DDFEA08EB382D69
                   * ((0x9DDFEA08EB382D69 * (v32 ^ (v33 >> 47) ^ v33)) ^ ((0x9DDFEA08EB382D69
                                                                           * (v32 ^ (v33 >> 47) ^ v33)) >> 47));
  *((_QWORD *)&v112 + 1) = 0x9DDFEA08EB382D69 * (v31 ^ (v31 >> 47));
  return llvm::hashing::detail::hash_combine_recursive_helper::combine<llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code,llvm::hash_code>((llvm::hashing::detail::hash_combine_recursive_helper *)&v112, 0, v113, (char *)v114, (uint64_t *)&v111, (uint64_t *)&v110, (uint64_t *)&v109, (uint64_t *)&v108, (uint64_t *)&v107, (uint64_t *)&v106);
}

uint64_t mlir::mps::LSTMOp::getInherentAttr(mlir::MLIRContext *a1, _QWORD *a2, char *__s1, size_t __n)
{
  uint64_t result;

  result = 0;
  switch(__n)
  {
    case 8uLL:
      if (memcmp(__s1, "training", __n))
        goto LABEL_21;
      return a2[5];
    case 9uLL:
    case 0xAuLL:
    case 0xCuLL:
    case 0xDuLL:
    case 0xEuLL:
    case 0x11uLL:
    case 0x12uLL:
    case 0x14uLL:
      goto LABEL_21;
    case 0xBuLL:
      if (memcmp(__s1, "gate_layout", __n))
        goto LABEL_21;
      return a2[2];
    case 0xFuLL:
      if (*(_QWORD *)__s1 != 0x7463615F6C6C6563 || *(_QWORD *)(__s1 + 7) != 0x6E6F697461766974)
        goto LABEL_21;
      return *a2;
    case 0x10uLL:
      if (!memcmp(__s1, "fgate_activation", __n))
      {
        result = a2[1];
      }
      else if (!memcmp(__s1, "igate_activation", __n))
      {
        result = a2[3];
      }
      else if (*(_QWORD *)__s1 == 0x63615F657461676FLL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
      {
        result = a2[4];
      }
      else if (!memcmp(__s1, "zgate_activation", __n))
      {
        result = a2[6];
      }
      else
      {
LABEL_21:
        result = 0;
      }
      break;
    case 0x13uLL:
      if (memcmp(__s1, "operandSegmentSizes", __n))
        goto LABEL_21;
      goto LABEL_23;
    case 0x15uLL:
      if (memcmp(__s1, "operand_segment_sizes", __n))
        goto LABEL_21;
LABEL_23:
      result = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::setInherentAttr(uint64_t result, char *__s1, size_t __n, _QWORD *a4)
{
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v10;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;

  v7 = (_QWORD *)result;
  switch(__n)
  {
    case 8uLL:
      result = memcmp(__s1, "training", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
            v15 = a4;
          else
            v15 = 0;
          v7[5] = v15;
        }
        else
        {
          v7[5] = 0;
        }
      }
      break;
    case 0xBuLL:
      result = memcmp(__s1, "gate_layout", __n);
      if (!(_DWORD)result)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id)
            v8 = a4;
          else
            v8 = 0;
          v7[2] = v8;
        }
        else
        {
          v7[2] = 0;
        }
      }
      break;
    case 0xFuLL:
      if (*(_QWORD *)__s1 == 0x7463615F6C6C6563 && *(_QWORD *)(__s1 + 7) == 0x6E6F697461766974)
      {
        if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v10 = a4;
          else
            v10 = 0;
          *(_QWORD *)result = v10;
        }
        else
        {
          *(_QWORD *)result = 0;
        }
      }
      break;
    case 0x10uLL:
      result = memcmp(__s1, "fgate_activation", __n);
      if ((_DWORD)result)
      {
        result = memcmp(__s1, "igate_activation", __n);
        if ((_DWORD)result)
        {
          if (*(_QWORD *)__s1 == 0x63615F657461676FLL && *((_QWORD *)__s1 + 1) == 0x6E6F697461766974)
          {
            if (a4)
            {
              if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                v18 = a4;
              else
                v18 = 0;
              v7[4] = v18;
            }
            else
            {
              v7[4] = 0;
            }
          }
          else
          {
            result = memcmp(__s1, "zgate_activation", __n);
            if (!(_DWORD)result)
            {
              if (a4)
              {
                if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
                  v12 = a4;
                else
                  v12 = 0;
                v7[6] = v12;
              }
              else
              {
                v7[6] = 0;
              }
            }
          }
        }
        else if (a4)
        {
          if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
            v17 = a4;
          else
            v17 = 0;
          v7[3] = v17;
        }
        else
        {
          v7[3] = 0;
        }
      }
      else if (a4)
      {
        if (*(_UNKNOWN **)(*a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id)
          v16 = a4;
        else
          v16 = 0;
        v7[1] = v16;
      }
      else
      {
        v7[1] = 0;
      }
      break;
    case 0x13uLL:
      result = memcmp(__s1, "operandSegmentSizes", __n);
      if (!(_DWORD)result)
        goto LABEL_35;
      break;
    case 0x15uLL:
      result = memcmp(__s1, "operand_segment_sizes", __n);
      if (!(_DWORD)result)
      {
LABEL_35:
        if (a4)
        {
          result = mlir::detail::DenseArrayAttrImpl<int>::classof(a4);
          v13 = (_DWORD)result ? a4 : 0;
          v19 = v13;
          if ((_DWORD)result)
          {
            result = mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v19);
            if (result == 7)
            {
              result = mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v19);
              if (v14)
                result = (uint64_t)memmove(v7 + 7, (const void *)result, 4 * v14);
            }
          }
        }
      }
      break;
    default:
      return result;
  }
  return result;
}

void mlir::mps::LSTMOp::populateInherentAttrs(mlir::MLIRContext *a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*a2)
    mlir::NamedAttrList::append(a3, (uint64_t)"cell_activation", 15, *a2);
  v6 = a2[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"fgate_activation", 16, v6);
  v7 = a2[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"gate_layout", 11, v7);
  v8 = a2[3];
  if (v8)
    mlir::NamedAttrList::append(a3, (uint64_t)"igate_activation", 16, v8);
  v9 = a2[4];
  if (v9)
    mlir::NamedAttrList::append(a3, (uint64_t)"ogate_activation", 16, v9);
  v10 = a2[5];
  if (v10)
    mlir::NamedAttrList::append(a3, (uint64_t)"training", 8, v10);
  v11 = a2[6];
  if (v11)
    mlir::NamedAttrList::append(a3, (uint64_t)"zgate_activation", 16, v11);
  v12 = mlir::detail::DenseArrayAttrImpl<int>::get(a1, (uint64_t)(a2 + 7), 7);
  mlir::NamedAttrList::append(a3, (uint64_t)"operandSegmentSizes", 19, v12);
}

BOOL mlir::mps::LSTMOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v8, (const void **)"cell_activation", (const char *)0xF, a3, a4))
  {
    v9 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"fgate_activation", (const char *)0x10, a3, a4))
    {
      v10 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v10, (const void **)"gate_layout", (const char *)0xB, a3, a4))
      {
        v11 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 24));
        if (!v11
          || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v11, (const void **)"igate_activation", (const char *)0x10, a3, a4))
        {
          v12 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 32));
          if (!v12
            || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v12, (const void **)"ogate_activation", (const char *)0x10, a3, a4))
          {
            v13 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 40));
            if (!v13
              || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v13, (const void **)"training", (const char *)8, a3, a4))
            {
              v14 = mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 48));
              if (!v14
                || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v14, (const void **)"zgate_activation", (const char *)0x10, a3, a4))
              {
                return 1;
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL mlir::mps::LSTMOp::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;
  const void *v4;
  uint64_t v5;
  uint64_t v7[4];
  __int16 v8;
  uint64_t v9;
  _QWORD v10[25];

  v10[24] = *MEMORY[0x1E0C80C00];
  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(a2);
  if (!mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 1)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::LSTMGateLayoutAttr>(a1, v3 + 2)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 3)
    || !mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 4))
  {
    return 0;
  }
  if ((unint64_t)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 40))(a1) <= 5)
  {
    v9 = 0;
    if (!mlir::DialectBytecodeReader::readAttribute<mlir::detail::DenseArrayAttrImpl<int>>(a1, &v9))
      return 0;
    if (mlir::AffineBinaryOpExpr::getLHS((mlir::AffineBinaryOpExpr *)&v9) >= 8)
    {
      v7[0] = (uint64_t)"size mismatch for operand/result_segment_size";
      v8 = 259;
      (*(void (**)(_QWORD *__return_ptr, uint64_t, uint64_t *))(*(_QWORD *)a1 + 16))(v10, a1, v7);
      mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v10);
      return 0;
    }
    v4 = (const void *)mlir::detail::DenseArrayAttrImpl<int>::operator llvm::ArrayRef<int>((uint64_t)&v9);
    if (v5)
      memmove(v3 + 7, v4, 4 * v5);
  }
  if (mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 5)
    && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::mps::RNNActivationAttr>(a1, v3 + 6))
  {
    v7[0] = a1;
    v7[1] = (uint64_t)(v3 + 7);
    return mlir::mps::GRUGradientOp::readProperties(mlir::DialectBytecodeReader &,mlir::OperationState &)::$_0::operator()(v7) != 0;
  }
  return 0;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _OWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x58uLL);
    *v3 = 0u;
    v3[1] = 0u;
    v3[2] = 0u;
    v3[3] = 0u;
    v3[4] = 0u;
    *((_DWORD *)v3 + 20) = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties]";
        v15 = 105;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[472];
    return a1[32];
  }
  return result;
}

uint64_t mlir::mps::LSTMOp::writeProperties(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  mlir::MLIRContext *Context;
  uint64_t v6;
  uint64_t result;

  if (HIBYTE(*(_DWORD *)(*(_QWORD *)a1 + 44)))
    v4 = *(_QWORD *)a1 + 16 * (((unint64_t)*(unsigned int *)(*(_QWORD *)a1 + 44) >> 23) & 1) + 64;
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 8));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 16));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 24));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 32));
  if ((*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2) <= 5)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(*(_QWORD *)a1 + 24));
    v6 = mlir::detail::DenseArrayAttrImpl<int>::get(Context, v4 + 56, 7);
    (*(void (**)(uint64_t, uint64_t))(*(_QWORD *)a2 + 16))(a2, v6);
  }
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 40));
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a2 + 24))(a2, *(_QWORD *)(v4 + 48));
  result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 104))(a2);
  if (result >= 6)
    return mlir::DialectBytecodeWriter::writeSparseArray<int>(a2, (int *)(v4 + 56), 7);
  return result;
}

void mlir::mps::LSTMOp::build(mlir::UnitAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, unsigned int a6, unsigned int a7, unsigned int a8, unsigned int a9, unsigned int a10, char a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, _BOOL8 a16)
{
  _BOOL4 v20;
  _BOOL4 v21;
  _BOOL4 v22;
  _BOOL4 v23;
  _BOOL4 v24;
  uint64_t v25;
  mlir::MLIRContext *v26;
  unsigned __int8 **AttributeUniquer;
  uint64_t v28;
  mlir::MLIRContext *v29;
  unsigned __int8 **v30;
  uint64_t v31;
  mlir::MLIRContext *v32;
  unsigned __int8 **v33;
  uint64_t v34;
  mlir::MLIRContext *v35;
  unsigned __int8 **v36;
  uint64_t v37;
  mlir::MLIRContext *v38;
  unsigned __int8 **v39;
  uint64_t v40;
  mlir::MLIRContext *v41;
  unsigned __int8 **v42;
  uint64_t v43;
  mlir::MLIRContext *v44;
  uint64_t UnitAttr;
  mlir::UnknownLoc *v46;
  mlir::MLIRContext *v47;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v50;
  int v51;
  const void *v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int v64;
  unint64_t v65[2];
  unint64_t v66[2];
  _QWORD *v67;
  uint64_t v68;
  _QWORD v69[4];

  v20 = a16;
  v69[2] = *MEMORY[0x1E0C80C00];
  v62 = a4;
  v63 = a3;
  v60 = a13;
  v61 = a12;
  v58 = a15;
  v59 = a14;
  v57 = a16;
  mlir::OperationState::addOperands(a2, (uint64_t)&v63, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v62, 1);
  if (a12)
    mlir::OperationState::addOperands(a2, (uint64_t)&v61, 1);
  if (a13)
    mlir::OperationState::addOperands(a2, (uint64_t)&v60, 1);
  if (a14)
    mlir::OperationState::addOperands(a2, (uint64_t)&v59, 1);
  if (a15)
    mlir::OperationState::addOperands(a2, (uint64_t)&v58, 1);
  if (a16)
  {
    mlir::OperationState::addOperands(a2, (uint64_t)&v57, 1);
    v20 = v57;
  }
  v21 = v61 != 0;
  v22 = v60 != 0;
  v23 = v59 != 0;
  v24 = v58 != 0;
  v25 = mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2);
  *(_QWORD *)(v25 + 56) = 0x100000001;
  *(_DWORD *)(v25 + 64) = v21;
  *(_DWORD *)(v25 + 68) = v22;
  *(_DWORD *)(v25 + 72) = v23;
  *(_DWORD *)(v25 + 76) = v24;
  *(_DWORD *)(v25 + 80) = v20;
  v26 = *a1;
  v64 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v26);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v68 = (uint64_t)v26;
  v28 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v64);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 24) = v28;
  v29 = *a1;
  v64 = a6;
  v30 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v29);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v68 = (uint64_t)v29;
  v31 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v30, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v64);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v31;
  v32 = *a1;
  v64 = a7;
  v33 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v32);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v68 = (uint64_t)v32;
  v34 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v33, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v64);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 48) = v34;
  v35 = *a1;
  v64 = a8;
  v36 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v35);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v68 = (uint64_t)v35;
  v37 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v36, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v64);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 32) = v37;
  v38 = *a1;
  v64 = a9;
  v39 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v38);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v68 = (uint64_t)v38;
  v40 = mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v39, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v64);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v40;
  v41 = *a1;
  v64 = a10;
  v42 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v41);
  v67 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
  v68 = (uint64_t)v41;
  v43 = mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v42, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v67, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v64);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = v43;
  if (a11)
  {
    UnitAttr = mlir::Builder::getUnitAttr(a1, v44);
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LSTMOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 40) = UnitAttr;
  }
  v67 = v69;
  v68 = 0x200000000;
  v46 = *a1;
  v47 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v66, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v50 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v65, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::LSTMOp::inferReturnTypes(v46, v47, 1, v66[0], v66[1], Dictionary, v50, v51, v65[0], v65[1], (uint64_t)&v67))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v52 = v67;
  v53 = v68;
  v54 = *(unsigned int *)(a2 + 72);
  if (v54 + (unint64_t)v68 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v54 + v68, 8);
    LODWORD(v54) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v53)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v54), v52, 8 * v53);
    LODWORD(v54) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v54 + v53;
  if (v67 != v69)
    free(v67);
}

mlir::MLIRContext *mlir::mps::LSTMOp::populateDefaultProperties(uint64_t a1, mlir::MLIRContext **a2)
{
  mlir::MLIRContext *result;
  mlir::MLIRContext *v4;
  unsigned __int8 **AttributeUniquer;
  unsigned __int8 **v6;
  unsigned __int8 **v7;
  unsigned __int8 **v8;
  unsigned __int8 **v9;
  unsigned __int8 **v10;
  unsigned int v11;
  void *v12;
  mlir::MLIRContext *v13;

  v12 = *(void **)(a1 + 8);
  result = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
  v4 = result;
  if (a2[3])
  {
    if (a2[1])
      goto LABEL_3;
  }
  else
  {
    v11 = 3;
    AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(result);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
    v13 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
    a2[3] = result;
    if (a2[1])
    {
LABEL_3:
      if (a2[6])
        goto LABEL_4;
      goto LABEL_10;
    }
  }
  v11 = 3;
  v6 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v6, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[1] = result;
  if (a2[6])
  {
LABEL_4:
    if (a2[4])
      goto LABEL_5;
    goto LABEL_11;
  }
LABEL_10:
  v11 = 2;
  v7 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v7, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[6] = result;
  if (a2[4])
  {
LABEL_5:
    if (*a2)
      goto LABEL_6;
    goto LABEL_12;
  }
LABEL_11:
  v11 = 3;
  v8 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v8, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  a2[4] = result;
  if (*a2)
  {
LABEL_6:
    if (a2[2])
      return result;
LABEL_13:
    v11 = 0;
    v10 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
    v12 = &mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id;
    v13 = v4;
    result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::LSTMGateLayoutAttrStorage,mlir::mps::LSTMGateLayout>(v10, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail25LSTMGateLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_18LSTMGateLayoutAttrEJNS2_14LSTMGateLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGateLayoutAttr,void>::id, &v11);
    a2[2] = result;
    return result;
  }
LABEL_12:
  v11 = 2;
  v9 = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v4);
  v12 = &mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id;
  v13 = v4;
  result = (mlir::MLIRContext *)mlir::StorageUniquer::get<mlir::mps::detail::RNNActivationAttrStorage,mlir::mps::RNNActivation>(v9, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail24RNNActivationAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_17RNNActivationAttrEJNS2_13RNNActivationEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&v12, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::RNNActivationAttr,void>::id, &v11);
  *a2 = result;
  if (!a2[2])
    goto LABEL_13;
  return result;
}

uint64_t mlir::mps::LSTMOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t ODSOperands;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t *v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  unint64_t v43;
  unsigned int v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  unint64_t v49;
  unsigned int v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t *v58;
  const void **v59;
  unsigned int v60;
  uint64_t ODSResults;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t NextResultAtOffset;
  uint64_t *v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v83;
  const void **v84[4];
  __int16 v85;
  unsigned int v86;
  _QWORD v87[25];

  v87[24] = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  v5 = v3[1];
  v7 = v3[2];
  v6 = v3[3];
  v9 = v3[4];
  v8 = v3[5];
  v10 = v3[6];
  v87[0] = v2;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v6, (const void **)"igate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v5, (const void **)"fgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v10, (const void **)"zgate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v9, (const void **)"ogate_activation", (const char *)0x10, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(v4, (const void **)"cell_activation", (const char *)0xF, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps28(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(v7, (const void **)"gate_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps30(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v87[0] = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v8, (const void **)"training", (const char *)8, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps0(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v87))return 0;
  v86 = 0;
  v11 = *((unsigned int *)*this + 11);
  v12 = (uint64_t)&(*this)[2 * ((v11 >> 23) & 1) + 8];
  if (!HIBYTE(*((_DWORD *)*this + 11)))
    v12 = 0;
  v13 = *(unsigned int *)(v12 + 56);
  if ((v11 & 0x800000) != 0)
  {
    v14 = (*this)[9];
    if ((_DWORD)v13)
      goto LABEL_15;
  }
  else
  {
    v14 = 0;
    if ((_DWORD)v13)
    {
LABEL_15:
      v15 = v14 + 24;
      do
      {
        v16 = *this;
        v17 = *(_QWORD *)(*(_QWORD *)v15 + 8) & 0xFFFFFFFFFFFFFFF8;
        v18 = v86++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v16, v17, (const void **)"operand", (const void **)7, v18))return 0;
        v15 += 32;
      }
      while (--v13);
    }
  }
  ODSOperands = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 1u);
  if (v20)
  {
    v21 = v20;
    v22 = ODSOperands + 24;
    do
    {
      v23 = *this;
      v24 = *(_QWORD *)(*(_QWORD *)v22 + 8) & 0xFFFFFFFFFFFFFFF8;
      v25 = v86++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v23, v24, (const void **)"operand", (const void **)7, v25))return 0;
      v22 += 32;
    }
    while (--v21);
  }
  v26 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 2u);
  v28 = v27;
  if (v27 >= 2)
    goto LABEL_35;
  if (v27)
  {
    v29 = *(_QWORD *)(v26 + 24);
    v30 = *this;
    v31 = *(_QWORD *)(v29 + 8) & 0xFFFFFFFFFFFFFFF8;
    v32 = v86++;
    if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v30, v31, (const void **)"operand", (const void **)7, v32))return 0;
  }
  v33 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 3u);
  v28 = v34;
  if (v34 < 2)
  {
    if (v34)
    {
      v35 = *(_QWORD *)(v33 + 24);
      v36 = *this;
      v37 = *(_QWORD *)(v35 + 8) & 0xFFFFFFFFFFFFFFF8;
      v38 = v86++;
      if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v36, v37, (const void **)"operand", (const void **)7, v38))return 0;
    }
    v39 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 4u);
    v28 = v40;
    if (v40 < 2)
    {
      if (v40)
      {
        v41 = *(_QWORD *)(v39 + 24);
        v42 = *this;
        v43 = *(_QWORD *)(v41 + 8) & 0xFFFFFFFFFFFFFFF8;
        v44 = v86++;
        if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v42, v43, (const void **)"operand", (const void **)7, v44))return 0;
      }
      v45 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 5u);
      v28 = v46;
      if (v46 < 2)
      {
        if (!v46
          || (v47 = *(_QWORD *)(v45 + 24),
              v48 = *this,
              v49 = *(_QWORD *)(v47 + 8) & 0xFFFFFFFFFFFFFFF8,
              v50 = v86,
              ++v86,
              mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v48, v49, (const void **)"operand", (const void **)7, v50)))
        {
          v51 = mlir::mps::GRUOp::getODSOperands((mlir::mps::GRUOp *)this, 6u);
          v28 = v52;
          if (v52 >= 2)
            goto LABEL_35;
          if (!v52
            || (v57 = *(_QWORD *)(v51 + 24),
                v58 = *this,
                v59 = (const void **)(*(_QWORD *)(v57 + 8) & 0xFFFFFFFFFFFFFFF8),
                v60 = v86,
                ++v86,
                mlir::mps::__mlir_ods_local_type_constraint_MPSOps31(v58, v59, (const void **)"operand", 7, v60)))
          {
            v86 = 0;
            ODSResults = mlir::mps::LSTMOp::getODSResults((mlir::mps::LSTMOp *)this, 0);
            if (v62)
            {
              v63 = ODSResults;
              v64 = v62;
              v65 = 0;
              while (1)
              {
                NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v63, v65);
                v67 = *this;
                v68 = *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8;
                v86 = v65 + 1;
                if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v67, v68, (const void **)"result", (const void **)6, v65))break;
                if (v64 == ++v65)
                  goto LABEL_45;
              }
            }
            else
            {
              LODWORD(v65) = 0;
LABEL_45:
              v69 = mlir::mps::LSTMOp::getODSResults((mlir::mps::LSTMOp *)this, 1u);
              if (v70)
              {
                v71 = v69;
                v72 = v70;
                v73 = 0;
                while (1)
                {
                  v74 = mlir::detail::OpResultImpl::getNextResultAtOffset(v71, v73);
                  v75 = *this;
                  v76 = *(_QWORD *)(v74 + 8) & 0xFFFFFFFFFFFFFFF8;
                  v86 = v65 + v73 + 1;
                  if (!mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(v75, v76, (const void **)"result", (const void **)6, (int)v65 + (int)v73))break;
                  if (v72 == ++v73)
                  {
                    LODWORD(v65) = v65 + v73;
                    goto LABEL_50;
                  }
                }
              }
              else
              {
LABEL_50:
                v77 = mlir::mps::LSTMOp::getODSResults((mlir::mps::LSTMOp *)this, 2u);
                v79 = v78;
                if (v78 >= 2)
                {
                  v84[0] = (const void **)"result group starting at #";
                  v85 = 259;
                  mlir::OpState::emitOpError(this, v84, (uint64_t)v87);
                  v80 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v87, &v86);
                  v54 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v80, " requires 0 or 1 element, but found ");
                  v83 = v79;
                  goto LABEL_36;
                }
                if (!v78)
                  return 1;
                v81 = mlir::detail::OpResultImpl::getNextResultAtOffset(v77, 0);
                if (mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(v81 + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, v65))return 1;
              }
            }
          }
        }
        return 0;
      }
    }
  }
LABEL_35:
  v84[0] = (const void **)"operand group starting at #";
  v85 = 259;
  mlir::OpState::emitOpError(this, v84, (uint64_t)v87);
  v53 = mlir::InFlightDiagnostic::operator<<<unsigned int const&>((uint64_t)v87, &v86);
  v54 = mlir::InFlightDiagnostic::operator<<<char const(&)[44]>(v53, " requires 0 or 1 element, but found ");
  v83 = v28;
LABEL_36:
  v55 = mlir::InFlightDiagnostic::operator<<<unsigned long>(v54, &v83);
  v56 = mlir::InFlightDiagnostic::operator mlir::LogicalResult(v55);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v87);
  return v56;
}

uint64_t mlir::mps::detail::LeakyReluOpGenericAdaptorBase::LeakyReluOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.leaky_relu", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::LessThanOpGenericAdaptorBase::LessThanOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.less", 8, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::LessThanOrEqualToOpGenericAdaptorBase::LessThanOrEqualToOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.less_equal", 14, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int *v51;
  char *v52;
  char *v53;
  __int128 v54;
  _QWORD **v55;
  _QWORD **v56;
  void *v57;
  _QWORD *v58;
  void *v59;
  void *v60;
  int *v61;
  char *v62;
  char *v63;
  __int128 v64;
  int *v65;
  char *v66;
  char *v67;
  __int128 v68;
  _QWORD **v69;
  _QWORD **v70;
  void *v71;
  _QWORD *v72;
  void *v73;
  void *v74;
  int *v75;
  char *v76;
  char *v77;
  __int128 v78;
  _QWORD **v79;
  _QWORD **v80;
  void *v81;
  _QWORD *v82;
  void *v83;
  void *v84;
  uint64_t v85;
  unint64_t v86;
  unint64_t v87;
  unint64_t v88;
  unint64_t v89;
  unint64_t v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  int64_t v94;
  int64_t v95;
  int64_t v96;
  int64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  const char *v105;
  uint64_t v106;
  _QWORD v107[3];
  void *v108;
  unsigned int v109;
  unsigned int v110;
  _BYTE v111[96];
  void *v112;
  _QWORD *v113;
  void *__p;
  _QWORD **v115;
  char v116;
  uint64_t v117;

  v117 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v103 = v6;
  if (!v6)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v105 = "expected DictionaryAttr to set properties";
      v106 = 41;
      v26 = &v104;
      v27 = (char *)v108;
      if (v109 >= v110)
      {
        v86 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v94 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v86, 24);
          v27 = (char *)v108;
          v26 = (int *)((char *)v108 + v94);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v86, 24);
          v26 = &v104;
          v27 = (char *)v108;
        }
      }
      v28 = &v27[24 * v109];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v109;
      if (v107[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
    }
    if (!v116)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v115;
      v32 = __p;
      if (v115 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v115 = v30;
      operator delete(v32);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v33 = v113;
    v23 = v112;
    if (v113 == v112)
    {
LABEL_113:
      v113 = v21;
      operator delete(v23);
LABEL_114:
      if (v108 != v111)
        free(v108);
      return 0;
    }
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
LABEL_112:
    v23 = v112;
    goto LABEL_113;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v103, "data_layout", 0xBuLL);
  if (!v8)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v105 = "expected key entry for data_layout in DictionaryAttr to set Properties.";
      v106 = 71;
      v36 = &v104;
      v37 = (char *)v108;
      if (v109 >= v110)
      {
        v88 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v96 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v88, 24);
          v37 = (char *)v108;
          v36 = (int *)((char *)v108 + v96);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v88, 24);
          v36 = &v104;
          v37 = (char *)v108;
        }
      }
      v38 = &v37[24 * v109];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v109;
      if (v107[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
    }
    if (!v116)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v115;
      v42 = __p;
      if (v115 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v115 = v40;
      operator delete(v42);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v43 = v113;
    v23 = v112;
    if (v113 == v112)
      goto LABEL_113;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_112;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) != &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v106 = 56;
      v10 = &v104;
      v11 = (char *)v108;
      if (v109 >= v110)
      {
        v87 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v95 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v87, 24);
          v11 = (char *)v108;
          v10 = (int *)((char *)v108 + v95);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v87, 24);
          v10 = &v104;
          v11 = (char *)v108;
        }
      }
      v12 = &v11[24 * v109];
      v13 = *(_OWORD *)v10;
      *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
      *(_OWORD *)v12 = v13;
      ++v109;
      if (v107[0])
      {
        v14 = &v104;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v104, v9);
        v15 = (char *)v108;
        if (v109 >= v110)
        {
          v89 = v109 + 1;
          if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
          {
            v97 = (char *)&v104 - (_BYTE *)v108;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v89, 24);
            v15 = (char *)v108;
            v14 = (int *)((char *)v108 + v97);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v89, 24);
            v14 = &v104;
            v15 = (char *)v108;
          }
        }
        v16 = &v15[24 * v109];
        v17 = *(_OWORD *)v14;
        *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
        *(_OWORD *)v16 = v17;
        ++v109;
        if (v107[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116)
      return 0;
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v115;
      v20 = __p;
      if (v115 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v115 = v18;
      operator delete(v20);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v22 = v113;
    v23 = v112;
    if (v113 == v112)
      goto LABEL_113;
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
    goto LABEL_112;
  }
  *a1 = v8;
  v46 = mlir::DictionaryAttr::get((uint64_t)&v103, "dilation_rates", 0xEuLL);
  if (!v46)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v105 = "expected key entry for dilation_rates in DictionaryAttr to set Properties.";
      v106 = 74;
      v51 = &v104;
      v52 = (char *)v108;
      if (v109 >= v110)
      {
        v90 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v98 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v90, 24);
          v52 = (char *)v108;
          v51 = (int *)((char *)v108 + v98);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v90, 24);
          v51 = &v104;
          v52 = (char *)v108;
        }
      }
      v53 = &v52[24 * v109];
      v54 = *(_OWORD *)v51;
      *((_QWORD *)v53 + 2) = *((_QWORD *)v51 + 2);
      *(_OWORD *)v53 = v54;
      ++v109;
      if (v107[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
    }
    if (!v116)
      return 0;
    v55 = (_QWORD **)__p;
    if (__p)
    {
      v56 = v115;
      v57 = __p;
      if (v115 != __p)
      {
        do
          v56 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v56 - 1);
        while (v56 != v55);
        v57 = __p;
      }
      v115 = v55;
      operator delete(v57);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v58 = v113;
    v23 = v112;
    if (v113 == v112)
      goto LABEL_113;
    do
    {
      v60 = (void *)*--v58;
      v59 = v60;
      *v58 = 0;
      if (v60)
        operator delete[](v59);
    }
    while (v58 != v21);
    goto LABEL_112;
  }
  v47 = v46;
  if ((mlir::DenseIntElementsAttr::classof(v46) & 1) == 0)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v106 = 59;
      v61 = &v104;
      v62 = (char *)v108;
      if (v109 >= v110)
      {
        v91 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v99 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v91, 24);
          v62 = (char *)v108;
          v61 = (int *)((char *)v108 + v99);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v91, 24);
          v61 = &v104;
          v62 = (char *)v108;
        }
      }
      v63 = &v62[24 * v109];
      v64 = *(_OWORD *)v61;
      *((_QWORD *)v63 + 2) = *((_QWORD *)v61 + 2);
      *(_OWORD *)v63 = v64;
      ++v109;
      if (v107[0])
      {
        v65 = &v104;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v104, v47);
        v66 = (char *)v108;
        if (v109 >= v110)
        {
          v92 = v109 + 1;
          if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
          {
            v100 = (char *)&v104 - (_BYTE *)v108;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v92, 24);
            v66 = (char *)v108;
            v65 = (int *)((char *)v108 + v100);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v92, 24);
            v65 = &v104;
            v66 = (char *)v108;
          }
        }
        v67 = &v66[24 * v109];
        v68 = *(_OWORD *)v65;
        *((_QWORD *)v67 + 2) = *((_QWORD *)v65 + 2);
        *(_OWORD *)v67 = v68;
        ++v109;
        if (v107[0])
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
      }
    }
    if (!v116)
      return 0;
    v69 = (_QWORD **)__p;
    if (__p)
    {
      v70 = v115;
      v71 = __p;
      if (v115 != __p)
      {
        do
          v70 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v70 - 1);
        while (v70 != v69);
        v71 = __p;
      }
      v115 = v69;
      operator delete(v71);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v72 = v113;
    v23 = v112;
    if (v113 == v112)
      goto LABEL_113;
    do
    {
      v74 = (void *)*--v72;
      v73 = v74;
      *v72 = 0;
      if (v74)
        operator delete[](v73);
    }
    while (v72 != v21);
    goto LABEL_112;
  }
  a1[1] = v47;
  v48 = mlir::DictionaryAttr::get((uint64_t)&v103, "kernel_sizes", 0xCuLL);
  v102 = v48;
  if (!v48)
  {
    a3(v107, a4);
    if (v107[0])
    {
      v104 = 3;
      v105 = "expected key entry for kernel_sizes in DictionaryAttr to set Properties.";
      v106 = 72;
      v75 = &v104;
      v76 = (char *)v108;
      if (v109 >= v110)
      {
        v93 = v109 + 1;
        if (v108 <= &v104 && (char *)v108 + 24 * v109 > (char *)&v104)
        {
          v101 = (char *)&v104 - (_BYTE *)v108;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v93, 24);
          v76 = (char *)v108;
          v75 = (int *)((char *)v108 + v101);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v108, v111, v93, 24);
          v75 = &v104;
          v76 = (char *)v108;
        }
      }
      v77 = &v76[24 * v109];
      v78 = *(_OWORD *)v75;
      *((_QWORD *)v77 + 2) = *((_QWORD *)v75 + 2);
      *(_OWORD *)v77 = v78;
      ++v109;
      if (v107[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v107);
    }
    if (!v116)
      return 0;
    v79 = (_QWORD **)__p;
    if (__p)
    {
      v80 = v115;
      v81 = __p;
      if (v115 != __p)
      {
        do
          v80 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v80 - 1);
        while (v80 != v79);
        v81 = __p;
      }
      v115 = v79;
      operator delete(v81);
    }
    v21 = v112;
    if (!v112)
      goto LABEL_114;
    v82 = v113;
    v23 = v112;
    if (v113 == v112)
      goto LABEL_113;
    do
    {
      v84 = (void *)*--v82;
      v83 = v84;
      *v82 = 0;
      if (v84)
        operator delete[](v83);
    }
    while (v82 != v21);
    goto LABEL_112;
  }
  v49 = v48;
  if ((mlir::DenseIntElementsAttr::classof(v48) & 1) != 0)
  {
    a1[2] = v49;
    return 1;
  }
  a3(v107, a4);
  mlir::InFlightDiagnostic::append<mlir::Attribute>(v85, &v102);
  mlir::InFlightDiagnostic::~InFlightDiagnostic((mlir::InFlightDiagnostic *)v107);
  return 0;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  uint64_t *v20;
  void *v21;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v24;
  void *v25;
  uint64_t v26;
  _QWORD v27[7];

  v27[6] = *MEMORY[0x1E0C80C00];
  v24 = a1;
  v25 = v27;
  v26 = 0x300000000;
  if (!*a2)
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_10;
    goto LABEL_7;
  }
  NamedAttr = mlir::Builder::getNamedAttr(&v24, (uint64_t)"data_layout", 11, *a2);
  v5 = v4;
  v6 = v26;
  if (v26 >= HIDWORD(v26))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
    v6 = v26;
  }
  v7 = (uint64_t *)((char *)v25 + 16 * v6);
  *v7 = NamedAttr;
  v7[1] = v5;
  v8 = v26 + 1;
  LODWORD(v26) = v26 + 1;
  v9 = a2[1];
  if (v9)
  {
LABEL_7:
    v10 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"dilation_rates", 14, v9);
    v12 = v11;
    v13 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v13 = v26;
    }
    v14 = (uint64_t *)((char *)v25 + 16 * v13);
    *v14 = v10;
    v14[1] = v12;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
LABEL_10:
  v15 = a2[2];
  if (v15)
  {
    v16 = mlir::Builder::getNamedAttr(&v24, (uint64_t)"kernel_sizes", 12, v15);
    v18 = v17;
    v19 = v26;
    if (v26 >= HIDWORD(v26))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v27, v26 + 1, 16);
      v19 = v26;
    }
    v20 = (uint64_t *)((char *)v25 + 16 * v19);
    *v20 = v16;
    v20[1] = v18;
    v8 = v26 + 1;
    LODWORD(v26) = v26 + 1;
  }
  v21 = v25;
  if (!v8)
  {
    DictionaryAttr = 0;
    if (v25 == v27)
      return DictionaryAttr;
    goto LABEL_16;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v24, (mlir::MLIRContext *)v25, v8);
  v21 = v25;
  if (v25 != v27)
LABEL_16:
    free(v21);
  return DictionaryAttr;
}

uint64_t mlir::mps::LocalConvolutionDataGradientOp::setInherentAttr(uint64_t result, char *__s1, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v5 = result;
  if (a3 == 14)
  {
    result = memcmp(__s1, "dilation_rates", 0xEuLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v7 = a4;
        else
          v7 = 0;
        *(_QWORD *)(v5 + 8) = v7;
      }
      else
      {
        *(_QWORD *)(v5 + 8) = 0;
      }
    }
  }
  else if (a3 == 12)
  {
    result = memcmp(__s1, "kernel_sizes", 0xCuLL);
    if (!(_DWORD)result)
    {
      if (a4)
      {
        result = mlir::DenseIntElementsAttr::classof(a4);
        if ((_DWORD)result)
          v8 = a4;
        else
          v8 = 0;
        *(_QWORD *)(v5 + 16) = v8;
      }
      else
      {
        *(_QWORD *)(v5 + 16) = 0;
      }
    }
  }
  else if (a3 == 11 && *(_QWORD *)__s1 == 0x79616C5F61746164 && *(_QWORD *)(__s1 + 3) == 0x74756F79616C5F61)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      *(_QWORD *)result = v9;
    }
    else
    {
      *(_QWORD *)result = 0;
    }
  }
  return result;
}

BOOL mlir::mps::LocalConvolutionDataGradientOp::verifyInherentAttrs(uint64_t a1, uint64_t a2, void (*a3)(uint64_t *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v8;
  const void **v9;
  const void **v10;
  _BOOL8 result;

  v8 = mlir::NamedAttrList::get(a2, **(_QWORD **)(a1 + 96));
  result = 0;
  if (!v8
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v8, (const void **)"data_layout", (const char *)0xB, a3, a4))
  {
    v9 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 8));
    if (!v9
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v9, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
    {
      v10 = (const void **)mlir::NamedAttrList::get(a2, *(_QWORD *)(*(_QWORD *)(a1 + 96) + 16));
      if (!v10
        || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v10, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(_QWORD **__return_ptr, uint64_t))a3, a4))
      {
        return 1;
      }
    }
  }
  return result;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(const void **a1, const void **a2, const char *a3, void (*a4)(_QWORD **__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v10;
  _QWORD *Type;
  _QWORD *v12;
  _QWORD *ArgAttrsAttr;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const void ***v17;
  char *v18;
  char *v19;
  __int128 v20;
  const void ***v21;
  char *v22;
  char *v23;
  __int128 v24;
  _QWORD **v25;
  _QWORD **v26;
  void *v27;
  _QWORD *v28;
  _QWORD *v29;
  void *v30;
  void *v31;
  void *v32;
  unint64_t v34;
  unint64_t v35;
  int64_t v36;
  int64_t v37;
  const void **v38;
  _QWORD v39[2];
  uint64_t OperandRange;
  const void **v41;
  const char *v42;
  uint64_t v43;
  __int16 v44;
  _QWORD *v45;
  _QWORD *v46;
  void *v47;
  unsigned int v48;
  unsigned int v49;
  _BYTE v50[96];
  void *v51;
  _QWORD *v52;
  void *__p;
  _QWORD **v54;
  char v55;
  uint64_t v56;
  uint64_t v57;

  v57 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 1;
  if (!mlir::DenseIntElementsAttr::classof((uint64_t)a1))
    goto LABEL_9;
  v10 = mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>((uint64_t)*a1 + 8);
  v41 = a1;
  v42 = (const char *)v10;
  Type = (_QWORD *)mlir::ElementsAttr::getType((mlir::ElementsAttr *)&v41);
  v12 = Type;
  if (Type)
    Type = (_QWORD *)mlir::detail::InterfaceMap::lookup<mlir::ShapedType>(*Type + 8);
  v45 = v12;
  v46 = Type;
  ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v45);
  v56 = 2;
  if (v14 == 1 && *ArgAttrsAttr == v56)
  {
    v38 = a1;
    v39[0] = mlir::ArrayAttr::getValue((mlir::ArrayAttr *)&v38);
    v39[1] = v15;
    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)v39);
    if (mlir::Type::isUnsignedInteger((mlir::Type *)&OperandRange, 64))
      return 1;
  }
LABEL_9:
  a4(&v45, a5);
  if (v45)
  {
    LODWORD(v41) = 3;
    v42 = "attribute '";
    v43 = 11;
    v17 = &v41;
    v18 = (char *)v47;
    if (v48 >= v49)
    {
      v34 = v48 + 1;
      if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
      {
        v36 = (char *)&v41 - (_BYTE *)v47;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v18 = (char *)v47;
        v17 = (const void ***)((char *)v47 + v36);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v34, 24);
        v17 = &v41;
        v18 = (char *)v47;
      }
    }
    v19 = &v18[24 * v48];
    v20 = *(_OWORD *)v17;
    *((_QWORD *)v19 + 2) = v17[2];
    *(_OWORD *)v19 = v20;
    ++v48;
    if (v45)
    {
      v44 = 261;
      v41 = a2;
      v42 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v46, &v41);
      if (v45)
      {
        LODWORD(v41) = 3;
        v42 = "' failed to satisfy constraint: ui64 elements attribute of shape {2}";
        v43 = 68;
        v21 = &v41;
        v22 = (char *)v47;
        if (v48 >= v49)
        {
          v35 = v48 + 1;
          if (v47 <= &v41 && (char *)v47 + 24 * v48 > (char *)&v41)
          {
            v37 = (char *)&v41 - (_BYTE *)v47;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v22 = (char *)v47;
            v21 = (const void ***)((char *)v47 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v47, v50, v35, 24);
            v21 = &v41;
            v22 = (char *)v47;
          }
        }
        v23 = &v22[24 * v48];
        v24 = *(_OWORD *)v21;
        *((_QWORD *)v23 + 2) = v21[2];
        *(_OWORD *)v23 = v24;
        ++v48;
      }
    }
  }
  v16 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v45);
  if (v45)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v45);
  if (v55)
  {
    v25 = (_QWORD **)__p;
    if (__p)
    {
      v26 = v54;
      v27 = __p;
      if (v54 != __p)
      {
        do
          v26 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v26 - 1);
        while (v26 != v25);
        v27 = __p;
      }
      v54 = v25;
      operator delete(v27);
    }
    v28 = v51;
    if (v51)
    {
      v29 = v52;
      v30 = v51;
      if (v52 != v51)
      {
        do
        {
          v32 = (void *)*--v29;
          v31 = v32;
          *v29 = 0;
          if (v32)
            operator delete[](v31);
        }
        while (v29 != v28);
        v30 = v51;
      }
      v52 = v28;
      operator delete(v30);
    }
    if (v47 != v50)
      free(v47);
  }
  return v16;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x18uLL);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::LocalConvolutionDataGradientOpGenericA"
              "daptorBase::Properties]";
        v15 = 129;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[474];
    return a1[32];
  }
  return result;
}

void mlir::mps::LocalConvolutionDataGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  mlir::MLIRContext *v12;
  unsigned __int8 **AttributeUniquer;
  uint64_t v14;
  mlir::Float32Type *v15;
  mlir::MLIRContext *Context;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  mlir::MLIRContext *v25[2];
  void *__src;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  v12 = *a1;
  v23 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v12);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v27 = (uint64_t)v12;
  v14 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v23);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v14;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionDataGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  __src = v28;
  v27 = 0x200000000;
  v15 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v25, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v17 = __src;
  v18 = v27;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v27;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v28)
    free(__src);
}

BOOL mlir::mps::LocalConvolutionDataGradientOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t v4;
  const void **v5;
  const void **v6;
  uint64_t v7;
  uint64_t NextResultAtOffset;
  uint64_t v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  void *v22;
  void *v23;
  _QWORD **v24;
  _QWORD **v25;
  void *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  const void **v31[4];
  __int16 v32;
  _QWORD v33[3];
  void *v34;
  uint64_t v35;
  void *v36;
  _QWORD *v37;
  void *__p;
  _QWORD **v39;
  char v40;
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = &(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *v3;
  if (*v3)
  {
    v5 = (const void **)v3[1];
    if (v5)
    {
      v6 = (const void **)v3[2];
      if (v6)
      {
        v33[0] = v2;
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(v4, (const void **)"data_layout", (const char *)0xB, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps11(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
        v33[0] = *this;
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v6, (const void **)"kernel_sizes", (const char *)0xC, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33))return 0;
        v33[0] = *this;
        if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(v5, (const void **)"dilation_rates", (const char *)0xE, (void (*)(_QWORD **__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps31(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)v33)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 1u))
        {
          return 0;
        }
        if (*((_DWORD *)*this + 9))
          v7 = (uint64_t)(*this - 2);
        else
          v7 = 0;
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
        return mlir::mps::__mlir_ods_local_type_constraint_MPSOps6(*this, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0) != 0;
      }
      v31[0] = (const void **)"requires attribute 'kernel_sizes'";
      v32 = 259;
      mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
      v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
      if (v33[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
      if (v40)
      {
        v24 = (_QWORD **)__p;
        if (__p)
        {
          v25 = v39;
          v26 = __p;
          if (v39 != __p)
          {
            do
              v25 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v25 - 1);
            while (v25 != v24);
            v26 = __p;
          }
          v39 = v24;
          operator delete(v26);
        }
        v13 = v36;
        if (!v36)
          goto LABEL_61;
        v27 = v37;
        v15 = v36;
        if (v37 == v36)
        {
LABEL_60:
          v37 = v13;
          operator delete(v15);
LABEL_61:
          if (v34 != &v35)
            free(v34);
          return v9;
        }
        do
        {
          v29 = (void *)*--v27;
          v28 = v29;
          *v27 = 0;
          if (v29)
            operator delete[](v28);
        }
        while (v27 != v13);
LABEL_59:
        v15 = v36;
        goto LABEL_60;
      }
    }
    else
    {
      v31[0] = (const void **)"requires attribute 'dilation_rates'";
      v32 = 259;
      mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
      v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
      if (v33[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
      if (v40)
      {
        v18 = (_QWORD **)__p;
        if (__p)
        {
          v19 = v39;
          v20 = __p;
          if (v39 != __p)
          {
            do
              v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
            while (v19 != v18);
            v20 = __p;
          }
          v39 = v18;
          operator delete(v20);
        }
        v13 = v36;
        if (!v36)
          goto LABEL_61;
        v21 = v37;
        v15 = v36;
        if (v37 == v36)
          goto LABEL_60;
        do
        {
          v23 = (void *)*--v21;
          v22 = v23;
          *v21 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v21 != v13);
        goto LABEL_59;
      }
    }
  }
  else
  {
    v31[0] = (const void **)"requires attribute 'data_layout'";
    v32 = 259;
    mlir::OpState::emitOpError(this, v31, (uint64_t)v33);
    v9 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)v33);
    if (v33[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v33);
    if (v40)
    {
      v10 = (_QWORD **)__p;
      if (__p)
      {
        v11 = v39;
        v12 = __p;
        if (v39 != __p)
        {
          do
            v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
          while (v11 != v10);
          v12 = __p;
        }
        v39 = v10;
        operator delete(v12);
      }
      v13 = v36;
      if (!v36)
        goto LABEL_61;
      v14 = v37;
      v15 = v36;
      if (v37 == v36)
        goto LABEL_60;
      do
      {
        v17 = (void *)*--v14;
        v16 = v17;
        *v14 = 0;
        if (v17)
          operator delete[](v16);
      }
      while (v14 != v13);
      goto LABEL_59;
    }
  }
  return v9;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x18uLL);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties]";
        v15 = 117;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[476];
    return a1[32];
  }
  return result;
}

void mlir::mps::LocalConvolutionOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  mlir::MLIRContext *v12;
  unsigned __int8 **AttributeUniquer;
  uint64_t v14;
  mlir::Float32Type *v15;
  mlir::MLIRContext *Context;
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int v23;
  unint64_t v24;
  mlir::MLIRContext *v25[2];
  void *__src;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v21 = a4;
  v22 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  v12 = *a1;
  v23 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v12);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v27 = (uint64_t)v12;
  v14 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v23);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v14;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  __src = v28;
  v27 = 0x200000000;
  v15 = *a1;
  mlir::ValueRange::ValueRange((unint64_t *)v25, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  mlir::ValueRange::ValueRange(&v24, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  v17 = __src;
  v18 = v27;
  v19 = *(unsigned int *)(a2 + 72);
  v20 = v19 + v27;
  if (v20 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v20, 8);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v18)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v19), v17, 8 * v18);
    LODWORD(v19) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v19 + v18;
  if (__src != v28)
    free(__src);
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  char **v4;
  unsigned __int8 v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x18uLL);
    v3[1] = 0;
    v3[2] = 0;
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v5 & 1) == 0)
    {
      v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::LocalConvolutionWeightGradientOpGeneri"
              "cAdaptorBase::Properties]";
        v15 = 131;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v4 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v4[478];
    return a1[32];
  }
  return result;
}

void mlir::mps::LocalConvolutionWeightGradientOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7)
{
  mlir::MLIRContext *v12;
  unsigned __int8 **AttributeUniquer;
  uint64_t v14;
  mlir::UnknownLoc *v15;
  mlir::MLIRContext *v16;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28[2];
  unint64_t v29[2];
  void *__src;
  uint64_t v31;
  _QWORD v32[3];

  v32[2] = *MEMORY[0x1E0C80C00];
  v25 = a4;
  v26 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v26, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v25, 1);
  v12 = *a1;
  v27 = a5;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v12);
  __src = &mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id;
  v31 = (uint64_t)v12;
  v14 = mlir::StorageUniquer::get<mlir::mps::detail::TensorDataLayoutAttrStorage,mlir::mps::TensorDataLayout>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail27TensorDataLayoutAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_20TensorDataLayoutAttrEJNS2_16TensorDataLayoutEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)&__src, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::TensorDataLayoutAttr,void>::id, &v27);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v14;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 16) = a6;
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::LocalConvolutionWeightGradientOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = a7;
  __src = v32;
  v31 = 0x200000000;
  v15 = *a1;
  v16 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v29, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v19 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v28, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::LocalConvolutionWeightGradientOp::inferReturnTypes(v15, v16, 1, v29[0], v29[1], Dictionary, v19, v20, v28[0], v28[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v21 = __src;
  v22 = v31;
  v23 = *(unsigned int *)(a2 + 72);
  v24 = v23 + v31;
  if (v24 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v24, 8);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v22)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v23), v21, 8 * v22);
    LODWORD(v23) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v23 + v22;
  if (__src != v32)
    free(__src);
}

uint64_t mlir::mps::detail::LogarithmBase10OpGenericAdaptorBase::LogarithmBase10OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm_base_10", 21, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::LogarithmBase2OpGenericAdaptorBase::LogarithmBase2OpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm_base_2", 20, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::LogarithmOpGenericAdaptorBase::LogarithmOpGenericAdaptorBase(uint64_t a1, mlir::Operation *this)
{
  unint64_t AttrDictionary;
  unint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t Context;
  unint64_t v10[3];
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  AttrDictionary = mlir::Operation::getAttrDictionary(this);
  v5 = *((unsigned int *)this + 11);
  v6 = v5 & 0x7FFFFF;
  if ((v5 & 0x7FFFFF) != 0)
  {
    v7 = (((unint64_t)this + 16 * ((v5 >> 23) & 1) + ((v5 >> 21) & 0x7F8) + 71) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *((unsigned int *)this + 10);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v10, v7, v6);
  *(_QWORD *)a1 = AttrDictionary;
  *(_BYTE *)(a1 + 8) = 0;
  *(_BYTE *)(a1 + 16) = 0;
  *(_OWORD *)(a1 + 24) = *(_OWORD *)v10;
  if (AttrDictionary)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.logarithm", 13, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::detail::MatMulOpGenericAdaptorBase::MatMulOpGenericAdaptorBase(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  _OWORD *v5;
  unint64_t v6;
  uint64_t v7;
  __int128 v8;
  uint64_t Context;
  unint64_t v11[3];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v3 = *(_QWORD *)(a2 + 56);
  v4 = *(unsigned int *)(a2 + 44);
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_OWORD *)(a2 + 16 * ((v4 >> 23) & 1) + 64);
  else
    v5 = 0;
  v6 = v4 & 0x7FFFFF;
  if ((v4 & 0x7FFFFF) != 0)
  {
    v7 = ((a2 + 16 * ((v4 >> 23) & 1) + 64 + ((v4 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
       + 32 * *(unsigned int *)(a2 + 40);
  }
  else
  {
    v7 = 0;
    v6 = 0;
  }
  mlir::ValueRange::ValueRange(v11, v7, v6);
  *(_BYTE *)(a1 + 8) = 0;
  *(_QWORD *)a1 = v3;
  *(_BYTE *)(a1 + 16) = 0;
  v8 = *(_OWORD *)v11;
  *(_OWORD *)(a1 + 24) = *v5;
  *(_OWORD *)(a1 + 40) = v8;
  if (v3)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)a1);
    if (*(_BYTE *)(a1 + 16))
      *(_BYTE *)(a1 + 16) = 0;
    mlir::OperationName::OperationName(a1 + 8, "mps.matmul", 10, Context);
    *(_BYTE *)(a1 + 16) = 1;
  }
  return a1;
}

uint64_t mlir::mps::MatMulOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int *v13;
  char *v14;
  char *v15;
  __int128 v16;
  _QWORD **v17;
  _QWORD **v18;
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  void *v22;
  void *v23;
  void *v24;
  int *v25;
  char *v26;
  char *v27;
  __int128 v28;
  int *v29;
  char *v30;
  char *v31;
  __int128 v32;
  _QWORD **v33;
  _QWORD **v34;
  void *v35;
  _QWORD *v36;
  void *v37;
  void *v38;
  int *v39;
  char *v40;
  char *v41;
  __int128 v42;
  int *v43;
  char *v44;
  char *v45;
  __int128 v46;
  _QWORD **v47;
  _QWORD **v48;
  void *v49;
  _QWORD *v50;
  void *v51;
  void *v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  int64_t v58;
  int64_t v59;
  int64_t v60;
  int64_t v61;
  int64_t v62;
  uint64_t v63;
  int v64;
  const char *v65;
  uint64_t v66;
  _QWORD v67[3];
  void *v68;
  unsigned int v69;
  unsigned int v70;
  _BYTE v71[96];
  void *v72;
  _QWORD *v73;
  void *__p;
  _QWORD **v75;
  char v76;
  uint64_t v77;

  v77 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v63 = v6;
  if (!v6)
  {
    a3(v67, a4);
    if (v67[0])
    {
      v64 = 3;
      v65 = "expected DictionaryAttr to set properties";
      v66 = 41;
      v13 = &v64;
      v14 = (char *)v68;
      if (v69 >= v70)
      {
        v53 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          v58 = (char *)&v64 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          v14 = (char *)v68;
          v13 = (int *)((char *)v68 + v58);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v53, 24);
          v13 = &v64;
          v14 = (char *)v68;
        }
      }
      v15 = &v14[24 * v69];
      v16 = *(_OWORD *)v13;
      *((_QWORD *)v15 + 2) = *((_QWORD *)v13 + 2);
      *(_OWORD *)v15 = v16;
      ++v69;
      if (v67[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
    if (!v76)
      return 0;
    v17 = (_QWORD **)__p;
    if (__p)
    {
      v18 = v75;
      v19 = __p;
      if (v75 != __p)
      {
        do
          v18 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v18 - 1);
        while (v18 != v17);
        v19 = __p;
      }
      v75 = v17;
      operator delete(v19);
    }
    v20 = v72;
    if (!v72)
      goto LABEL_66;
    v21 = v73;
    v22 = v72;
    if (v73 == v72)
      goto LABEL_65;
    do
    {
      v24 = (void *)*--v21;
      v23 = v24;
      *v21 = 0;
      if (v24)
        operator delete[](v23);
    }
    while (v21 != v20);
    goto LABEL_64;
  }
  v8 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v63, "transpose_lhs", 0xDuLL);
  if (v8)
  {
    v9 = (uint64_t)v8;
    if (!mlir::BoolAttr::classof(v8))
    {
      a3(v67, a4);
      if (v67[0])
      {
        v64 = 3;
        v66 = 58;
        v25 = &v64;
        v26 = (char *)v68;
        if (v69 >= v70)
        {
          v54 = v69 + 1;
          if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
          {
            v59 = (char *)&v64 - (_BYTE *)v68;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            v26 = (char *)v68;
            v25 = (int *)((char *)v68 + v59);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v54, 24);
            v25 = &v64;
            v26 = (char *)v68;
          }
        }
        v27 = &v26[24 * v69];
        v28 = *(_OWORD *)v25;
        *((_QWORD *)v27 + 2) = *((_QWORD *)v25 + 2);
        *(_OWORD *)v27 = v28;
        ++v69;
        if (v67[0])
        {
          v29 = &v64;
          mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v9);
          v30 = (char *)v68;
          if (v69 >= v70)
          {
            v56 = v69 + 1;
            if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
            {
              v61 = (char *)&v64 - (_BYTE *)v68;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
              v30 = (char *)v68;
              v29 = (int *)((char *)v68 + v61);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v56, 24);
              v29 = &v64;
              v30 = (char *)v68;
            }
          }
          v31 = &v30[24 * v69];
          v32 = *(_OWORD *)v29;
          *((_QWORD *)v31 + 2) = *((_QWORD *)v29 + 2);
          *(_OWORD *)v31 = v32;
          ++v69;
          if (v67[0])
            mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
        }
      }
      if (!v76)
        return 0;
      v33 = (_QWORD **)__p;
      if (__p)
      {
        v34 = v75;
        v35 = __p;
        if (v75 != __p)
        {
          do
            v34 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v34 - 1);
          while (v34 != v33);
          v35 = __p;
        }
        v75 = v33;
        operator delete(v35);
      }
      v20 = v72;
      if (!v72)
        goto LABEL_66;
      v36 = v73;
      v22 = v72;
      if (v73 == v72)
        goto LABEL_65;
      do
      {
        v38 = (void *)*--v36;
        v37 = v38;
        *v36 = 0;
        if (v38)
          operator delete[](v37);
      }
      while (v36 != v20);
      goto LABEL_64;
    }
    *a1 = v9;
  }
  v10 = (_QWORD *)mlir::DictionaryAttr::get((uint64_t)&v63, "transpose_rhs", 0xDuLL);
  if (!v10)
    return 1;
  v11 = (uint64_t)v10;
  if (mlir::BoolAttr::classof(v10))
  {
    a1[1] = v11;
    return 1;
  }
  a3(v67, a4);
  if (v67[0])
  {
    v64 = 3;
    v66 = 58;
    v39 = &v64;
    v40 = (char *)v68;
    if (v69 >= v70)
    {
      v55 = v69 + 1;
      if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
      {
        v60 = (char *)&v64 - (_BYTE *)v68;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        v40 = (char *)v68;
        v39 = (int *)((char *)v68 + v60);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v55, 24);
        v39 = &v64;
        v40 = (char *)v68;
      }
    }
    v41 = &v40[24 * v69];
    v42 = *(_OWORD *)v39;
    *((_QWORD *)v41 + 2) = *((_QWORD *)v39 + 2);
    *(_OWORD *)v41 = v42;
    ++v69;
    if (v67[0])
    {
      v43 = &v64;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v64, v11);
      v44 = (char *)v68;
      if (v69 >= v70)
      {
        v57 = v69 + 1;
        if (v68 <= &v64 && (char *)v68 + 24 * v69 > (char *)&v64)
        {
          v62 = (char *)&v64 - (_BYTE *)v68;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          v44 = (char *)v68;
          v43 = (int *)((char *)v68 + v62);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v68, v71, v57, 24);
          v43 = &v64;
          v44 = (char *)v68;
        }
      }
      v45 = &v44[24 * v69];
      v46 = *(_OWORD *)v43;
      *((_QWORD *)v45 + 2) = *((_QWORD *)v43 + 2);
      *(_OWORD *)v45 = v46;
      ++v69;
      if (v67[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v67);
    }
  }
  if (v76)
  {
    v47 = (_QWORD **)__p;
    if (__p)
    {
      v48 = v75;
      v49 = __p;
      if (v75 != __p)
      {
        do
          v48 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v48 - 1);
        while (v48 != v47);
        v49 = __p;
      }
      v75 = v47;
      operator delete(v49);
    }
    v20 = v72;
    if (!v72)
      goto LABEL_66;
    v50 = v73;
    v22 = v72;
    if (v73 == v72)
    {
LABEL_65:
      v73 = v20;
      operator delete(v22);
LABEL_66:
      if (v68 != v71)
        free(v68);
      return 0;
    }
    do
    {
      v52 = (void *)*--v50;
      v51 = v52;
      *v50 = 0;
      if (v52)
        operator delete[](v51);
    }
    while (v50 != v20);
LABEL_64:
    v22 = v72;
    goto LABEL_65;
  }
  return 0;
}

uint64_t mlir::mps::MatMulOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t *v7;
  unsigned int v8;
  uint64_t v9;
  mlir::MLIRContext *v10;
  uint64_t DictionaryAttr;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t *v17;
  mlir::DictionaryAttr *v18;
  void *v19;
  uint64_t v20;
  _QWORD v21[7];

  v21[6] = *MEMORY[0x1E0C80C00];
  v18 = a1;
  v19 = v21;
  v20 = 0x300000000;
  if (*a2)
  {
    NamedAttr = mlir::Builder::getNamedAttr(&v18, (uint64_t)"transpose_lhs", 13, *a2);
    v5 = v4;
    v6 = v20;
    if (v20 >= HIDWORD(v20))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
      v6 = v20;
    }
    v7 = (uint64_t *)((char *)v19 + 16 * v6);
    *v7 = NamedAttr;
    v7[1] = v5;
    v8 = v20 + 1;
    LODWORD(v20) = v20 + 1;
    v9 = a2[1];
    if (!v9)
    {
LABEL_5:
      v10 = (mlir::MLIRContext *)v19;
      if (v8)
        goto LABEL_6;
LABEL_13:
      DictionaryAttr = 0;
      if (v10 == (mlir::MLIRContext *)v21)
        return DictionaryAttr;
      goto LABEL_7;
    }
  }
  else
  {
    v8 = 0;
    v9 = a2[1];
    if (!v9)
      goto LABEL_5;
  }
  v13 = mlir::Builder::getNamedAttr(&v18, (uint64_t)"transpose_rhs", 13, v9);
  v15 = v14;
  v16 = v20;
  if (v20 >= HIDWORD(v20))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v19, v21, v20 + 1, 16);
    v16 = v20;
  }
  v17 = (uint64_t *)((char *)v19 + 16 * v16);
  *v17 = v13;
  v17[1] = v15;
  v8 = v20 + 1;
  LODWORD(v20) = v8;
  v10 = (mlir::MLIRContext *)v19;
  if (!v8)
    goto LABEL_13;
LABEL_6:
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v18, v10, v8);
  v10 = (mlir::MLIRContext *)v19;
  if (v19 != v21)
LABEL_7:
    free(v10);
  return DictionaryAttr;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(0x10uLL);
    *v3 = 0;
    v3[1] = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties]";
        v15 = 107;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[480];
    return a1[32];
  }
  return result;
}

void mlir::mps::MatMulOp::build(mlir::UnknownLoc **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  mlir::UnknownLoc *v10;
  mlir::MLIRContext *v11;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v14;
  int v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22[2];
  unint64_t v23[2];
  void *__src;
  uint64_t v25;
  _QWORD v26[3];

  v26[2] = *MEMORY[0x1E0C80C00];
  v20 = a4;
  v21 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v21, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v20, 1);
  if (a5)
    *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>((_QWORD *)a2) = a5;
  if (a6)
    *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>((_QWORD *)a2)
              + 8) = a6;
  __src = v26;
  v25 = 0x200000000;
  v10 = *a1;
  v11 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v14 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::MatMulOp::inferReturnTypes(v10, v11, 1, v23[0], v23[1], Dictionary, v14, v15, v22[0], v22[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v16 = __src;
  v17 = v25;
  v18 = *(unsigned int *)(a2 + 72);
  v19 = v18 + v25;
  if (v19 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v19, 8);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v17)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v18), v16, 8 * v17);
    LODWORD(v18) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v18 + v17;
  if (__src != v26)
    free(__src);
}

void mlir::mps::MatMulOp::build(mlir::BoolAttr **a1, uint64_t a2, uint64_t a3, uint64_t a4, mlir::MLIRContext *a5, mlir::MLIRContext *a6)
{
  uint64_t BoolAttr;
  uint64_t v11;
  mlir::UnknownLoc *v12;
  mlir::MLIRContext *v13;
  mlir::MLIRContext *Context;
  unint64_t Dictionary;
  __int128 *v16;
  int v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24[2];
  unint64_t v25[2];
  void *__src;
  uint64_t v27;
  _QWORD v28[3];

  v28[2] = *MEMORY[0x1E0C80C00];
  v22 = a4;
  v23 = a3;
  mlir::OperationState::addOperands(a2, (uint64_t)&v23, 1);
  mlir::OperationState::addOperands(a2, (uint64_t)&v22, 1);
  BoolAttr = mlir::Builder::getBoolAttr(a1, a5);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>((_QWORD *)a2) = BoolAttr;
  v11 = mlir::Builder::getBoolAttr(a1, a6);
  *(_QWORD *)(mlir::OperationState::getOrAddProperties<mlir::mps::detail::MatMulOpGenericAdaptorBase::Properties>((_QWORD *)a2)
            + 8) = v11;
  __src = v28;
  v27 = 0x200000000;
  v12 = *a1;
  v13 = *(mlir::MLIRContext **)a2;
  mlir::ValueRange::ValueRange(v25, *(_QWORD *)(a2 + 16), *(unsigned int *)(a2 + 24));
  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)a2);
  Dictionary = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)(a2 + 112), Context);
  v16 = *(__int128 **)(a2 + 256);
  mlir::ValueRange::ValueRange(v24, *(_QWORD *)(a2 + 224), *(unsigned int *)(a2 + 232));
  if (!mlir::mps::MatMulOp::inferReturnTypes(v12, v13, 1, v25[0], v25[1], Dictionary, v16, v17, v24[0], v24[1], (uint64_t)&__src))llvm::report_fatal_error((llvm *)"Failed to infer result type(s).", (const char *)1);
  v18 = __src;
  v19 = v27;
  v20 = *(unsigned int *)(a2 + 72);
  v21 = v20 + v27;
  if (v21 > *(unsigned int *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v21, 8);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  if ((_DWORD)v19)
  {
    memcpy((void *)(*(_QWORD *)(a2 + 64) + 8 * v20), v18, 8 * v19);
    LODWORD(v20) = *(_DWORD *)(a2 + 72);
  }
  *(_DWORD *)(a2 + 72) = v20 + v19;
  if (__src != v28)
    free(__src);
}

BOOL mlir::mps::MatMulOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  uint64_t *v9;

  v2 = *this;
  if (HIBYTE(*((_DWORD *)*this + 11)))
    v3 = (unint64_t)&(*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  else
    v3 = 0;
  v4 = *(_QWORD **)v3;
  v5 = *(_QWORD **)(v3 + 8);
  v9 = v2;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v4, (const void **)"transpose_lhs", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9))return 0;
  v9 = *this;
  if (!mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps2(v5, (const void **)"transpose_rhs", (const char *)0xD, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps17(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v9)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)|| !mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*this, (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 56) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 1u))
  {
    return 0;
  }
  if (*((_DWORD *)*this + 9))
    v6 = (uint64_t)(*this - 2);
  else
    v6 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0);
  return mlir::mps::__mlir_ods_local_type_constraint_MPSOps26(*this, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0) != 0;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::setPropertiesFromAttr(uint64_t *a1, uint64_t a2, void (*a3)(_QWORD *__return_ptr, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  char *v11;
  char *v12;
  __int128 v13;
  int *v14;
  char *v15;
  char *v16;
  __int128 v17;
  _QWORD **v18;
  _QWORD **v19;
  void *v20;
  _QWORD *v21;
  _QWORD *v22;
  void *v23;
  void *v24;
  void *v25;
  int *v26;
  char *v27;
  char *v28;
  __int128 v29;
  _QWORD **v30;
  _QWORD **v31;
  void *v32;
  _QWORD *v33;
  void *v34;
  void *v35;
  int *v36;
  char *v37;
  char *v38;
  __int128 v39;
  _QWORD **v40;
  _QWORD **v41;
  void *v42;
  _QWORD *v43;
  void *v44;
  void *v45;
  unint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  int64_t v51;
  int64_t v52;
  int64_t v53;
  int64_t v54;
  uint64_t v55;
  int v56;
  const char *v57;
  uint64_t v58;
  _QWORD v59[3];
  void *v60;
  unsigned int v61;
  unsigned int v62;
  _BYTE v63[96];
  void *v64;
  _QWORD *v65;
  void *__p;
  _QWORD **v67;
  char v68;
  uint64_t v69;

  v69 = *MEMORY[0x1E0C80C00];
  if (*(_UNKNOWN **)(*(_QWORD *)a2 + 136) == &mlir::detail::TypeIDResolver<mlir::DictionaryAttr,void>::id)
    v6 = a2;
  else
    v6 = 0;
  v55 = v6;
  if (!v6)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected DictionaryAttr to set properties";
      v58 = 41;
      v26 = &v56;
      v27 = (char *)v60;
      if (v61 >= v62)
      {
        v47 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v51 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v27 = (char *)v60;
          v26 = (int *)((char *)v60 + v51);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v47, 24);
          v26 = &v56;
          v27 = (char *)v60;
        }
      }
      v28 = &v27[24 * v61];
      v29 = *(_OWORD *)v26;
      *((_QWORD *)v28 + 2) = *((_QWORD *)v26 + 2);
      *(_OWORD *)v28 = v29;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v30 = (_QWORD **)__p;
    if (__p)
    {
      v31 = v67;
      v32 = __p;
      if (v67 != __p)
      {
        do
          v31 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v31 - 1);
        while (v31 != v30);
        v32 = __p;
      }
      v67 = v30;
      operator delete(v32);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v33 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v35 = (void *)*--v33;
      v34 = v35;
      *v33 = 0;
      if (v35)
        operator delete[](v34);
    }
    while (v33 != v21);
    goto LABEL_57;
  }
  v8 = mlir::DictionaryAttr::get((uint64_t)&v55, "storage_type", 0xCuLL);
  if (!v8)
  {
    a3(v59, a4);
    if (v59[0])
    {
      v56 = 3;
      v57 = "expected key entry for storage_type in DictionaryAttr to set Properties.";
      v58 = 72;
      v36 = &v56;
      v37 = (char *)v60;
      if (v61 >= v62)
      {
        v49 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v53 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v37 = (char *)v60;
          v36 = (int *)((char *)v60 + v53);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v49, 24);
          v36 = &v56;
          v37 = (char *)v60;
        }
      }
      v38 = &v37[24 * v61];
      v39 = *(_OWORD *)v36;
      *((_QWORD *)v38 + 2) = *((_QWORD *)v36 + 2);
      *(_OWORD *)v38 = v39;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
    if (!v68)
      return 0;
    v40 = (_QWORD **)__p;
    if (__p)
    {
      v41 = v67;
      v42 = __p;
      if (v67 != __p)
      {
        do
          v41 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v41 - 1);
        while (v41 != v40);
        v42 = __p;
      }
      v67 = v40;
      operator delete(v42);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v43 = v65;
    v23 = v64;
    if (v65 == v64)
      goto LABEL_58;
    do
    {
      v45 = (void *)*--v43;
      v44 = v45;
      *v43 = 0;
      if (v45)
        operator delete[](v44);
    }
    while (v43 != v21);
    goto LABEL_57;
  }
  v9 = v8;
  if (*(_UNKNOWN **)(*(_QWORD *)v8 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    *a1 = v8;
    return 1;
  }
  a3(v59, a4);
  if (v59[0])
  {
    v56 = 3;
    v58 = 57;
    v10 = &v56;
    v11 = (char *)v60;
    if (v61 >= v62)
    {
      v48 = v61 + 1;
      if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
      {
        v52 = (char *)&v56 - (_BYTE *)v60;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v11 = (char *)v60;
        v10 = (int *)((char *)v60 + v52);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v48, 24);
        v10 = &v56;
        v11 = (char *)v60;
      }
    }
    v12 = &v11[24 * v61];
    v13 = *(_OWORD *)v10;
    *((_QWORD *)v12 + 2) = *((_QWORD *)v10 + 2);
    *(_OWORD *)v12 = v13;
    ++v61;
    if (v59[0])
    {
      v14 = &v56;
      mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v56, v9);
      v15 = (char *)v60;
      if (v61 >= v62)
      {
        v50 = v61 + 1;
        if (v60 <= &v56 && (char *)v60 + 24 * v61 > (char *)&v56)
        {
          v54 = (char *)&v56 - (_BYTE *)v60;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v15 = (char *)v60;
          v14 = (int *)((char *)v60 + v54);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v60, v63, v50, 24);
          v14 = &v56;
          v15 = (char *)v60;
        }
      }
      v16 = &v15[24 * v61];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v16 = v17;
      ++v61;
      if (v59[0])
        mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v59);
    }
  }
  if (v68)
  {
    v18 = (_QWORD **)__p;
    if (__p)
    {
      v19 = v67;
      v20 = __p;
      if (v67 != __p)
      {
        do
          v19 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v19 - 1);
        while (v19 != v18);
        v20 = __p;
      }
      v67 = v18;
      operator delete(v20);
    }
    v21 = v64;
    if (!v64)
      goto LABEL_59;
    v22 = v65;
    v23 = v64;
    if (v65 == v64)
    {
LABEL_58:
      v65 = v21;
      operator delete(v23);
LABEL_59:
      if (v60 != v63)
        free(v60);
      return 0;
    }
    do
    {
      v25 = (void *)*--v22;
      v24 = v25;
      *v22 = 0;
      if (v25)
        operator delete[](v24);
    }
    while (v22 != v21);
LABEL_57:
    v23 = v64;
    goto LABEL_58;
  }
  return 0;
}

uint64_t mlir::mps::MaterializeSparseTensorOp::getPropertiesAsAttr(mlir::DictionaryAttr *a1, uint64_t *a2)
{
  uint64_t NamedAttr;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t *v6;
  void *v7;
  BOOL v8;
  uint64_t v9;
  uint64_t DictionaryAttr;
  mlir::DictionaryAttr *v12;
  void *v13;
  uint64_t v14;
  _QWORD v15[7];

  v15[6] = *MEMORY[0x1E0C80C00];
  v12 = a1;
  v13 = v15;
  v14 = 0x300000000;
  if (!*a2)
    return 0;
  NamedAttr = mlir::Builder::getNamedAttr(&v12, (uint64_t)"storage_type", 12, *a2);
  v4 = v3;
  v5 = v14;
  if (v14 >= HIDWORD(v14))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v13, v15, v14 + 1, 16);
    v5 = v14;
  }
  v6 = (uint64_t *)((char *)v13 + 16 * v5);
  *v6 = NamedAttr;
  v6[1] = v4;
  v7 = v13;
  v8 = __CFADD__((_DWORD)v14, 1);
  v9 = (v14 + 1);
  LODWORD(v14) = v14 + 1;
  if (v8)
  {
    DictionaryAttr = 0;
    if (v13 == v15)
      return DictionaryAttr;
    goto LABEL_10;
  }
  DictionaryAttr = mlir::Builder::getDictionaryAttr(&v12, (mlir::MLIRContext *)v13, v9);
  v7 = v13;
  if (v13 != v15)
LABEL_10:
    free(v7);
  return DictionaryAttr;
}

uint64_t mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(uint64_t a1, const void **a2, const char *a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void ***v7;
  char *v8;
  char *v9;
  __int128 v10;
  const void ***v11;
  char *v12;
  char *v13;
  __int128 v14;
  uint64_t v15;
  _QWORD **v16;
  _QWORD **v17;
  void *v18;
  _QWORD *v19;
  _QWORD *v20;
  void *v21;
  void *v22;
  void *v23;
  unint64_t v25;
  unint64_t v26;
  int64_t v27;
  int64_t v28;
  const void **v29;
  const char *v30;
  uint64_t v31;
  __int16 v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;
  unsigned int v36;
  unsigned int v37;
  _BYTE v38[96];
  void *v39;
  _QWORD *v40;
  void *__p;
  _QWORD **v42;
  char v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  if (!a1
    || *(_UNKNOWN **)(*(_QWORD *)a1 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
  {
    return 1;
  }
  a4(&v33, a5);
  if (v33)
  {
    LODWORD(v29) = 3;
    v30 = "attribute '";
    v31 = 11;
    v7 = &v29;
    v8 = (char *)v35;
    if (v36 >= v37)
    {
      v25 = v36 + 1;
      if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
      {
        v27 = (char *)&v29 - (_BYTE *)v35;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v8 = (char *)v35;
        v7 = (const void ***)((char *)v35 + v27);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v25, 24);
        v7 = &v29;
        v8 = (char *)v35;
      }
    }
    v9 = &v8[24 * v36];
    v10 = *(_OWORD *)v7;
    *((_QWORD *)v9 + 2) = v7[2];
    *(_OWORD *)v9 = v10;
    ++v36;
    if (v33)
    {
      v32 = 261;
      v29 = a2;
      v30 = a3;
      mlir::Diagnostic::operator<<((uint64_t)&v34, &v29);
      if (v33)
      {
        LODWORD(v29) = 3;
        v30 = "' failed to satisfy constraint: valid SparseTensorStorage";
        v31 = 57;
        v11 = &v29;
        v12 = (char *)v35;
        if (v36 >= v37)
        {
          v26 = v36 + 1;
          if (v35 <= &v29 && (char *)v35 + 24 * v36 > (char *)&v29)
          {
            v28 = (char *)&v29 - (_BYTE *)v35;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v12 = (char *)v35;
            v11 = (const void ***)((char *)v35 + v28);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v35, v38, v26, 24);
            v11 = &v29;
            v12 = (char *)v35;
          }
        }
        v13 = &v12[24 * v36];
        v14 = *(_OWORD *)v11;
        *((_QWORD *)v13 + 2) = v11[2];
        *(_OWORD *)v13 = v14;
        ++v36;
      }
    }
  }
  v15 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v33);
  if (v33)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v33);
  if (v43)
  {
    v16 = (_QWORD **)__p;
    if (__p)
    {
      v17 = v42;
      v18 = __p;
      if (v42 != __p)
      {
        do
          v17 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v17 - 1);
        while (v17 != v16);
        v18 = __p;
      }
      v42 = v16;
      operator delete(v18);
    }
    v19 = v39;
    if (v39)
    {
      v20 = v40;
      v21 = v39;
      if (v40 != v39)
      {
        do
        {
          v23 = (void *)*--v20;
          v22 = v23;
          *v20 = 0;
          if (v23)
            operator delete[](v22);
        }
        while (v20 != v19);
        v21 = v39;
      }
      v40 = v19;
      operator delete(v21);
    }
    if (v35 != v38)
      free(v35);
  }
  return v15;
}

uint64_t mlir::OperationState::getOrAddProperties<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>(_QWORD *a1)
{
  uint64_t result;
  _QWORD *v3;
  unsigned __int8 v4;
  char **v5;
  int v6;
  unint64_t v7;
  unint64_t v8;
  const char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  const char *v14;
  unint64_t v15;

  result = a1[32];
  if (!result)
  {
    v3 = operator new(8uLL);
    *v3 = 0;
    a1[32] = v3;
    a1[34] = llvm::function_ref<void ()(mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties)#1}>;
    a1[35] = &v14;
    a1[36] = llvm::function_ref<void ()(mlir::OpaqueProperties,mlir::OpaqueProperties)>::callback_fn<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties & mlir::OperationState::getOrAddProperties<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>(void)::{lambda(mlir::OpaqueProperties,mlir::OpaqueProperties)#1}>;
    a1[37] = &v14;
    v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
    if ((v4 & 1) == 0)
    {
      v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      if (v6)
      {
        v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::detail::MaterializeSparseTensorOpGenericAdapto"
              "rBase::Properties]";
        v15 = 124;
        v7 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
        if (v15 >= v7)
          v8 = v7;
        else
          v8 = v15;
        v9 = &v14[v8];
        v10 = v15 - v8;
        if (v15 - v8 >= 0x12)
          v11 = 18;
        else
          v11 = v15 - v8;
        v12 = v10 - v11;
        if (v12 >= v12 - 1)
          v13 = v12 - 1;
        else
          v13 = v12;
        mlir::detail::TypeIDResolver<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v9[v11], v13);
        v5 = &mlir::mps::LSTMGradientOp::getAttributeNames(void)::attrNames;
      }
    }
    a1[33] = v5[482];
    return a1[32];
  }
  return result;
}

uint64_t mlir::DialectBytecodeReader::readAttribute<mlir::mps::SparseTensorStorageAttr>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  void *v5;
  const void ***v6;
  char *v7;
  char *v8;
  __int128 v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  const void ***v14;
  char *v15;
  char *v16;
  __int128 v17;
  const void ***v18;
  char *v19;
  char *v20;
  __int128 v21;
  uint64_t v22;
  _QWORD **v23;
  _QWORD **v24;
  void *v25;
  _QWORD *v26;
  _QWORD *v27;
  void *v28;
  void *v29;
  void *v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  int64_t v35;
  int64_t v36;
  int64_t v37;
  _WORD v38[20];
  uint64_t v39;
  const void **v40;
  unint64_t v41;
  uint64_t v42;
  __int16 v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  unsigned int v47;
  unsigned int v48;
  _BYTE v49[96];
  void *v50;
  _QWORD *v51;
  void *__p;
  _QWORD **v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x1E0C80C00];
  v39 = 0;
  if (!(*(unsigned __int8 (**)(uint64_t, uint64_t *))(*(_QWORD *)a1 + 48))(a1, &v39))
    return 0;
  v4 = v39;
  v5 = *(void **)(*(_QWORD *)v39 + 136);
  if (v5 != &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
    v4 = 0;
  *a2 = v4;
  if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id)
    return 1;
  v38[16] = 257;
  (*(void (**)(uint64_t *__return_ptr, uint64_t, _WORD *))(*(_QWORD *)a1 + 16))(&v44, a1, v38);
  if (v44)
  {
    LODWORD(v40) = 3;
    v41 = (unint64_t)"expected ";
    v42 = 9;
    v6 = &v40;
    v7 = (char *)v46;
    if (v47 >= v48)
    {
      v32 = v47 + 1;
      if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
      {
        v35 = (char *)&v40 - (_BYTE *)v46;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v7 = (char *)v46;
        v6 = (const void ***)((char *)v46 + v35);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v32, 24);
        v6 = &v40;
        v7 = (char *)v46;
      }
    }
    v8 = &v7[24 * v47];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = v6[2];
    *(_OWORD *)v8 = v9;
    ++v47;
  }
  v40 = (const void **)"StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::SparseTensorStorageAttr]";
  v41 = 84;
  v10 = llvm::StringRef::find((uint64_t *)&v40, "DesiredTypeName = ", 0x12uLL, 0);
  if (v44)
  {
    if (v41 >= v10)
      v11 = v10;
    else
      v11 = v41;
    v12 = 18;
    if (v41 - v11 < 0x12)
      v12 = v41 - v11;
    v13 = v41 - v11 - v12;
    if (v13 >= v13 - 1)
      --v13;
    v43 = 261;
    v40 = (const void **)((char *)v40 + v11 + v12);
    v41 = v13;
    mlir::Diagnostic::operator<<((uint64_t)&v45, &v40);
    if (v44)
    {
      LODWORD(v40) = 3;
      v41 = (unint64_t)", but got: ";
      v42 = 11;
      v14 = &v40;
      v15 = (char *)v46;
      if (v47 >= v48)
      {
        v33 = v47 + 1;
        if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
        {
          v36 = (char *)&v40 - (_BYTE *)v46;
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v15 = (char *)v46;
          v14 = (const void ***)((char *)v46 + v36);
        }
        else
        {
          llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v33, 24);
          v14 = &v40;
          v15 = (char *)v46;
        }
      }
      v16 = &v15[24 * v47];
      v17 = *(_OWORD *)v14;
      *((_QWORD *)v16 + 2) = v14[2];
      *(_OWORD *)v16 = v17;
      ++v47;
      if (v44)
      {
        v18 = &v40;
        mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v40, v39);
        v19 = (char *)v46;
        if (v47 >= v48)
        {
          v34 = v47 + 1;
          if (v46 <= &v40 && (char *)v46 + 24 * v47 > (char *)&v40)
          {
            v37 = (char *)&v40 - (_BYTE *)v46;
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v19 = (char *)v46;
            v18 = (const void ***)((char *)v46 + v37);
          }
          else
          {
            llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v46, v49, v34, 24);
            v18 = &v40;
            v19 = (char *)v46;
          }
        }
        v20 = &v19[24 * v47];
        v21 = *(_OWORD *)v18;
        *((_QWORD *)v20 + 2) = v18[2];
        *(_OWORD *)v20 = v21;
        ++v47;
      }
    }
  }
  v22 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v44);
  if (v44)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v44);
  if (v54)
  {
    v23 = (_QWORD **)__p;
    if (__p)
    {
      v24 = v53;
      v25 = __p;
      if (v53 != __p)
      {
        do
          v24 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v24 - 1);
        while (v24 != v23);
        v25 = __p;
      }
      v53 = v23;
      operator delete(v25);
    }
    v26 = v50;
    if (v50)
    {
      v27 = v51;
      v28 = v50;
      if (v51 != v50)
      {
        do
        {
          v30 = (void *)*--v27;
          v29 = v30;
          *v27 = 0;
          if (v30)
            operator delete[](v29);
        }
        while (v27 != v26);
        v28 = v50;
      }
      v51 = v26;
      operator delete(v28);
    }
    if (v46 != v49)
      free(v46);
  }
  return v22;
}

void mlir::mps::MaterializeSparseTensorOp::build(mlir::MLIRContext **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, unsigned int a7)
{
  mlir::MLIRContext *v13;
  unsigned __int8 **AttributeUniquer;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  _QWORD v19[2];

  v17 = a4;
  mlir::OperationState::addOperands(a2, (uint64_t)&v17, 1);
  mlir::OperationState::addOperands(a2, a5, a6);
  v13 = *a1;
  v18 = a7;
  AttributeUniquer = (unsigned __int8 **)mlir::MLIRContext::getAttributeUniquer(v13);
  v19[0] = &mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id;
  v19[1] = v13;
  v15 = mlir::StorageUniquer::get<mlir::mps::detail::SparseTensorStorageAttrStorage,mlir::mps::SparseTensorStorage>(AttributeUniquer, (uint64_t)_ZN4llvm12function_refIFvPN4mlir3mps6detail30SparseTensorStorageAttrStorageEEE11callback_fnIZNS1_6detail16AttributeUniquer13getWithTypeIDINS2_23SparseTensorStorageAttrEJNS2_19SparseTensorStorageEEEENSt3__19enable_ifIXntsr3std7is_sameINT_8ImplTypeENS1_16AttributeStorageEEE5valueESG_E4typeEPNS1_11MLIRContextENS1_6TypeIDEDpOT0_EUlPSI_E_EEvlS5_, (uint64_t)v19, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::SparseTensorStorageAttr,void>::id, &v18);
  *(_QWORD *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::MaterializeSparseTensorOpGenericAdaptorBase::Properties>((_QWORD *)a2) = v15;
  v16 = *(unsigned int *)(a2 + 72);
  if (v16 >= *(_DWORD *)(a2 + 76))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a2 + 64, (void *)(a2 + 80), v16 + 1, 8);
    LODWORD(v16) = *(_DWORD *)(a2 + 72);
  }
  *(_QWORD *)(*(_QWORD *)(a2 + 64) + 8 * v16) = a3;
  ++*(_DWORD *)(a2 + 72);
}

BOOL mlir::mps::MaterializeSparseTensorOp::verifyInvariantsImpl(uint64_t **this)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t *v4;
  const void **v5;
  const void *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD **v13;
  _QWORD **v14;
  void *v15;
  _QWORD *v16;
  _QWORD *v17;
  void *v18;
  void *v19;
  void *v20;
  uint64_t v21;
  const void ***v22;
  char *v23;
  char *v24;
  __int128 v25;
  uint64_t v26;
  const void ***v27;
  char *v28;
  char *v29;
  __int128 v30;
  uint64_t v31;
  const void ***v32;
  char *v33;
  char *v34;
  __int128 v35;
  const void ***v36;
  char *v37;
  char *v38;
  __int128 v39;
  char v40;
  _QWORD **v41;
  _QWORD **v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  void *v47;
  void *v48;
  uint64_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int v54;
  uint64_t *v55;
  const void **v56;
  const void *v57;
  void *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  char *v64;
  const void ***v65;
  char *v66;
  __int128 v67;
  uint64_t v68;
  char *v69;
  const void ***v70;
  char *v71;
  __int128 v72;
  uint64_t v73;
  char *v74;
  const void ***v75;
  char *v76;
  __int128 v77;
  const void ***v78;
  char *v79;
  char *v80;
  __int128 v81;
  char v82;
  _QWORD **v83;
  _QWORD **v84;
  void *v85;
  _QWORD *v86;
  void *v87;
  _QWORD *v88;
  void *v89;
  void *v90;
  void *v91;
  unint64_t v92;
  unint64_t v93;
  BOOL v94;
  unint64_t v95;
  BOOL v96;
  unint64_t v97;
  int64_t v98;
  int64_t v99;
  int64_t v100;
  int64_t v101;
  uint64_t v102;
  uint64_t NextResultAtOffset;
  uint64_t *v104;
  const void **v105;
  void *v106;
  uint64_t v108;
  uint64_t v109;
  _QWORD *ArgAttrsAttr;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const void ***v116;
  char *v117;
  char *v118;
  __int128 v119;
  uint64_t v120;
  const void ***v121;
  char *v122;
  char *v123;
  __int128 v124;
  uint64_t v125;
  const void ***v126;
  char *v127;
  char *v128;
  __int128 v129;
  const void ***v130;
  char *v131;
  char *v132;
  __int128 v133;
  char v134;
  _QWORD **v135;
  _QWORD **v136;
  void *v137;
  _QWORD *v138;
  _QWORD *v139;
  void *v140;
  void *v141;
  void *v142;
  unint64_t v144;
  unint64_t v145;
  unint64_t v146;
  BOOL v147;
  unint64_t v148;
  BOOL v149;
  unint64_t v150;
  BOOL v151;
  unint64_t v152;
  BOOL v153;
  unint64_t v154;
  unint64_t v155;
  int64_t v156;
  int64_t v157;
  int64_t v158;
  int64_t v159;
  int64_t v160;
  int64_t v161;
  int64_t v162;
  int64_t v163;
  const void **v164;
  uint64_t v165;
  __int16 v166;
  const void **v167;
  uint64_t v168;
  uint64_t OperandRange;
  const void **v170;
  const char *v171;
  uint64_t v172;
  const void **v173;
  uint64_t v174;
  void *v175;
  unsigned int v176;
  unsigned int v177;
  _BYTE v178[96];
  void *v179;
  _QWORD *v180;
  void *__p;
  _QWORD **v182;
  char v183;
  uint64_t v184;

  v184 = *MEMORY[0x1E0C80C00];
  v2 = *this;
  v3 = (*this)[2 * (((unint64_t)*((unsigned int *)*this + 11) >> 23) & 1) + 8];
  if (v3)
  {
    v173 = (const void **)v2;
    if (!mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(v3, (const void **)"storage_type", (const char *)0xC, (void (*)(uint64_t *__return_ptr, uint64_t))llvm::function_ref<mlir::InFlightDiagnostic ()(void)>::callback_fn<mlir::mps::__mlir_ods_local_attr_constraint_MPSOps32(mlir::Operation *,mlir::Attribute,llvm::StringRef)::$_0>, (uint64_t)&v173))return 0;
    v4 = *this;
    v5 = (const void **)(*(_QWORD *)(*(_QWORD *)((*this)[9] + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
    v6 = *v5;
    v7 = &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id;
    v8 = (void *)*((_QWORD *)*v5 + 17);
    if (v8 == &mlir::detail::TypeIDResolver<mlir::UnrankedTensorType,void>::id)
    {
      v21 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
      v173 = v5;
      v174 = v21;
      OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
      if (mlir::Type::isF32((mlir::Type *)&OperandRange))
      {
LABEL_57:
        v49 = *this;
        if ((*((_BYTE *)*this + 46) & 0x80) == 0)
        {
          v51 = -1;
          v52 = 32;
          goto LABEL_60;
        }
        v50 = *((unsigned int *)v49 + 17);
        v51 = v50 - 1;
        if (v50 != 1)
        {
          v52 = v49[9] + 32;
LABEL_60:
          v53 = 0;
          v54 = 1;
          do
          {
            v55 = *this;
            v56 = (const void **)(*(_QWORD *)(*(_QWORD *)(v52 + 32 * v53 + 24) + 8) & 0xFFFFFFFFFFFFFFF8);
            v57 = *v56;
            v58 = (void *)*((_QWORD *)*v56 + 17);
            if (v58 == v7)
            {
              v63 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v57 + 8);
              v173 = v56;
              v174 = v63;
              OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
              if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
                || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
              {
                goto LABEL_62;
              }
              v57 = *v56;
              if (*((_UNKNOWN **)*v56 + 17) == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
              {
LABEL_65:
                v59 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v57 + 8);
                v164 = v56;
                v165 = v59;
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
                {
                  v60 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v56 + 8);
                  v170 = v56;
                  v171 = (const char *)v60;
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v170);
                  if (v61 == 1)
                  {
                    v62 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v56 + 8);
                    v167 = v56;
                    v168 = v62;
                    OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v167);
                    if (mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 32)
                      || mlir::Type::isSignedInteger((mlir::Type *)&OperandRange, 64))
                    {
                      goto LABEL_62;
                    }
                  }
                }
              }
            }
            else if (v58 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
            {
              goto LABEL_65;
            }
            v166 = 261;
            v164 = (const void **)"operand";
            v165 = 7;
            mlir::Operation::emitOpError(v55, &v164, (uint64_t)&v173);
            if (v173)
            {
              LODWORD(v170) = 3;
              v171 = " #";
              v172 = 2;
              v64 = (char *)v175;
              if (v176 >= v177)
              {
                v92 = v176 + 1;
                if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                {
                  v98 = (char *)&v170 - (_BYTE *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v92, 24);
                  v64 = (char *)v175;
                  v65 = (const void ***)((char *)v175 + v98);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v92, 24);
                  v65 = &v170;
                  v64 = (char *)v175;
                }
              }
              else
              {
                v65 = &v170;
              }
              v66 = &v64[24 * v176];
              v67 = *(_OWORD *)v65;
              *((_QWORD *)v66 + 2) = v65[2];
              *(_OWORD *)v66 = v67;
              v68 = ++v176;
              if (v173)
              {
                LODWORD(v170) = 5;
                v171 = (const char *)v54;
                v69 = (char *)v175;
                if (v68 >= v177)
                {
                  v93 = v68 + 1;
                  v94 = (char *)v175 + 24 * v68 > (char *)&v170;
                  if (v175 <= &v170 && v94)
                  {
                    v99 = (char *)&v170 - (_BYTE *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v93, 24);
                    v69 = (char *)v175;
                    v70 = (const void ***)((char *)v175 + v99);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v93, 24);
                    v70 = &v170;
                    v69 = (char *)v175;
                  }
                }
                else
                {
                  v70 = &v170;
                }
                v71 = &v69[24 * v176];
                v72 = *(_OWORD *)v70;
                *((_QWORD *)v71 + 2) = v70[2];
                *(_OWORD *)v71 = v72;
                v73 = ++v176;
                if (v173)
                {
                  LODWORD(v170) = 3;
                  v171 = " must be variadic of unranked tensor of 32/64-bit signed integer values or 1D tensor of 32/64-b"
                         "it signed integer values, but got ";
                  v172 = 129;
                  v74 = (char *)v175;
                  if (v73 >= v177)
                  {
                    v95 = v73 + 1;
                    v96 = (char *)v175 + 24 * v73 > (char *)&v170;
                    if (v175 <= &v170 && v96)
                    {
                      v100 = (char *)&v170 - (_BYTE *)v175;
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v95, 24);
                      v74 = (char *)v175;
                      v75 = (const void ***)((char *)v175 + v100);
                    }
                    else
                    {
                      llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v95, 24);
                      v75 = &v170;
                      v74 = (char *)v175;
                    }
                  }
                  else
                  {
                    v75 = &v170;
                  }
                  v76 = &v74[24 * v176];
                  v77 = *(_OWORD *)v75;
                  *((_QWORD *)v76 + 2) = v75[2];
                  *(_OWORD *)v76 = v77;
                  ++v176;
                  if (v173)
                  {
                    v78 = &v170;
                    mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v56);
                    v79 = (char *)v175;
                    if (v176 >= v177)
                    {
                      v97 = v176 + 1;
                      if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                      {
                        v101 = (char *)&v170 - (_BYTE *)v175;
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v97, 24);
                        v79 = (char *)v175;
                        v78 = (const void ***)((char *)v175 + v101);
                      }
                      else
                      {
                        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v97, 24);
                        v78 = &v170;
                        v79 = (char *)v175;
                      }
                    }
                    v80 = &v79[24 * v176];
                    v81 = *(_OWORD *)v78;
                    *((_QWORD *)v80 + 2) = v78[2];
                    *(_OWORD *)v80 = v81;
                    ++v176;
                  }
                }
              }
            }
            v82 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
            if (v173)
              mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
            if (v183)
            {
              v83 = (_QWORD **)__p;
              if (__p)
              {
                v84 = v182;
                v85 = __p;
                if (v182 != __p)
                {
                  do
                    v84 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v84 - 1);
                  while (v84 != v83);
                  v85 = __p;
                }
                v182 = v83;
                operator delete(v85);
              }
              v86 = v179;
              if (v179)
              {
                v87 = v7;
                v88 = v180;
                v89 = v179;
                if (v180 != v179)
                {
                  do
                  {
                    v91 = (void *)*--v88;
                    v90 = v91;
                    *v88 = 0;
                    if (v91)
                      operator delete[](v90);
                  }
                  while (v88 != v86);
                  v89 = v179;
                }
                v180 = v86;
                operator delete(v89);
                v7 = v87;
              }
              if (v175 != v178)
                free(v175);
            }
            if (!v82)
              return 0;
LABEL_62:
            ++v54;
            ++v53;
          }
          while (v53 != v51);
        }
        if (*((_DWORD *)*this + 9))
          v102 = (uint64_t)(*this - 2);
        else
          v102 = 0;
        NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v102, 0);
        v104 = *this;
        v105 = (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8);
        v106 = (void *)*((_QWORD *)*v105 + 17);
        if (v106 == &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id || v106 == v7)
        {
          v108 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
          v173 = v105;
          v174 = v108;
          OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v173);
          if (mlir::Type::isF32((mlir::Type *)&OperandRange))
          {
            v109 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
            v164 = v105;
            v165 = v109;
            if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
            {
              ArgAttrsAttr = (_QWORD *)mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v164);
              if (v111)
              {
                v112 = 8 * v111;
                while (*ArgAttrsAttr != 0x8000000000000000)
                {
                  ++ArgAttrsAttr;
                  v112 -= 8;
                  if (!v112)
                    goto LABEL_133;
                }
              }
              else
              {
LABEL_133:
                v113 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
                v170 = v105;
                v171 = (const char *)v113;
                if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v170))
                {
                  v114 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v105 + 8);
                  v167 = v105;
                  v168 = v114;
                  mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v167);
                  if (v115 == 2)
                    return 1;
                }
              }
            }
          }
        }
        v166 = 261;
        v164 = (const void **)"result";
        v165 = 6;
        mlir::Operation::emitOpError(v104, &v164, (uint64_t)&v173);
        if (v173)
        {
          LODWORD(v170) = 3;
          v171 = " #";
          v172 = 2;
          v116 = &v170;
          v117 = (char *)v175;
          if (v176 >= v177)
          {
            v145 = v176 + 1;
            if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
            {
              v157 = (char *)&v170 - (_BYTE *)v175;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v145, 24);
              v117 = (char *)v175;
              v116 = (const void ***)((char *)v175 + v157);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v145, 24);
              v116 = &v170;
              v117 = (char *)v175;
            }
          }
          v118 = &v117[24 * v176];
          v119 = *(_OWORD *)v116;
          *((_QWORD *)v118 + 2) = v116[2];
          *(_OWORD *)v118 = v119;
          v120 = ++v176;
          if (v173)
          {
            LODWORD(v170) = 5;
            v171 = 0;
            v121 = &v170;
            v122 = (char *)v175;
            if (v120 >= v177)
            {
              v148 = v120 + 1;
              v149 = (char *)v175 + 24 * v120 > (char *)&v170;
              if (v175 <= &v170 && v149)
              {
                v159 = (char *)&v170 - (_BYTE *)v175;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v148, 24);
                v122 = (char *)v175;
                v121 = (const void ***)((char *)v175 + v159);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v148, 24);
                v121 = &v170;
                v122 = (char *)v175;
              }
            }
            v123 = &v122[24 * v176];
            v124 = *(_OWORD *)v121;
            *((_QWORD *)v123 + 2) = v121[2];
            *(_OWORD *)v123 = v124;
            v125 = ++v176;
            if (v173)
            {
              LODWORD(v170) = 3;
              v171 = " must be static-shape defined tensor with rank equal to any of:2, but got ";
              v172 = 74;
              v126 = &v170;
              v127 = (char *)v175;
              if (v125 >= v177)
              {
                v152 = v125 + 1;
                v153 = (char *)v175 + 24 * v125 > (char *)&v170;
                if (v175 <= &v170 && v153)
                {
                  v161 = (char *)&v170 - (_BYTE *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v152, 24);
                  v127 = (char *)v175;
                  v126 = (const void ***)((char *)v175 + v161);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v152, 24);
                  v126 = &v170;
                  v127 = (char *)v175;
                }
              }
              v128 = &v127[24 * v176];
              v129 = *(_OWORD *)v126;
              *((_QWORD *)v128 + 2) = v126[2];
              *(_OWORD *)v128 = v129;
              ++v176;
              if (v173)
              {
                v130 = &v170;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v105);
                v131 = (char *)v175;
                if (v176 >= v177)
                {
                  v155 = v176 + 1;
                  if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                  {
                    v163 = (char *)&v170 - (_BYTE *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v155, 24);
                    v131 = (char *)v175;
                    v130 = (const void ***)((char *)v175 + v163);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v155, 24);
                    v130 = &v170;
                    v131 = (char *)v175;
                  }
                }
                v132 = &v131[24 * v176];
                v133 = *(_OWORD *)v130;
                *((_QWORD *)v132 + 2) = v130[2];
                *(_OWORD *)v132 = v133;
                ++v176;
              }
            }
          }
        }
        v134 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
        if (v173)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
        if (v183)
        {
          v135 = (_QWORD **)__p;
          if (__p)
          {
            v136 = v182;
            v137 = __p;
            if (v182 != __p)
            {
              do
                v136 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v136 - 1);
              while (v136 != v135);
              v137 = __p;
            }
            v182 = v135;
            operator delete(v137);
          }
          v138 = v179;
          if (v179)
          {
            v139 = v180;
            v140 = v179;
            if (v180 != v179)
            {
              do
              {
                v142 = (void *)*--v139;
                v141 = v142;
                *v139 = 0;
                if (v142)
                  operator delete[](v141);
              }
              while (v139 != v138);
              v140 = v179;
            }
            v180 = v138;
            operator delete(v140);
          }
          if (v175 != v178)
            free(v175);
        }
        return v134 != 0;
      }
      v6 = *v5;
      if (*((_UNKNOWN **)*v5 + 17) != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
      {
LABEL_25:
        v166 = 261;
        v164 = (const void **)"operand";
        v165 = 7;
        mlir::Operation::emitOpError(v4, &v164, (uint64_t)&v173);
        if (v173)
        {
          LODWORD(v170) = 3;
          v171 = " #";
          v172 = 2;
          v22 = &v170;
          v23 = (char *)v175;
          if (v176 >= v177)
          {
            v144 = v176 + 1;
            if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
            {
              v156 = (char *)&v170 - (_BYTE *)v175;
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v144, 24);
              v23 = (char *)v175;
              v22 = (const void ***)((char *)v175 + v156);
            }
            else
            {
              llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v144, 24);
              v22 = &v170;
              v23 = (char *)v175;
            }
          }
          v24 = &v23[24 * v176];
          v25 = *(_OWORD *)v22;
          *((_QWORD *)v24 + 2) = v22[2];
          *(_OWORD *)v24 = v25;
          v26 = ++v176;
          if (v173)
          {
            LODWORD(v170) = 5;
            v171 = 0;
            v27 = &v170;
            v28 = (char *)v175;
            if (v26 >= v177)
            {
              v146 = v26 + 1;
              v147 = (char *)v175 + 24 * v26 > (char *)&v170;
              if (v175 <= &v170 && v147)
              {
                v158 = (char *)&v170 - (_BYTE *)v175;
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v146, 24);
                v28 = (char *)v175;
                v27 = (const void ***)((char *)v175 + v158);
              }
              else
              {
                llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v146, 24);
                v27 = &v170;
                v28 = (char *)v175;
              }
            }
            v29 = &v28[24 * v176];
            v30 = *(_OWORD *)v27;
            *((_QWORD *)v29 + 2) = v27[2];
            *(_OWORD *)v29 = v30;
            v31 = ++v176;
            if (v173)
            {
              LODWORD(v170) = 3;
              v171 = " must be unranked tensor of 32-bit float values or 1D tensor of 32-bit float values, but got ";
              v172 = 93;
              v32 = &v170;
              v33 = (char *)v175;
              if (v31 >= v177)
              {
                v150 = v31 + 1;
                v151 = (char *)v175 + 24 * v31 > (char *)&v170;
                if (v175 <= &v170 && v151)
                {
                  v160 = (char *)&v170 - (_BYTE *)v175;
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v150, 24);
                  v33 = (char *)v175;
                  v32 = (const void ***)((char *)v175 + v160);
                }
                else
                {
                  llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v150, 24);
                  v32 = &v170;
                  v33 = (char *)v175;
                }
              }
              v34 = &v33[24 * v176];
              v35 = *(_OWORD *)v32;
              *((_QWORD *)v34 + 2) = v32[2];
              *(_OWORD *)v34 = v35;
              ++v176;
              if (v173)
              {
                v36 = &v170;
                mlir::DiagnosticArgument::DiagnosticArgument((uint64_t)&v170, (uint64_t)v5);
                v37 = (char *)v175;
                if (v176 >= v177)
                {
                  v154 = v176 + 1;
                  if (v175 <= &v170 && (char *)v175 + 24 * v176 > (char *)&v170)
                  {
                    v162 = (char *)&v170 - (_BYTE *)v175;
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v154, 24);
                    v37 = (char *)v175;
                    v36 = (const void ***)((char *)v175 + v162);
                  }
                  else
                  {
                    llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v175, v178, v154, 24);
                    v36 = &v170;
                    v37 = (char *)v175;
                  }
                }
                v38 = &v37[24 * v176];
                v39 = *(_OWORD *)v36;
                *((_QWORD *)v38 + 2) = v36[2];
                *(_OWORD *)v38 = v39;
                ++v176;
              }
            }
          }
        }
        v40 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
        if (v173)
          mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
        if (v183)
        {
          v41 = (_QWORD **)__p;
          if (__p)
          {
            v42 = v182;
            v43 = __p;
            if (v182 != __p)
            {
              do
                v42 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v42 - 1);
              while (v42 != v41);
              v43 = __p;
            }
            v182 = v41;
            operator delete(v43);
          }
          v44 = v179;
          if (v179)
          {
            v45 = v180;
            v46 = v179;
            if (v180 != v179)
            {
              do
              {
                v48 = (void *)*--v45;
                v47 = v48;
                *v45 = 0;
                if (v48)
                  operator delete[](v47);
              }
              while (v45 != v44);
              v46 = v179;
            }
            v180 = v44;
            operator delete(v46);
          }
          if (v175 != v178)
            free(v175);
        }
        if (!v40)
          return 0;
        goto LABEL_57;
      }
    }
    else if (v8 != &mlir::detail::TypeIDResolver<mlir::RankedTensorType,void>::id)
    {
      goto LABEL_25;
    }
    v164 = v5;
    v165 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)v6 + 8);
    if (mlir::CallOpInterface::getArgOperands((mlir::CallOpInterface *)&v164))
    {
      v9 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
      v170 = v5;
      v171 = (const char *)v9;
      mlir::CallableOpInterface::getArgAttrsAttr((mlir::CallableOpInterface *)&v170);
      if (v10 == 1)
      {
        v11 = mlir::detail::InterfaceMap::lookup<mlir::ShapedType>((uint64_t)*v5 + 8);
        v167 = v5;
        v168 = v11;
        OperandRange = mlir::MemoryMapperInterface::getOperandRange((mlir::MemoryMapperInterface *)&v167);
        if (mlir::Type::isF32((mlir::Type *)&OperandRange))
          goto LABEL_57;
      }
    }
    goto LABEL_25;
  }
  v164 = (const void **)"requires attribute 'storage_type'";
  v166 = 259;
  mlir::OpState::emitOpError(this, &v164, (uint64_t)&v173);
  v12 = mlir::InFlightDiagnostic::operator mlir::LogicalResult((uint64_t)&v173);
  if (v173)
    mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)&v173);
  if (v183)
  {
    v13 = (_QWORD **)__p;
    if (__p)
    {
      v14 = v182;
      v15 = __p;
      if (v182 != __p)
      {
        do
          v14 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v14 - 1);
        while (v14 != v13);
        v15 = __p;
      }
      v182 = v13;
      operator delete(v15);
    }
    v16 = v179;
    if (v179)
    {
      v17 = v180;
      v18 = v179;
      if (v180 != v179)
      {
        do
        {
          v20 = (void *)*--v17;
          v19 = v20;
          *v17 = 0;
          if (v20)
            operator delete[](v19);
        }
        while (v17 != v16);
        v18 = v179;
      }
      v180 = v16;
      operator delete(v18);
    }
    if (v175 != v178)
      free(v175);
  }
  return v12;
}

