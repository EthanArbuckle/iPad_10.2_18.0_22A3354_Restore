uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CeilOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CeilOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CeilOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CeilOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CeilOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.ceil";
  v28 = 8;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CeilOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CeilOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::CeilOpGenericAdaptorBase::CeilOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::CeilOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.clamp", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ClampOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37150;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.clamp", 9, v3, v4, 0, 0);
  *v5 = &off_1E0DFF3B0;
  v5[12] = mlir::mps::ClampOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ClampOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ClampOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ClampOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.clamp";
  v28[1] = 9;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ClampOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ClampOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ClampOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ClampOpGenericAdaptorBase::ClampOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  __guard *v26;
  __guard v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  __guard v144;
  __guard v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[209];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v210 = 97;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[204];
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v210 = 82;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[132];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ClampOp>,mlir::OpTrait::OneResult<mlir::mps::ClampOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ClampOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ClampOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::ClampOp>,mlir::OpTrait::OpInvariants<mlir::mps::ClampOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ClampOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ClampOp>,mlir::OpTrait::Stitchable<mlir::mps::ClampOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ClampOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ClampOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ClampOp>,mlir::OpTrait::OneResult<mlir::mps::ClampOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ClampOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ClampOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::ClampOp>,mlir::OpTrait::OpInvariants<mlir::mps::ClampOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ClampOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ClampOp>,mlir::OpTrait::Stitchable<mlir::mps::ClampOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ClampOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ClampOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3)
    && (v7 = a1, mlir::mps::ClampOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ClampOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.col_to_im", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ColToImOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E385A0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.col_to_im", 13, v3, v4, 0, 0);
  *v5 = &off_1E0DFFC48;
  v5[12] = mlir::mps::ColToImOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::ColToImOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::ColToImOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::ColToImOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::ColToImOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ColToImOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::ColToImOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ColToImOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ColToImOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ColToImOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ColToImOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51180;
  v11 = v10;
  v12[0] = off_1E0E51180;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ColToImOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::ColToImOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E51180;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E51180;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.col_to_im";
  v28[1] = 13;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ColToImOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51180;
  v11 = v10;
  v12[0] = off_1E0E51180;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ColToImOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ColToImOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_QWORD *)(v10 + 32);
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.col_to_im", 13, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  void *v134;
  void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v186 = 90;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v186 = 89;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v186 = 100;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::ColToImOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::ColToImOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ColToImOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.concat", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ConcatOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37B78;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.concat", 10, v3, v4, 0, 0);
  *v5 = &off_1E0E52898;
  v5[12] = mlir::mps::ConcatOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 10
    && (*(_QWORD *)a3 == 0x61656C7265746E69 ? (v7 = *(unsigned __int16 *)(a3 + 8) == 25974) : (v7 = 0), v7))
  {
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 10 && *(_QWORD *)result == 0x61656C7265746E69 && *(_WORD *)(result + 8) == 25974)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"interleave", 10, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"interleave", (const char *)0xA, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ConcatOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::ConcatOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConcatOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ConcatOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, char *a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ConcatOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, char *a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ConcatOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ConcatOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, char *a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::ConcatOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.concat";
  v28[1] = 10;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConcatOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ConcatOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ConcatOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.concat", 10, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  void *v134;
  void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<1>::Impl<Empty>]";
      v186 = 97;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[197];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v186 = 89;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v186 = 100;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
    return 0;
  v6 = a1;
  if (!mlir::mps::ConcatOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::ConcatOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::ConcatOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conjugate", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ConjugateOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2EFA0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conjugate", 13, v3, v4, 0, 0);
  *v5 = &off_1E0DFBF70;
  v5[12] = mlir::mps::ConjugateOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConjugateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ConjugateOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ConjugateOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ConjugateOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.conjugate";
  v28 = 13;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ConjugateOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ConjugateOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ConjugateOpGenericAdaptorBase::ConjugateOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  __guard v162;
  __guard v163;
  __guard v164;
  __guard v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  void *v199;
  void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v235 = 104;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v235 = 82;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[158];
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v235 = 82;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[132];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v235 = 97;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[205];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v235 = 97;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[204];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v235 = 100;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[169];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v235 = 90;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v35[152] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ConjugateOp>,mlir::OpTrait::OneResult<mlir::mps::ConjugateOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ConjugateOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ConjugateOp>,mlir::OpTrait::OneOperand<mlir::mps::ConjugateOp>,mlir::OpTrait::OpInvariants<mlir::mps::ConjugateOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ConjugateOp>,mlir::OpTrait::Stitchable<mlir::mps::ConjugateOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ConjugateOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ConjugateOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ConjugateOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ConjugateOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ConjugateOp>,mlir::OpTrait::OneResult<mlir::mps::ConjugateOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ConjugateOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ConjugateOp>,mlir::OpTrait::OneOperand<mlir::mps::ConjugateOp>,mlir::OpTrait::OpInvariants<mlir::mps::ConjugateOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ConjugateOp>,mlir::OpTrait::Stitchable<mlir::mps::ConjugateOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ConjugateOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ConjugateOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ConjugateOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ConjugateOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  mlir::Operation *v8;
  mlir::Operation *v9;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& (*(_DWORD *)(a1 + 36) ? (v6 = a1 - 16) : (v6 = 0), (NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0))&& mlir::OpTrait::impl::verifySameOperandsAndResultType((mlir::OpTrait::impl *)a1, v8)))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast((mlir::OpTrait::impl *)a1, v9) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ConjugateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::ResultsBroadcastableShape,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.constant", 12, v3, v4, 0, 0);
  *v5 = &off_1E0DFB9F0;
  v5[12] = mlir::mps::ConstantOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::getInherentAttr(uint64_t a1, uint64_t a2)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a3;
  return mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::populateInherentAttrs(uint64_t a1, uint64_t a2)
{
  return mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD **a4)
{
  _QWORD *v4;
  void *v5;
  BOOL v6;
  _QWORD *v7;
  uint64_t v8;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v10;
  pthread_rwlock_t **v11;
  _QWORD *v12;

  if (a4)
  {
    v4 = *a4;
    *a3 = *a4;
    if (v4)
    {
      v5 = *(void **)(*v4 + 136);
      v6 = v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
      if (v5 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
        v7 = v4;
      else
        v7 = 0;
      v12 = v7;
      if (v6)
      {
        v8 = v4[2];
        Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v12);
        v11 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v10) + 48);
        llvm::sys::RWMutexImpl::lock(v11);
        ++*(_QWORD *)(v8 + 88);
        llvm::sys::RWMutexImpl::unlock_shared(v11);
      }
    }
  }
  else
  {
    *a3 = 0;
  }
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::deleteProperties(uint64_t a1, _QWORD **a2)
{
  _QWORD *v2;
  void *v3;
  BOOL v4;
  _QWORD *v5;
  MPSResourceBlobEntry *v6;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v8;
  pthread_rwlock_t **Manager;
  _QWORD *v10;

  v2 = *a2;
  if (*a2)
  {
    v3 = *(void **)(*v2 + 136);
    v4 = v3 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v3 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v5 = *a2;
    else
      v5 = 0;
    v10 = v5;
    if (v4)
    {
      v6 = (MPSResourceBlobEntry *)v2[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v10);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v8);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, v6);
    }
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ConstantOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  mlir::MLIRContext *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (mlir::MLIRContext *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::ConstantOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD **a3)
{
  _QWORD *v3;
  void *v4;
  BOOL v5;
  _QWORD *v6;
  uint64_t v7;
  mlir::mps::MPSResourceBlobManagerInterface *Context;
  mlir::MLIRContext *v9;
  pthread_rwlock_t **v10;
  _QWORD *v11;

  v3 = *a3;
  *a2 = *a3;
  if (v3)
  {
    v4 = *(void **)(*v3 + 136);
    v5 = v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    if (v4 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id)
      v6 = v3;
    else
      v6 = 0;
    v11 = v6;
    if (v5)
    {
      v7 = v3[2];
      Context = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)&v11);
      v10 = (pthread_rwlock_t **)((char *)mlir::mps::MPSResourceBlobManagerInterface::getManager(Context, v9) + 48);
      llvm::sys::RWMutexImpl::lock(v10);
      ++*(_QWORD *)(v7 + 88);
      llvm::sys::RWMutexImpl::unlock_shared(v10);
    }
  }
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ConstantOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::ConstantOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;

  if (*(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64))
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 16))(a3);
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ConstantOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::foldSingleResultHook<mlir::mps::ConstantOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::foldSingleResultHook<mlir::mps::ConstantOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD **v13;
  mlir::UnitAttr *Context;
  mlir::MLIRContext *v15;
  uint64_t v16;
  unint64_t v17;
  void *v18;
  BOOL v19;
  unint64_t v20;
  uint64_t v21;
  MPSResourceBlobEntry *v23;
  mlir::mps::MPSResourceBlobManagerInterface *v24;
  mlir::MLIRContext *v25;
  pthread_rwlock_t **Manager;
  _BYTE v27[24];
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31[3];

  v31[2] = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = a1 + 64;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 64 + 16 * ((v9 >> 23) & 1) + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v13 = (_QWORD **)(a1 + 64 + 16 * ((v9 >> 23) & 1));
  else
    v13 = 0;
  mlir::ValueRange::ValueRange(v31, v12, v11);
  mlir::mps::detail::ConstantOpGenericAdaptorBase::ConstantOpGenericAdaptorBase((mlir::Attribute *)v27, v8, v13, v31[0], v31[1]);
  v29 = a2;
  v30 = a3;
  Context = (mlir::UnitAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a1 + 24));
  v16 = *(_QWORD *)(v10 + 16 * (((unint64_t)*(unsigned int *)(a1 + 44) >> 23) & 1));
  if (!v16)
    v16 = mlir::UnitAttr::get(Context, v15);
  if (v16)
    mlir::detail::InterfaceMap::lookup<mlir::ElementsAttr>(*(_QWORD *)v16 + 8);
  v17 = v16 & 0xFFFFFFFFFFFFFFFBLL;
  if (v28)
  {
    v18 = *(void **)(*v28 + 136);
    v19 = v18 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id;
    v20 = v18 == &mlir::detail::TypeIDResolver<mlir::mps::MPSBufferTensorAttr,void>::id ? (unint64_t)v28 : 0;
    v31[0] = v20;
    if (v19)
    {
      v23 = (MPSResourceBlobEntry *)v28[2];
      v24 = (mlir::mps::MPSResourceBlobManagerInterface *)mlir::Attribute::getContext((mlir::Attribute *)v31);
      Manager = (pthread_rwlock_t **)mlir::mps::MPSResourceBlobManagerInterface::getManager(v24, v25);
      mlir::mps::MPSResourceBlobManagerInterface::decrementResourceRefcount(Manager, v23);
      if (v17 >= 8)
        goto LABEL_17;
      return 0;
    }
  }
  if (v17 < 8)
    return 0;
LABEL_17:
  v21 = *(unsigned int *)(a4 + 8);
  if (v21 >= *(_DWORD *)(a4 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v21 + 1, 8);
    LODWORD(v21) = *(_DWORD *)(a4 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a4 + 8 * v21) = v17;
  ++*(_DWORD *)(a4 + 8);
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  __guard *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  void *v134;
  void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroOperands<Empty>]";
      v186 = 84;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroOperands<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroOperands>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[193];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v186 = 89;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ConstantLike<Empty>]";
      v186 = 84;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ConstantLike<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ConstantLike>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[189];
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v186 = 82;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[132] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroOperands(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::mps::ConstantOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::mps::ConstantOp::verify((uint64_t **)&v7) != 0;
}

uint64_t mlir::Op<mlir::mps::ConstantOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::ZeroOperands,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::ConstantLike,mlir::OpTrait::Stitchable>::verifyRegionInvariants()
{
  return 1;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_2d_data_gradient", 25, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv2DDataGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33B68;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_2d_data_gradient", 25, v3, v4, 0, 0);
  *v5 = &off_1E0DFDBF8;
  v5[12] = mlir::mps::Conv2DDataGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv2DDataGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv2DDataGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DDataGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Conv2DDataGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DDataGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv2DDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_2d_data_gradient";
  v28[1] = 25;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DDataGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DDataGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_2d_data_gradient", 25, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  __guard v158;
  __guard v159;
  __guard v160;
  __guard v161;
  __guard v162;
  __guard v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v210 = 97;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[303];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface::Trait<Empty>]";
      v210 = 98;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::mps::MixedPrecisionInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[489];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DDataGradientOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::Conv2DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DDataGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv2DDataGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_2d", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv2DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37C40;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_2d", 11, v3, v4, 0, 0);
  *v5 = &off_1E0DFF828;
  v5[12] = mlir::mps::Conv2DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv2DOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv2DOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isValidMixedPrecision(uint64_t a1, mlir::mps::mixed_precision *a2)
{
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck(a2, 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, _DWORD *a11)
{
  return mlir::mps::Conv2DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51078;
  v11 = v10;
  v12[0] = off_1E0E51078;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, &v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E51078;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E51078;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_2d";
  v28[1] = 11;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51078;
  v11 = v10;
  v12[0] = off_1E0E51078;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_2d", 11, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::Conv2DOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::Conv2DOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv2DOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_2d_weights_gradient", 28, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv2DWeightsGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34658;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_2d_weights_gradient", 28, v3, v4, 0, 0);
  *v5 = &off_1E0DFE120;
  v5[12] = mlir::mps::Conv2DWeightsGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv2DWeightsGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv2DWeightsGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv2DWeightsGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Conv2DWeightsGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DWeightsGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv2DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv2DWeightsGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_2d_weights_gradient";
  v28[1] = 28;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv2DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DWeightsGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv2DWeightsGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_2d_weights_gradient", 28, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  void **v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[209];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface::Trait<Empty>]";
      v210 = 98;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::mps::MixedPrecisionInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[489];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::Conv2DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv2DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv2DWeightsGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)3)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv2DWeightsGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_3d_data_gradient", 25, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv3DDataGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33C30;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_3d_data_gradient", 25, v3, v4, 0, 0);
  *v5 = &off_1E0DFDC50;
  v5[12] = mlir::mps::Conv3DDataGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv3DDataGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv3DDataGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DDataGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Conv3DDataGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DDataGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E50FC8;
  v11 = v10;
  v12[0] = off_1E0E50FC8;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv3DDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E50FC8;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E50FC8;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_3d_data_gradient";
  v28[1] = 25;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E50FC8;
  v11 = v10;
  v12[0] = off_1E0E50FC8;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DDataGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DDataGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_3d_data_gradient", 25, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  uint64_t *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DDataGradientOp>>(a1, a2))return 0;
  v4 = (uint64_t *)a1;
  return mlir::mps::Conv3DDataGradientOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::Conv3DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DDataGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv3DDataGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_3d", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv3DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37D08;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_3d", 11, v3, v4, 0, 0);
  *v5 = &off_1E0DFF880;
  v5[12] = mlir::mps::Conv3DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv3DOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv3DOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isValidMixedPrecision(uint64_t a1, mlir::mps::mixed_precision *a2)
{
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck(a2, 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Conv3DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E510D0;
  v11 = v10;
  v12[0] = off_1E0E510D0;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv3DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E510D0;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E510D0;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_3d";
  v28[1] = 11;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E510D0;
  v11 = v10;
  v12[0] = off_1E0E510D0;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_3d", 11, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  uint64_t *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::Conv3DOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DOp>>(a1, a2))return 0;
  v4 = (uint64_t *)a1;
  return mlir::mps::Conv3DOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::Conv3DOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv3DOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.conv_3d_weights_gradient", 28, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Conv3DWeightsGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34720;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.conv_3d_weights_gradient", 28, v3, v4, 0, 0);
  *v5 = &off_1E0DFE178;
  v5[12] = mlir::mps::Conv3DWeightsGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  char *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, char *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::Conv3DWeightsGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::Conv3DWeightsGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::Conv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::Conv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::getOpPropertyByteSize()
{
  return 56;
}

double mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::Conv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::Conv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::Conv3DWeightsGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 0, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Conv3DWeightsGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DWeightsGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51020;
  v11 = v10;
  v12[0] = off_1E0E51020;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Conv3DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::Conv3DWeightsGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E51020;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E51020;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.conv_3d_weights_gradient";
  v28[1] = 28;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Conv3DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E51020;
  v11 = v10;
  v12[0] = off_1E0E51020;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DWeightsGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Conv3DWeightsGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.conv_3d_weights_gradient", 28, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  uint64_t *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>>(a1, a2))return 0;
  v4 = (uint64_t *)a1;
  return mlir::mps::Conv3DWeightsGradientOp::verify(&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::Conv3DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::Conv3DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::Conv3DWeightsGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)3)
    && (v6 = (uint64_t *)a1, mlir::mps::Conv3DWeightsGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::Conv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cos", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CosOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E35530;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cos", 7, v3, v4, 0, 0);
  *v5 = &off_1E0DFE7A8;
  v5[12] = mlir::mps::CosOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CosOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CosOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CosOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CosOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.cos";
  v28 = 7;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CosOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CosOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::CosOpGenericAdaptorBase::CosOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::CosOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cosh", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CoshOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E361B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cosh", 8, v3, v4, 0, 0);
  *v5 = &off_1E0DFECD0;
  v5[12] = mlir::mps::CoshOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CoshOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CoshOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CoshOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CoshOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.cosh";
  v28 = 8;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CoshOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CoshOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::CoshOpGenericAdaptorBase::CoshOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::CoshOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cost_volume", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CostVolumeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F6A8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cost_volume", 15, v3, v4, 0, 0);
  *v5 = &off_1E0DFC230;
  v5[12] = mlir::mps::CostVolumeOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::CostVolumeOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::CostVolumeOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::CostVolumeOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::CostVolumeOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::CostVolumeOp::populateDefaultProperties(a2, (_QWORD *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return mlir::mps::CostVolumeOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CostVolumeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CostVolumeOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CostVolumeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::inferReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::CostVolumeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CostVolumeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CostVolumeOp>::refineReturnTypes(mlir::UnknownLoc *a1, uint64_t a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::CostVolumeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.cost_volume";
  v28[1] = 15;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CostVolumeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CostVolumeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CostVolumeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.cost_volume", 15, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  void *v133;
  void *v134;
  void *v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v186 = 90;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[209];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v186 = 89;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v186 = 100;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
    return 0;
  v6 = a1;
  if (!mlir::mps::CostVolumeOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::CostVolumeOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::CostVolumeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.create_complex", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CreateComplexOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E31778;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.create_complex", 18, v3, v4, 0, 0);
  *v5 = &off_1E0DFCC28;
  v5[12] = mlir::mps::CreateComplexOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateComplexOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::CreateComplexOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CreateComplexOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CreateComplexOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v11 = a3;
  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::CreateComplexOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.create_complex";
  v30[1] = 18;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateComplexOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CreateComplexOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CreateComplexOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::CreateComplexOpGenericAdaptorBase::CreateComplexOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  __guard v146;
  __guard v147;
  __guard v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[158];
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v210 = 82;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[132];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v210 = 97;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[204];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::CreateComplexOp>,mlir::OpTrait::OneResult<mlir::mps::CreateComplexOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::CreateComplexOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::CreateComplexOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::CreateComplexOp>,mlir::OpTrait::OpInvariants<mlir::mps::CreateComplexOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::CreateComplexOp>,mlir::OpTrait::Stitchable<mlir::mps::CreateComplexOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::CreateComplexOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::CreateComplexOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::CreateComplexOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::CreateComplexOp>,mlir::OpTrait::OneResult<mlir::mps::CreateComplexOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::CreateComplexOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::CreateComplexOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::CreateComplexOp>,mlir::OpTrait::OpInvariants<mlir::mps::CreateComplexOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::CreateComplexOp>,mlir::OpTrait::Stitchable<mlir::mps::CreateComplexOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::CreateComplexOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::CreateComplexOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::CreateComplexOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v7 = a1, mlir::mps::CreateComplexOp::verifyInvariantsImpl((uint64_t **)&v7)))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(a1, v5) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::CreateComplexOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.create_texture_tensor", 25, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CreateTextureTensorOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34270;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.create_texture_tensor", 25, v3, v4, 0, 0);
  *v5 = &off_1E0DFDF10;
  v5[12] = mlir::mps::CreateTextureTensorOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 12)
  {
    if (*(_QWORD *)a3 != 0x6F665F6C65786970 || *(_DWORD *)(a3 + 8) != 1952542066)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 10)
      return 0;
    if (*(_QWORD *)a3 != 0x73736572706D6F63 || *(_WORD *)(a3 + 8) != 25701)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 12)
  {
    if (*(_QWORD *)result == 0x6F665F6C65786970 && *(_DWORD *)(result + 8) == 1952542066)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::MetalPixelFormatAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 10 && *(_QWORD *)result == 0x73736572706D6F63 && *(_WORD *)(result + 8) == 25701)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"compressed", 10, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"pixel_format", 12, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"compressed", (const char *)0xA, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps18(v10, (const void **)"pixel_format", (const char *)0xC, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CreateTextureTensorOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CreateTextureTensorOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CreateTextureTensorOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CreateTextureTensorOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::MetalPixelFormatAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CreateTextureTensorOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CreateTextureTensorOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CreateTextureTensorOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.create_texture_tensor";
  v28 = 25;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CreateTextureTensorOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::CreateTextureTensorOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.create_texture_tensor", 25, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v210 = 82;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v210 = 97;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[205];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[169];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[152] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v8 = a1;
  if (!mlir::mps::CreateTextureTensorOp::verifyInvariantsImpl((uint64_t **)&v8)
    || !mlir::OpTrait::impl::verifySameOperandsAndResultType(a1, v6))
  {
    return 0;
  }
  v8 = a1;
  return mlir::mps::CreateTextureTensorOp::verify((uint64_t **)&v8) != 0;
}

BOOL mlir::Op<mlir::mps::CreateTextureTensorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.crop", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E36278;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.crop", 8, v3, v4, 0, 0);
  *v5 = &off_1E0DFED28;
  v5[12] = mlir::mps::CropOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::CropOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CropOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CropOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, void *a4, unint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::CropOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.crop";
  v28[1] = 8;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CropOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CropOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  unsigned int *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::CropOpGenericAdaptorBase::CropOpGenericAdaptorBase((uint64_t)v14, a1);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!a1)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = a1;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if (a1 - 4 != (unsigned int *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  void *v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  void *v123;
  void *v124;
  void *v125;
  void *v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v163 = 104;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[196];
  v14 = &unk_1EDC07000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_1EDC07000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_1EDC07000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = (void *)v14[201];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v163 = 93;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v163 = 90;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[152];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v163 = 100;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v26[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4))
    return 0;
  v6 = a1;
  if (!mlir::mps::CropOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::CropOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::CropOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.crop_resize", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CropResizeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F770;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.crop_resize", 15, v3, v4, 0, 0);
  *v5 = &off_1E0DFC288;
  v5[12] = mlir::mps::CropResizeOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::CropResizeOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::CropResizeOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::CropResizeOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::CropResizeOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::getOpPropertyByteSize()
{
  return 56;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    v6 = a4[2];
    *(_QWORD *)(a3 + 48) = *((_QWORD *)a4 + 6);
    *(_OWORD *)(a3 + 16) = v5;
    *(_OWORD *)(a3 + 32) = v6;
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)(a3 + 48) = 0;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::CropResizeOp::populateDefaultProperties(a2, (mlir::MLIRContext **)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::mps::CropResizeOp::populateDefaultProperties(a2, a3);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CropResizeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CropResizeOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  v5 = *(_OWORD *)(a3 + 32);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 16) = v4;
  *(_OWORD *)(a2 + 32) = v5;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] == a2[5])
    return a3[6] == a2[6];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CropResizeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::Conv2DDataGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[4]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[5]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[6]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::CropResizeOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CropResizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CropResizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::CropResizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.crop_resize";
  v28[1] = 15;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CropResizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CropResizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CropResizeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 32);
  v26 = *(_QWORD *)(v10 + 48);
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.crop_resize", 15, Context);
    v22 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v30, v28, v29);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::CropResizeOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::CropResizeOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::CropResizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cumulative_maximum", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CumulativeMaximumOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E336B8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cumulative_maximum", 22, v3, v4, 0, 0);
  *v5 = &off_1E0DFD9E8;
  v5[12] = mlir::mps::CumulativeMaximumOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 7)
  {
    if (*(_DWORD *)a3 != 1702258034 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 9)
      return 0;
    if (*(_QWORD *)a3 != 0x766973756C637865 || *(_BYTE *)(a3 + 8) != 101)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 7)
  {
    if (*(_DWORD *)result == 1702258034 && *(_DWORD *)(result + 3) == 1702064741)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(_QWORD *)result == 0x766973756C637865 && *(_BYTE *)(result + 8) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"exclusive", 9, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"reverse", 7, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"exclusive", (const char *)9, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"reverse", (const char *)7, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMaximumOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMaximumOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeMaximumOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeMaximumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.cumulative_maximum";
  v30 = 22;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMaximumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeMaximumOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeMaximumOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.cumulative_maximum", 22, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::mps::_anonymous_namespace_ *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl((uint64_t **)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::CumulativeMaximumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cumulative_minimum", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CumulativeMinimumOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33780;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cumulative_minimum", 22, v3, v4, 0, 0);
  *v5 = &off_1E0DFDA40;
  v5[12] = mlir::mps::CumulativeMinimumOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 7)
  {
    if (*(_DWORD *)a3 != 1702258034 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 9)
      return 0;
    if (*(_QWORD *)a3 != 0x766973756C637865 || *(_BYTE *)(a3 + 8) != 101)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 7)
  {
    if (*(_DWORD *)result == 1702258034 && *(_DWORD *)(result + 3) == 1702064741)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(_QWORD *)result == 0x766973756C637865 && *(_BYTE *)(result + 8) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"exclusive", 9, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"reverse", 7, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"exclusive", (const char *)9, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"reverse", (const char *)7, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeMinimumOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeMinimumOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeMinimumOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeMinimumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.cumulative_minimum";
  v30 = 22;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeMinimumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeMinimumOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeMinimumOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.cumulative_minimum", 22, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::mps::_anonymous_namespace_ *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl((uint64_t **)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::CumulativeMinimumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cumulative_product", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CumulativeProductOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33848;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cumulative_product", 22, v3, v4, 0, 0);
  *v5 = &off_1E0DFDA98;
  v5[12] = mlir::mps::CumulativeProductOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 7)
  {
    if (*(_DWORD *)a3 != 1702258034 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 9)
      return 0;
    if (*(_QWORD *)a3 != 0x766973756C637865 || *(_BYTE *)(a3 + 8) != 101)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 7)
  {
    if (*(_DWORD *)result == 1702258034 && *(_DWORD *)(result + 3) == 1702064741)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(_QWORD *)result == 0x766973756C637865 && *(_BYTE *)(result + 8) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"exclusive", 9, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"reverse", 7, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"exclusive", (const char *)9, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"reverse", (const char *)7, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeProductOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeProductOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeProductOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeProductOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.cumulative_product";
  v30 = 22;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeProductOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeProductOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeProductOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.cumulative_product", 22, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::mps::_anonymous_namespace_ *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl((uint64_t **)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::CumulativeProductOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.cumulative_sum", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::CumulativeSumOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E31840;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.cumulative_sum", 18, v3, v4, 0, 0);
  *v5 = &off_1E0DFCC80;
  v5[12] = mlir::mps::CumulativeSumOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 7)
  {
    if (*(_DWORD *)a3 != 1702258034 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 9)
      return 0;
    if (*(_QWORD *)a3 != 0x766973756C637865 || *(_BYTE *)(a3 + 8) != 101)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 7)
  {
    if (*(_DWORD *)result == 1702258034 && *(_DWORD *)(result + 3) == 1702064741)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 9 && *(_QWORD *)result == 0x766973756C637865 && *(_BYTE *)(result + 8) == 101)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"exclusive", 9, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"reverse", 7, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"exclusive", (const char *)9, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"reverse", (const char *)7, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CumulativeMaximumOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CumulativeMaximumOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::CumulativeSumOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::CumulativeSumOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeSumOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::CumulativeSumOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.cumulative_sum";
  v30 = 18;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::CumulativeSumOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeSumOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::CumulativeSumOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.cumulative_sum", 18, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::mps::_anonymous_namespace_ *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::mps::_anonymous_namespace_ *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::CumulativeMaximumOp::verifyInvariantsImpl((uint64_t **)&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::CumulativeSumOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.degamma", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DegammaOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E38668;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.degamma", 11, v3, v4, 0, 0);
  *v5 = &off_1E0DFFCA0;
  v5[12] = mlir::mps::DegammaOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DegammaOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DegammaOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DegammaOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DegammaOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.degamma";
  v28 = 11;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::DegammaOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::DegammaOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::DegammaOpGenericAdaptorBase::DegammaOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  mlir::Operation *v8;
  mlir::Operation *v9;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps6((uint64_t *)a1, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"operand", (const void **)7, 0)&& (*(_DWORD *)(a1 + 36) ? (v6 = a1 - 16) : (v6 = 0), (NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps6((uint64_t *)a1, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0))&& mlir::OpTrait::impl::verifySameOperandsAndResultElementType((mlir::OpTrait::impl *)a1, v8)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType((mlir::OpTrait::impl *)a1, v9) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DegammaOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depth_to_space_2d", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthToSpace2DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32268;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depth_to_space_2d", 21, v3, v4, 0, 0);
  *v5 = &off_1E0DFD0F8;
  v5[12] = mlir::mps::DepthToSpace2DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 13)
  {
    if (*(_QWORD *)a3 != 0x68735F6C65786970 || *(_QWORD *)(a3 + 5) != 0x656C66667568735FLL)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 10)
      return 0;
    if (*(_QWORD *)a3 != 0x69735F6B636F6C62 || *(_WORD *)(a3 + 8) != 25978)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 13)
  {
    if (*(_QWORD *)result == 0x68735F6C65786970 && *(_QWORD *)(result + 5) == 0x656C66667568735FLL)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 10 && *(_QWORD *)result == 0x69735F6B636F6C62 && *(_WORD *)(result + 8) == 25978)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"block_size", 10, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"pixel_shuffle", 13, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void **v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = (const void **)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v9, (const void **)"block_size", (const char *)0xA, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v10, (const void **)"pixel_shuffle", (const char *)0xD, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthToSpace2DOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthToSpace2DOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthToSpace2DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthToSpace2DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthToSpace2DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthToSpace2DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthToSpace2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthToSpace2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depth_to_space_2d";
  v28[1] = 21;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthToSpace2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthToSpace2DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthToSpace2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.depth_to_space_2d", 21, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  void *v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &unk_1EDC07000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_1EDC07000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_1EDC07000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = (void *)v14[201];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v210 = 82;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = (void *)v26[132];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4))
    return 0;
  v6 = a1;
  if (!mlir::mps::DepthToSpace2DOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::DepthToSpace2DOp::verify((mlir::mps::DepthToSpace2DOp *)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::DepthToSpace2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_2d_data_gradient", 35, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DDataGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34E28;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_2d_data_gradient", 35, v3, v4, 0, 0);
  *v5 = &off_1E0DFE490;
  v5[12] = mlir::mps::DepthwiseConv2DDataGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv2DDataGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv2DDataGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] == a2[4])
    return a3[5] == a2[5];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::GlobalOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DDataGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthwiseConv2DDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depthwise_conv_2d_data_gradient";
  v28[1] = 35;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DDataGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DDataGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = v10[1];
  v23 = *v10;
  v24 = v13;
  v25 = v10[2];
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_2d_data_gradient", 35, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)3)
    && (v6 = (uint64_t *)a1, mlir::mps::DepthwiseConv2DDataGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_2d", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32970;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_2d", 21, v3, v4, 0, 0);
  *v5 = &off_1E0DFD410;
  v5[12] = mlir::mps::DepthwiseConv2DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv2DOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv2DOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] == a2[4])
    return a3[5] == a2[5];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::GlobalOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isValidMixedPrecision(uint64_t a1, mlir::mps::mixed_precision *a2)
{
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck(a2, (mlir::Operation *)1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv2DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthwiseConv2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depthwise_conv_2d";
  v28[1] = 21;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = v10[1];
  v23 = *v10;
  v24 = v13;
  v25 = v10[2];
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_2d", 21, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv2DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv2DOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::DepthwiseConv2DOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv2DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv2DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv2DOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::DepthwiseConv2DOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_2d_weights_gradient", 38, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv2DWeightsGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E35080;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_2d_weights_gradient", 38, v3, v4, 0, 0);
  *v5 = &off_1E0DFE598;
  v5[12] = mlir::mps::DepthwiseConv2DWeightsGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv2DWeightsGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv2DWeightsGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv2DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getOpPropertyByteSize()
{
  return 48;
}

double mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::initProperties(uint64_t a1, uint64_t a2, _OWORD *a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[2];
    a3[1] = a4[1];
    a3[2] = v5;
    *a3 = v4;
  }
  else
  {
    *(_QWORD *)&v4 = 0;
    a3[1] = 0u;
    a3[2] = 0u;
    *a3 = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv2DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv2DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(a2 + 16) = *(_OWORD *)(a3 + 16);
  *(_OWORD *)(a2 + 32) = v4;
  *(__n128 *)a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] == a2[4])
    return a3[5] == a2[5];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::GlobalOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[5]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv2DWeightsGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DWeightsGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv2DWeightsGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthwiseConv2DWeightsGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depthwise_conv_2d_weights_gradient";
  v28[1] = 38;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv2DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DWeightsGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv2DWeightsGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = v10[1];
  v23 = *v10;
  v24 = v13;
  v25 = v10[2];
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_2d_weights_gradient", 38, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv2DDataGradientOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv2DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_3d_data_gradient", 35, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DDataGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34EF0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_3d_data_gradient", 35, v3, v4, 0, 0);
  *v5 = &off_1E0DFE4E8;
  v5[12] = mlir::mps::DepthwiseConv3DDataGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv3DDataGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv3DDataGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getOpPropertyByteSize()
{
  return 40;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v5;
  __int128 v6;
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v9;

  if (a4)
  {
    v5 = *a4;
    v6 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(a3 + 16) = v6;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    v5 = 0uLL;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  *(_OWORD *)a3 = v5;
  v9 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v9);
  v9 = result;
  if (!*(_QWORD *)a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v9, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v9, IntegerType, -4);
    *(_QWORD *)a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v6);
  v6 = result;
  if (!*a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v6, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v6, IntegerType, -4);
    *a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DDataGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DDataGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DDataGradientOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthwiseConv3DDataGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depthwise_conv_3d_data_gradient";
  v28[1] = 35;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DDataGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DDataGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DDataGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_QWORD *)(v10 + 32);
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_3d_data_gradient", 35, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  void *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::DepthwiseConv3DDataGradientOp::verify((mlir::mps::DepthwiseConv3DDataGradientOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DDataGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyAtLeastNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::DepthwiseConv3DDataGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DDataGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_3d", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32A38;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_3d", 21, v3, v4, 0, 0);
  *v5 = &off_1E0DFD468;
  v5[12] = mlir::mps::DepthwiseConv3DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv3DOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv3DOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::getOpPropertyByteSize()
{
  return 40;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v5;
  __int128 v6;
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v9;

  if (a4)
  {
    v5 = *a4;
    v6 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(a3 + 16) = v6;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    v5 = 0uLL;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  *(_OWORD *)a3 = v5;
  v9 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v9);
  v9 = result;
  if (!*(_QWORD *)a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v9, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v9, IntegerType, -4);
    *(_QWORD *)a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v6);
  v6 = result;
  if (!*a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v6, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v6, IntegerType, -4);
    *a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isValidMixedPrecision(uint64_t a1, mlir::mps::mixed_precision *a2)
{
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck(a2, (mlir::Operation *)1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv3DOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DepthwiseConv3DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.depthwise_conv_3d";
  v28[1] = 21;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_QWORD *)(v10 + 32);
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_3d", 21, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  void *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::DepthwiseConv3DOp::verify((mlir::mps::DepthwiseConv3DOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::DepthwiseConv3DOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = (uint64_t *)a1, mlir::mps::DepthwiseConv3DOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.depthwise_conv_3d_weights_gradient", 38, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DepthwiseConv3DWeightsGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E35148;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.depthwise_conv_3d_weights_gradient", 38, v3, v4, 0, 0);
  *v5 = &off_1E0DFE5F0;
  v5[12] = mlir::mps::DepthwiseConv3DWeightsGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::DepthwiseConv3DWeightsGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::DepthwiseConv3DWeightsGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::DepthwiseConv3DDataGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getOpPropertyByteSize()
{
  return 40;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v5;
  __int128 v6;
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v9;

  if (a4)
  {
    v5 = *a4;
    v6 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)(a3 + 16) = v6;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    v5 = 0uLL;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  *(_OWORD *)a3 = v5;
  v9 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v9);
  v9 = result;
  if (!*(_QWORD *)a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v9, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v9, IntegerType, -4);
    *(_QWORD *)a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t result;
  uint64_t IntegerType;
  uint64_t v6;

  v6 = *(_QWORD *)(a2 + 8);
  result = mlir::Attribute::getContext((mlir::Attribute *)&v6);
  v6 = result;
  if (!*a3)
  {
    IntegerType = mlir::Builder::getIntegerType((mlir::Builder *)&v6, 0x20u, 1);
    result = mlir::Builder::getIntegerAttr((uint64_t)&v6, IntegerType, -4);
    *a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DepthwiseConv3DDataGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DepthwiseConv3DDataGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DepthwiseConv3DWeightsGradientOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::PaddingStyleAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isValidMixedPrecision;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::mps::MixedPrecisionInterface]";
      v15 = 84;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::mps::MixedPrecisionInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[490], v2);
}

void mlir::mps::detail::MixedPrecisionInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isValidMixedPrecision(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD v8[2];
  unint64_t v9[2];
  unint64_t v10[3];

  v10[2] = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a2 + 36))
    v3 = a2 - 16;
  else
    v3 = 0;
  v7 = *(_QWORD *)(mlir::detail::OpResultImpl::getNextResultAtOffset(v3, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v10, (uint64_t)&v7, 1uLL);
  v4 = *(_QWORD *)(a2 + 72);
  v5 = *(_QWORD *)(*(_QWORD *)(v4 + 24) + 8) & 0xFFFFFFFFFFFFFFF8;
  v6 = *(_QWORD *)(*(_QWORD *)(v4 + 56) + 8) & 0xFFFFFFFFFFFFFFF8;
  v8[0] = v5;
  v8[1] = v6;
  mlir::ValueRange::ValueRange(v9, (uint64_t)v8, 2uLL);
  mlir::mps::mixed_precision::defaultMixedPrecisionCheck((uint64_t *)a2, v10[0], v10[1], v9[0], v9[1], 1, 1);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DepthwiseConv3DWeightsGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DWeightsGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DepthwiseConv3DWeightsGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::DepthwiseConv3DWeightsGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.depthwise_conv_3d_weights_gradient";
  v30[1] = 38;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DepthwiseConv3DWeightsGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DWeightsGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DepthwiseConv3DWeightsGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_QWORD *)(v10 + 32);
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.depthwise_conv_3d_weights_gradient", 38, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(void *a1, mlir::Operation *a2)
{
  void *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::DepthwiseConv3DWeightsGradientOp::verify((mlir::mps::DepthwiseConv3DWeightsGradientOp *)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OneResult<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::NOperands<3u>::Impl<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DepthwiseConv3DWeightsGradientOp>>(void *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)3)
    && (v6 = (uint64_t *)a1, mlir::mps::DepthwiseConv3DWeightsGradientOp::verifyInvariantsImpl(&v6)))
  {
    return mlir::op_definition_impl::verifyTrait<mlir::mps::MixedPrecisionInterface::Trait<mlir::mps::BiasAddOp>>(a1) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::DepthwiseConv3DWeightsGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::mps::MixedPrecisionInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.dequantize_lut", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DequantizeLUTOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E31908;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.dequantize_lut", 18, v3, v4, 0, 0);
  *v5 = &off_1E0DFCCD8;
  v5[12] = mlir::mps::DequantizeLUTOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 4 && *a3 == 1936291937)
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

_DWORD *mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _DWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  if (v7 == 4 && *result == 1936291937)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v8 = a4;
      else
        v8 = 0;
      *v5 = v8;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"axis", 4, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void **v7;

  v7 = (const void **)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v7, (const void **)"axis", (const char *)4, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DequantizeLUTOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DequantizeLUTOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeLUTOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeLUTOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::downgradeToVersion;
  v4 = &unk_1EDC07000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_1EDC07000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_1EDC07000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[197], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::downgradeToVersion(uint64_t *a1@<X1>, uint64_t a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  v3 = a1;
  mlir::mps::UnrealizedFoldOp::downgradeToVersion(&v3, a2, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DequantizeLUTOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DequantizeLUTOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DequantizeLUTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DequantizeLUTOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.dequantize_lut";
  v28[1] = 18;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeLUTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DequantizeLUTOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DequantizeLUTOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.dequantize_lut", 18, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &unk_1EDC07000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_1EDC07000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      v210 = 89;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_1EDC07000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = (void *)v26[199];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  void *__p;
  unsigned int v12;
  uint64_t v13;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  __p = a1;
  if (!mlir::mps::DequantizeLUTOp::verifyInvariantsImpl((uint64_t **)&__p))
    return 0;
  v5 = *((_QWORD *)a1 + 9);
  v6 = *(_QWORD *)(v5 + 24);
  v7 = *(_QWORD *)(v5 + 56);
  v13 = *((_QWORD *)a1 + 10);
  if (v13)
  {
    mlir::IntegerAttr::getValue(&v13, (llvm::APInt *)&__p);
    if (v12 > 0x40)
    {
      LODWORD(v8) = *(_DWORD *)__p;
      operator delete[](__p);
    }
    else
    {
      v8 = (uint64_t)((_QWORD)__p << -(uint64_t)v12) >> -(uint64_t)v12;
    }
    v10 = v8 | 0x100000000;
  }
  else
  {
    v10 = 0;
  }
  return mlir::mps::verifyDequantLUT((uint64_t *)a1, v6, v7, v10) != 0;
}

BOOL mlir::Op<mlir::mps::DequantizeLUTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.dequantize", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DequantizeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F838;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.dequantize", 14, v3, v4, 0, 0);
  *v5 = &off_1E0E52738;
  v5[12] = mlir::mps::DequantizeOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 5)
  {
    if (*(_DWORD *)a3 == 1887007844 && *(_BYTE *)(a3 + 4) == 101)
      return v7[1];
    return 0;
  }
  if (a4 != 4 || *(_DWORD *)a3 != 1936291937)
    return 0;
  return *v7;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 5)
  {
    if (*(_DWORD *)result == 1887007844 && *(_BYTE *)(result + 4) == 101)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
          v9 = a4;
        else
          v9 = 0;
        v5[1] = v9;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 4 && *(_DWORD *)result == 1936291937)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
        v10 = a4;
      else
        v10 = 0;
      *v5 = v10;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"axis", 4, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"dtype", 5, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void **v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = (const void **)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps26(v9, (const void **)"axis", (const char *)4, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v10, (const void **)"dtype", (const char *)5, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DequantizeOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DequantizeOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DequantizeOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DequantizeOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::IntegerAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::downgradeToVersion;
  v4 = &unk_1EDC07000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_1EDC07000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_1EDC07000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[197], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::downgradeToVersion(uint64_t *a1@<X1>, _DWORD *a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  v3 = a1;
  mlir::mps::DequantizeOp::downgradeToVersion(&v3, a2, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DequantizeOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DequantizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DequantizeOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DequantizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.dequantize";
  v28[1] = 14;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DequantizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DequantizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DequantizeOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.dequantize", 14, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  void *v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  _QWORD *v26;
  void *v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  void *v144;
  void *v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  void *v162;
  void *v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &unk_1EDC07000;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = (_QWORD *)&unk_1EDC07000;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = (_QWORD *)&unk_1EDC07000;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = (void *)v14[201];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &unk_1EDC07000;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = (_QWORD *)&unk_1EDC07000;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      v210 = 89;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = (_QWORD *)&unk_1EDC07000;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = (void *)v26[199];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4))
    return 0;
  v6 = a1;
  if (!mlir::mps::DequantizeOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::DequantizeOp::verify((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::mps::DequantizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.dimension_size", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DimensionSizeOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E319D0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.dimension_size", 18, v3, v4, 0, 0);
  *v5 = &off_1E0DFCD30;
  v5[12] = mlir::mps::DimensionSizeOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DimensionSizeOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DimensionSizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DimensionSizeOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DimensionSizeOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::DimensionSizeOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.dimension_size";
  v30[1] = 18;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DimensionSizeOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DimensionSizeOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DimensionSizeOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::DimensionSizeOpGenericAdaptorBase::DimensionSizeOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  v6 = a1;
  return mlir::mps::DimensionSizeOp::verifyInvariantsImpl((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::mps::DimensionSizeOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.dirac", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DiracOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37218;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.dirac", 9, v3, v4, 0, 0);
  *v5 = &off_1E0DFF408;
  v5[12] = mlir::mps::DiracOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DiracOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DiracOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DiracOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DiracOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.dirac";
  v28 = 9;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::DiracOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::DiracOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::DiracOpGenericAdaptorBase::DiracOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::DiracOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.divide", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DivideOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37DD0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.divide", 10, v3, v4, 0, 0);
  *v5 = &off_1E0DFF8D8;
  v5[12] = mlir::mps::DivideOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::hasTrait(uint64_t a1, void *a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DivideOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DivideOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DivideOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.divide";
  v28[1] = 10;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DivideOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DivideOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DivideOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::DivideOpGenericAdaptorBase::DivideOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ATan2Op>,mlir::OpTrait::OneResult<mlir::mps::ATan2Op>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ATan2Op>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::OpInvariants<mlir::mps::ATan2Op>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ATan2Op>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ATan2Op>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ATan2Op>,mlir::OpTrait::Stitchable<mlir::mps::ATan2Op>,mlir::InferTypeOpInterface::Trait<mlir::mps::ATan2Op>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ATan2Op>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::DivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.dynamic_shape_cast", 22, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::DynamicShapeCastOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33398;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.dynamic_shape_cast", 22, v3, v4, 0, 0);
  *v5 = &off_1E0DFD888;
  v5[12] = mlir::mps::DynamicShapeCastOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 8 && *a3 == 0x64656B6E61726E75)
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  if (v7 == 8 && *result == 0x64656B6E61726E75)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v8 = a4;
      else
        v8 = 0;
      *v5 = v8;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"unranked", 8, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"unranked", (const char *)8, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::DynamicShapeCastOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::DynamicShapeCastOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::DynamicShapeCastOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::DynamicShapeCastOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::inferReturnTypes(mlir::Float32Type *a1, mlir::MLIRContext *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::DynamicShapeCastOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::refineReturnTypes(mlir::Float32Type *a1, mlir::MLIRContext *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DynamicShapeCastOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::DynamicShapeCastOp>::refineReturnTypes(mlir::Float32Type *a1, mlir::MLIRContext *a2, uint64_t a3, void *a4, uint64_t a5, uint64_t a6, uint64_t *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::DynamicShapeCastOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.dynamic_shape_cast";
  v28[1] = 22;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::DynamicShapeCastOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DynamicShapeCastOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::DynamicShapeCastOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.dynamic_shape_cast", 22, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)1))
    return 0;
  v6 = a1;
  if (!mlir::mps::DynamicShapeCastOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::DynamicShapeCastOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::DynamicShapeCastOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<1u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.elu", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::EluOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E355F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.elu", 7, v3, v4, 0, 0);
  *v5 = &off_1E0DFE800;
  v5[12] = mlir::mps::EluOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EluOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::EluOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::EluOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.elu";
  v28[1] = 7;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::EluOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::EluOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::EluOpGenericAdaptorBase::EluOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v210 = 90;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultElementType<Empty>]";
      v210 = 104;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[206];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v210 = 97;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[204];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ATan2Op>,mlir::OpTrait::OneResult<mlir::mps::ATan2Op>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ATan2Op>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::ATan2Op>,mlir::OpTrait::OpInvariants<mlir::mps::ATan2Op>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ATan2Op>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ATan2Op>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::ATan2Op>,mlir::OpTrait::Stitchable<mlir::mps::ATan2Op>,mlir::InferTypeOpInterface::Trait<mlir::mps::ATan2Op>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ATan2Op>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::EluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.equal", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::EqualToOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E38730;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.equal", 9, v3, v4, 0, 0);
  *v5 = &off_1E0DFFCF8;
  v5[12] = mlir::mps::EqualToOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::EqualToOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::EqualToOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::EqualToOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.equal";
  v28[1] = 9;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::EqualToOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::EqualToOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::EqualToOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  mlir::Operation *v13;
  uint64_t InterfaceFor;
  _BYTE v15[40];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::EqualToOpGenericAdaptorBase::EqualToOpGenericAdaptorBase((uint64_t)v15, this);
  v16 = a2;
  v17 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v13 = 0;
    InterfaceFor = 0;
    goto LABEL_11;
  }
  if (!this)
  {
    v13 = 0;
    InterfaceFor = 0;
    goto LABEL_11;
  }
  v13 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v13, v16, v17);
  if (v8 < 8)
  {
LABEL_11:
    v11 = 0;
    if (*(_DWORD *)(a4 + 8))
      return v11;
    goto LABEL_12;
  }
  v9 = v8;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v10 = *(unsigned int *)(a4 + 8);
    if (v10 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v10 + 1, 8);
      LODWORD(v10) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v10) = v9;
    ++*(_DWORD *)(a4 + 8);
    return 1;
  }
  v11 = 1;
  if (*(_DWORD *)(a4 + 8))
    return v11;
LABEL_12:
  if (mlir::OpTrait::impl::foldCommutative((uint64_t)this, a2, a3))
    return 1;
  return v11;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  __guard *v32;
  __guard v33;
  unsigned __int8 v34;
  uint64_t *v35;
  uint64_t v36;
  unsigned __int8 v37;
  uint64_t *v38;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  const char *v56;
  unint64_t v57;
  uint64_t v58;
  unint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  const char *v65;
  unint64_t v66;
  uint64_t v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  const char *v74;
  unint64_t v75;
  uint64_t v76;
  unint64_t v77;
  uint64_t v78;
  int v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  const char *v83;
  unint64_t v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  const char *v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  const char *v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  unint64_t v108;
  unint64_t v109;
  const char *v110;
  unint64_t v111;
  uint64_t v112;
  unint64_t v113;
  uint64_t v114;
  int v115;
  int v116;
  unint64_t v117;
  unint64_t v118;
  const char *v119;
  unint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  int v124;
  int v125;
  unint64_t v126;
  unint64_t v127;
  const char *v128;
  unint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  int v133;
  int v134;
  unint64_t v135;
  unint64_t v136;
  const char *v137;
  unint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unint64_t v144;
  unint64_t v145;
  const char *v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  int v151;
  int v152;
  unint64_t v153;
  unint64_t v154;
  const char *v155;
  unint64_t v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  int v160;
  int v161;
  unint64_t v162;
  unint64_t v163;
  const char *v164;
  unint64_t v165;
  uint64_t v166;
  unint64_t v167;
  uint64_t v168;
  uint64_t v169;
  __guard v170;
  __guard v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  __guard v179;
  __guard v180;
  __guard v181;
  __guard v182;
  __guard v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  void *v214;
  void *v215;
  void *v216;
  void *v217;
  void *v218;
  void *v219;
  void *v220;
  void *v221;
  void *v222;
  void *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  void *v247;
  void *v248;
  void *v249;
  void *v250;
  void *v251;
  void *v252;
  void *v253;
  void *v254;
  void *v255;
  void *v256;
  void *v257;
  void *v258;
  void *v259;
  const char *v260;
  unint64_t v261;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v247 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v53 = v52;
    a1 = v247;
    if (v53)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v261 = 83;
      v54 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v54)
        v55 = v54;
      else
        v55 = v261;
      v56 = &v260[v55];
      v57 = v261 - v55;
      if (v261 - v55 >= 0x12)
        v58 = 18;
      else
        v58 = v261 - v55;
      v59 = v57 - v58;
      if (v59 >= v59 - 1)
        v60 = v59 - 1;
      else
        v60 = v59;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v56[v58], v60);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v247;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v235 = v3;
    v248 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v62 = v61;
    v3 = v235;
    a1 = v248;
    if (v62)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v261 = 81;
      v63 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v63)
        v64 = v63;
      else
        v64 = v261;
      v65 = &v260[v64];
      v66 = v261 - v64;
      if (v261 - v64 >= 0x12)
        v67 = 18;
      else
        v67 = v261 - v64;
      v68 = v66 - v67;
      if (v68 >= v68 - 1)
        v69 = v68 - 1;
      else
        v69 = v68;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v65[v67], v69);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v235;
      a1 = v248;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v236 = v3;
    v249 = a1;
    v224 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v224;
    v3 = v236;
    v71 = v70;
    a1 = v249;
    if (v71)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v261 = 104;
      v72 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v72)
        v73 = v72;
      else
        v73 = v261;
      v74 = &v260[v73];
      v75 = v261 - v73;
      if (v261 - v73 >= 0x12)
        v76 = 18;
      else
        v76 = v261 - v73;
      v77 = v75 - v76;
      if (v77 >= v77 - 1)
        v78 = v77 - 1;
      else
        v78 = v77;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v74[v76], v78);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v224;
      v3 = v236;
      a1 = v249;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v237 = v3;
    v250 = a1;
    v214 = v9;
    v225 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v214;
    v6 = v225;
    v80 = v79;
    v3 = v237;
    a1 = v250;
    if (v80)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v261 = 86;
      v81 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v81)
        v82 = v81;
      else
        v82 = v261;
      v83 = &v260[v82];
      v84 = v261 - v82;
      if (v261 - v82 >= 0x12)
        v85 = 18;
      else
        v85 = v261 - v82;
      v86 = v84 - v85;
      if (v86 >= v86 - 1)
        v87 = v86 - 1;
      else
        v87 = v86;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v83[v85], v87);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v214;
      v6 = v225;
      v3 = v237;
      a1 = v250;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v238 = v3;
    v251 = a1;
    v215 = v9;
    v226 = v6;
    v205 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v205;
    v9 = v215;
    v6 = v226;
    v89 = v88;
    v3 = v238;
    a1 = v251;
    if (v89)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v261 = 90;
      v90 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v90)
        v91 = v90;
      else
        v91 = v261;
      v92 = &v260[v91];
      v93 = v261 - v91;
      if (v261 - v91 >= 0x12)
        v94 = 18;
      else
        v94 = v261 - v91;
      v95 = v93 - v94;
      if (v95 >= v95 - 1)
        v96 = v95 - 1;
      else
        v96 = v95;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v92[v94], v96);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v205;
      v9 = v215;
      v6 = v226;
      v3 = v238;
      a1 = v251;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v239 = v3;
    v252 = a1;
    v216 = v9;
    v227 = v6;
    v197 = v15;
    v206 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v197;
    v12 = v206;
    v9 = v216;
    v6 = v227;
    v98 = v97;
    v3 = v239;
    a1 = v252;
    if (v98)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v261 = 84;
      v99 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v99)
        v100 = v99;
      else
        v100 = v261;
      v101 = &v260[v100];
      v102 = v261 - v100;
      if (v261 - v100 >= 0x12)
        v103 = 18;
      else
        v103 = v261 - v100;
      v104 = v102 - v103;
      if (v104 >= v104 - 1)
        v105 = v104 - 1;
      else
        v105 = v104;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v101[v103], v105);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v197;
      v12 = v206;
      v9 = v216;
      v6 = v227;
      v3 = v239;
      a1 = v252;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v240 = v3;
    v253 = a1;
    v217 = v9;
    v228 = v6;
    v198 = v15;
    v207 = v12;
    v190 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v190;
    v15 = v198;
    v12 = v207;
    v9 = v217;
    v6 = v228;
    v107 = v106;
    v3 = v240;
    a1 = v253;
    if (v107)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v261 = 93;
      v108 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v108)
        v109 = v108;
      else
        v109 = v261;
      v110 = &v260[v109];
      v111 = v261 - v109;
      if (v261 - v109 >= 0x12)
        v112 = 18;
      else
        v112 = v261 - v109;
      v113 = v111 - v112;
      if (v113 >= v113 - 1)
        v114 = v113 - 1;
      else
        v114 = v113;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v110[v112], v114);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v190;
      v15 = v198;
      v12 = v207;
      v9 = v217;
      v6 = v228;
      v3 = v240;
      a1 = v253;
    }
  }
  v21 = v20[158];
  if ((v22 & 1) == 0)
  {
    v241 = v3;
    v254 = a1;
    v218 = v9;
    v229 = v6;
    v199 = v15;
    v208 = v12;
    v184 = v21;
    v191 = v18;
    v21 = v184;
    v18 = v191;
    v15 = v199;
    v12 = v208;
    v9 = v218;
    v6 = v229;
    v116 = v115;
    v3 = v241;
    a1 = v254;
    if (v116)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsElementType<Empty>]";
      v261 = 95;
      v117 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v117)
        v118 = v117;
      else
        v118 = v261;
      v119 = &v260[v118];
      v120 = v261 - v118;
      if (v261 - v118 >= 0x12)
        v121 = 18;
      else
        v121 = v261 - v118;
      v122 = v120 - v121;
      if (v122 >= v122 - 1)
        v123 = v122 - 1;
      else
        v123 = v122;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v119[v121], v123);
      v21 = v184;
      v18 = v191;
      v15 = v199;
      v12 = v208;
      v9 = v218;
      v6 = v229;
      v3 = v241;
      a1 = v254;
    }
  }
  v24 = v23[501];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v242 = v3;
    v255 = a1;
    v219 = v9;
    v230 = v6;
    v200 = v15;
    v209 = v12;
    v185 = v21;
    v192 = v18;
    v179 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v179;
    v21 = v185;
    v18 = v192;
    v15 = v200;
    v12 = v209;
    v9 = v219;
    v6 = v230;
    v125 = v124;
    v3 = v242;
    a1 = v255;
    if (v125)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v261 = 97;
      v126 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v126)
        v127 = v126;
      else
        v127 = v261;
      v128 = &v260[v127];
      v129 = v261 - v127;
      if (v261 - v127 >= 0x12)
        v130 = 18;
      else
        v130 = v261 - v127;
      v131 = v129 - v130;
      if (v131 >= v131 - 1)
        v132 = v131 - 1;
      else
        v132 = v131;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v128[v130], v132);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v179;
      v21 = v185;
      v18 = v192;
      v15 = v200;
      v12 = v209;
      v9 = v219;
      v6 = v230;
      v3 = v242;
      a1 = v255;
    }
  }
  v27 = v26[204];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v243 = v3;
    v256 = a1;
    v220 = v9;
    v231 = v6;
    v201 = v15;
    v210 = v12;
    v186 = v21;
    v193 = v18;
    v175 = v27;
    v180 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v175;
    v24 = v180;
    v21 = v186;
    v18 = v193;
    v15 = v201;
    v12 = v210;
    v9 = v220;
    v6 = v231;
    v134 = v133;
    v3 = v243;
    a1 = v256;
    if (v134)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::IsCommutative<Empty>]";
      v261 = 85;
      v135 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v135)
        v136 = v135;
      else
        v136 = v261;
      v137 = &v260[v136];
      v138 = v261 - v136;
      if (v261 - v136 >= 0x12)
        v139 = 18;
      else
        v139 = v261 - v136;
      v140 = v138 - v139;
      if (v140 >= v140 - 1)
        v141 = v140 - 1;
      else
        v141 = v140;
      mlir::detail::TypeIDResolver<mlir::OpTrait::IsCommutative<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::IsCommutative>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v137[v139], v141);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v175;
      v24 = v180;
      v21 = v186;
      v18 = v193;
      v15 = v201;
      v12 = v210;
      v9 = v220;
      v6 = v231;
      v3 = v243;
      a1 = v256;
    }
  }
  v30 = v29[194];
  if ((v31 & 1) == 0)
  {
    v244 = v3;
    v257 = a1;
    v221 = v9;
    v232 = v6;
    v202 = v15;
    v211 = v12;
    v187 = v21;
    v194 = v18;
    v176 = v27;
    v181 = v24;
    v172 = v30;
    v30 = v172;
    v27 = v176;
    v24 = v181;
    v21 = v187;
    v18 = v194;
    v15 = v202;
    v12 = v211;
    v9 = v221;
    v6 = v232;
    v143 = v142;
    v3 = v244;
    a1 = v257;
    if (v143)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v261 = 82;
      v144 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v144)
        v145 = v144;
      else
        v145 = v261;
      v146 = &v260[v145];
      v147 = v261 - v145;
      if (v261 - v145 >= 0x12)
        v148 = 18;
      else
        v148 = v261 - v145;
      v149 = v147 - v148;
      if (v149 >= v149 - 1)
        v150 = v149 - 1;
      else
        v150 = v149;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v146[v148], v150);
      v30 = v172;
      v27 = v176;
      v24 = v181;
      v21 = v187;
      v18 = v194;
      v15 = v202;
      v12 = v211;
      v9 = v221;
      v6 = v232;
      v3 = v244;
      a1 = v257;
    }
  }
  v33 = v32[132];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v245 = v3;
    v258 = a1;
    v222 = v9;
    v233 = v6;
    v203 = v15;
    v212 = v12;
    v188 = v21;
    v195 = v18;
    v177 = v27;
    v182 = v24;
    v170 = v33;
    v173 = v30;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v170;
    v30 = v173;
    v27 = v177;
    v24 = v182;
    v21 = v188;
    v18 = v195;
    v15 = v203;
    v12 = v212;
    v9 = v222;
    v6 = v233;
    v152 = v151;
    v3 = v245;
    a1 = v258;
    if (v152)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v261 = 90;
      v153 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v153)
        v154 = v153;
      else
        v154 = v261;
      v155 = &v260[v154];
      v156 = v261 - v154;
      if (v261 - v154 >= 0x12)
        v157 = 18;
      else
        v157 = v261 - v154;
      v158 = v156 - v157;
      if (v158 >= v158 - 1)
        v159 = v158 - 1;
      else
        v159 = v158;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v155[v157], v159);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v170;
      v30 = v173;
      v27 = v177;
      v24 = v182;
      v21 = v188;
      v18 = v195;
      v15 = v203;
      v12 = v212;
      v9 = v222;
      v6 = v233;
      v3 = v245;
      a1 = v258;
    }
  }
  v36 = v35[152];
  v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v37 & 1) == 0)
  {
    v246 = v3;
    v259 = a1;
    v223 = v9;
    v234 = v6;
    v204 = v15;
    v213 = v12;
    v189 = v21;
    v196 = v18;
    v178 = v27;
    v183 = v24;
    v171 = v33;
    v174 = v30;
    v169 = v36;
    v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v36 = v169;
    v33 = v171;
    v30 = v174;
    v27 = v178;
    v24 = v183;
    v21 = v189;
    v18 = v196;
    v15 = v204;
    v12 = v213;
    v9 = v223;
    v6 = v234;
    v161 = v160;
    v3 = v246;
    a1 = v259;
    if (v161)
    {
      v260 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v261 = 100;
      v162 = llvm::StringRef::find((uint64_t *)&v260, "DesiredTypeName = ", 0x12uLL, 0);
      if (v261 >= v162)
        v163 = v162;
      else
        v163 = v261;
      v164 = &v260[v163];
      v165 = v261 - v163;
      if (v261 - v163 >= 0x12)
        v166 = 18;
      else
        v166 = v261 - v163;
      v167 = v165 - v166;
      if (v167 >= v167 - 1)
        v168 = v167 - 1;
      else
        v168 = v167;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v164[v166], v168);
      v38 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v36 = v169;
      v33 = v171;
      v30 = v174;
      v27 = v178;
      v24 = v183;
      v21 = v189;
      v18 = v196;
      v15 = v204;
      v12 = v213;
      v9 = v223;
      v6 = v234;
      v3 = v246;
      a1 = v259;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v36 == (_QWORD)a1
      || v38[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::EqualToOp>,mlir::OpTrait::OneResult<mlir::mps::EqualToOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::EqualToOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::OpInvariants<mlir::mps::EqualToOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::EqualToOp>,mlir::OpTrait::SameOperandsElementType<mlir::mps::EqualToOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::EqualToOp>,mlir::OpTrait::IsCommutative<mlir::mps::EqualToOp>,mlir::OpTrait::Stitchable<mlir::mps::EqualToOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::EqualToOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::EqualToOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::EqualToOp>,mlir::OpTrait::OneResult<mlir::mps::EqualToOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::EqualToOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::OpInvariants<mlir::mps::EqualToOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::EqualToOp>,mlir::OpTrait::SameOperandsElementType<mlir::mps::EqualToOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::EqualToOp>,mlir::OpTrait::IsCommutative<mlir::mps::EqualToOp>,mlir::OpTrait::Stitchable<mlir::mps::EqualToOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::EqualToOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::EqualToOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v8 = a1, mlir::mps::EqualToOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsElementType(a1, v5))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::EqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::IsCommutative,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.erf", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ErfOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E356C0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.erf", 7, v3, v4, 0, 0);
  *v5 = &off_1E0DFE858;
  v5[12] = mlir::mps::ErfOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ErfOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ErfOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ErfOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ErfOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.erf";
  v28 = 7;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ErfOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ErfOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ErfOpGenericAdaptorBase::ErfOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ErfOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.expand_dims", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ExpandDimsOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F900;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.expand_dims", 15, v3, v4, 0, 0);
  *v5 = &off_1E0E52790;
  v5[12] = mlir::mps::ExpandDimsOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExpandDimsOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ExpandDimsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExpandDimsOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExpandDimsOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::ExpandDimsOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.expand_dims";
  v30[1] = 15;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExpandDimsOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ExpandDimsOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ExpandDimsOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  unsigned int *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ExpandDimsOpGenericAdaptorBase::ExpandDimsOpGenericAdaptorBase((uint64_t)v14, a1);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!a1)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = a1;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if (a1 - 4 != (unsigned int *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v186 = 90;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::TypeChanger<Empty>]";
      v186 = 83;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::TypeChanger<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::TypeChanger>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[186];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v186 = 100;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::BroadcastToOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::ExpandDimsOp::verify(&v6);
}

BOOL mlir::Op<mlir::mps::ExpandDimsOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::TypeChanger,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.exponent_base_10", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ExponentBase10Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32330;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.exponent_base_10", 20, v3, v4, 0, 0);
  *v5 = &off_1E0DFD150;
  v5[12] = mlir::mps::ExponentBase10Op::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase10Op>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentBase10Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase10Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentBase10Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.exponent_base_10";
  v28 = 20;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentBase10Op>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentBase10Op>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ExponentBase10OpGenericAdaptorBase::ExponentBase10OpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ExponentBase10Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.exponent_base_2", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ExponentBase2Op,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E31A98;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unsigned int *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.exponent_base_2", 19, v3, v4, 0, 0);
  *v5 = &off_1E0DFCD88;
  v5[12] = mlir::mps::ExponentBase2Op::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentBase2Op>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentBase2Op>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentBase2Op>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentBase2Op>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.exponent_base_2";
  v28 = 19;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentBase2Op>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentBase2Op>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ExponentBase2OpGenericAdaptorBase::ExponentBase2OpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ExponentBase2Op,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.exponent", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ExponentOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E320;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.exponent", 12, v3, v4, 0, 0);
  *v5 = &off_1E0DFBA48;
  v5[12] = mlir::mps::ExponentOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ExponentOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ExponentOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ExponentOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.exponent";
  v28 = 12;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::ExponentOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ExponentOpGenericAdaptorBase::ExponentOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::ExponentOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.fast_fourier_transform", 26, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FastFourierTransformOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34338;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.fast_fourier_transform", 26, v3, v4, 0, 0);
  *v5 = &off_1E0DFDF68;
  v5[12] = mlir::mps::FastFourierTransformOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 12)
  {
    if (*(_QWORD *)a3 != 0x5F676E696C616373 || *(_DWORD *)(a3 + 8) != 1701080941)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 7)
      return 0;
    if (*(_DWORD *)a3 != 1702260329 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v12 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v12);
  if (v7 == 12)
  {
    if (*(_QWORD *)result == 0x5F676E696C616373 && *(_DWORD *)(result + 8) == 1701080941)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::mps::FFTScalingModeAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        v5[1] = v10;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 7 && *(_DWORD *)result == 1702260329 && *(_DWORD *)(result + 3) == 1702064741)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
        v11 = a4;
      else
        v11 = 0;
      *v5 = v11;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"inverse", 7, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"scaling_mode", 12, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"inverse", (const char *)7, a4, a5))
  {
    v10 = mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps27(v10, (const void **)"scaling_mode", (const char *)0xC, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::FastFourierTransformOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::FastFourierTransformOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::FastFourierTransformOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::FastFourierTransformOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::FastFourierTransformOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FastFourierTransformOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FastFourierTransformOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::FastFourierTransformOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.fast_fourier_transform";
  v28[1] = 26;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FastFourierTransformOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::FastFourierTransformOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::FastFourierTransformOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.fast_fourier_transform", 26, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::FastFourierTransformOp::verifyInvariantsImpl(&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::FastFourierTransformOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.flatten_2d", 14, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::Flatten2DOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F068;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.flatten_2d", 14, v3, v4, 0, 0);
  *v5 = &off_1E0E526E0;
  v5[12] = mlir::mps::Flatten2DOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::Flatten2DOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::Flatten2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Flatten2DOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::Flatten2DOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::Flatten2DOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.flatten_2d";
  v30[1] = 14;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::Flatten2DOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Flatten2DOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::Flatten2DOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::Flatten2DOpGenericAdaptorBase::Flatten2DOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
  {
    return 0;
  }
  v6 = a1;
  return mlir::mps::Flatten2DOp::verifyInvariantsImpl((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::mps::Flatten2DOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.floor_divide", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FloorDivideOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E30008;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.floor_divide", 16, v3, v4, 0, 0);
  *v5 = &off_1E0DFC5A0;
  v5[12] = mlir::mps::FloorDivideOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorDivideOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::inferReturnTypes(mlir::Float32Type *a1, uint64_t a2, uint64_t a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FloorDivideOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FloorDivideOp>::refineReturnTypes(mlir::Float32Type *a1, uint64_t a2, char a3, mlir::MLIRContext *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.floor_divide";
  v28[1] = 16;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorDivideOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::FloorDivideOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::FloorDivideOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::FloorDivideOpGenericAdaptorBase::FloorDivideOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::FloorDivideOp>,mlir::OpTrait::OneResult<mlir::mps::FloorDivideOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::FloorDivideOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::FloorDivideOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::FloorDivideOp>,mlir::OpTrait::OpInvariants<mlir::mps::FloorDivideOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::FloorDivideOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::FloorDivideOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::FloorDivideOp>,mlir::OpTrait::Stitchable<mlir::mps::FloorDivideOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::FloorDivideOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::FloorDivideOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::FloorDivideOp>,mlir::OpTrait::OneResult<mlir::mps::FloorDivideOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::FloorDivideOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::FloorDivideOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::FloorDivideOp>,mlir::OpTrait::OpInvariants<mlir::mps::FloorDivideOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::FloorDivideOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::FloorDivideOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::FloorDivideOp>,mlir::OpTrait::Stitchable<mlir::mps::FloorDivideOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::FloorDivideOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::FloorDivideOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::Operation *v6;
  mlir::OpTrait::impl *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    && mlir::OpTrait::impl::verifyOneResult(a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    && mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2)
    && (v8 = a1, mlir::mps::FloorDivideOp::verifyInvariantsImpl((uint64_t **)&v8))
    && mlir::OpTrait::impl::verifySameOperandsAndResultElementType(a1, v5))
  {
    return mlir::OpTrait::impl::verifyCompatibleOperandBroadcast(a1, v6) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::FloorDivideOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.floor", 9, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::FloorOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E372E0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.floor", 9, v3, v4, 0, 0);
  *v5 = &off_1E0DFF460;
  v5[12] = mlir::mps::FloorOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::FloorOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FloorOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::FloorOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::FloorOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.floor";
  v28 = 9;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::FloorOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::FloorOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::FloorOpGenericAdaptorBase::FloorOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ACosOp>,mlir::OpTrait::OneResult<mlir::mps::ACosOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ACosOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ACosOp>,mlir::OpTrait::OneOperand<mlir::mps::ACosOp>,mlir::OpTrait::OpInvariants<mlir::mps::ACosOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::ACosOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::ACosOp>,mlir::OpTrait::Stitchable<mlir::mps::ACosOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ACosOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ACosOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::FloorOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gru_gradient", 16, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E300D0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gru_gradient", 16, v3, v4, 0, 0);
  *v5 = &off_1E0DFC5F8;
  v5[12] = mlir::mps::GRUGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, _WORD *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::GRUGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _WORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_WORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::GRUGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::GRUGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::GRUGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::getOpPropertyByteSize()
{
  return 80;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    *(_OWORD *)a3 = *a4;
    v4 = a4[1];
    v5 = a4[2];
    v6 = a4[4];
    *(_OWORD *)(a3 + 48) = a4[3];
    *(_OWORD *)(a3 + 64) = v6;
    *(_OWORD *)(a3 + 16) = v4;
    *(_OWORD *)(a3 + 32) = v5;
  }
  else
  {
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::GRUGradientOp::populateDefaultProperties(a2, (_QWORD *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return mlir::mps::GRUGradientOp::populateDefaultProperties(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GRUGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GRUGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  result = *(__n128 *)(a3 + 16);
  v4 = *(_OWORD *)(a3 + 32);
  v5 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 60) = *(_OWORD *)(a3 + 60);
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a3 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  if (*(_QWORD *)(a3 + 24) != *(_QWORD *)(a2 + 24))
    return 0;
  if (*(_QWORD *)(a3 + 32) != *(_QWORD *)(a2 + 32))
    return 0;
  if (*(_QWORD *)(a3 + 40) != *(_QWORD *)(a2 + 40))
    return 0;
  return *(_QWORD *)(a3 + 48) == *(_QWORD *)(a2 + 48)
      && *(_QWORD *)(a3 + 56) == *(_QWORD *)(a2 + 56)
      && *(_QWORD *)(a3 + 64) == *(_QWORD *)(a2 + 64)
      && *(_DWORD *)(a3 + 72) == (unint64_t)*(unsigned int *)(a2 + 72);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::GRUGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::mps::GRUGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::GRUGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GRUGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GRUGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::GRUGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.gru_gradient";
  v28[1] = 16;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::mps::GRUGradientOp::getAsmResultNames(&v5, a3, a4);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUGradientOp>::getDefaultDialect()
{
  return "";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::GRUGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::GRUGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t Context;
  uint64_t InterfaceFor;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31[3];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v31, v12, v11);
  v13 = *v10;
  v14 = v10[2];
  v15 = v10[3];
  v24 = v10[1];
  v25 = v14;
  v16 = v10[4];
  v26 = v15;
  v27 = v16;
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v23 = v13;
  v28 = *(_OWORD *)v31;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.gru_gradient", 16, Context);
    v22 = 1;
  }
  v29 = a2;
  v30 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v31 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v31[0] = a1;
  v31[1] = InterfaceFor;
  if (!a1)
    return 0;
  return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v31, v29, v30, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  void *v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  void *v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  __guard v158;
  __guard v159;
  __guard v160;
  __guard v161;
  __guard v162;
  __guard v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &unk_1EDC07000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_1EDC07000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNResults<3>::Impl<Empty>]";
      v210 = 96;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_1EDC07000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = (void *)v5[441];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[196];
  v11 = &unk_1EDC07000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_1EDC07000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<4>::Impl<Empty>]";
      v210 = 97;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_1EDC07000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = (void *)v11[163];
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v210 = 96;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[423];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = p_vtable[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[169];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == a1
      || v9 == (_QWORD)a1
      || v12 == a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[138] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::GRUGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::GRUGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::GRUGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::GRUGradientOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::GRUGradientOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNResults<3u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::GRUGradientOp>,mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::mps::GRUGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::GRUGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::GRUGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::GRUGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::GRUGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::GRUGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyAtLeastNResults(a1, (mlir::Operation *)3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)4)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  v5 = a1;
  return mlir::mps::GRUGradientOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::GRUGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<3u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gru", 7, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GRUOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E35788;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gru", 7, v3, v4, 0, 0);
  *v5 = &off_1E0DFE8B0;
  v5[12] = mlir::mps::GRUOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::getInherentAttr(uint64_t a1, uint64_t a2, _WORD *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::GRUOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  _WORD *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (_WORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::GRUOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::GRUOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::GRUOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::getOpPropertyByteSize()
{
  return 80;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;

  if (a4)
  {
    *(_OWORD *)a3 = *a4;
    v4 = a4[1];
    v5 = a4[2];
    v6 = a4[4];
    *(_OWORD *)(a3 + 48) = a4[3];
    *(_OWORD *)(a3 + 64) = v6;
    *(_OWORD *)(a3 + 16) = v4;
    *(_OWORD *)(a3 + 32) = v5;
  }
  else
  {
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::GRUOp::populateDefaultProperties(a2, (_QWORD *)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  return mlir::mps::GRUOp::populateDefaultProperties(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GRUOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GRUOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;
  __int128 v5;

  *(_OWORD *)a2 = *(_OWORD *)a3;
  result = *(__n128 *)(a3 + 16);
  v4 = *(_OWORD *)(a3 + 32);
  v5 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(a2 + 60) = *(_OWORD *)(a3 + 60);
  *(_OWORD *)(a2 + 32) = v4;
  *(_OWORD *)(a2 + 48) = v5;
  *(__n128 *)(a2 + 16) = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::compareProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(_QWORD *)a3 != *(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(a3 + 8) != *(_QWORD *)(a2 + 8))
    return 0;
  if (*(_QWORD *)(a3 + 16) != *(_QWORD *)(a2 + 16))
    return 0;
  if (*(_QWORD *)(a3 + 24) != *(_QWORD *)(a2 + 24))
    return 0;
  if (*(_QWORD *)(a3 + 32) != *(_QWORD *)(a2 + 32))
    return 0;
  if (*(_QWORD *)(a3 + 40) != *(_QWORD *)(a2 + 40))
    return 0;
  if (*(_QWORD *)(a3 + 48) != *(_QWORD *)(a2 + 48))
    return 0;
  return *(_QWORD *)(a3 + 56) == *(_QWORD *)(a2 + 56)
      && *(_QWORD *)(a3 + 64) == *(_QWORD *)(a2 + 64)
      && *(_DWORD *)(a3 + 72) == (unint64_t)*(unsigned int *)(a2 + 72);
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GRUOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::GRUOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::mps::GRUOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::GRUOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GRUOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GRUOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::GRUOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.gru";
  v28[1] = 7;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t NextResultAtOffset;
  int v9;
  uint64_t v10;
  uint64_t result;
  uint64_t v12;

  v6 = a2 - 16;
  if (*(_DWORD *)(a2 + 36))
    v7 = a2 - 16;
  else
    v7 = 0;
  NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v7, 0);
  a3(a4, NextResultAtOffset, "result", 6);
  v9 = *(_DWORD *)(a2 + 36);
  if (v9)
    v10 = v6;
  else
    v10 = 0;
  result = mlir::detail::OpResultImpl::getNextResultAtOffset(v10, 1);
  if (v9 != 1)
  {
    v12 = mlir::detail::OpResultImpl::getNextResultAtOffset(result, 0);
    return ((uint64_t (*)(uint64_t, uint64_t, const char *, uint64_t))a3)(a4, v12, "training_state", 14);
  }
  return result;
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::GRUOp>::getDefaultDialect()
{
  return "";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::GRUOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::GRUOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t Context;
  uint64_t InterfaceFor;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31[3];
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v31, v12, v11);
  v13 = *v10;
  v14 = v10[2];
  v15 = v10[3];
  v24 = v10[1];
  v25 = v14;
  v16 = v10[4];
  v26 = v15;
  v27 = v16;
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v23 = v13;
  v28 = *(_OWORD *)v31;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.gru", 7, Context);
    v22 = 1;
  }
  v29 = a2;
  v30 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v31 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v31[0] = a1;
  v31[1] = InterfaceFor;
  if (!a1)
    return 0;
  return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v31, v29, v30, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  void *v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  __guard *v11;
  __guard v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  __guard v158;
  __guard v159;
  __guard v160;
  __guard v161;
  __guard v162;
  __guard v163;
  __guard v164;
  __guard v165;
  __guard v166;
  __guard v167;
  __guard v168;
  __guard v169;
  __guard v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &unk_1EDC07000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_1EDC07000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNResults<1>::Impl<Empty>]";
      v210 = 96;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<1u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_1EDC07000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = (void *)v5[457];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[196];
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<2>::Impl<Empty>]";
      v210 = 97;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[303];
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v210 = 96;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[423];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = p_vtable[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[169];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == a1
      || v9 == (_QWORD)a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[138] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::GRUOp>,mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::mps::GRUOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::GRUOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::GRUOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::GRUOp>,mlir::OpTrait::OpInvariants<mlir::mps::GRUOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::GRUOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::GRUOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::GRUOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::GRUOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::GRUOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::GRUOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::GRUOp>,mlir::OpTrait::AtLeastNResults<1u>::Impl<mlir::mps::GRUOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::GRUOp>,mlir::OpTrait::AtLeastNOperands<2u>::Impl<mlir::mps::GRUOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::GRUOp>,mlir::OpTrait::OpInvariants<mlir::mps::GRUOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::GRUOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::GRUOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::GRUOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::GRUOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::GRUOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyAtLeastNResults(a1, (mlir::Operation *)1)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)2)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  v5 = a1;
  return mlir::mps::GRUOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::GRUOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<1u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<2u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gather_along_axis", 21, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GatherAlongAxisOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32B00;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gather_along_axis", 21, v3, v4, 0, 0);
  *v5 = &off_1E0DFD4C0;
  v5[12] = mlir::mps::GatherAlongAxisOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  BOOL v7;
  BOOL v8;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 22
    && (*a3 == 0x656E5F776F6C6C61 ? (v7 = a3[1] == 0x695F657669746167) : (v7 = 0),
        v7 ? (v8 = *(_QWORD *)((char *)a3 + 14) == 0x73656369646E695FLL) : (v8 = 0),
        v8))
  {
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  BOOL v8;
  uint64_t v10;
  uint64_t v11;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 22)
  {
    v8 = *result == 0x656E5F776F6C6C61 && result[1] == 0x695F657669746167;
    if (v8 && *(_QWORD *)((char *)result + 14) == 0x73656369646E695FLL)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        *v5 = v10;
      }
      else
      {
        *v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"allow_negative_indices", 22, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v7, (const void **)"allow_negative_indices", (const char *)0x16, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GatherAlongAxisOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GatherAlongAxisOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherAlongAxisOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherAlongAxisOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::GatherAlongAxisOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherAlongAxisOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherAlongAxisOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23[2];
  unint64_t v24[2];
  void *v25;
  uint64_t v26;
  _BYTE v27[32];
  _QWORD v28[3];
  _QWORD *v29;
  _QWORD v30[3];
  _QWORD *v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v25 = v27;
  v26 = 0x400000000;
  if (!mlir::mps::GatherAlongAxisOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, v21, v22, (uint64_t)&v25))
  {
    v16 = 0;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v24, (uint64_t)v25, v26);
  mlir::ValueRange::ValueRange(v23, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v28[0] = off_1E0E4FE08;
  v29 = v28;
  v31 = v30;
  v30[0] = off_1E0E4FE08;
  v14 = v31;
  if (v31 == v30)
  {
    v15 = 4;
    v14 = v30;
  }
  else
  {
    if (!v31)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v29;
  if (v29 == v28)
  {
    v19 = 4;
    v18 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v25;
    if (v25 == v27)
      return v16;
    goto LABEL_18;
  }
  v30[0] = "mps.gather_along_axis";
  v30[1] = 21;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v30, "' op inferred type(s) ", (uint64_t)&v25, " are incompatible with return type(s) of operation ", a11);
  v17 = v25;
  if (v25 != v27)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherAlongAxisOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherAlongAxisOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherAlongAxisOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.gather_along_axis", 21, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v163 = 104;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<3>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<3u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<3u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[209];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v163 = 89;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v163 = 90;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[152];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v163 = 100;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v26[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
    return 0;
  v6 = a1;
  if (!mlir::mps::GatherAlongAxisOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::GatherAlongAxisOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::GatherAlongAxisOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gather_nd", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GatherNDOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E3E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gather_nd", 13, v3, v4, 0, 0);
  *v5 = &off_1E0DFBAA0;
  v5[12] = mlir::mps::GatherNDOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  BOOL v8;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 10)
  {
    if (*(_QWORD *)a3 != 0x69645F6863746162 || *(_WORD *)(a3 + 8) != 29549)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 22)
      return 0;
    v8 = *(_QWORD *)a3 == 0x656E5F776F6C6C61 && *(_QWORD *)(a3 + 8) == 0x695F657669746167;
    if (!v8 || *(_QWORD *)(a3 + 14) != 0x73656369646E695FLL)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  BOOL v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v13);
  if (v7 == 10)
  {
    if (*(_QWORD *)result == 0x69645F6863746162 && *(_WORD *)(result + 8) == 29549)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          v11 = a4;
        else
          v11 = 0;
        v5[1] = v11;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 22)
  {
    v8 = *(_QWORD *)result == 0x656E5F776F6C6C61 && *(_QWORD *)(result + 8) == 0x695F657669746167;
    if (v8 && *(_QWORD *)(result + 14) == 0x73656369646E695FLL)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v12 = a4;
        else
          v12 = 0;
        *v5 = v12;
      }
      else
      {
        *v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"allow_negative_indices", 22, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"batch_dims", 10, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void **v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"allow_negative_indices", (const char *)0x16, a4, a5))
  {
    v10 = (const void **)mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v10, (const void **)"batch_dims", (const char *)0xA, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GatherNDOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GatherNDOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherNDOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherNDOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, _DWORD *a11)
{
  return mlir::mps::GatherNDOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherNDOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherNDOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::GatherNDOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, &v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.gather_nd";
  v28[1] = 13;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherNDOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherNDOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherNDOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.gather_nd", 13, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  void *v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  void *v132;
  void *v133;
  void *v134;
  void *v135;
  void *v136;
  void *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  void *v158;
  void *v159;
  void *v160;
  void *v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v163 = 104;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v163 = 89;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v163 = 90;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[152];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v163 = 100;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v26[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::GatherNDOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::GatherNDOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::GatherNDOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gather", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GatherOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37E98;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gather", 10, v3, v4, 0, 0);
  *v5 = &off_1E0DFF930;
  v5[12] = mlir::mps::GatherOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;
  BOOL v8;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 10)
  {
    if (*(_QWORD *)a3 != 0x69645F6863746162 || *(_WORD *)(a3 + 8) != 29549)
      return 0;
    return v7[1];
  }
  else
  {
    if (a4 != 22)
      return 0;
    v8 = *(_QWORD *)a3 == 0x656E5F776F6C6C61 && *(_QWORD *)(a3 + 8) == 0x695F657669746167;
    if (!v8 || *(_QWORD *)(a3 + 14) != 0x73656369646E695FLL)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  BOOL v8;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v13);
  if (v7 == 10)
  {
    if (*(_QWORD *)result == 0x69645F6863746162 && *(_WORD *)(result + 8) == 29549)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::IntegerAttr,void>::id)
          v11 = a4;
        else
          v11 = 0;
        v5[1] = v11;
      }
      else
      {
        v5[1] = 0;
      }
    }
  }
  else if (v7 == 22)
  {
    v8 = *(_QWORD *)result == 0x656E5F776F6C6C61 && *(_QWORD *)(result + 8) == 0x695F657669746167;
    if (v8 && *(_QWORD *)(result + 14) == 0x73656369646E695FLL)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::UnitAttr,void>::id)
          v12 = a4;
        else
          v12 = 0;
        *v5 = v12;
      }
      else
      {
        *v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"allow_negative_indices", 22, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"batch_dims", 10, v6);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v9;
  const void **v10;
  _BOOL8 result;

  v9 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  result = 0;
  if (!v9
    || mlir::memref::__mlir_ods_local_attr_constraint_MemRefOps9(v9, (const void **)"allow_negative_indices", (const char *)0x16, a4, a5))
  {
    v10 = (const void **)mlir::NamedAttrList::get(a3, *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8));
    if (!v10
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps19(v10, (const void **)"batch_dims", (const char *)0xA, a4, a5))
    {
      return 1;
    }
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::getOpPropertyByteSize()
{
  return 16;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, _OWORD *a4)
{
  if (a4)
  {
    *(_OWORD *)a3 = *a4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GatherNDOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GatherNDOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  *a2 = *a3;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2 && a3[1] == a2[1];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GatherOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::ModuleOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GatherOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::IntegerAttr>(a1, v3 + 1) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::GatherOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GatherOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, char a3, uint64_t a4, unint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::GatherOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.gather";
  v28[1] = 10;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GatherOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GatherOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  __int128 *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = (__int128 *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.gather", 10, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
    return 0;
  v6 = a1;
  if (!mlir::mps::GatherOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::GatherOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::GatherOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.gelu", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GeluOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E36340;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.gelu", 8, v3, v4, 0, 0);
  *v5 = &off_1E0DFED80;
  v5[12] = mlir::mps::GeluOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GeluOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GeluOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GeluOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GeluOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.gelu";
  v28 = 8;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::GeluOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::GeluOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::GeluOpGenericAdaptorBase::GeluOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::DegammaOp>,mlir::OpTrait::OneResult<mlir::mps::DegammaOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::DegammaOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::DegammaOp>,mlir::OpTrait::OneOperand<mlir::mps::DegammaOp>,mlir::OpTrait::OpInvariants<mlir::mps::DegammaOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultElementType<mlir::mps::DegammaOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::DegammaOp>,mlir::OpTrait::Stitchable<mlir::mps::DegammaOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::DegammaOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::DegammaOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::GeluOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultElementType,mlir::OpTrait::SameOperandsAndResultType,mlir::OpTrait::Stitchable,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.get_coordinates", 19, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GetCoordOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E4B0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.get_coordinates", 19, v3, v4, 0, 0);
  *v5 = &off_1E0DFBAF8;
  v5[12] = mlir::mps::GetCoordOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::hasTrait(uint64_t a1, void *a2)
{
  _BOOL8 v2;
  char v3;
  llvm **v4;
  llvm *v6[2];
  unint64_t v7;
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v7 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v2 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v6, a2);
  v3 = v7;
  if (v7 >= 8)
  {
    if ((v7 & 4) != 0)
    {
      if ((v7 & 2) != 0)
        v4 = v6;
      else
        v4 = (llvm **)v6[0];
      (*(void (**)(llvm **))((v7 & 0xFFFFFFFFFFFFFFF8) + 16))(v4);
    }
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer(v6[0], v6[1]);
  }
  return v2;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  char v6;
  llvm **v7;
  llvm *v8[2];
  unint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v9 = (unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
     + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v8, a2, a3, a4, a5);
  v6 = v9;
  if (v9 >= 8)
  {
    if ((v9 & 4) != 0)
    {
      if ((v9 & 2) != 0)
        v7 = v8;
      else
        v7 = (llvm **)v8[0];
      result = (*(uint64_t (**)(llvm **))((v9 & 0xFFFFFFFFFFFFFFF8) + 16))(v7);
    }
    if ((v6 & 2) == 0)
      llvm::deallocate_buffer(v8[0], v8[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::getInherentAttr(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 11
    && (*a3 == 0x745F746C75736572 ? (v7 = *(_QWORD *)((char *)a3 + 3) == 0x657079745F746C75) : (v7 = 0), v7))
  {
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _QWORD *result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = (_QWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 11 && *result == 0x745F746C75736572 && *(_QWORD *)((char *)result + 3) == 0x657079745F746C75)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"result_type", 11, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v7, (const void **)"result_type", (const char *)0xB, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::GetCoordOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::GetCoordOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::GetCoordOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  _DWORD *v4;
  char v5;
  int v6;
  unsigned int v7;
  uint64_t *v8;

  v4 = (_DWORD *)(*(uint64_t (**)(uint64_t, const char *, uint64_t))(*(_QWORD *)a1 + 24))(a1, "mps", 3);
  if (!v5 || (v6 = v4[2]) != 0 && (v6 != 1 || (v7 = v4[3], v7 >= 2) && (v7 != 2 || v4[4])))
  {
    v8 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::GetCoordOpGenericAdaptorBase::Properties>(a2);
    mlir::DialectBytecodeReader::readOptionalAttribute<mlir::TypeAttr>(a1, v8);
  }
  return 1;
}

_DWORD *mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;
  uint64_t *Context;
  uint64_t LoadedDialect;
  _DWORD *result;
  int v9;
  unsigned int v10;
  BOOL v11;

  v5 = *(unsigned int *)(a2 + 44);
  Context = (uint64_t *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  LoadedDialect = mlir::MLIRContext::getLoadedDialect(Context, (uint64_t)"mps", 3);
  result = mlir::Dialect::getRegisteredInterface<mlir::BytecodeDialectInterface>(LoadedDialect);
  v9 = result[8];
  if (v9)
  {
    if (v9 != 1 || (v10 = result[9], v10 >= 2) && (v10 == 2 ? (v11 = result[10] == 0) : (v11 = 0), !v11))
    {
      if (*(_QWORD *)(a2 + 16 * ((v5 >> 23) & 1) + 64))
        return (_DWORD *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 24))(a3);
    }
  }
  return result;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  _QWORD *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::downgradeToVersion;
  v4 = &unk_1EDC07000;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = (_QWORD *)&unk_1EDC07000;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = (_QWORD *)&unk_1EDC07000;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[197], v2);
}

void mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::downgradeToVersion(uint64_t *a1@<X1>, _DWORD *a2@<X3>, uint64_t a3@<X8>)
{
  uint64_t *v3;

  v3 = a1;
  mlir::mps::GetCoordOp::downgradeToVersion(&v3, a2, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, _QWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::GetCoordOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, _QWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GetCoordOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GetCoordOp>::refineReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, uint64_t a5, uint64_t a6, _QWORD *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::GetCoordOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.get_coordinates";
  v28[1] = 19;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GetCoordOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GetCoordOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GetCoordOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.get_coordinates", 19, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **v20;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  __guard *v26;
  __guard v27;
  unsigned __int8 v28;
  _QWORD *v29;
  void *v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *v157;
  void *v158;
  __guard v159;
  __guard v160;
  __guard v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  void *v199;
  void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v235 = 104;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v235 = 90;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  v20 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v235 = 89;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[158];
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v235 = 82;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[132];
  v29 = &unk_1EDC07000;
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v29 = (_QWORD *)&unk_1EDC07000;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::DowngraderInterface::Trait<Empty>]";
      v235 = 89;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::DowngraderInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::DowngraderInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v29 = (_QWORD *)&unk_1EDC07000;
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = (void *)v29[199];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v235 = 90;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[152];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v235 = 100;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == a1
      || v33 == (_QWORD)a1
      || v35[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::GetCoordOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::GetCoordOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::GetCoordOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::Stitchable,mlir::DowngraderInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.greater", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E30198;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.greater", 11, v3, v4, 0, 0);
  *v5 = &off_1E0DFC650;
  v5[12] = mlir::mps::GreaterThanOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::hasTrait(uint64_t a1, void *a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GreaterThanOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GreaterThanOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.greater";
  v28[1] = 11;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GreaterThanOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GreaterThanOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::GreaterThanOpGenericAdaptorBase::GreaterThanOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  __guard *v23;
  __guard v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  __guard *v29;
  __guard v30;
  unsigned __int8 v31;
  uint64_t *v32;
  uint64_t v33;
  unsigned __int8 v34;
  uint64_t *v35;
  int v48;
  int v49;
  unint64_t v50;
  unint64_t v51;
  const char *v52;
  unint64_t v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  const char *v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  uint64_t v65;
  int v66;
  int v67;
  unint64_t v68;
  unint64_t v69;
  const char *v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int v75;
  int v76;
  unint64_t v77;
  unint64_t v78;
  const char *v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  int v85;
  unint64_t v86;
  unint64_t v87;
  const char *v88;
  unint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  int v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  const char *v97;
  unint64_t v98;
  uint64_t v99;
  unint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unint64_t v105;
  const char *v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  unint64_t v113;
  unint64_t v114;
  const char *v115;
  unint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  int v120;
  int v121;
  unint64_t v122;
  unint64_t v123;
  const char *v124;
  unint64_t v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  int v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  const char *v133;
  unint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  const char *v142;
  unint64_t v143;
  uint64_t v144;
  unint64_t v145;
  uint64_t v146;
  int v147;
  int v148;
  unint64_t v149;
  unint64_t v150;
  const char *v151;
  unint64_t v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  __guard v157;
  __guard v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  __guard v162;
  __guard v163;
  __guard v164;
  __guard v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  void *v192;
  void *v193;
  void *v194;
  void *v195;
  void *v196;
  void *v197;
  void *v198;
  void *v199;
  void *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  void *v222;
  void *v223;
  void *v224;
  void *v225;
  void *v226;
  void *v227;
  void *v228;
  void *v229;
  void *v230;
  void *v231;
  void *v232;
  void *v233;
  const char *v234;
  unint64_t v235;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v222 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v49 = v48;
    a1 = v222;
    if (v49)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v235 = 83;
      v50 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v50)
        v51 = v50;
      else
        v51 = v235;
      v52 = &v234[v51];
      v53 = v235 - v51;
      if (v235 - v51 >= 0x12)
        v54 = 18;
      else
        v54 = v235 - v51;
      v55 = v53 - v54;
      if (v55 >= v55 - 1)
        v56 = v55 - 1;
      else
        v56 = v55;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v52[v54], v56);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v222;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v211 = v3;
    v223 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v58 = v57;
    v3 = v211;
    a1 = v223;
    if (v58)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v235 = 81;
      v59 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v59)
        v60 = v59;
      else
        v60 = v235;
      v61 = &v234[v60];
      v62 = v235 - v60;
      if (v235 - v60 >= 0x12)
        v63 = 18;
      else
        v63 = v235 - v60;
      v64 = v62 - v63;
      if (v64 >= v64 - 1)
        v65 = v64 - 1;
      else
        v65 = v64;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v61[v63], v65);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v211;
      a1 = v223;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v212 = v3;
    v224 = a1;
    v201 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v201;
    v3 = v212;
    v67 = v66;
    a1 = v224;
    if (v67)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v235 = 104;
      v68 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v68)
        v69 = v68;
      else
        v69 = v235;
      v70 = &v234[v69];
      v71 = v235 - v69;
      if (v235 - v69 >= 0x12)
        v72 = 18;
      else
        v72 = v235 - v69;
      v73 = v71 - v72;
      if (v73 >= v73 - 1)
        v74 = v73 - 1;
      else
        v74 = v73;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v70[v72], v74);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v201;
      v3 = v212;
      a1 = v224;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v213 = v3;
    v225 = a1;
    v202 = v6;
    v192 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v192;
    v6 = v202;
    v3 = v213;
    v76 = v75;
    a1 = v225;
    if (v76)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v235 = 86;
      v77 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v77)
        v78 = v77;
      else
        v78 = v235;
      v79 = &v234[v78];
      v80 = v235 - v78;
      if (v235 - v78 >= 0x12)
        v81 = 18;
      else
        v81 = v235 - v78;
      v82 = v80 - v81;
      if (v82 >= v82 - 1)
        v83 = v82 - 1;
      else
        v83 = v82;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v79[v81], v83);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v192;
      v6 = v202;
      v3 = v213;
      a1 = v225;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v214 = v3;
    v226 = a1;
    v203 = v6;
    v184 = v12;
    v193 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v184;
    v9 = v193;
    v6 = v203;
    v3 = v214;
    v85 = v84;
    a1 = v226;
    if (v85)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<2>::Impl<Empty>]";
      v235 = 90;
      v86 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v86)
        v87 = v86;
      else
        v87 = v235;
      v88 = &v234[v87];
      v89 = v235 - v87;
      if (v235 - v87 >= 0x12)
        v90 = 18;
      else
        v90 = v235 - v87;
      v91 = v89 - v90;
      if (v91 >= v91 - 1)
        v92 = v91 - 1;
      else
        v92 = v91;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<2u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<2u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v88[v90], v92);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v184;
      v9 = v193;
      v6 = v203;
      v3 = v214;
      a1 = v226;
    }
  }
  v15 = v14[208];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v215 = v3;
    v227 = a1;
    v204 = v6;
    v185 = v12;
    v194 = v9;
    v177 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v177;
    v12 = v185;
    v9 = v194;
    v6 = v204;
    v3 = v215;
    v94 = v93;
    a1 = v227;
    if (v94)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v235 = 84;
      v95 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v95)
        v96 = v95;
      else
        v96 = v235;
      v97 = &v234[v96];
      v98 = v235 - v96;
      if (v235 - v96 >= 0x12)
        v99 = 18;
      else
        v99 = v235 - v96;
      v100 = v98 - v99;
      if (v100 >= v100 - 1)
        v101 = v100 - 1;
      else
        v101 = v100;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v97[v99], v101);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v177;
      v12 = v185;
      v9 = v194;
      v6 = v204;
      v3 = v215;
      a1 = v227;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v216 = v3;
    v228 = a1;
    v205 = v6;
    v186 = v12;
    v195 = v9;
    v171 = v18;
    v178 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v171;
    v15 = v178;
    v12 = v186;
    v9 = v195;
    v6 = v205;
    v3 = v216;
    v103 = v102;
    a1 = v228;
    if (v103)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v235 = 93;
      v104 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v104)
        v105 = v104;
      else
        v105 = v235;
      v106 = &v234[v105];
      v107 = v235 - v105;
      if (v235 - v105 >= 0x12)
        v108 = 18;
      else
        v108 = v235 - v105;
      v109 = v107 - v108;
      if (v109 >= v109 - 1)
        v110 = v109 - 1;
      else
        v110 = v109;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v106[v108], v110);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v171;
      v15 = v178;
      v12 = v186;
      v9 = v195;
      v6 = v205;
      v3 = v216;
      a1 = v228;
    }
  }
  v21 = v20[158];
  if ((v22 & 1) == 0)
  {
    v217 = v3;
    v229 = a1;
    v206 = v6;
    v187 = v12;
    v196 = v9;
    v172 = v18;
    v179 = v15;
    v166 = v21;
    v21 = v166;
    v18 = v172;
    v15 = v179;
    v12 = v187;
    v9 = v196;
    v6 = v206;
    v3 = v217;
    v112 = v111;
    a1 = v229;
    if (v112)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsElementType<Empty>]";
      v235 = 95;
      v113 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v113)
        v114 = v113;
      else
        v114 = v235;
      v115 = &v234[v114];
      v116 = v235 - v114;
      if (v235 - v114 >= 0x12)
        v117 = 18;
      else
        v117 = v235 - v114;
      v118 = v116 - v117;
      if (v118 >= v118 - 1)
        v119 = v118 - 1;
      else
        v119 = v118;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsElementType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsElementType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v115[v117], v119);
      v21 = v166;
      v18 = v172;
      v15 = v179;
      v12 = v187;
      v9 = v196;
      v6 = v206;
      v3 = v217;
      a1 = v229;
    }
  }
  v24 = v23[501];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v218 = v3;
    v230 = a1;
    v207 = v6;
    v188 = v12;
    v197 = v9;
    v173 = v18;
    v180 = v15;
    v162 = v24;
    v167 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v162;
    v21 = v167;
    v18 = v173;
    v15 = v180;
    v12 = v188;
    v9 = v197;
    v6 = v207;
    v3 = v218;
    v121 = v120;
    a1 = v230;
    if (v121)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ResultsBroadcastableShape<Empty>]";
      v235 = 97;
      v122 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v122)
        v123 = v122;
      else
        v123 = v235;
      v124 = &v234[v123];
      v125 = v235 - v123;
      if (v235 - v123 >= 0x12)
        v126 = 18;
      else
        v126 = v235 - v123;
      v127 = v125 - v126;
      if (v127 >= v127 - 1)
        v128 = v127 - 1;
      else
        v128 = v127;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ResultsBroadcastableShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ResultsBroadcastableShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v124[v126], v128);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v162;
      v21 = v167;
      v18 = v173;
      v15 = v180;
      v12 = v188;
      v9 = v197;
      v6 = v207;
      v3 = v218;
      a1 = v230;
    }
  }
  v27 = v26[204];
  if ((v28 & 1) == 0)
  {
    v219 = v3;
    v231 = a1;
    v208 = v6;
    v189 = v12;
    v198 = v9;
    v174 = v18;
    v181 = v15;
    v163 = v24;
    v168 = v21;
    v159 = v27;
    v27 = v159;
    v24 = v163;
    v21 = v168;
    v18 = v174;
    v15 = v181;
    v12 = v189;
    v9 = v198;
    v6 = v208;
    v3 = v219;
    v130 = v129;
    a1 = v231;
    if (v130)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v235 = 82;
      v131 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v131)
        v132 = v131;
      else
        v132 = v235;
      v133 = &v234[v132];
      v134 = v235 - v132;
      if (v235 - v132 >= 0x12)
        v135 = 18;
      else
        v135 = v235 - v132;
      v136 = v134 - v135;
      if (v136 >= v136 - 1)
        v137 = v136 - 1;
      else
        v137 = v136;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v133[v135], v137);
      v27 = v159;
      v24 = v163;
      v21 = v168;
      v18 = v174;
      v15 = v181;
      v12 = v189;
      v9 = v198;
      v6 = v208;
      v3 = v219;
      a1 = v231;
    }
  }
  v30 = v29[132];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v220 = v3;
    v232 = a1;
    v209 = v6;
    v190 = v12;
    v199 = v9;
    v175 = v18;
    v182 = v15;
    v164 = v24;
    v169 = v21;
    v157 = v30;
    v160 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v157;
    v27 = v160;
    v24 = v164;
    v21 = v169;
    v18 = v175;
    v15 = v182;
    v12 = v190;
    v9 = v199;
    v6 = v209;
    v3 = v220;
    v139 = v138;
    a1 = v232;
    if (v139)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v235 = 90;
      v140 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v140)
        v141 = v140;
      else
        v141 = v235;
      v142 = &v234[v141];
      v143 = v235 - v141;
      if (v235 - v141 >= 0x12)
        v144 = 18;
      else
        v144 = v235 - v141;
      v145 = v143 - v144;
      if (v145 >= v145 - 1)
        v146 = v145 - 1;
      else
        v146 = v145;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v142[v144], v146);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v157;
      v27 = v160;
      v24 = v164;
      v21 = v169;
      v18 = v175;
      v15 = v182;
      v12 = v190;
      v9 = v199;
      v6 = v209;
      v3 = v220;
      a1 = v232;
    }
  }
  v33 = v32[152];
  v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v34 & 1) == 0)
  {
    v221 = v3;
    v233 = a1;
    v210 = v6;
    v191 = v12;
    v200 = v9;
    v176 = v18;
    v183 = v15;
    v165 = v24;
    v170 = v21;
    v158 = v30;
    v161 = v27;
    v156 = v33;
    v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v33 = v156;
    v30 = v158;
    v27 = v161;
    v24 = v165;
    v21 = v170;
    v18 = v176;
    v15 = v183;
    v12 = v191;
    v9 = v200;
    v6 = v210;
    v3 = v221;
    v148 = v147;
    a1 = v233;
    if (v148)
    {
      v234 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v235 = 100;
      v149 = llvm::StringRef::find((uint64_t *)&v234, "DesiredTypeName = ", 0x12uLL, 0);
      if (v235 >= v149)
        v150 = v149;
      else
        v150 = v235;
      v151 = &v234[v150];
      v152 = v235 - v150;
      if (v235 - v150 >= 0x12)
        v153 = 18;
      else
        v153 = v235 - v150;
      v154 = v152 - v153;
      if (v154 >= v154 - 1)
        v155 = v154 - 1;
      else
        v155 = v154;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v151[v153], v155);
      v35 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v33 = v156;
      v30 = v158;
      v27 = v161;
      v24 = v165;
      v21 = v170;
      v18 = v176;
      v15 = v183;
      v12 = v191;
      v9 = v200;
      v6 = v210;
      v3 = v221;
      a1 = v233;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v33 == (_QWORD)a1
      || v35[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::EqualToOp>,mlir::OpTrait::OneResult<mlir::mps::EqualToOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::EqualToOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::OpInvariants<mlir::mps::EqualToOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::EqualToOp>,mlir::OpTrait::SameOperandsElementType<mlir::mps::EqualToOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::EqualToOp>,mlir::OpTrait::IsCommutative<mlir::mps::EqualToOp>,mlir::OpTrait::Stitchable<mlir::mps::EqualToOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::EqualToOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::EqualToOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::GreaterThanOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.greater_equal", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::GreaterThanOrEqualToOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E34400;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.greater_equal", 17, v3, v4, 0, 0);
  *v5 = &off_1E0DFDFC0;
  v5[12] = mlir::mps::GreaterThanOrEqualToOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::GreaterThanOrEqualToOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GreaterThanOrEqualToOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::GreaterThanOrEqualToOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.greater_equal";
  v28[1] = 17;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::GreaterThanOrEqualToOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GreaterThanOrEqualToOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::GreaterThanOrEqualToOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::GreaterThanOrEqualToOpGenericAdaptorBase::GreaterThanOrEqualToOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::EqualToOp>,mlir::OpTrait::OneResult<mlir::mps::EqualToOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::EqualToOp>,mlir::OpTrait::NOperands<2u>::Impl<mlir::mps::EqualToOp>,mlir::OpTrait::OpInvariants<mlir::mps::EqualToOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::EqualToOp>,mlir::OpTrait::SameOperandsElementType<mlir::mps::EqualToOp>,mlir::OpTrait::ResultsBroadcastableShape<mlir::mps::EqualToOp>,mlir::OpTrait::IsCommutative<mlir::mps::EqualToOp>,mlir::OpTrait::Stitchable<mlir::mps::EqualToOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::EqualToOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::EqualToOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::GreaterThanOrEqualToOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsElementType,mlir::OpTrait::ResultsBroadcastableShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.hamming_distance", 20, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::HammingDistanceOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E32BC8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.hamming_distance", 20, v3, v4, 0, 0);
  *v5 = &off_1E0DFD518;
  v5[12] = mlir::mps::HammingDistanceOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v7;
  BOOL v8;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 17
    && (*(_QWORD *)a3 == 0x6C45746C75736572 ? (v7 = *(_QWORD *)(a3 + 8) == 0x707954746E656D65) : (v7 = 0),
        v7 ? (v8 = *(_BYTE *)(a3 + 16) == 101) : (v8 = 0),
        v8))
  {
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  }
  else
  {
    return 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;
  BOOL v8;
  uint64_t v10;
  uint64_t v11;

  v11 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v11);
  if (v7 == 17)
  {
    v8 = *(_QWORD *)result == 0x6C45746C75736572 && *(_QWORD *)(result + 8) == 0x707954746E656D65;
    if (v8 && *(_BYTE *)(result + 16) == 101)
    {
      if (a4)
      {
        if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::TypeAttr,void>::id)
          v10 = a4;
        else
          v10 = 0;
        *v5 = v10;
      }
      else
      {
        *v5 = 0;
      }
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"resultElementType", 17, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  uint64_t v7;

  v7 = mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::pdl::__mlir_ods_local_attr_constraint_PDLOps6(v7, (const void **)"resultElementType", (const char *)0x11, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::getOpPropertyByteSize()
{
  return 8;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::initProperties(uint64_t a1, uint64_t a2, _QWORD *a3, _QWORD *a4)
{
  if (a4)
    *a3 = *a4;
  else
    *a3 = 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::CastOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::CastOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::HammingDistanceOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HammingDistanceOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::TypeAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::HammingDistanceOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::HammingDistanceOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::HammingDistanceOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, unint64_t a5, uint64_t a6, uint64_t *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::HammingDistanceOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.hamming_distance";
  v28[1] = 20;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HammingDistanceOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::HammingDistanceOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::HammingDistanceOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.hamming_distance", 20, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::HammingDistanceOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::HammingDistanceOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::HammingDistanceOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.hermitean_to_real_fft", 25, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::HermiteanToRealFFTOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E33CF8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.hermitean_to_real_fft", 25, v3, v4, 0, 0);
  *v5 = &off_1E0DFDCA8;
  v5[12] = mlir::mps::HermiteanToRealFFTOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::getInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v7 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (!HIBYTE(*(_DWORD *)(a2 + 44)))
    v7 = 0;
  if (a4 == 12)
  {
    if (*(_QWORD *)a3 == 0x6F745F646E756F72 && *(_DWORD *)(a3 + 8) == 1684303711)
    {
      return v7[1];
    }
    else
    {
      if (*(_QWORD *)a3 != 0x5F676E696C616373 || *(_DWORD *)(a3 + 8) != 1701080941)
        return 0;
      return v7[2];
    }
  }
  else
  {
    if (a4 != 7)
      return 0;
    if (*(_DWORD *)a3 != 1702260329 || *(_DWORD *)(a3 + 3) != 1702064741)
      return 0;
    return *v7;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  uint64_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::HermiteanToRealFFTOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  if (*v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"inverse", 7, *v5);
  v6 = v5[1];
  if (v6)
    mlir::NamedAttrList::append(a3, (uint64_t)"round_to_odd", 12, v6);
  v7 = v5[2];
  if (v7)
    mlir::NamedAttrList::append(a3, (uint64_t)"scaling_mode", 12, v7);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::HermiteanToRealFFTOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::getOpPropertyByteSize()
{
  return 24;
}

void mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;

  if (a4)
  {
    v4 = *a4;
    *(_QWORD *)(a3 + 16) = *((_QWORD *)a4 + 2);
    *(_OWORD *)a3 = v4;
  }
  else
  {
    *(_QWORD *)a3 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
  }
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::HermiteanToRealFFTOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::HermiteanToRealFFTOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::copyProperties(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  result = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  *a2 = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] == a2[1])
    return a3[2] == a2[2];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::HermiteanToRealFFTOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::memref::PrefetchOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::HermiteanToRealFFTOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readOptionalAttribute<mlir::UnitAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::mps::FFTScalingModeAttr>(a1, v3 + 2) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, v4[1]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::HermiteanToRealFFTOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::HermiteanToRealFFTOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, unint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::HermiteanToRealFFTOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.hermitean_to_real_fft";
  v28[1] = 25;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::HermiteanToRealFFTOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::HermiteanToRealFFTOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::HermiteanToRealFFTOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  __int128 v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27[3];
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v27, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *(_OWORD *)v10;
  v23 = *(_QWORD *)(v10 + 16);
  v24 = *(_OWORD *)v27;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.hermitean_to_real_fft", 25, Context);
    v21 = 1;
  }
  v25 = a2;
  v26 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v27 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v27[0] = a1;
  v27[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v27, v25, v26);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  uint64_t *v6;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyNOperands((mlir::OpTrait::impl *)a1, (mlir::Operation *)2)
    && (v6 = a1, mlir::mps::HermiteanToRealFFTOp::verifyInvariantsImpl(&v6)))
  {
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::HermiteanToRealFFTOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.identity", 12, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::IdentityOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E578;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.identity", 12, v3, v4, 0, 0);
  *v5 = &off_1E0DFBB50;
  v5[12] = mlir::mps::IdentityOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IdentityOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  int v11;
  unsigned int v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  v11 = *(_DWORD *)(a11 + 8);
  if (v11 != 1)
  {
    if (!v11)
    {
      if (*(_DWORD *)(a11 + 12))
      {
        v12 = 0;
LABEL_6:
        bzero((void *)(*(_QWORD *)a11 + 8 * v12), 8 - 8 * v12);
        goto LABEL_7;
      }
      llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), 1uLL, 8);
      v12 = *(_DWORD *)(a11 + 8);
      if (v12 != 1)
        goto LABEL_6;
    }
LABEL_7:
    *(_DWORD *)(a11 + 8) = 1;
  }
  **(_QWORD **)a11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IdentityOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IdentityOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IdentityOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  const char **v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23[2];
  _QWORD v24[4];
  _QWORD v25[3];
  _QWORD *v26;
  const char *v27;
  uint64_t v28;
  const char **v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23[0] = v24;
  v27 = a4;
  v28 = a5;
  v24[0] = 0;
  v23[1] = (void *)0x400000001;
  v24[0] = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v27, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  mlir::ValueRange::ValueRange(v22, (uint64_t)v24, 1uLL);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v25[0] = off_1E0E4FE08;
  v26 = v25;
  v29 = &v27;
  v27 = (const char *)off_1E0E4FE08;
  v14 = v29;
  if (v29 == &v27)
  {
    v15 = 4;
    v14 = &v27;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v15 = 5;
  }
  (*(void (**)(void))&(*v14)[8 * v15])();
LABEL_6:
  v16 = v26;
  if (v26 == v25)
  {
    v17 = 4;
    v16 = v25;
  }
  else
  {
    if (!v26)
      goto LABEL_11;
    v17 = 5;
  }
  (*(void (**)(void))(*v16 + 8 * v17))();
LABEL_11:
  if ((v13 & 1) != 0)
  {
    v18 = 1;
    v19 = v23[0];
    if (v23[0] == v24)
      return v18;
    goto LABEL_15;
  }
  v27 = "mps.identity";
  v28 = 12;
  v18 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v27, "' op inferred type(s) ", (uint64_t)v23, " are incompatible with return type(s) of operation ", a11);
  v19 = v23[0];
  if (v23[0] != v24)
LABEL_15:
    free(v19);
  return v18;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::IdentityOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::foldSingleResultHook<mlir::mps::IdentityOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::IdentityOpGenericAdaptorBase::IdentityOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  int v40;
  int v41;
  unint64_t v42;
  unint64_t v43;
  const char *v44;
  unint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  unint64_t v51;
  unint64_t v52;
  const char *v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  uint64_t v57;
  int v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  const char *v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  const char *v71;
  unint64_t v72;
  uint64_t v73;
  unint64_t v74;
  uint64_t v75;
  int v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  const char *v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  int v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  const char *v89;
  unint64_t v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  int v94;
  int v95;
  unint64_t v96;
  unint64_t v97;
  const char *v98;
  unint64_t v99;
  uint64_t v100;
  unint64_t v101;
  uint64_t v102;
  int v103;
  int v104;
  unint64_t v105;
  unint64_t v106;
  const char *v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  int v112;
  int v113;
  unint64_t v114;
  unint64_t v115;
  const char *v116;
  unint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  int v122;
  unint64_t v123;
  unint64_t v124;
  const char *v125;
  unint64_t v126;
  uint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  void *v151;
  void *v152;
  void *v153;
  void *v154;
  void *v155;
  void *v156;
  void *v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  const char *v185;
  unint64_t v186;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v175 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v41 = v40;
    a1 = v175;
    if (v41)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v186 = 83;
      v42 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v42)
        v43 = v42;
      else
        v43 = v186;
      v44 = &v185[v43];
      v45 = v186 - v43;
      if (v186 - v43 >= 0x12)
        v46 = 18;
      else
        v46 = v186 - v43;
      v47 = v45 - v46;
      if (v47 >= v47 - 1)
        v48 = v47 - 1;
      else
        v48 = v47;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v44[v46], v48);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v175;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v166 = v3;
    v176 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v50 = v49;
    v3 = v166;
    a1 = v176;
    if (v50)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v186 = 81;
      v51 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v51)
        v52 = v51;
      else
        v52 = v186;
      v53 = &v185[v52];
      v54 = v186 - v52;
      if (v186 - v52 >= 0x12)
        v55 = 18;
      else
        v55 = v186 - v52;
      v56 = v54 - v55;
      if (v56 >= v56 - 1)
        v57 = v56 - 1;
      else
        v57 = v56;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v53[v55], v57);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v166;
      a1 = v176;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v167 = v3;
    v177 = a1;
    v158 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v158;
    v59 = v58;
    v3 = v167;
    a1 = v177;
    if (v59)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v186 = 104;
      v60 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v60)
        v61 = v60;
      else
        v61 = v186;
      v62 = &v185[v61];
      v63 = v186 - v61;
      if (v186 - v61 >= 0x12)
        v64 = 18;
      else
        v64 = v186 - v61;
      v65 = v63 - v64;
      if (v65 >= v65 - 1)
        v66 = v65 - 1;
      else
        v66 = v65;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v62[v64], v66);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v158;
      v3 = v167;
      a1 = v177;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v168 = v3;
    v178 = a1;
    v151 = v9;
    v159 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v151;
    v6 = v159;
    v68 = v67;
    v3 = v168;
    a1 = v178;
    if (v68)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v186 = 86;
      v69 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v69)
        v70 = v69;
      else
        v70 = v186;
      v71 = &v185[v70];
      v72 = v186 - v70;
      if (v186 - v70 >= 0x12)
        v73 = 18;
      else
        v73 = v186 - v70;
      v74 = v72 - v73;
      if (v74 >= v74 - 1)
        v75 = v74 - 1;
      else
        v75 = v74;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v71[v73], v75);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v151;
      v6 = v159;
      v3 = v168;
      a1 = v178;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v169 = v3;
    v179 = a1;
    v152 = v9;
    v160 = v6;
    v145 = v12;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v145;
    v9 = v152;
    v6 = v160;
    v77 = v76;
    v3 = v169;
    a1 = v179;
    if (v77)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v186 = 82;
      v78 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v78)
        v79 = v78;
      else
        v79 = v186;
      v80 = &v185[v79];
      v81 = v186 - v79;
      if (v186 - v79 >= 0x12)
        v82 = 18;
      else
        v82 = v186 - v79;
      v83 = v81 - v82;
      if (v83 >= v83 - 1)
        v84 = v83 - 1;
      else
        v84 = v83;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v80[v82], v84);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v145;
      v9 = v152;
      v6 = v160;
      v3 = v169;
      a1 = v179;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v170 = v3;
    v180 = a1;
    v153 = v9;
    v161 = v6;
    v140 = v15;
    v146 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v140;
    v12 = v146;
    v9 = v153;
    v6 = v161;
    v86 = v85;
    v3 = v170;
    a1 = v180;
    if (v86)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v186 = 84;
      v87 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v87)
        v88 = v87;
      else
        v88 = v186;
      v89 = &v185[v88];
      v90 = v186 - v88;
      if (v186 - v88 >= 0x12)
        v91 = 18;
      else
        v91 = v186 - v88;
      v92 = v90 - v91;
      if (v92 >= v92 - 1)
        v93 = v92 - 1;
      else
        v93 = v92;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v89[v91], v93);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v140;
      v12 = v146;
      v9 = v153;
      v6 = v161;
      v3 = v170;
      a1 = v180;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v171 = v3;
    v181 = a1;
    v154 = v9;
    v162 = v6;
    v141 = v15;
    v147 = v12;
    v136 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v136;
    v15 = v141;
    v12 = v147;
    v9 = v154;
    v6 = v162;
    v95 = v94;
    v3 = v171;
    a1 = v181;
    if (v95)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v186 = 93;
      v96 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v96)
        v97 = v96;
      else
        v97 = v186;
      v98 = &v185[v97];
      v99 = v186 - v97;
      if (v186 - v97 >= 0x12)
        v100 = 18;
      else
        v100 = v186 - v97;
      v101 = v99 - v100;
      if (v101 >= v101 - 1)
        v102 = v101 - 1;
      else
        v102 = v101;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v98[v100], v102);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v136;
      v15 = v141;
      v12 = v147;
      v9 = v154;
      v6 = v162;
      v3 = v171;
      a1 = v181;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v172 = v3;
    v182 = a1;
    v155 = v9;
    v163 = v6;
    v142 = v15;
    v148 = v12;
    v133 = v21;
    v137 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v133;
    v18 = v137;
    v15 = v142;
    v12 = v148;
    v9 = v155;
    v6 = v163;
    v104 = v103;
    v3 = v172;
    a1 = v182;
    if (v104)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultType<Empty>]";
      v186 = 97;
      v105 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v105)
        v106 = v105;
      else
        v106 = v186;
      v107 = &v185[v106];
      v108 = v186 - v106;
      if (v186 - v106 >= 0x12)
        v109 = 18;
      else
        v109 = v186 - v106;
      v110 = v108 - v109;
      if (v110 >= v110 - 1)
        v111 = v110 - 1;
      else
        v111 = v110;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultType<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultType>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v107[v109], v111);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v133;
      v18 = v137;
      v15 = v142;
      v12 = v148;
      v9 = v155;
      v6 = v163;
      v3 = v172;
      a1 = v182;
    }
  }
  v24 = v23[205];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v173 = v3;
    v183 = a1;
    v156 = v9;
    v164 = v6;
    v143 = v15;
    v149 = v12;
    v134 = v21;
    v138 = v18;
    v131 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v131;
    v21 = v134;
    v18 = v138;
    v15 = v143;
    v12 = v149;
    v9 = v156;
    v6 = v164;
    v113 = v112;
    v3 = v173;
    a1 = v183;
    if (v113)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v186 = 100;
      v114 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v114)
        v115 = v114;
      else
        v115 = v186;
      v116 = &v185[v115];
      v117 = v186 - v115;
      if (v186 - v115 >= 0x12)
        v118 = 18;
      else
        v118 = v186 - v115;
      v119 = v117 - v118;
      if (v119 >= v119 - 1)
        v120 = v119 - 1;
      else
        v120 = v119;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v116[v118], v120);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v131;
      v21 = v134;
      v18 = v138;
      v15 = v143;
      v12 = v149;
      v9 = v156;
      v6 = v164;
      v3 = v173;
      a1 = v183;
    }
  }
  v27 = v26[169];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v174 = v3;
    v184 = a1;
    v157 = v9;
    v165 = v6;
    v144 = v15;
    v150 = v12;
    v135 = v21;
    v139 = v18;
    v130 = v27;
    v132 = v24;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v130;
    v24 = v132;
    v21 = v135;
    v18 = v139;
    v15 = v144;
    v12 = v150;
    v9 = v157;
    v6 = v165;
    v122 = v121;
    v3 = v174;
    a1 = v184;
    if (v122)
    {
      v185 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v186 = 90;
      v123 = llvm::StringRef::find((uint64_t *)&v185, "DesiredTypeName = ", 0x12uLL, 0);
      if (v186 >= v123)
        v124 = v123;
      else
        v124 = v186;
      v125 = &v185[v124];
      v126 = v186 - v124;
      if (v186 - v124 >= 0x12)
        v127 = 18;
      else
        v127 = v186 - v124;
      v128 = v126 - v127;
      if (v128 >= v128 - 1)
        v129 = v128 - 1;
      else
        v129 = v128;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v125[v127], v129);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v130;
      v24 = v132;
      v21 = v135;
      v18 = v139;
      v15 = v144;
      v12 = v150;
      v9 = v157;
      v6 = v165;
      v3 = v174;
      a1 = v184;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v29[152] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IdentityOp>,mlir::OpTrait::OneResult<mlir::mps::IdentityOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IdentityOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IdentityOp>,mlir::OpTrait::OneOperand<mlir::mps::IdentityOp>,mlir::OpTrait::OpInvariants<mlir::mps::IdentityOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IdentityOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::IdentityOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IdentityOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IdentityOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IdentityOp>,mlir::OpTrait::OneResult<mlir::mps::IdentityOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IdentityOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IdentityOp>,mlir::OpTrait::OneOperand<mlir::mps::IdentityOp>,mlir::OpTrait::OpInvariants<mlir::mps::IdentityOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IdentityOp>,mlir::OpTrait::SameOperandsAndResultType<mlir::mps::IdentityOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IdentityOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IdentityOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  mlir::Operation *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& (*(_DWORD *)(a1 + 36) ? (v6 = a1 - 16) : (v6 = 0), NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"result", 6, 0)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultType((mlir::OpTrait::impl *)a1, v8) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::IdentityOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultType,mlir::CompatibleReturnTypesInterface::Trait,mlir::InferTypeOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.im_to_col", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ImToColOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E387F8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.im_to_col", 13, v3, v4, 0, 0);
  *v5 = &off_1E0DFFD50;
  v5[12] = mlir::mps::ImToColOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  int Context;
  _QWORD *v8;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::ImToColOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::ImToColOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t Context;
  uint64_t *v6;

  Context = mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::ColToImOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(const void ***__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::ColToImOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::getOpPropertyByteSize()
{
  return 40;
}

double mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, __int128 *a4)
{
  __int128 v4;
  __int128 v5;

  if (a4)
  {
    v4 = *a4;
    v5 = a4[1];
    *(_QWORD *)(a3 + 32) = *((_QWORD *)a4 + 4);
    *(_OWORD *)a3 = v4;
    *(_OWORD *)(a3 + 16) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 32) = 0;
    *(_QWORD *)&v4 = 0;
    *(_OWORD *)a3 = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
  }
  return *(double *)&v4;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::ColToImOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::ColToImOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  __int128 v4;

  result = *(__n128 *)a3;
  v4 = *(_OWORD *)(a3 + 16);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a3 + 32);
  *(__n128 *)a2 = result;
  *(_OWORD *)(a2 + 16) = v4;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] == a2[3])
    return a3[4] == a2[4];
  return 0;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImToColOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::func::FuncOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::ImToColOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readAttribute<mlir::mps::TensorDataLayoutAttr>(a1, v3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 1)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 2)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 3)
      && mlir::DialectBytecodeReader::readAttribute<mlir::DenseIntElementsAttr>(a1, v3 + 4) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;

  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, *v4);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[1]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[2]);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[3]);
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 16))(a3, v4[4]);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ImToColOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ImToColOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E511D8;
  v11 = v10;
  v12[0] = off_1E0E511D8;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ImToColOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::ImToColOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E511D8;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E511D8;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.im_to_col";
  v28[1] = 13;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImToColOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E511D8;
  v11 = v10;
  v12[0] = off_1E0E511D8;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ImToColOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ImToColOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v20;
  _BYTE v21[8];
  char v22;
  __int128 v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29[3];
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v29, v12, v11);
  v20 = v8;
  v21[0] = 0;
  v22 = 0;
  v13 = *(_OWORD *)(v10 + 16);
  v23 = *(_OWORD *)v10;
  v24 = v13;
  v25 = *(_QWORD *)(v10 + 32);
  v26 = *(_OWORD *)v29;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v20);
    if (v22)
      v22 = 0;
    mlir::OperationName::OperationName(v21, "mps.im_to_col", 13, Context);
    v22 = 1;
  }
  v27 = a2;
  v28 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v29 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v29[0] = a1;
  v29[1] = InterfaceFor;
  if (!a1)
    return 0;
  v16 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v29, v27, v28);
  if (v16 < 8)
    return 0;
  v17 = v16;
  if (a1 - 16 != (v16 & ((uint64_t)(v16 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v18 = *(unsigned int *)(a4 + 8);
    if (v18 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v18 + 1, 8);
      LODWORD(v18) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v18) = v17;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  mlir::OpTrait::impl *v7;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneOperand(a1, v5))
    return 0;
  v7 = a1;
  if (!mlir::mps::ImToColOp::verifyInvariantsImpl((uint64_t **)&v7))
    return 0;
  v7 = a1;
  return mlir::mps::ImToColOp::verify((uint64_t **)&v7) != 0;
}

BOOL mlir::Op<mlir::mps::ImToColOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.imaginary_part", 18, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::ImaginaryPartOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E31B60;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.imaginary_part", 18, v3, v4, 0, 0);
  *v5 = &off_1E0DFCDE0;
  v5[12] = mlir::mps::ImaginaryPartOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::ImaginaryPartOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::inferReturnTypes(mlir::UnknownLoc *this, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::ImaginaryPartOp::inferReturnTypes(this, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ImaginaryPartOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::ImaginaryPartOp>::refineReturnTypes(mlir::UnknownLoc *a1, mlir::MLIRContext *a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v11;
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v11 = a3;
  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::ImaginaryPartOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.imaginary_part";
  v28[1] = 18;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>((uint64_t)a2, v11, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::ImaginaryPartOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ImaginaryPartOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::ImaginaryPartOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::ImaginaryPartOpGenericAdaptorBase::ImaginaryPartOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  void **p_vtable;
  void *v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  uint64_t *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  void **v23;
  void *v24;
  unsigned __int8 v25;
  __guard *v26;
  __guard v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  __guard v144;
  __guard v145;
  void *v146;
  void *v147;
  void *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  void *v171;
  void *v172;
  void *v173;
  void *v174;
  void *v175;
  void *v176;
  void *v177;
  void *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v210 = 81;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = v5[211];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<Empty>]";
      v210 = 104;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::Type>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = p_vtable[501];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = v11[196];
  v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneOperand<Empty>]";
      v210 = 82;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneOperand<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneOperand>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v14 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[181];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = v20[158];
  v23 = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::SameOperandsAndResultShape<Empty>]";
      v210 = 98;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::OpTrait::SameOperandsAndResultShape<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::SameOperandsAndResultShape>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[503];
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::Stitchable<Empty>]";
      v210 = 82;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::OpTrait::Stitchable<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::Stitchable>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[132];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[152];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == (_QWORD)a1
      || v9 == a1
      || v12 == (_QWORD)a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == (_QWORD)a1
      || v24 == a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[169] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneResult<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneOperand<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OpInvariants<mlir::mps::ImaginaryPartOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::Stitchable<mlir::mps::ImaginaryPartOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ImaginaryPartOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneResult<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OneOperand<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::OpInvariants<mlir::mps::ImaginaryPartOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::ImaginaryPartOp>,mlir::OpTrait::Stitchable<mlir::mps::ImaginaryPartOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::ImaginaryPartOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::ImaginaryPartOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  mlir::Operation *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& (*(_DWORD *)(a1 + 36) ? (v6 = a1 - 16) : (v6 = 0), NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps6((uint64_t *)a1, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultShape((mlir::OpTrait::impl *)a1, v8) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::ImaginaryPartOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.init_random_philox_state", 28, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::InitRandomPhiloxStateOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E347E8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)&llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.init_random_philox_state", 28, v3, v4, 0, 0);
  *v5 = &off_1E0DFE1D0;
  v5[12] = mlir::mps::InitRandomPhiloxStateOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InitRandomPhiloxStateOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x1E0C80C00];
  v15[0] = 7;
  v11 = mlir::IntegerType::get(a1, 0x20u, 1u);
  v12 = mlir::RankedTensorType::get((uint64_t)v15, 1, v11, 0);
  v13 = *(unsigned int *)(a11 + 8);
  if (v13 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v13 + 1, 8);
    LODWORD(v13) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v13) = v12;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::InitRandomPhiloxStateOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::InitRandomPhiloxStateOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  uint64_t v13;
  char v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24[2];
  _QWORD v25[4];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v24[0] = v25;
  v24[1] = (void *)0x400000001;
  v28[0] = 7;
  v13 = mlir::IntegerType::get(a1, 0x20u, 1u);
  v25[0] = mlir::RankedTensorType::get((uint64_t)v28, 1, v13, 0);
  mlir::ValueRange::ValueRange(v23, (uint64_t)v25, 1uLL);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v15 = v29;
  if (v29 == v28)
  {
    v16 = 4;
    v15 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_6;
    v16 = 5;
  }
  (*(void (**)(void))(*v15 + 8 * v16))();
LABEL_6:
  v17 = v27;
  if (v27 == v26)
  {
    v18 = 4;
    v17 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_11;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_11:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24[0];
    if (v24[0] == v25)
      return v19;
    goto LABEL_15;
  }
  v28[0] = "mps.init_random_philox_state";
  v28[1] = 28;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24[0];
  if (v24[0] != v25)
LABEL_15:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InitRandomPhiloxStateOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::InitRandomPhiloxStateOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::InitRandomPhiloxStateOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::InitRandomPhiloxStateOpGenericAdaptorBase::InitRandomPhiloxStateOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyOneResult(a1, v3)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4)
    || !mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)3))
  {
    return 0;
  }
  v6 = a1;
  return mlir::mps::InitRandomPhiloxStateOp::verifyInvariantsImpl((uint64_t **)&v6);
}

BOOL mlir::Op<mlir::mps::InitRandomPhiloxStateOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<3u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.instance_norm", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::InstanceNormOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E30E18;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.instance_norm", 17, v3, v4, 0, 0);
  *v5 = &off_1E0DFC860;
  v5[12] = mlir::mps::InstanceNormOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::getInherentAttr(uint64_t a1, uint64_t a2, _DWORD *a3, uint64_t a4)
{
  BOOL v7;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (a4 == 7 && (*a3 == 1769173093 ? (v7 = *(_DWORD *)((char *)a3 + 3) == 1852796009) : (v7 = 0), v7))
    return *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64) & 0xFFFFFFFFFFFFFF00 | *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    return 0;
}

_DWORD *mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v5;
  _DWORD *result;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  v10 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v5 = 0;
  result = (_DWORD *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v10);
  if (v7 == 7 && *result == 1769173093 && *(_DWORD *)((char *)result + 3) == 1852796009)
  {
    if (a4)
    {
      if (*(_UNKNOWN **)(*(_QWORD *)a4 + 136) == &mlir::detail::TypeIDResolver<mlir::FloatAttr,void>::id)
        v9 = a4;
      else
        v9 = 0;
      *v5 = v9;
    }
    else
    {
      *v5 = 0;
    }
  }
  return result;
}

void mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;

  mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  v5 = *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  if (v5)
    mlir::NamedAttrList::append(a3, (uint64_t)"epsilon", 7, v5);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  const void **v7;

  v7 = (const void **)mlir::NamedAttrList::get(a3, **(_QWORD **)(a2 + 96));
  return !v7
      || mlir::mps::__mlir_ods_local_attr_constraint_MPSOps20(v7, (const void **)"epsilon", (const char *)7, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::getOpPropertyByteSize()
{
  return 8;
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::initProperties(uint64_t a1, uint64_t a2, mlir::Float32Type **a3, mlir::Float32Type **a4)
{
  mlir::Float32Type *v5;
  mlir::Float32Type *result;
  mlir::MLIRContext *v7;
  uint64_t F32Type;
  mlir::Float32Type *v9;

  if (a4)
    v5 = *a4;
  else
    v5 = 0;
  *a3 = v5;
  v9 = *(mlir::Float32Type **)(a2 + 8);
  result = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&v9);
  v9 = result;
  if (!*a3)
  {
    F32Type = mlir::Builder::getF32Type(&v9, v7);
    result = mlir::Builder::getFloatAttr(0.0, (uint64_t)&v9, F32Type);
    *a3 = result;
  }
  return result;
}

mlir::Float32Type *mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::Float32Type **a3)
{
  mlir::Float32Type *result;
  mlir::MLIRContext *v5;
  uint64_t F32Type;
  mlir::Float32Type *v7;

  v7 = *(mlir::Float32Type **)(a2 + 8);
  result = (mlir::Float32Type *)mlir::Attribute::getContext((mlir::Attribute *)&v7);
  v7 = result;
  if (!*a3)
  {
    F32Type = mlir::Builder::getF32Type(&v7, v5);
    result = mlir::Builder::getFloatAttr(0.0, (uint64_t)&v7, F32Type);
    *a3 = result;
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::InstanceNormOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::InstanceNormOp::getPropertiesAsAttr(Context, v4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::copyProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  return *a3 == *a2;
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::InstanceNormOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::arith::AddFOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

BOOL mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::readProperties(uint64_t a1, _QWORD *a2)
{
  uint64_t *v3;

  v3 = (uint64_t *)mlir::OperationState::getOrAddProperties<mlir::mps::detail::InstanceNormOpGenericAdaptorBase::Properties>(a2);
  return mlir::DialectBytecodeReader::readOptionalAttribute<mlir::FloatAttr>(a1, v3) != 0;
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)a3 + 24))(a3, *(_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64));
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::InstanceNormOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::InstanceNormOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.instance_norm";
  v30 = 17;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::InstanceNormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::InstanceNormOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::InstanceNormOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t Context;
  uint64_t InterfaceFor;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v19;
  _BYTE v20[8];
  char v21;
  uint64_t v22;
  __int128 v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26[3];
  uint64_t v27;

  v27 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  v10 = (uint64_t *)(a1 + 16 * ((v9 >> 23) & 1) + 64);
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = (((unint64_t)v10 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v26, v12, v11);
  v19 = v8;
  v20[0] = 0;
  v21 = 0;
  v22 = *v10;
  v23 = *(_OWORD *)v26;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v19);
    if (v21)
      v21 = 0;
    mlir::OperationName::OperationName(v20, "mps.instance_norm", 17, Context);
    v21 = 1;
  }
  v24 = a2;
  v25 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v26 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v26[0] = a1;
  v26[1] = InterfaceFor;
  if (!a1)
    return 0;
  v15 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)v26, v24, v25);
  if (v15 < 8)
    return 0;
  v16 = v15;
  if (a1 - 16 != (v15 & ((uint64_t)(v15 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v17 = *(unsigned int *)(a4 + 8);
    if (v17 >= *(_DWORD *)(a4 + 12))
    {
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v17 + 1, 8);
      LODWORD(v17) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v17) = v16;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)2))
    return 0;
  v6 = a1;
  if (!mlir::mps::InstanceNormOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::InstanceNormOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::InstanceNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<2u>::Impl,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.is_finite", 13, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::IsFiniteOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2E640;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.is_finite", 13, v3, v4, 0, 0);
  *v5 = &off_1E0DFBBA8;
  v5[12] = mlir::mps::IsFiniteOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsFiniteOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsFiniteOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsFiniteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.is_finite";
  v28[1] = 13;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsFiniteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsFiniteOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsFiniteOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::IsFiniteOpGenericAdaptorBase::IsFiniteOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneResult<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IsFiniteOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneOperand<mlir::mps::IsFiniteOp>,mlir::OpTrait::OpInvariants<mlir::mps::IsFiniteOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::IsFiniteOp>,mlir::OpTrait::Stitchable<mlir::mps::IsFiniteOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IsFiniteOp>>(a1, a2);
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneResult<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IsFiniteOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneOperand<mlir::mps::IsFiniteOp>,mlir::OpTrait::OpInvariants<mlir::mps::IsFiniteOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::IsFiniteOp>,mlir::OpTrait::Stitchable<mlir::mps::IsFiniteOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IsFiniteOp>>(uint64_t a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t NextResultAtOffset;
  mlir::Operation *v8;

  if (mlir::OpTrait::impl::verifyZeroRegions((mlir::OpTrait::impl *)a1, a2)
    && mlir::OpTrait::impl::verifyOneResult((mlir::OpTrait::impl *)a1, v3)
    && mlir::OpTrait::impl::verifyZeroSuccessors((mlir::OpTrait::impl *)a1, v4)
    && mlir::OpTrait::impl::verifyOneOperand((mlir::OpTrait::impl *)a1, v5)
    && mlir::mps::__mlir_ods_local_type_constraint_MPSOps0((uint64_t *)a1, (const void **)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 72) + 24) + 8) & 0xFFFFFFFFFFFFFFF8), (const void **)"operand", 7, 0)&& (*(_DWORD *)(a1 + 36) ? (v6 = a1 - 16) : (v6 = 0), NextResultAtOffset = mlir::detail::OpResultImpl::getNextResultAtOffset(v6, 0), mlir::mps::__mlir_ods_local_type_constraint_MPSOps25((uint64_t *)a1, *(_QWORD *)(NextResultAtOffset + 8) & 0xFFFFFFFFFFFFFFF8, (const void **)"result", (const void **)6, 0)))
  {
    return mlir::OpTrait::impl::verifySameOperandsAndResultShape((mlir::OpTrait::impl *)a1, v8) != 0;
  }
  else
  {
    return 0;
  }
}

BOOL mlir::Op<mlir::mps::IsFiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.is_infinite", 15, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::IsInfiniteOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E2F9C8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.is_infinite", 15, v3, v4, 0, 0);
  *v5 = &off_1E0DFC2E0;
  v5[12] = mlir::mps::IsInfiniteOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsInfiniteOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsInfiniteOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsInfiniteOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.is_infinite";
  v28[1] = 15;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsInfiniteOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsInfiniteOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsInfiniteOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::IsInfiniteOpGenericAdaptorBase::IsInfiniteOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneResult<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IsFiniteOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneOperand<mlir::mps::IsFiniteOp>,mlir::OpTrait::OpInvariants<mlir::mps::IsFiniteOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::IsFiniteOp>,mlir::OpTrait::Stitchable<mlir::mps::IsFiniteOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IsFiniteOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::IsInfiniteOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.is_nan", 10, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::IsNaNOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E373A8;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::foldHook(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                         + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.is_nan", 10, v3, v4, 0, 0);
  *v5 = &off_1E0DFF4B8;
  v5[12] = mlir::mps::IsNaNOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::hasTrait(uint64_t a1, void *a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::IsNaNOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::inferReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsNaNOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::IsNaNOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.is_nan";
  v28[1] = 10;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::IsNaNOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, mlir::Operation *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsNaNOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::IsNaNOp>(mlir::Operation *this, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  mlir::Operation *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::IsNaNOpGenericAdaptorBase::IsNaNOpGenericAdaptorBase((uint64_t)v14, this);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!this)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = this;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)this);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if ((mlir::Operation *)((char *)this - 16) != (mlir::Operation *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(uint64_t a1, mlir::Operation *a2)
{
  return mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneResult<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl<mlir::mps::IsFiniteOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::IsFiniteOp>,mlir::OpTrait::OneOperand<mlir::mps::IsFiniteOp>,mlir::OpTrait::OpInvariants<mlir::mps::IsFiniteOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::OpTrait::SameOperandsAndResultShape<mlir::mps::IsFiniteOp>,mlir::OpTrait::Stitchable<mlir::mps::IsFiniteOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::IsFiniteOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::IsFiniteOp>>(a1, a2);
}

BOOL mlir::Op<mlir::mps::IsNaNOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::Type>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::OneOperand,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::OpTrait::SameOperandsAndResultShape,mlir::OpTrait::Stitchable,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.lp_norm", 11, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LPNormOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E37F60;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::foldHook(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, unsigned int *, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                                      + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.lp_norm", 11, v3, v4, 0, 0);
  *v5 = &off_1E0DFF988;
  v5[12] = mlir::mps::LPNormOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::hasTrait(uint64_t a1, uint64_t a2)
{
  void *v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                 + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, void *))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::getInherentAttr(uint64_t a1, uint64_t a2, const void *a3, size_t a4)
{
  return mlir::DictionaryAttr::get(a2 + 56, a3, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  mlir::MLIRContext *Context;
  void *v8[2];
  _QWORD v9[10];

  v9[9] = *MEMORY[0x1E0C80C00];
  mlir::NamedAttrList::NamedAttrList(v8, *(_QWORD *)(a2 + 56));
  if (mlir::NamedAttrList::set((uint64_t)v8, a3, a4) != a4)
  {
    Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
    *(_QWORD *)(a2 + 56) = mlir::NamedAttrList::getDictionary((mlir::NamedAttrList *)v8, Context);
  }
  if (v8[0] != v9)
    free(v8[0]);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::verifyInherentAttrs()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::getOpPropertyByteSize()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void (*a5)(_QWORD *__return_ptr, uint64_t), uint64_t a6)
{
  int *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _QWORD **v10;
  _QWORD **v11;
  void *v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v15;
  void *v16;
  void *v17;
  unint64_t v19;
  int64_t v20;
  int v21;
  const char *v22;
  uint64_t v23;
  _QWORD v24[3];
  void *v25;
  unsigned int v26;
  unsigned int v27;
  _BYTE v28[96];
  void *v29;
  _QWORD *v30;
  void *__p;
  _QWORD **v32;
  char v33;
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  a5(v24, a6);
  if (v24[0])
  {
    v21 = 3;
    v22 = "this operation does not support properties";
    v23 = 42;
    v6 = &v21;
    v7 = (char *)v25;
    if (v26 >= v27)
    {
      v19 = v26 + 1;
      if (v25 <= &v21 && (char *)v25 + 24 * v26 > (char *)&v21)
      {
        v20 = (char *)&v21 - (_BYTE *)v25;
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v7 = (char *)v25;
        v6 = (int *)((char *)v25 + v20);
      }
      else
      {
        llvm::SmallVectorBase<unsigned int>::grow_pod((uint64_t)&v25, v28, v19, 24);
        v6 = &v21;
        v7 = (char *)v25;
      }
    }
    v8 = &v7[24 * v26];
    v9 = *(_OWORD *)v6;
    *((_QWORD *)v8 + 2) = *((_QWORD *)v6 + 2);
    *(_OWORD *)v8 = v9;
    ++v26;
    if (v24[0])
      mlir::InFlightDiagnostic::report((mlir::InFlightDiagnostic *)v24);
  }
  if (v33)
  {
    v10 = (_QWORD **)__p;
    if (__p)
    {
      v11 = v32;
      v12 = __p;
      if (v32 != __p)
      {
        do
          v11 = std::unique_ptr<mlir::Diagnostic>::~unique_ptr[abi:nn180100](v11 - 1);
        while (v11 != v10);
        v12 = __p;
      }
      v32 = v10;
      operator delete(v12);
    }
    v13 = v29;
    if (v29)
    {
      v14 = v30;
      v15 = v29;
      if (v30 != v29)
      {
        do
        {
          v17 = (void *)*--v14;
          v16 = v17;
          *v14 = 0;
          if (v17)
            operator delete[](v16);
        }
        while (v14 != v13);
        v15 = v29;
      }
      v30 = v13;
      operator delete(v15);
    }
    if (v25 != v28)
      free(v25);
  }
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::getPropertiesAsAttr()
{
  return 0;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::compareProperties()
{
  return 1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LPNormOp>::hashProperties()
{
  return 0;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unint64_t v11;
  uint64_t v12;
  _QWORD v14[3];

  v14[2] = *MEMORY[0x1E0C80C00];
  v14[0] = a4;
  v14[1] = a5;
  if (!a5)
    return mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands");
  v11 = *(_QWORD *)(mlir::ValueRange::dereference_iterator(v14, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
  v12 = *(unsigned int *)(a11 + 8);
  if (v12 >= *(_DWORD *)(a11 + 12))
  {
    llvm::SmallVectorBase<unsigned int>::grow_pod(a11, (void *)(a11 + 16), v12 + 1, 8);
    LODWORD(v12) = *(_DWORD *)(a11 + 8);
  }
  *(_QWORD *)(*(_QWORD *)a11 + 8 * v12) = v11;
  ++*(_DWORD *)(a11 + 8);
  return 1;
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::LPNormOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::LPNormOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  unsigned int v13;
  char v14;
  const char **v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v22[2];
  unint64_t v23[2];
  void *v24;
  uint64_t v25;
  _BYTE v26[32];
  _QWORD v27[3];
  _QWORD *v28;
  const char *v29;
  uint64_t v30;
  const char **v31;
  uint64_t v32;

  v32 = *MEMORY[0x1E0C80C00];
  v24 = v26;
  v25 = 0x400000000;
  v29 = a4;
  v30 = a5;
  if (a5)
  {
    *((_QWORD *)v24 + v25) = *(_QWORD *)(mlir::ValueRange::dereference_iterator(&v29, 0) + 8) & 0xFFFFFFFFFFFFFFF8;
    v13 = v25 + 1;
    LODWORD(v25) = v25 + 1;
  }
  else
  {
    if (!mlir::emitOptionalError<char const(&)[39]>(a2, a3, "invalid number of operands"))
    {
      v19 = 0;
      v20 = v24;
      if (v24 == v26)
        return v19;
      goto LABEL_19;
    }
    v13 = v25;
  }
  mlir::ValueRange::ValueRange(v23, (uint64_t)v24, v13);
  mlir::ValueRange::ValueRange(v22, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v27[0] = off_1E0E4FE08;
  v28 = v27;
  v31 = &v29;
  v29 = (const char *)off_1E0E4FE08;
  v15 = v31;
  if (v31 == &v29)
  {
    v16 = 4;
    v15 = &v29;
  }
  else
  {
    if (!v31)
      goto LABEL_10;
    v16 = 5;
  }
  (*(void (**)(void))&(*v15)[8 * v16])();
LABEL_10:
  v17 = v28;
  if (v28 == v27)
  {
    v18 = 4;
    v17 = v27;
  }
  else
  {
    if (!v28)
      goto LABEL_15;
    v18 = 5;
  }
  (*(void (**)(void))(*v17 + 8 * v18))();
LABEL_15:
  if ((v14 & 1) != 0)
  {
    v19 = 1;
    v20 = v24;
    if (v24 == v26)
      return v19;
    goto LABEL_19;
  }
  v29 = "mps.lp_norm";
  v30 = 11;
  v19 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)&v29, "' op inferred type(s) ", (uint64_t)&v24, " are incompatible with return type(s) of operation ", a11);
  v20 = v24;
  if (v24 != v26)
LABEL_19:
    free(v20);
  return v19;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LPNormOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::LPNormOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::foldSingleResultHook<mlir::mps::LPNormOp>(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v11;
  unsigned int *v12;
  uint64_t InterfaceFor;
  _BYTE v14[40];
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  mlir::mps::detail::LPNormOpGenericAdaptorBase::LPNormOpGenericAdaptorBase((uint64_t)v14, a1);
  v15 = a2;
  v16 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1))
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  if (!a1)
  {
    v12 = 0;
    InterfaceFor = 0;
    return 0;
  }
  v12 = a1;
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor((uint64_t)a1);
  v8 = mlir::anec::PlistGeneratorInterface::addOpToNetwork((uint64_t)&v12, v15, v16);
  if (v8 < 8)
    return 0;
  if (a1 - 4 != (unsigned int *)(v8 & ((uint64_t)(v8 << 61) >> 63) & 0xFFFFFFFFFFFFFFF8))
  {
    v9 = *(unsigned int *)(a4 + 8);
    if (v9 >= *(_DWORD *)(a4 + 12))
    {
      v11 = v8;
      llvm::SmallVectorBase<unsigned int>::grow_pod(a4, (void *)(a4 + 16), v9 + 1, 8);
      v8 = v11;
      LODWORD(v9) = *(_DWORD *)(a4 + 8);
    }
    *(_QWORD *)(*(_QWORD *)a4 + 8 * v9) = v8;
    ++*(_DWORD *)(a4 + 8);
  }
  return 1;
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, uint64_t a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>(uint64_t a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  uint64_t *v5;
  uint64_t v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  uint64_t *v11;
  uint64_t v12;
  unsigned __int8 v13;
  _QWORD *v14;
  uint64_t v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  uint64_t *v20;
  uint64_t v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  int v36;
  int v37;
  unint64_t v38;
  unint64_t v39;
  const char *v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  uint64_t v44;
  int v45;
  int v46;
  unint64_t v47;
  unint64_t v48;
  const char *v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  uint64_t v53;
  int v54;
  int v55;
  unint64_t v56;
  unint64_t v57;
  const char *v58;
  unint64_t v59;
  uint64_t v60;
  unint64_t v61;
  uint64_t v62;
  int v63;
  int v64;
  unint64_t v65;
  unint64_t v66;
  const char *v67;
  unint64_t v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unint64_t v74;
  unint64_t v75;
  const char *v76;
  unint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  int v81;
  int v82;
  unint64_t v83;
  unint64_t v84;
  const char *v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  int v90;
  int v91;
  unint64_t v92;
  unint64_t v93;
  const char *v94;
  unint64_t v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  int v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  const char *v103;
  unint64_t v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  unint64_t v110;
  unint64_t v111;
  const char *v112;
  unint64_t v113;
  uint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  const char *v162;
  unint64_t v163;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v153 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v37 = v36;
    a1 = v153;
    if (v37)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v163 = 83;
      v38 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v38)
        v39 = v38;
      else
        v39 = v163;
      v40 = &v162[v39];
      v41 = v163 - v39;
      if (v163 - v39 >= 0x12)
        v42 = 18;
      else
        v42 = v163 - v39;
      v43 = v41 - v42;
      if (v43 >= v43 - 1)
        v44 = v43 - 1;
      else
        v44 = v43;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v40[v42], v44);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v153;
    }
  }
  v3 = v2[187];
  v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v4 & 1) == 0)
  {
    v145 = v3;
    v154 = a1;
    v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v46 = v45;
    v3 = v145;
    a1 = v154;
    if (v46)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneResult<Empty>]";
      v163 = 81;
      v47 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v47)
        v48 = v47;
      else
        v48 = v163;
      v49 = &v162[v48];
      v50 = v163 - v48;
      if (v163 - v48 >= 0x12)
        v51 = 18;
      else
        v51 = v163 - v48;
      v52 = v50 - v51;
      if (v52 >= v52 - 1)
        v53 = v52 - 1;
      else
        v53 = v52;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneResult<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneResult>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v49[v51], v53);
      v5 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v3 = v145;
      a1 = v154;
    }
  }
  v6 = v5[211];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v146 = v3;
    v155 = a1;
    v138 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v138;
    v55 = v54;
    v3 = v146;
    a1 = v155;
    if (v55)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<Empty>]";
      v163 = 110;
      v56 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v56)
        v57 = v56;
      else
        v57 = v163;
      v58 = &v162[v57];
      v59 = v163 - v57;
      if (v163 - v57 >= 0x12)
        v60 = 18;
      else
        v60 = v163 - v57;
      v61 = v59 - v60;
      if (v61 >= v61 - 1)
        v62 = v61 - 1;
      else
        v62 = v61;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v58[v60], v62);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v138;
      v3 = v146;
      a1 = v155;
    }
  }
  v9 = v8[195];
  v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v10 & 1) == 0)
  {
    v147 = v3;
    v156 = a1;
    v132 = v9;
    v139 = v6;
    v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v9 = v132;
    v6 = v139;
    v64 = v63;
    v3 = v147;
    a1 = v156;
    if (v64)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v163 = 86;
      v65 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v65)
        v66 = v65;
      else
        v66 = v163;
      v67 = &v162[v66];
      v68 = v163 - v66;
      if (v163 - v66 >= 0x12)
        v69 = 18;
      else
        v69 = v163 - v66;
      v70 = v68 - v69;
      if (v70 >= v70 - 1)
        v71 = v70 - 1;
      else
        v71 = v70;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v67[v69], v71);
      v11 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v9 = v132;
      v6 = v139;
      v3 = v147;
      a1 = v156;
    }
  }
  v12 = v11[196];
  v14 = &unk_1EDC07000;
  if ((v13 & 1) == 0)
  {
    v148 = v3;
    v157 = a1;
    v133 = v9;
    v140 = v6;
    v127 = v12;
    v14 = (_QWORD *)&unk_1EDC07000;
    v12 = v127;
    v9 = v133;
    v6 = v140;
    v73 = v72;
    v3 = v148;
    a1 = v157;
    if (v73)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::NOperands<4>::Impl<Empty>]";
      v163 = 90;
      v74 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v74)
        v75 = v74;
      else
        v75 = v163;
      v76 = &v162[v75];
      v77 = v163 - v75;
      if (v163 - v75 >= 0x12)
        v78 = 18;
      else
        v78 = v163 - v75;
      v79 = v77 - v78;
      if (v79 >= v79 - 1)
        v80 = v79 - 1;
      else
        v80 = v79;
      mlir::detail::TypeIDResolver<mlir::OpTrait::NOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::NOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v76[v78], v80);
      v14 = (_QWORD *)&unk_1EDC07000;
      v12 = v127;
      v9 = v133;
      v6 = v140;
      v3 = v148;
      a1 = v157;
    }
  }
  v15 = v14[201];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v149 = v3;
    v158 = a1;
    v134 = v9;
    v141 = v6;
    v123 = v15;
    v128 = v12;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v123;
    v12 = v128;
    v9 = v134;
    v6 = v141;
    v82 = v81;
    v3 = v149;
    a1 = v158;
    if (v82)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v163 = 84;
      v83 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v83)
        v84 = v83;
      else
        v84 = v163;
      v85 = &v162[v84];
      v86 = v163 - v84;
      if (v163 - v84 >= 0x12)
        v87 = 18;
      else
        v87 = v163 - v84;
      v88 = v86 - v87;
      if (v88 >= v88 - 1)
        v89 = v88 - 1;
      else
        v89 = v88;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v85[v87], v89);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v123;
      v12 = v128;
      v9 = v134;
      v6 = v141;
      v3 = v149;
      a1 = v158;
    }
  }
  v18 = v17[192];
  v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v19 & 1) == 0)
  {
    v150 = v3;
    v159 = a1;
    v135 = v9;
    v142 = v6;
    v124 = v15;
    v129 = v12;
    v120 = v18;
    v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v18 = v120;
    v15 = v124;
    v12 = v129;
    v9 = v135;
    v6 = v142;
    v91 = v90;
    v3 = v150;
    a1 = v159;
    if (v91)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v163 = 93;
      v92 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v92)
        v93 = v92;
      else
        v93 = v163;
      v94 = &v162[v93];
      v95 = v163 - v93;
      if (v163 - v93 >= 0x12)
        v96 = 18;
      else
        v96 = v163 - v93;
      v97 = v95 - v96;
      if (v97 >= v97 - 1)
        v98 = v97 - 1;
      else
        v98 = v97;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v94[v96], v98);
      v20 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v18 = v120;
      v15 = v124;
      v12 = v129;
      v9 = v135;
      v6 = v142;
      v3 = v150;
      a1 = v159;
    }
  }
  v21 = v20[158];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v151 = v3;
    v160 = a1;
    v136 = v9;
    v143 = v6;
    v125 = v15;
    v130 = v12;
    v118 = v21;
    v121 = v18;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v118;
    v18 = v121;
    v15 = v125;
    v12 = v130;
    v9 = v136;
    v6 = v143;
    v100 = v99;
    v3 = v151;
    a1 = v160;
    if (v100)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v163 = 90;
      v101 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v101)
        v102 = v101;
      else
        v102 = v163;
      v103 = &v162[v102];
      v104 = v163 - v102;
      if (v163 - v102 >= 0x12)
        v105 = 18;
      else
        v105 = v163 - v102;
      v106 = v104 - v105;
      if (v106 >= v106 - 1)
        v107 = v106 - 1;
      else
        v107 = v106;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v103[v105], v107);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v118;
      v18 = v121;
      v15 = v125;
      v12 = v130;
      v9 = v136;
      v6 = v143;
      v3 = v151;
      a1 = v160;
    }
  }
  v24 = v23[152];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v152 = v3;
    v161 = a1;
    v137 = v9;
    v144 = v6;
    v126 = v15;
    v131 = v12;
    v119 = v21;
    v122 = v18;
    v117 = v24;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v117;
    v21 = v119;
    v18 = v122;
    v15 = v126;
    v12 = v131;
    v9 = v137;
    v6 = v144;
    v109 = v108;
    v3 = v152;
    a1 = v161;
    if (v109)
    {
      v162 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v163 = 100;
      v110 = llvm::StringRef::find((uint64_t *)&v162, "DesiredTypeName = ", 0x12uLL, 0);
      if (v163 >= v110)
        v111 = v110;
      else
        v111 = v163;
      v112 = &v162[v111];
      v113 = v163 - v111;
      if (v163 - v111 >= 0x12)
        v114 = 18;
      else
        v114 = v163 - v111;
      v115 = v113 - v114;
      if (v115 >= v115 - 1)
        v116 = v115 - 1;
      else
        v116 = v115;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v112[v114], v116);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v117;
      v21 = v119;
      v18 = v122;
      v15 = v126;
      v12 = v131;
      v9 = v137;
      v6 = v144;
      v3 = v152;
      a1 = v161;
    }
  }
  return v3 == a1
      || v6 == a1
      || v9 == a1
      || v12 == a1
      || v15 == a1
      || v18 == a1
      || v21 == a1
      || v24 == a1
      || v26[169] == a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::Operation *v4;
  mlir::OpTrait::impl *v6;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2))
    return 0;
  if (!mlir::OpTrait::impl::verifyOneResult(a1, v3))
    return 0;
  if (!mlir::OpTrait::impl::verifyZeroSuccessors(a1, v4))
    return 0;
  if (!mlir::OpTrait::impl::verifyNOperands(a1, (mlir::Operation *)4))
    return 0;
  v6 = a1;
  if (!mlir::mps::LPNormOp::verifyInvariantsImpl((uint64_t **)&v6))
    return 0;
  v6 = a1;
  return mlir::mps::LPNormOp::verify((uint64_t **)&v6) != 0;
}

BOOL mlir::Op<mlir::mps::LPNormOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::OneResult,mlir::OpTrait::OneTypedResult<mlir::TensorType>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::NOperands<4u>::Impl,mlir::OpTrait::OpInvariants,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.lstm_gradient", 17, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMGradientOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E30EE0;
  return a1;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::~Model(uint64_t a1)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *(_QWORD *)a1 = off_1E0E2B520;
  v2 = *(void ***)(a1 + 32);
  v3 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = *(void ***)(a1 + 32);
  }
  if (v2 != (void **)(a1 + 48))
    free(v2);
  return a1;
}

void mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::~Model(_QWORD *__p)
{
  void **v2;
  uint64_t v3;
  uint64_t v4;
  void **v5;
  void *v6;

  *__p = off_1E0E2B520;
  v2 = (void **)__p[4];
  v3 = *((unsigned int *)__p + 10);
  if ((_DWORD)v3)
  {
    v4 = 16 * v3;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      v5 += 2;
      free(v6);
      v4 -= 16;
    }
    while (v4);
    v2 = (void **)__p[4];
  }
  if (v2 != __p + 6)
    free(v2);
  operator delete(__p);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::foldHook(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  mlir::Operation *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v13[2];
  unint64_t v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  v14 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
      + 2;
  v9 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const,void>::Callbacks
                                                                               + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v13, a2, a3, a4, a5);
  v10 = v14;
  if (v14 >= 8)
  {
    if ((v14 & 4) != 0)
    {
      if ((v14 & 2) != 0)
        v11 = v13;
      else
        v11 = (llvm **)v13[0];
      (*(void (**)(uint64_t, mlir::Operation *, uint64_t, uint64_t, uint64_t))((v14 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v5, v6, v7, v8);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v13[0], v13[1]);
  }
  return v9;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::getCanonicalizationPatterns(uint64_t a1, uint64_t *a2)
{
  __int16 v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t result;
  _QWORD *v7;
  _QWORD *v8;
  __int16 v9;
  _QWORD *v10;

  mlir::PatternBenefit::PatternBenefit(&v9, 1);
  v3 = v9;
  v4 = *a2;
  v5 = operator new(0x68uLL);
  result = mlir::Pattern::Pattern((uint64_t)(v5 + 1), (uint64_t)"mps.lstm_gradient", 17, v3, v4, 0, 0);
  *v5 = &off_1E0DFC8B8;
  v5[12] = mlir::mps::LSTMGradientOp::canonicalize;
  v10 = v5;
  v7 = (_QWORD *)a2[2];
  if ((unint64_t)v7 >= a2[3])
  {
    v8 = std::vector<std::unique_ptr<mlir::RewritePattern>>::__emplace_back_slow_path<std::unique_ptr<mlir::RewritePattern>>(a2 + 1, (uint64_t *)&v10);
    result = (uint64_t)v10;
    a2[2] = (uint64_t)v8;
    v10 = 0;
    if (result)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  else
  {
    *v7 = v5;
    a2[2] = (uint64_t)(v7 + 1);
  }
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::hasTrait(uint64_t a1, void *a2)
{
  uint64_t v2;
  _BOOL8 v3;
  char v4;
  llvm **v5;
  llvm *v7[2];
  unint64_t v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v8 = (unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
     + 2;
  v3 = (*(BOOL (**)(uint64_t, void *))(((unint64_t)llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const,void>::Callbacks
                                                + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v7, a2);
  v4 = v8;
  if (v8 >= 8)
  {
    if ((v8 & 4) != 0)
    {
      if ((v8 & 2) != 0)
        v5 = v7;
      else
        v5 = (llvm **)v7[0];
      (*(void (**)(uint64_t, uint64_t))((v8 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v5, v2);
    }
    if ((v4 & 2) == 0)
      llvm::deallocate_buffer(v7[0], v7[1]);
  }
  return v3;
}

void mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::getParseAssemblyFn(uint64_t (**a1)(uint64_t a1, uint64_t a2)@<X8>)
{
  *a1 = mlir::OpState::parse;
  a1[3] = (uint64_t (*)(uint64_t, uint64_t))((char *)llvm::detail::UniqueFunctionBase<mlir::ParseResult,mlir::OpAsmParser &,mlir::OperationState &>::CallbacksHolder<mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),mlir::ParseResult (*)(mlir::OpAsmParser &,mlir::OperationState &),void>::Callbacks
                                                   + 2);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::printAssembly(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10;
  llvm **v11;
  llvm *v12[2];
  unint64_t v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v13 = (unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
      + 2;
  result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallbacksHolder<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1},mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const,void>::Callbacks
                                                                                   + 2) & 0xFFFFFFFFFFFFFFF8))((uint64_t)v12, a2, a3, a4, a5);
  v10 = v13;
  if (v13 >= 8)
  {
    if ((v13 & 4) != 0)
    {
      if ((v13 & 2) != 0)
        v11 = v12;
      else
        v11 = (llvm **)v12[0];
      result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))((v13 & 0xFFFFFFFFFFFFFFF8) + 16))((uint64_t)v11, v6, v7, v8, v9);
    }
    if ((v10 & 2) == 0)
      llvm::deallocate_buffer(v12[0], v12[1]);
  }
  return result;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::verifyInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::verifyRegionInvariants(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  char v3;
  uint64_t (*v5[2])(uint64_t);
  unint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v5[0] = (uint64_t (*)(uint64_t))mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants;
  v6 = (unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
     + 2;
  v2 = (*(uint64_t (**)(uint64_t (**)(uint64_t), uint64_t))(((unint64_t)llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *>::CallbacksHolder<mlir::LogicalResult (*)(mlir::Operation *),mlir::LogicalResult (* const)(mlir::Operation *),void>::Callbacks
                                                                             + 2) & 0xFFFFFFFFFFFFFFF8))(v5, a2);
  v3 = v6;
  if (v6 >= 8)
  {
    if ((v6 & 4) != 0)
      (*(void (__cdecl **)())((v6 & 0xFFFFFFFFFFFFFFF8) + 16))();
    if ((v3 & 2) == 0)
      llvm::deallocate_buffer((llvm *)v5[0], v5[1]);
  }
  return v2;
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::getInherentAttr(uint64_t a1, uint64_t a2, char *a3, size_t a4)
{
  mlir::MLIRContext *Context;
  _QWORD *v8;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v8 = (_QWORD *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v8 = 0;
  return mlir::mps::LSTMGradientOp::getInherentAttr(Context, v8, a3, a4);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::setInherentAttr(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  char *AttrData;
  size_t v7;
  uint64_t v9;

  v9 = a3;
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v5 = a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64;
  else
    v5 = 0;
  AttrData = (char *)mlir::OpaqueAttr::getAttrData((mlir::OpaqueAttr *)&v9);
  return mlir::mps::LSTMGradientOp::setInherentAttr(v5, AttrData, v7, a4);
}

void mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::populateInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3)
{
  mlir::MLIRContext *Context;
  uint64_t *v6;

  Context = (mlir::MLIRContext *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v6 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v6 = 0;
  mlir::mps::LSTMGradientOp::populateInherentAttrs(Context, v6, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::verifyInherentAttrs(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(uint64_t *__return_ptr, uint64_t), uint64_t a5)
{
  return mlir::mps::LSTMGradientOp::verifyInherentAttrs(a2, a3, a4, a5);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::getOpPropertyByteSize()
{
  return 88;
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::initProperties(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  if (a4)
  {
    v4 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v4;
    v5 = *(_OWORD *)(a4 + 32);
    v6 = *(_OWORD *)(a4 + 48);
    v7 = *(_OWORD *)(a4 + 64);
    *(_QWORD *)(a3 + 80) = *(_QWORD *)(a4 + 80);
    *(_OWORD *)(a3 + 48) = v6;
    *(_OWORD *)(a3 + 64) = v7;
    *(_OWORD *)(a3 + 32) = v5;
  }
  else
  {
    *(_QWORD *)(a3 + 80) = 0;
    *(_OWORD *)(a3 + 48) = 0u;
    *(_OWORD *)(a3 + 64) = 0u;
    *(_OWORD *)(a3 + 16) = 0u;
    *(_OWORD *)(a3 + 32) = 0u;
    *(_OWORD *)a3 = 0u;
  }
  return mlir::mps::LSTMGradientOp::populateDefaultProperties(a2, (mlir::MLIRContext **)a3);
}

mlir::MLIRContext *mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::populateDefaultProperties(uint64_t a1, uint64_t a2, mlir::MLIRContext **a3)
{
  return mlir::mps::LSTMGradientOp::populateDefaultProperties(a2, a3);
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::setPropertiesFromAttr(uint64_t a1, uint64_t a2, uint64_t *a3, uint64_t a4, void (*a5)(uint64_t *__return_ptr, uint64_t), uint64_t a6)
{
  return mlir::mps::LSTMGradientOp::setPropertiesFromAttr(a3, a4, a5, a6);
}

uint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::getPropertiesAsAttr(uint64_t a1, uint64_t a2)
{
  mlir::DictionaryAttr *Context;
  uint64_t *v4;

  Context = (mlir::DictionaryAttr *)mlir::Attribute::getContext((mlir::Attribute *)(a2 + 24));
  if (HIBYTE(*(_DWORD *)(a2 + 44)))
    v4 = (uint64_t *)(a2 + 16 * (((unint64_t)*(unsigned int *)(a2 + 44) >> 23) & 1) + 64);
  else
    v4 = 0;
  return mlir::mps::LSTMGradientOp::getPropertiesAsAttr(Context, v4);
}

__n128 mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::copyProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __int128 v3;
  __n128 result;
  __int128 v5;
  __int128 v6;

  v3 = *(_OWORD *)(a3 + 16);
  *(_OWORD *)a2 = *(_OWORD *)a3;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)(a3 + 32);
  v5 = *(_OWORD *)(a3 + 48);
  v6 = *(_OWORD *)(a3 + 64);
  *(_QWORD *)(a2 + 80) = *(_QWORD *)(a3 + 80);
  *(_OWORD *)(a2 + 48) = v5;
  *(_OWORD *)(a2 + 64) = v6;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

BOOL mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::compareProperties(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  if (*a3 != *a2)
    return 0;
  if (a3[1] != a2[1])
    return 0;
  if (a3[2] != a2[2])
    return 0;
  if (a3[3] != a2[3])
    return 0;
  if (a3[4] != a2[4])
    return 0;
  if (a3[5] != a2[5])
    return 0;
  return a3[6] == a2[6] && a3[7] == a2[7] && a3[8] == a2[8] && a3[9] == a2[9] && a3[10] == a2[10];
}

unint64_t mlir::RegisteredOperationName::Model<mlir::mps::LSTMGradientOp>::hashProperties(uint64_t a1, unint64_t *a2)
{
  return mlir::mps::LSTMGradientOp::computePropertiesHash(a2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  void **p_vtable;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x10uLL);
  *v2 = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::readProperties;
  v2[1] = mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::writeProperties;
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface]";
      v15 = 75;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, (unint64_t)p_vtable[482], v2);
}

uint64_t mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::writeProperties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = a2;
  return mlir::mps::LSTMGradientOp::writeProperties((uint64_t)&v4, a3);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getEffects;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface]";
      v15 = 79;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[159], v2);
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x18uLL);
  *v2 = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::inferReturnTypes;
  v2[1] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::refineReturnTypes;
  v2[2] = mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface]";
      v15 = 76;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[153], v2);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::inferReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::mps::LSTMGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  return mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::LSTMGradientOp>::refineReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11);
}

uint64_t mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

uint64_t mlir::detail::InferTypeOpInterfaceTrait<mlir::mps::LSTMGradientOp>::refineReturnTypes(uint64_t a1, uint64_t a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, __int128 *a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11)
{
  char v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v21[2];
  unint64_t v22[2];
  void *v23;
  uint64_t v24;
  _BYTE v25[32];
  _QWORD v26[3];
  _QWORD *v27;
  _QWORD v28[3];
  _QWORD *v29;
  uint64_t v30;

  v30 = *MEMORY[0x1E0C80C00];
  v23 = v25;
  v24 = 0x400000000;
  if (!mlir::mps::LSTMGradientOp::inferReturnTypes(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, (uint64_t)&v23))
  {
    v16 = 0;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  mlir::ValueRange::ValueRange(v22, (uint64_t)v23, v24);
  mlir::ValueRange::ValueRange(v21, *(_QWORD *)a11, *(unsigned int *)(a11 + 8));
  v26[0] = off_1E0E4FE08;
  v27 = v26;
  v29 = v28;
  v28[0] = off_1E0E4FE08;
  v14 = v29;
  if (v29 == v28)
  {
    v15 = 4;
    v14 = v28;
  }
  else
  {
    if (!v29)
      goto LABEL_9;
    v15 = 5;
  }
  (*(void (**)(void))(*v14 + 8 * v15))();
LABEL_9:
  v18 = v27;
  if (v27 == v26)
  {
    v19 = 4;
    v18 = v26;
  }
  else
  {
    if (!v27)
      goto LABEL_14;
    v19 = 5;
  }
  (*(void (**)(void))(*v18 + 8 * v19))();
LABEL_14:
  if ((v13 & 1) != 0)
  {
    v16 = 1;
    v17 = v23;
    if (v23 == v25)
      return v16;
    goto LABEL_18;
  }
  v28[0] = "mps.lstm_gradient";
  v28[1] = 17;
  v16 = mlir::emitOptionalError<char const(&)[2],llvm::StringLiteral,char const(&)[23],llvm::SmallVector<mlir::Type,4u> &,char const(&)[52],llvm::SmallVectorImpl<mlir::Type> &>(a2, a3, "'", (uint64_t)v28, "' op inferred type(s) ", (uint64_t)&v23, " are incompatible with return type(s) of operation ", a11);
  v17 = v23;
  if (v23 != v25)
LABEL_18:
    free(v17);
  return v16;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(8uLL);
  *v2 = mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::isCompatibleReturnTypes;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface]";
      v15 = 86;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[170], v2);
}

uint64_t mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::isCompatibleReturnTypes(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD v10[3];
  _QWORD *v11;
  _QWORD v12[3];
  _QWORD *v13;
  uint64_t v14;

  v14 = *MEMORY[0x1E0C80C00];
  v10[0] = off_1E0E4FE08;
  v11 = v10;
  v12[0] = off_1E0E4FE08;
  v13 = v12;
  v5 = v13;
  if (v13 == v12)
  {
    v6 = 4;
    v5 = v12;
  }
  else
  {
    if (!v13)
      goto LABEL_6;
    v6 = 5;
  }
  (*(void (**)(void))(*v5 + 8 * v6))();
LABEL_6:
  v7 = v11;
  if (v11 == v10)
  {
    v8 = 4;
    v7 = v10;
    goto LABEL_10;
  }
  if (v11)
  {
    v8 = 5;
LABEL_10:
    (*(void (**)(void))(*v7 + 8 * v8))();
  }
  return v4;
}

void mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>>(uint64_t a1)
{
  _QWORD *v2;
  unsigned __int8 v3;
  uint64_t *v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  const char *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  const char *v14;
  unint64_t v15;

  v2 = malloc(0x20uLL);
  *v2 = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getAsmResultNames;
  v2[1] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getAsmBlockArgumentNames;
  v2[2] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getAsmBlockNames;
  v2[3] = mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getDefaultDialect;
  v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v3 & 1) == 0)
  {
    v13 = v2;
    v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v2 = v13;
    if (v5)
    {
      v14 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface]";
      v15 = 72;
      v6 = llvm::StringRef::find((uint64_t *)&v14, "DesiredTypeName = ", 0x12uLL, 0);
      if (v15 >= v6)
        v7 = v6;
      else
        v7 = v15;
      v8 = &v14[v7];
      v9 = v15 - v7;
      if (v15 - v7 >= 0x12)
        v10 = 18;
      else
        v10 = v15 - v7;
      v11 = v9 - v10;
      if (v11 >= v11 - 1)
        v12 = v11 - 1;
      else
        v12 = v11;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v8[v10], v12);
      v4 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v2 = v13;
    }
  }
  mlir::detail::InterfaceMap::insert(a1, v4[139], v2);
}

uint64_t mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getAsmResultNames(uint64_t a1, uint64_t a2, void (*a3)(uint64_t, uint64_t, const char *, uint64_t), uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  return mlir::mps::LSTMGradientOp::getAsmResultNames(&v5, a3, a4);
}

const char *mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMGradientOp>::getDefaultDialect()
{
  return "";
}

uint64_t llvm::detail::UniqueFunctionBase<mlir::LogicalResult,mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &>::CallImpl<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getFoldHookFn(void)::{lambda(mlir::Operation *,llvm::ArrayRef<mlir::Attribute>,llvm::SmallVectorImpl<mlir::OpFoldResult> &)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::LSTMGradientOp>(a2, a3, a4, a5);
}

uint64_t mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::foldHook<mlir::mps::LSTMGradientOp>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  uint64_t Context;
  uint64_t InterfaceFor;
  uint64_t v18;
  _BYTE v19[8];
  char v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  uint64_t v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30[3];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v8 = *(_QWORD *)(a1 + 56);
  v9 = *(unsigned int *)(a1 + 44);
  if (HIBYTE(*(_DWORD *)(a1 + 44)))
    v10 = a1 + 16 * ((v9 >> 23) & 1) + 64;
  else
    v10 = 0;
  v11 = v9 & 0x7FFFFF;
  if ((v9 & 0x7FFFFF) != 0)
  {
    v12 = ((a1 + 16 * ((v9 >> 23) & 1) + 64 + ((v9 >> 21) & 0x7F8) + 7) & 0xFFFFFFFFFFFFFFF8)
        + 32 * *(unsigned int *)(a1 + 40);
  }
  else
  {
    v12 = 0;
    v11 = 0;
  }
  mlir::ValueRange::ValueRange(v30, v12, v11);
  v13 = *(_OWORD *)(v10 + 48);
  v23 = *(_OWORD *)(v10 + 32);
  v24 = v13;
  v25 = *(_OWORD *)(v10 + 64);
  v14 = *(_OWORD *)(v10 + 16);
  v21 = *(_OWORD *)v10;
  v18 = v8;
  v19[0] = 0;
  v20 = 0;
  v26 = *(_QWORD *)(v10 + 80);
  v22 = v14;
  v27 = *(_OWORD *)v30;
  if (v8)
  {
    Context = mlir::Attribute::getContext((mlir::Attribute *)&v18);
    if (v20)
      v20 = 0;
    mlir::OperationName::OperationName(v19, "mps.lstm_gradient", 17, Context);
    v20 = 1;
  }
  v28 = a2;
  v29 = a3;
  if (!mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1))
  {
    *(_OWORD *)v30 = 0uLL;
    return 0;
  }
  InterfaceFor = mlir::OpInterface<mlir::ExternalFoldInterface,mlir::detail::ExternalFoldInterfaceInterfaceTraits>::getInterfaceFor(a1);
  v30[0] = a1;
  v30[1] = InterfaceFor;
  if (!a1)
    return 0;
  return mlir::RegionBranchOpInterface::getEntrySuccessorRegions(v30, v28, v29, a4);
}

BOOL llvm::detail::UniqueFunctionBase<BOOL,mlir::TypeID>::CallImpl<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getHasTraitFn(void)::{lambda(mlir::TypeID)#1} const>(uint64_t a1, void *a2)
{
  return mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(a2);
}

BOOL mlir::op_definition_impl::hasTrait<mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>(void *a1)
{
  unsigned __int8 v1;
  uint64_t *v2;
  uint64_t v3;
  unsigned __int8 v4;
  _QWORD *v5;
  void *v6;
  unsigned __int8 v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned __int8 v10;
  _QWORD *v11;
  void *v12;
  unsigned __int8 v13;
  __guard *v14;
  __guard v15;
  unsigned __int8 v16;
  uint64_t *v17;
  uint64_t v18;
  unsigned __int8 v19;
  void **p_vtable;
  void *v21;
  unsigned __int8 v22;
  uint64_t *v23;
  uint64_t v24;
  unsigned __int8 v25;
  uint64_t *v26;
  uint64_t v27;
  unsigned __int8 v28;
  uint64_t *v29;
  uint64_t v30;
  unsigned __int8 v31;
  uint64_t *v32;
  int v44;
  int v45;
  unint64_t v46;
  unint64_t v47;
  const char *v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  const char *v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  unint64_t v64;
  unint64_t v65;
  const char *v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  const char *v75;
  unint64_t v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  int v80;
  int v81;
  unint64_t v82;
  unint64_t v83;
  const char *v84;
  unint64_t v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  int v89;
  int v90;
  unint64_t v91;
  unint64_t v92;
  const char *v93;
  unint64_t v94;
  uint64_t v95;
  unint64_t v96;
  uint64_t v97;
  int v98;
  int v99;
  unint64_t v100;
  unint64_t v101;
  const char *v102;
  unint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  int v107;
  int v108;
  unint64_t v109;
  unint64_t v110;
  const char *v111;
  unint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  int v116;
  int v117;
  unint64_t v118;
  unint64_t v119;
  const char *v120;
  unint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  int v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  const char *v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  uint64_t v133;
  int v134;
  int v135;
  unint64_t v136;
  unint64_t v137;
  const char *v138;
  unint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  void *v149;
  void *v150;
  void *v151;
  void *v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  __guard v158;
  __guard v159;
  __guard v160;
  __guard v161;
  __guard v162;
  __guard v163;
  void *v164;
  void *v165;
  void *v166;
  void *v167;
  void *v168;
  void *v169;
  void *v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  void *v179;
  void *v180;
  void *v181;
  void *v182;
  void *v183;
  void *v184;
  void *v185;
  void *v186;
  void *v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  void *v198;
  void *v199;
  void *v200;
  void *v201;
  void *v202;
  void *v203;
  void *v204;
  void *v205;
  void *v206;
  void *v207;
  void *v208;
  const char *v209;
  unint64_t v210;

  v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v1 & 1) == 0)
  {
    v198 = a1;
    v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v45 = v44;
    a1 = v198;
    if (v45)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroRegions<Empty>]";
      v210 = 83;
      v46 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v46)
        v47 = v46;
      else
        v47 = v210;
      v48 = &v209[v47];
      v49 = v210 - v47;
      if (v210 - v47 >= 0x12)
        v50 = 18;
      else
        v50 = v210 - v47;
      v51 = v49 - v50;
      if (v51 >= v51 - 1)
        v52 = v51 - 1;
      else
        v52 = v51;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroRegions<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroRegions>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v48[v50], v52);
      v2 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      a1 = v198;
    }
  }
  v3 = v2[187];
  v5 = &unk_1EDC07000;
  if ((v4 & 1) == 0)
  {
    v188 = v3;
    v199 = a1;
    v5 = (_QWORD *)&unk_1EDC07000;
    v54 = v53;
    v3 = v188;
    a1 = v199;
    if (v54)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNResults<4>::Impl<Empty>]";
      v210 = 96;
      v55 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v55)
        v56 = v55;
      else
        v56 = v210;
      v57 = &v209[v56];
      v58 = v210 - v56;
      if (v210 - v56 >= 0x12)
        v59 = 18;
      else
        v59 = v210 - v56;
      v60 = v58 - v59;
      if (v60 >= v60 - 1)
        v61 = v60 - 1;
      else
        v61 = v60;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNResults<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNResults<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v57[v59], v61);
      v5 = (_QWORD *)&unk_1EDC07000;
      v3 = v188;
      a1 = v199;
    }
  }
  v6 = (void *)v5[510];
  v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v7 & 1) == 0)
  {
    v189 = v3;
    v200 = a1;
    v179 = v6;
    v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v6 = v179;
    v3 = v189;
    v63 = v62;
    a1 = v200;
    if (v63)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::ZeroSuccessors<Empty>]";
      v210 = 86;
      v64 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v64)
        v65 = v64;
      else
        v65 = v210;
      v66 = &v209[v65];
      v67 = v210 - v65;
      if (v210 - v65 >= 0x12)
        v68 = 18;
      else
        v68 = v210 - v65;
      v69 = v67 - v68;
      if (v69 >= v69 - 1)
        v70 = v69 - 1;
      else
        v70 = v69;
      mlir::detail::TypeIDResolver<mlir::OpTrait::ZeroSuccessors<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::ZeroSuccessors>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v66[v68], v70);
      v8 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v6 = v179;
      v3 = v189;
      a1 = v200;
    }
  }
  v9 = v8[196];
  v11 = &unk_1EDC07000;
  if ((v10 & 1) == 0)
  {
    v190 = v3;
    v201 = a1;
    v180 = v6;
    v171 = v9;
    v11 = (_QWORD *)&unk_1EDC07000;
    v9 = v171;
    v6 = v180;
    v3 = v190;
    v72 = v71;
    a1 = v201;
    if (v72)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AtLeastNOperands<4>::Impl<Empty>]";
      v210 = 97;
      v73 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v73)
        v74 = v73;
      else
        v74 = v210;
      v75 = &v209[v74];
      v76 = v210 - v74;
      if (v210 - v74 >= 0x12)
        v77 = 18;
      else
        v77 = v210 - v74;
      v78 = v76 - v77;
      if (v78 >= v78 - 1)
        v79 = v78 - 1;
      else
        v79 = v78;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AtLeastNOperands<4u>::Impl>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v75[v77], v79);
      v11 = (_QWORD *)&unk_1EDC07000;
      v9 = v171;
      v6 = v180;
      v3 = v190;
      a1 = v201;
    }
  }
  v12 = (void *)v11[163];
  if ((v13 & 1) == 0)
  {
    v191 = v3;
    v202 = a1;
    v181 = v6;
    v164 = v12;
    v172 = v9;
    v12 = v164;
    v9 = v172;
    v6 = v181;
    v3 = v191;
    v81 = v80;
    a1 = v202;
    if (v81)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::AttrSizedOperandSegments<Empty>]";
      v210 = 96;
      v82 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v82)
        v83 = v82;
      else
        v83 = v210;
      v84 = &v209[v83];
      v85 = v210 - v83;
      if (v210 - v83 >= 0x12)
        v86 = 18;
      else
        v86 = v210 - v83;
      v87 = v85 - v86;
      if (v87 >= v87 - 1)
        v88 = v87 - 1;
      else
        v88 = v87;
      mlir::detail::TypeIDResolver<mlir::OpTrait::AttrSizedOperandSegments<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::AttrSizedOperandSegments>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v84[v86], v88);
      v12 = v164;
      v9 = v172;
      v6 = v181;
      v3 = v191;
      a1 = v202;
    }
  }
  v15 = v14[423];
  v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v16 & 1) == 0)
  {
    v192 = v3;
    v203 = a1;
    v182 = v6;
    v165 = v12;
    v173 = v9;
    v158 = v15;
    v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v15 = v158;
    v12 = v165;
    v9 = v173;
    v6 = v182;
    v3 = v192;
    v90 = v89;
    a1 = v203;
    if (v90)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpTrait::OpInvariants<Empty>]";
      v210 = 84;
      v91 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v91)
        v92 = v91;
      else
        v92 = v210;
      v93 = &v209[v92];
      v94 = v210 - v92;
      if (v210 - v92 >= 0x12)
        v95 = 18;
      else
        v95 = v210 - v92;
      v96 = v94 - v95;
      if (v96 >= v96 - 1)
        v97 = v96 - 1;
      else
        v97 = v96;
      mlir::detail::TypeIDResolver<mlir::OpTrait::OpInvariants<mlir::TypeID mlir::TypeID::get<mlir::OpTrait::OpInvariants>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v93[v95], v97);
      v17 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v15 = v158;
      v12 = v165;
      v9 = v173;
      v6 = v182;
      v3 = v192;
      a1 = v203;
    }
  }
  v18 = v17[192];
  p_vtable = &OBJC_METACLASS___MPSGraphRankOp.vtable;
  if ((v19 & 1) == 0)
  {
    v193 = v3;
    v204 = a1;
    v183 = v6;
    v166 = v12;
    v174 = v9;
    v153 = v18;
    v159 = v15;
    p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
    v18 = v153;
    v15 = v159;
    v12 = v166;
    v9 = v174;
    v6 = v183;
    v3 = v193;
    v99 = v98;
    a1 = v204;
    if (v99)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::BytecodeOpInterface::Trait<Empty>]";
      v210 = 89;
      v100 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v100)
        v101 = v100;
      else
        v101 = v210;
      v102 = &v209[v101];
      v103 = v210 - v101;
      if (v210 - v101 >= 0x12)
        v104 = 18;
      else
        v104 = v210 - v101;
      v105 = v103 - v104;
      if (v105 >= v105 - 1)
        v106 = v105 - 1;
      else
        v106 = v105;
      mlir::detail::TypeIDResolver<mlir::BytecodeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::BytecodeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v102[v104], v106);
      p_vtable = (void **)(&OBJC_METACLASS___MPSGraphRankOp + 24);
      v18 = v153;
      v15 = v159;
      v12 = v166;
      v9 = v174;
      v6 = v183;
      v3 = v193;
      a1 = v204;
    }
  }
  v21 = p_vtable[481];
  v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v22 & 1) == 0)
  {
    v194 = v3;
    v205 = a1;
    v184 = v6;
    v167 = v12;
    v175 = v9;
    v154 = v18;
    v160 = v15;
    v149 = v21;
    v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v21 = v149;
    v18 = v154;
    v15 = v160;
    v12 = v167;
    v9 = v175;
    v6 = v184;
    v3 = v194;
    v108 = v107;
    a1 = v205;
    if (v108)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::MemoryEffectOpInterface::Trait<Empty>]";
      v210 = 93;
      v109 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v109)
        v110 = v109;
      else
        v110 = v210;
      v111 = &v209[v110];
      v112 = v210 - v110;
      if (v210 - v110 >= 0x12)
        v113 = 18;
      else
        v113 = v210 - v110;
      v114 = v112 - v113;
      if (v114 >= v114 - 1)
        v115 = v114 - 1;
      else
        v115 = v114;
      mlir::detail::TypeIDResolver<mlir::MemoryEffectOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::MemoryEffectOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v111[v113], v115);
      v23 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v21 = v149;
      v18 = v154;
      v15 = v160;
      v12 = v167;
      v9 = v175;
      v6 = v184;
      v3 = v194;
      a1 = v205;
    }
  }
  v24 = v23[158];
  v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v25 & 1) == 0)
  {
    v195 = v3;
    v206 = a1;
    v185 = v6;
    v168 = v12;
    v176 = v9;
    v155 = v18;
    v161 = v15;
    v146 = v24;
    v150 = v21;
    v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v24 = v146;
    v21 = v150;
    v18 = v155;
    v15 = v161;
    v12 = v168;
    v9 = v176;
    v6 = v185;
    v3 = v195;
    v117 = v116;
    a1 = v206;
    if (v117)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::InferTypeOpInterface::Trait<Empty>]";
      v210 = 90;
      v118 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v118)
        v119 = v118;
      else
        v119 = v210;
      v120 = &v209[v119];
      v121 = v210 - v119;
      if (v210 - v119 >= 0x12)
        v122 = 18;
      else
        v122 = v210 - v119;
      v123 = v121 - v122;
      if (v123 >= v123 - 1)
        v124 = v123 - 1;
      else
        v124 = v123;
      mlir::detail::TypeIDResolver<mlir::InferTypeOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::InferTypeOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v120[v122], v124);
      v26 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v24 = v146;
      v21 = v150;
      v18 = v155;
      v15 = v161;
      v12 = v168;
      v9 = v176;
      v6 = v185;
      v3 = v195;
      a1 = v206;
    }
  }
  v27 = v26[152];
  v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v28 & 1) == 0)
  {
    v196 = v3;
    v207 = a1;
    v186 = v6;
    v169 = v12;
    v177 = v9;
    v156 = v18;
    v162 = v15;
    v147 = v24;
    v151 = v21;
    v144 = v27;
    v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v27 = v144;
    v24 = v147;
    v21 = v151;
    v18 = v156;
    v15 = v162;
    v12 = v169;
    v9 = v177;
    v6 = v186;
    v3 = v196;
    v126 = v125;
    a1 = v207;
    if (v126)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::CompatibleReturnTypesInterface::Trait<Empty>]";
      v210 = 100;
      v127 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v127)
        v128 = v127;
      else
        v128 = v210;
      v129 = &v209[v128];
      v130 = v210 - v128;
      if (v210 - v128 >= 0x12)
        v131 = 18;
      else
        v131 = v210 - v128;
      v132 = v130 - v131;
      if (v132 >= v132 - 1)
        v133 = v132 - 1;
      else
        v133 = v132;
      mlir::detail::TypeIDResolver<mlir::CompatibleReturnTypesInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::CompatibleReturnTypesInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v129[v131], v133);
      v29 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v27 = v144;
      v24 = v147;
      v21 = v151;
      v18 = v156;
      v15 = v162;
      v12 = v169;
      v9 = v177;
      v6 = v186;
      v3 = v196;
      a1 = v207;
    }
  }
  v30 = v29[169];
  v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
  if ((v31 & 1) == 0)
  {
    v197 = v3;
    v208 = a1;
    v187 = v6;
    v170 = v12;
    v178 = v9;
    v157 = v18;
    v163 = v15;
    v148 = v24;
    v152 = v21;
    v143 = v30;
    v145 = v27;
    v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
    v30 = v143;
    v27 = v145;
    v24 = v148;
    v21 = v152;
    v18 = v157;
    v15 = v163;
    v12 = v170;
    v9 = v178;
    v6 = v187;
    v3 = v197;
    v135 = v134;
    a1 = v208;
    if (v135)
    {
      v209 = "StringRef llvm::getTypeName() [DesiredTypeName = mlir::OpAsmOpInterface::Trait<Empty>]";
      v210 = 86;
      v136 = llvm::StringRef::find((uint64_t *)&v209, "DesiredTypeName = ", 0x12uLL, 0);
      if (v210 >= v136)
        v137 = v136;
      else
        v137 = v210;
      v138 = &v209[v137];
      v139 = v210 - v137;
      if (v210 - v137 >= 0x12)
        v140 = 18;
      else
        v140 = v210 - v137;
      v141 = v139 - v140;
      if (v141 >= v141 - 1)
        v142 = v141 - 1;
      else
        v142 = v141;
      mlir::detail::TypeIDResolver<mlir::OpAsmOpInterface::Trait<mlir::TypeID mlir::TypeID::get<mlir::OpAsmOpInterface::Trait>(void)::Empty>,void>::resolveTypeID(void)::id = mlir::detail::FallbackTypeIDResolver::registerImplicitTypeID((uint64_t)&v138[v140], v142);
      v32 = &mlir::detail::TypeIDResolver<std::complex<int>,void>::resolveTypeID(void)::id;
      v30 = v143;
      v27 = v145;
      v24 = v148;
      v21 = v152;
      v18 = v157;
      v15 = v163;
      v12 = v170;
      v9 = v178;
      v6 = v187;
      v3 = v197;
      a1 = v208;
    }
  }
  return (void *)v3 == a1
      || v6 == a1
      || v9 == (_QWORD)a1
      || v12 == a1
      || v15 == (_QWORD)a1
      || v18 == (_QWORD)a1
      || v21 == a1
      || v24 == (_QWORD)a1
      || v27 == (_QWORD)a1
      || v30 == (_QWORD)a1
      || v32[138] == (_QWORD)a1;
}

uint64_t llvm::detail::UniqueFunctionBase<void,mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef>::CallImpl<mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::getPrintAssemblyFn(void)::{lambda(mlir::Operation *,mlir::OpAsmPrinter &,llvm::StringRef)#1} const>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  return mlir::OpState::print(a2, a3, a4, a5);
}

BOOL mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyInvariants(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::OpTrait::impl *v4;

  if (!mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AtLeastNResults<4u>::Impl<mlir::mps::LSTMGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::LSTMGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::LSTMGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::LSTMGradientOp>>(a1, a2))return 0;
  v4 = a1;
  return mlir::mps::LSTMGradientOp::verify((uint64_t **)&v4) != 0;
}

BOOL mlir::op_definition_impl::verifyTraits<mlir::OpTrait::ZeroRegions<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AtLeastNResults<4u>::Impl<mlir::mps::LSTMGradientOp>,mlir::OpTrait::ZeroSuccessors<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AtLeastNOperands<4u>::Impl<mlir::mps::LSTMGradientOp>,mlir::OpTrait::AttrSizedOperandSegments<mlir::mps::LSTMGradientOp>,mlir::OpTrait::OpInvariants<mlir::mps::LSTMGradientOp>,mlir::BytecodeOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::MemoryEffectOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::InferTypeOpInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::CompatibleReturnTypesInterface::Trait<mlir::mps::LSTMGradientOp>,mlir::OpAsmOpInterface::Trait<mlir::mps::LSTMGradientOp>>(mlir::OpTrait::impl *a1, mlir::Operation *a2)
{
  mlir::Operation *v3;
  mlir::OpTrait::impl *v5;

  if (!mlir::OpTrait::impl::verifyZeroRegions(a1, a2)
    || !mlir::OpTrait::impl::verifyAtLeastNResults(a1, (mlir::Operation *)4)
    || !mlir::OpTrait::impl::verifyZeroSuccessors(a1, v3)
    || !mlir::OpTrait::impl::verifyAtLeastNOperands(a1, (mlir::Operation *)4)
    || !mlir::OpTrait::impl::verifyOperandSizeAttr((uint64_t)a1, "operandSegmentSizes", 0x13uLL))
  {
    return 0;
  }
  v5 = a1;
  return mlir::mps::LSTMGradientOp::verifyInvariantsImpl((uint64_t **)&v5) != 0;
}

BOOL mlir::Op<mlir::mps::LSTMGradientOp,mlir::OpTrait::ZeroRegions,mlir::OpTrait::AtLeastNResults<4u>::Impl,mlir::OpTrait::ZeroSuccessors,mlir::OpTrait::AtLeastNOperands<4u>::Impl,mlir::OpTrait::AttrSizedOperandSegments,mlir::OpTrait::OpInvariants,mlir::BytecodeOpInterface::Trait,mlir::MemoryEffectOpInterface::Trait,mlir::InferTypeOpInterface::Trait,mlir::CompatibleReturnTypesInterface::Trait,mlir::OpAsmOpInterface::Trait>::verifyRegionInvariants(mlir::detail *a1, mlir::Operation *a2)
{
  return mlir::detail::verifyInferredResultTypes(a1, a2) != 0;
}

_QWORD *mlir::RegisteredOperationName::Model<mlir::mps::LSTMOp>::Model(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;
  uint64_t v5;
  void **v6;
  void *v7;
  void *v9;
  uint64_t v10;
  _QWORD v11[7];

  v11[6] = *MEMORY[0x1E0C80C00];
  v9 = v11;
  v10 = 0x300000000;
  mlir::detail::InterfaceMap::insertModel<mlir::detail::BytecodeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::MemoryEffectOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::DowngraderInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::InferTypeOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::CompatibleReturnTypesInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::detail::InterfaceMap::insertModel<mlir::detail::OpAsmOpInterfaceInterfaceTraits::Model<mlir::mps::LSTMOp>>((uint64_t)&v9);
  mlir::OperationName::Impl::Impl(a1, (uint64_t)"mps.lstm", 8, a2, (uint64_t)&mlir::detail::TypeIDResolver<mlir::mps::LSTMOp,void>::id, (uint64_t)&v9);
  v4 = v9;
  if ((_DWORD)v10)
  {
    v5 = 16 * v10;
    v6 = (void **)((char *)v9 + 8);
    do
    {
      v7 = *v6;
      v6 += 2;
      free(v7);
      v5 -= 16;
    }
    while (v5);
    v4 = v9;
  }
  if (v4 != v11)
    free(v4);
  *a1 = &unk_1E0E36408;
  return a1;
}

