int *resample_byte_h_3cpp_armv7(int *result, unsigned int a2, uint64_t a3, int a4, uint64_t a5, _QWORD *a6, int *a7, int a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int *v13;
  int v14;
  const __int16 *v15;
  uint64_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int32x4_t v19;
  int16x8_t v20;
  unsigned int v21;
  int16x8_t v22;
  int16x8_t v23;
  unint64_t v24;
  int16x4_t v25;
  int16x4_t v26;
  int16x4_t v27;
  int16x4_t v28;
  unsigned int v29;
  int32x4_t v30;
  unsigned int v31;
  int16x4_t v32;
  uint32x4_t v33;
  int8x8x3_t v34;

  if (a8 >= 1)
  {
    v8 = 0;
    v9 = 2 * a2 + 8;
    do
    {
      if (a4)
      {
        v10 = *a6 + *a7 * (uint64_t)(int)v8;
        v11 = *(_QWORD *)(a5 + 8 * v8);
        v12 = a4;
        v13 = result;
        do
        {
          v14 = v13[1];
          v15 = (const __int16 *)(v13 + 2);
          v16 = v10 + 3 * *v13;
          if (v14 < 8)
          {
            v30.i64[0] = 0x200000002000;
            v30.i64[1] = 0x200000002000;
            v22.i8[1] = 0;
            v22.i8[3] = 0;
            v22.i8[5] = 0;
            v22.i16[3] = 0;
          }
          else
          {
            v17 = (int32x4_t)xmmword_185004C30;
            v18 = (int32x4_t)xmmword_185004C30;
            v19 = (int32x4_t)xmmword_185004C30;
            do
            {
              v34 = vld3_s8((const char *)v16);
              v16 += 24;
              v20 = *(int16x8_t *)v15;
              v15 += 8;
              v21 = v14;
              v22 = (int16x8_t)vmovl_u8((uint8x8_t)v34.val[0]);
              v23 = (int16x8_t)vmovl_u8((uint8x8_t)v34.val[1]);
              *(uint16x8_t *)v34.val[0].i8 = vmovl_u8((uint8x8_t)v34.val[2]);
              v17 = vmlal_high_s16(vmlal_s16(v17, *(int16x4_t *)v22.i8, *(int16x4_t *)v20.i8), v22, v20);
              v18 = vmlal_high_s16(vmlal_s16(v18, *(int16x4_t *)v23.i8, *(int16x4_t *)v20.i8), v23, v20);
              v19 = vmlal_high_s16(vmlal_s16(v19, (int16x4_t)v34.val[0], *(int16x4_t *)v20.i8), *(int16x8_t *)v34.val[0].i8, v20);
              v14 -= 8;
            }
            while (v21 > 0xF);
            if (v21 >= 0xC)
            {
              v24 = vextq_s8((int8x16_t)v22, (int8x16_t)v22, 8uLL).u64[0];
              do
              {
                v25 = *(int16x4_t *)v15;
                v15 += 4;
                v26 = *(int16x4_t *)v22.i8;
                v27 = (int16x4_t)v24;
                v28 = *(int16x4_t *)v23.i8;
                v26.i8[0] = *(_BYTE *)v16;
                v27.i8[0] = *(_BYTE *)(v16 + 1);
                v28.i8[0] = *(_BYTE *)(v16 + 2);
                v26.i8[2] = *(_BYTE *)(v16 + 3);
                v27.i8[2] = *(_BYTE *)(v16 + 4);
                v28.i8[2] = *(_BYTE *)(v16 + 5);
                v26.i8[4] = *(_BYTE *)(v16 + 6);
                v27.i8[4] = *(_BYTE *)(v16 + 7);
                v28.i8[4] = *(_BYTE *)(v16 + 8);
                v29 = v14;
                v26.i8[6] = *(_BYTE *)(v16 + 9);
                v27.i8[6] = *(_BYTE *)(v16 + 10);
                v28.i8[6] = *(_BYTE *)(v16 + 11);
                v16 += 12;
                v17 = vmlal_s16(v17, v26, v25);
                v18 = vmlal_s16(v18, v27, v25);
                v19 = vmlal_s16(v19, v28, v25);
                v14 -= 4;
              }
              while (v29 > 7);
            }
            *(int32x2_t *)v30.i8 = vpadd_s32(vadd_s32(*(int32x2_t *)v17.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v17, (int8x16_t)v17, 8uLL)), vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL)));
            v30.i64[1] = vpaddl_s32((int32x2_t)*(_OWORD *)&vpaddq_s32(v19, v19));
          }
          if (v14 >= 1)
          {
            v31 = v14 + 1;
            do
            {
              v22.i8[0] = *(_BYTE *)v16;
              v22.i8[2] = *(_BYTE *)(v16 + 1);
              v22.i8[4] = *(_BYTE *)(v16 + 2);
              v32 = vld1_dup_s16(v15++);
              v30 = vmlal_s16(v30, *(int16x4_t *)v22.i8, v32);
              --v31;
              v16 += 3;
            }
            while (v31 > 1);
          }
          v33 = vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(vqmovn_u16((uint16x8_t)vqshrun_high_n_s32(vqshrun_n_s32(v30, 0xEuLL), v30, 0xEuLL))));
          *(_QWORD *)v11 = v33.i64[0];
          *(_DWORD *)(v11 + 8) = v33.i32[2];
          v11 += 12;
          v13 = (int *)((char *)v13 + v9);
          --v12;
        }
        while (v12);
      }
      ++v8;
    }
    while (v8 != a8);
  }
  return result;
}

uint64_t type4_lexer_scan(_QWORD **a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  int v18;
  int v19;
  int v20;
  char v21;
  char v22;
  _QWORD *v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  double v29;
  char v31;
  _QWORD *v32;
  _QWORD *v33;
  _QWORD *v34;
  size_t v35;
  const char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  const char *v40;
  uint64_t v41;
  double *v42;
  char *v43;

  a1[2] = 0;
LABEL_2:
  while (2)
  {
    v10 = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
    v11 = v10;
    if ((int)v10 > 90)
    {
      if ((int)v10 <= 122)
      {
        if ((_DWORD)v10 != 91 && (_DWORD)v10 != 93)
          goto LABEL_60;
LABEL_18:
        return 0xFFFFFFFFLL;
      }
      if ((_DWORD)v10 == 123 || (_DWORD)v10 == 125)
        return v11;
LABEL_60:
      while (1)
      {
        v31 = v11 + 1;
        if ((v11 + 1) <= 0x3F)
        {
          if (((1 << v31) & 0x200006C03) != 0)
            goto LABEL_71;
          if (((1 << v31) & 0xA001064000000000) != 0)
            break;
        }
        if ((v11 - 91) <= 0x22 && ((1 << (v11 - 91)) & 0x500000005) != 0)
          break;
        v32 = a1[2];
        v33 = a1[3];
        if (v32 >= v33)
        {
          a1[3] = (_QWORD *)(2 * (_QWORD)v33 + 64);
          v34 = malloc_type_realloc(a1[1], 2 * (_QWORD)v33 + 68, 0x768CAC5CuLL);
          a1[1] = v34;
          v32 = a1[2];
        }
        else
        {
          v34 = a1[1];
        }
        a1[2] = (_QWORD *)((char *)v32 + 1);
        *((_BYTE *)v32 + (_QWORD)v34) = v11;
        LODWORD(v11) = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
      }
      CGPDFSourceUngetc(*a1, v11);
LABEL_71:
      *((_BYTE *)a1[2] + (_QWORD)a1[1]) = 0;
      v35 = (size_t)a1[2];
      if (v35 == 5)
      {
        v36 = (const char *)a1[1];
        if (!strcmp(v36, "false"))
        {
          v11 = 256;
          *(_DWORD *)a2 = 256;
          *(_BYTE *)(a2 + 8) = 0;
          return v11;
        }
      }
      else if (v35 == 4)
      {
        v36 = (const char *)a1[1];
        if (!strcmp(v36, "true"))
        {
          v11 = 256;
          *(_DWORD *)a2 = 256;
          *(_BYTE *)(a2 + 8) = 1;
          return v11;
        }
      }
      else
      {
        v36 = (const char *)a1[1];
        if (!v35)
          v35 = strlen(v36);
        if (v35 > 0xFFFFFFFE || (v35 - 2) > 6)
        {
LABEL_88:
          return 0xFFFFFFFFLL;
        }
        if ((_DWORD)v35 == 2)
        {
          v37 = 2;
          goto LABEL_77;
        }
      }
      v37 = v35 + hash_asso_values[*((unsigned __int8 *)v36 + 2)];
LABEL_77:
      v38 = *(unsigned __int8 *)v36;
      v39 = v37 + hash_asso_values[*((unsigned __int8 *)v36 + 1)] + hash_asso_values[v38];
      if (v39 <= 0x2F)
      {
        v40 = (const char *)*((_QWORD *)&wordlist
                            + 2 * v37
                            + 2 * hash_asso_values[*((unsigned __int8 *)v36 + 1)]
                            + 2 * hash_asso_values[v38]);
        if ((_DWORD)v38 == *(unsigned __int8 *)v40
          && !strcmp(v36 + 1, v40 + 1)
          && ((0x165000004003uLL >> v39) & 1) == 0)
        {
          v41 = *((_QWORD *)&wordlist + 2 * v39 + 1);
          v11 = 260;
          *(_DWORD *)a2 = 260;
          *(_QWORD *)(a2 + 8) = v41;
          return v11;
        }
      }
      goto LABEL_88;
    }
    switch((int)v10)
    {
      case -1:
        return v11;
      case 0:
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
        continue;
      case 37:
        while (1)
        {
          v12 = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
          if (v12 == -1 || v12 == 10)
            goto LABEL_2;
          if (v12 == 13)
          {
            v14 = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
            if (v14 != 10)
              CGPDFSourceUngetc(*a1, v14);
            goto LABEL_2;
          }
        }
      case 40:
      case 41:
      case 47:
      case 60:
      case 62:
        goto LABEL_18;
      case 43:
      case 45:
      case 46:
      case 48:
      case 49:
      case 50:
      case 51:
      case 52:
      case 53:
      case 54:
      case 55:
      case 56:
      case 57:
        v42 = (double *)a2;
        v43 = 0;
        if ((_DWORD)v10 == 45 || (_DWORD)v10 == 43)
        {
          v15 = a1[2];
          v16 = a1[3];
          if (v15 >= v16)
          {
            a1[3] = (_QWORD *)(2 * (_QWORD)v16 + 64);
            v17 = malloc_type_realloc(a1[1], 2 * (_QWORD)v16 + 68, 0x768CAC5CuLL);
            a1[1] = v17;
            v15 = a1[2];
          }
          else
          {
            v17 = a1[1];
          }
          a1[2] = (_QWORD *)((char *)v15 + 1);
          *((_BYTE *)v15 + (_QWORD)v17) = v11;
          v18 = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
        }
        else
        {
          v18 = v10;
          LODWORD(v11) = 43;
        }
        v19 = 0;
        v20 = 0;
        v21 = 0;
        v22 = 1;
        while (2)
        {
          if ((v18 - 48) < 0xA)
          {
            v20 = v18 + 10 * v20 - 48;
            ++v19;
LABEL_25:
            v23 = a1[2];
            v24 = a1[3];
            if (v23 >= v24)
            {
              a1[3] = (_QWORD *)(2 * (_QWORD)v24 + 64);
              v25 = malloc_type_realloc(a1[1], 2 * (_QWORD)v24 + 68, 0x768CAC5CuLL);
              a1[1] = v25;
              v23 = a1[2];
            }
            else
            {
              v25 = a1[1];
            }
            a1[2] = (_QWORD *)((char *)v23 + 1);
            *((_BYTE *)v23 + (_QWORD)v25) = v18;
            v18 = CGPDFSourceGetc((uint64_t)*a1, a2, a3, a4, a5, a6, a7, a8);
            continue;
          }
          break;
        }
        v26 = (v18 + 1);
        if (v26 > 0x3F)
          goto LABEL_34;
        if (v26 == 47)
        {
          v21 = v22;
LABEL_37:
          v22 = 0;
          goto LABEL_25;
        }
        if (((1 << (v18 + 1)) & 0x200006C03) == 0)
        {
          if (((1 << (v18 + 1)) & 0xA001064000000000) == 0)
          {
LABEL_34:
            if ((v18 - 91) > 0x22 || ((1 << (v18 - 91)) & 0x500000005) == 0)
            {
              v21 = 0;
              goto LABEL_37;
            }
          }
          CGPDFSourceUngetc(*a1, v18);
        }
        *((_BYTE *)a1[2] + (_QWORD)a1[1]) = 0;
        if ((v22 & (v19 > 0)) != 1)
          goto LABEL_51;
        if (v19 > 9)
        {
          *__error() = 0;
          v28 = strtol_l((const char *)a1[1], &v43, 10, 0);
          if (v43 == (char *)a1[1] || *v43)
            goto LABEL_55;
          v21 = 1;
          if (*__error() != 34 && v28 >= (uint64_t)0xFFFFFFFF80000000 && v28 <= 0x7FFFFFFF)
          {
            v11 = 257;
            *(_DWORD *)v42 = 257;
            *((_DWORD *)v42 + 2) = v28;
            return v11;
          }
LABEL_51:
          if ((v21 & 1) == 0
            || v19 < 1
            || (v29 = strtod_l((const char *)a1[1], &v43, 0), v43 == (char *)a1[1])
            || *v43)
          {
LABEL_55:
            return 0xFFFFFFFFLL;
          }
          v11 = 258;
          *(_DWORD *)v42 = 258;
          v42[1] = v29;
        }
        else
        {
          if ((_DWORD)v11 == 45)
            v27 = -v20;
          else
            v27 = v20;
          v11 = 257;
          *(_DWORD *)v42 = 257;
          *((_DWORD *)v42 + 2) = v27;
        }
        break;
      default:
        goto LABEL_60;
    }
    return v11;
  }
}

uint64_t CG::DisplayListRecorder::BeginPage(CFArrayRef *a1, uint64_t a2, uint64_t a3, uint64_t a4, const void *a5)
{
  return CG::DisplayListRecorder::recordAction(a1, 3, 0, a5);
}

uint64_t CG::DisplayListRecorder::EndPage(CFArrayRef *a1)
{
  return CG::DisplayListRecorder::recordAction(a1, 4, 0, 0);
}

void dlRecorder_DrawLines(uint64_t a1, uint64_t a2, uint64_t a3, const CGPoint *a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef *v8;
  int64x2_t *v13;
  int64x2_t *v14;
  BOOL v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double x;
  double y;
  unint64_t v22;
  double *p_y;
  double v24;
  double v25;
  double v26;
  __int128 v27;
  CGFloat v28;
  CGFloat v29;
  CGFloat v30;
  double v31;
  double v32;
  double v33;
  double v34;
  BOOL v35;
  _QWORD *EntryDrawingState;
  uint64_t v37;
  _QWORD *v38;
  int v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  uint64_t StrokeColor;
  uint64_t v44;
  uint64_t v45;
  int v46;
  int v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t EntryFillState;
  uint64_t EntryStrokeState;
  uint64_t v53;
  uint64_t v54;
  int v55;
  const CGRect *v56;
  CGSize size;
  __int128 v58;
  __int128 v59;
  uint64_t EntryPatternState;
  CGAffineTransform v61;
  CGRect v62;

  if (a1 && (v8 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    v13 = (int64x2_t *)CG::DisplayListRecorder::currentDisplayList(v8);
    if (v13)
    {
      v14 = v13;
      v15 = *(double *)&v13[2].i64[1] == INFINITY || *(double *)v13[3].i64 == INFINITY;
      if (!v15 && *(double *)&v13[3].i64[1] != 0.0 && *(double *)v13[4].i64 != 0.0)
      {
        if (!v13[4].i8[9])
          goto LABEL_37;
        v16 = 0.0;
        v17 = 0.0;
        v18 = 0.0;
        v19 = 0.0;
        if (a4 && a5)
        {
          x = a4->x;
          y = a4->y;
          if (a5 >= 2)
          {
            v22 = a5 - 1;
            p_y = &a4[1].y;
            v17 = a4->x;
            v16 = a4->y;
            while (1)
            {
              v25 = *(p_y - 1);
              v24 = *p_y;
              v26 = v25 > x ? *(p_y - 1) : x;
              if (v25 >= v17)
                x = v26;
              else
                v17 = *(p_y - 1);
              if (v24 < v16)
                break;
              if (v24 <= y)
                goto LABEL_24;
LABEL_25:
              p_y += 2;
              y = v24;
              if (!--v22)
                goto LABEL_30;
            }
            v16 = *p_y;
LABEL_24:
            v24 = y;
            goto LABEL_25;
          }
          v16 = a4->y;
          v17 = a4->x;
          v24 = v16;
LABEL_30:
          v18 = x - v17;
          v19 = v24 - v16;
        }
        v27 = *(_OWORD *)(a3 + 40);
        *(_OWORD *)&v61.a = *(_OWORD *)(a3 + 24);
        *(_OWORD *)&v61.c = v27;
        *(_OWORD *)&v61.tx = *(_OWORD *)(a3 + 56);
        v62 = CGRectApplyAffineTransform(*(CGRect *)&v17, &v61);
        v62.origin.x = CG::DisplayListRecorder::adjustBoundingBoxToIncludeStroke(&v62, a3);
        v62.origin.y = v28;
        v62.size.width = v29;
        v62.size.height = v30;
        CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(&v62.origin.x, a2, *(double **)(a3 + 112), *(_QWORD *)(*(_QWORD *)(a3 + 120) + 16));
        v62.origin.x = v34;
        v62.origin.y = v31;
        v62.size.width = v32;
        v62.size.height = v33;
        v35 = v34 == INFINITY || v31 == INFINITY;
        if (!v35 && v32 != 0.0 && v33 != 0.0)
        {
LABEL_37:
          EntryDrawingState = (_QWORD *)CG::DisplayList::getEntryDrawingState(v14[1].i64, a3, a2);
          v37 = EntryDrawingState[1];
          if (v37)
          {
            v38 = EntryDrawingState;
            v39 = *(_DWORD *)(v37 + 8);
            v40 = EntryDrawingState[2];
            if (v40)
              v39 |= *(_DWORD *)(v40 + 8);
            v41 = v39 & 0x1000;
            v42 = EntryDrawingState[3];
            if (v42)
              v41 |= *(_DWORD *)(v42 + 8) & 0x3400;
            StrokeColor = CGGStateGetStrokeColor(a3);
            v44 = (*(uint64_t (**)(int64x2_t *, uint64_t))(v14[1].i64[0] + 8))(v14 + 1, StrokeColor);
            v45 = v44;
            if (v44)
              v46 = *(_DWORD *)(v44 + 8) & 0x3400 | 0x200;
            else
              v46 = 512;
            v47 = v46 | v41;
            v48 = *(_QWORD *)(a3 + 120);
            v49 = v46 | v41 | 0x1000;
            if (*(double *)(v48 + 8) >= 1.0)
              v50 = v47;
            else
              v50 = v49;
            if ((v50 & 0x1000) == 0 && (((int)(*(_DWORD *)(v48 + 4) << 16) >> 24) - 3) < 0xFFFFFFFE)
              v50 = v49;
            if ((v50 & 0x3000) != 0)
              v14[5].i32[0] |= v50 & 0x3000;
            if (v14[4].i8[10])
            {
              if ((v50 & 0x400) != 0)
                EntryPatternState = CG::DisplayList::getEntryPatternState((int64x2_t *)v14[1].i64, a3, a2);
              else
                EntryPatternState = 0;
              if ((v50 & 0x100) != 0)
                EntryFillState = CG::DisplayList::getEntryFillState((CG::DisplayList *)&v14[1], 0);
              else
                EntryFillState = 0;
              if ((v50 & 0x200) != 0)
                EntryStrokeState = CG::DisplayList::getEntryStrokeState((int64x2_t *)v14[1].i64, a3, v45);
              else
                EntryStrokeState = 0;
              v53 = operator new();
              v54 = v53;
              v55 = v14[4].u8[9];
              *(_DWORD *)(v53 + 8) = (v50 << 8) | 4;
              v15 = v55 == 0;
              v56 = &v62;
              if (v15)
                v56 = &CGRectInfinite;
              size = v56->size;
              *(CGPoint *)(v53 + 16) = v56->origin;
              *(CGSize *)(v53 + 32) = size;
              *(_QWORD *)(v53 + 48) = v38;
              *(_QWORD *)(v53 + 56) = EntryFillState;
              *(_QWORD *)(v53 + 64) = EntryStrokeState;
              *(_QWORD *)(v53 + 72) = EntryPatternState;
              *(_QWORD *)v53 = &off_1E16290C0;
              v58 = *(_OWORD *)(a3 + 56);
              v59 = *(_OWORD *)(a3 + 24);
              *(_OWORD *)(v53 + 96) = *(_OWORD *)(a3 + 40);
              *(_OWORD *)(v53 + 112) = v58;
              *(_OWORD *)(v53 + 80) = v59;
              *(_QWORD *)(v53 + 128) = 0;
              *(_QWORD *)(v53 + 136) = a5;
              CG::DisplayListEntryLines::setPoints((CG::DisplayListEntryLines *)v53, a4, a5);
              CG::DisplayList::appendEntry(v14 + 1, v54);
            }
          }
        }
      }
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawLines");
  }
}

void sub_184B84120(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x186DC23C4](v1, 0x10E1C40AEE7E256);
  _Unwind_Resume(a1);
}

uint64_t dlRecorder_DrawRadialGradient(uint64_t a1, uint64_t a2, uint64_t a3, CGGradient *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12, double a13, double a14)
{
  CFArrayRef *v14;
  int v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;

  if (a1 && (v14 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    v16 = 1;
    v17 = a9;
    v18 = a10;
    v19 = a11;
    v20 = a12;
    v21 = a13;
    v22 = a14;
    return CG::DisplayListRecorder::DrawGradient(v14, a2, a3, a4, a5, &v16);
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawRadialGradient");
    return 1000;
  }
}

uint64_t dlRecorder_DrawConicGradient(uint64_t a1, uint64_t a2, uint64_t a3, CGGradient *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11)
{
  CFArrayRef *v11;
  int v13;
  double v14;
  double v15;
  double v16;

  if (a1 && (v11 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    v13 = 2;
    v14 = a9;
    v15 = a10;
    v16 = a11;
    return CG::DisplayListRecorder::DrawGradient(v11, a2, a3, a4, 0, &v13);
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_DrawConicGradient");
    return 1000;
  }
}

uint64_t dlRecorder_DrawDisplayList(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef *v8;

  if (a1)
  {
    v8 = *(CFArrayRef **)(a1 + 288);
    if (v8)
      return CG::DisplayListRecorder::DrawDisplayList(v8, a2, a3, a4);
  }
  CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_DrawDisplayList");
  return 1000;
}

uint64_t dlRecorder_BeginPage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1)
  {
    a5 = a4;
    a4 = a3;
    a3 = a2;
    a2 = a1;
    v8 = *(_QWORD *)(a1 + 288);
    if (v8)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 24))(v8, a2, a3, a4, a5);
  }
  CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_BeginPage");
  return 1000;
}

uint64_t dlRecorder_EndPage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (a1)
  {
    a4 = a3;
    a3 = a2;
    a2 = a1;
    v8 = *(_QWORD *)(a1 + 288);
    if (v8)
      return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 32))(v8, a2, a3, a4);
  }
  CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_EndPage");
  return 1000;
}

uint64_t dlRecorder_GetLayer(uint64_t a1, uint64_t a2, uint64_t a3, const __CFDictionary *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, double a9, double a10, double a11, double a12)
{
  CFArrayRef *v12;
  const void *v18;
  __CFDictionary *v19;
  const CGRect *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const void *CGDisplayList;
  uint64_t ContextDelegate;
  _QWORD v29[4];

  if (a1 && (v12 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    v18 = CG::DisplayListRecorder::currentDisplayList(v12);
    if (v18)
    {
      v19 = CG::DisplayListRecorder::initializeGroupInfoDictionary((uint64_t)v18, a4);
      *(double *)v29 = a9;
      *(double *)&v29[1] = a10;
      *(double *)&v29[2] = a11;
      *(double *)&v29[3] = a12;
      CGDisplayList = (const void *)CG::DisplayList::createCGDisplayList(v19, (const __CFDictionary *)v29, v20, v21, v22, v23, v24, v25);
      if (v19)
        CFRelease(v19);
      if (CGDisplayList)
      {
        ContextDelegate = CG::DisplayList::createContextDelegate(CGDisplayList);
        CFRelease(CGDisplayList);
        return ContextDelegate;
      }
    }
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, (uint64_t)a4, a5, a6, a7, a8, (char)"dlRecorder_GetLayer");
  }
  return 0;
}

CGImageRef dlRecorder_CreateImage(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CFArrayRef *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a1 && (v8 = *(CFArrayRef **)(a1 + 288)) != 0)
  {
    v9 = (char *)CG::DisplayListRecorder::currentDisplayList(v8);
    if (v9)
      return CG::DisplayList::createImage((CG::DisplayList *)(v9 + 16));
    CGPostError((uint64_t)"%s: recorder->currentDisplayList() returned NULL", v10, v11, v12, v13, v14, v15, v16, (char)"dlRecorder_CreateImage");
  }
  else
  {
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_CreateImage");
  }
  return 0;
}

CGFloat dlRecorder_GetTransform@<D0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X4>, uint64_t a6@<X5>, uint64_t a7@<X6>, uint64_t a8@<X7>, CGAffineTransform *a9@<X8>)
{
  if (!a1 || !*(_QWORD *)(a1 + 288))
    CGPostError((uint64_t)"%s: CGContextDelegateGetInfo() returned NULL", a2, a3, a4, a5, a6, a7, a8, (char)"dlRecorder_GetTransform");
  *a9 = CGAffineTransformIdentity;
  return CGAffineTransformIdentity.tx;
}

uint64_t dlRecorder_DrawImageApplyingToneMapping(uint64_t a1, uint64_t a2, uint64_t a3, void *a4, uint64_t a5, void *a6, uint64_t a7, uint64_t a8, double a9, CGFloat a10, double a11, double a12)
{
  CFDictionaryRef v20;
  CFDictionaryRef v21;
  CGImage *Copy;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v20 = CGCreatePayloadForToneMapping(a5, a6, a3, (uint64_t)a4, a5, (uint64_t)a6, a7, a8);
  if (!v20)
    return 1000;
  v21 = v20;
  if (a4)
    CFRetain(a4);
  Copy = CGImageCreateCopy((CGImageRef)a4);
  if ((CGImageSetColorConversionInfoPayload((uint64_t)Copy, v21) & 1) != 0)
  {
    if (a4)
      CFRelease(a4);
    v27 = dlRecorder_DrawImage(a1, a2, a3, Copy, v23, v24, v25, v26, a9, a10, a11, a12);
    if (!Copy)
      return v27;
LABEL_13:
    CFRelease(Copy);
    return v27;
  }
  if (Copy)
    CFRelease(Copy);
  v27 = 1000;
  Copy = (CGImage *)a4;
  if (a4)
    goto LABEL_13;
  return v27;
}

void ___ZN2CG19DisplayListRecorder29initializeGroupInfoDictionaryEP13CGDisplayListPK14__CFDictionary_block_invoke(uint64_t a1, const void *a2, const void *a3)
{
  CFDictionarySetValue(*(CFMutableDictionaryRef *)(a1 + 32), a2, a3);
}

void CG::DisplayListRecorder::intersectRectWithClipConsideringStyle(double *a1, uint64_t a2, double *a3, uint64_t a4)
{
  double Bounds;
  CGFloat v8;
  CGFloat v9;
  CGFloat v10;
  __int128 v11;
  double DrawBoundingBoxWithMatrix;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  __int128 v23;
  double v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _OWORD v31[3];
  _OWORD v32[3];

  if (!a3)
  {
    v8 = -8.98846567e307;
    v9 = 1.79769313e308;
    Bounds = -8.98846567e307;
    v10 = 1.79769313e308;
    if (a4)
      goto LABEL_3;
LABEL_5:
    v24 = *a1;
    v26 = *((_QWORD *)a1 + 1);
    v28 = *((_QWORD *)a1 + 2);
    v30 = *((_QWORD *)a1 + 3);
    goto LABEL_6;
  }
  Bounds = CGClipStackGetBounds(a3);
  if (!a4)
    goto LABEL_5;
LABEL_3:
  v11 = *(_OWORD *)(a2 + 40);
  v32[0] = *(_OWORD *)(a2 + 24);
  v32[1] = v11;
  v32[2] = *(_OWORD *)(a2 + 56);
  DrawBoundingBoxWithMatrix = CGStyleGetDrawBoundingBoxWithMatrix(a4, v32, Bounds, v8, v9, v10);
  v14 = v13;
  v16 = v15;
  v18 = v17;
  v19 = *a1;
  v20 = a1[1];
  v21 = a1[2];
  v22 = a1[3];
  v23 = *(_OWORD *)(a2 + 40);
  v31[0] = *(_OWORD *)(a2 + 24);
  v31[1] = v23;
  v31[2] = *(_OWORD *)(a2 + 56);
  v24 = CGStyleGetDrawBoundingBoxWithMatrix(a4, v31, v19, v20, v21, v22);
  v26 = v25;
  v28 = v27;
  v30 = v29;
  Bounds = DrawBoundingBoxWithMatrix;
  v8 = v14;
  v9 = v16;
  v10 = v18;
LABEL_6:
  CGRectIntersection(*(CGRect *)&Bounds, *(CGRect *)&v24);
}

const void **applesauce::CF::ObjectRef<CGImage *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **applesauce::CF::ObjectRef<CGDataProvider *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

const void **applesauce::CF::ObjectRef<__CFData const*>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

BOOL CGImageSetHeadroom(uint64_t *image, int a2, float a3)
{
  uint64_t v7;
  CGColorSpaceRef ColorSpace;
  _QWORD *v9;
  uint64_t v10;
  float v11;
  uint64_t v13;
  CFNumberRef v14;
  CFNumberRef v15;
  const __CFString *v16;
  float valuePtr;

  if (a3 < 1.0 && (a3 != 0.0 || a2 != 0))
    return 0;
  ColorSpace = CGImageGetColorSpace((CGImageRef)image);
  if (!ColorSpace)
    return 1;
  v9 = ColorSpace;
  v10 = *((_QWORD *)ColorSpace + 3);
  if (*(_DWORD *)(v10 + 24) != 1)
    return 1;
  if (*(_BYTE *)(v10 + 16) || *(_BYTE *)(v10 + 17) || *(_BYTE *)(v10 + 13))
  {
    if (CGColorSpaceContainsFlexGTCInfo((_BOOL8)ColorSpace))
    {
      v11 = vabds_f32(CGColorSpaceGetHeadroomInfo(v9, 0), a3);
      return v11 <= 0.00001;
    }
    if (a2 == 1)
    {
      v13 = image[26];
      if (v13)
      {
        v14 = 0;
LABEL_28:
        CGImageProviderSetContentHeadroom(v13, a3);
LABEL_29:
        v7 = 1;
        if (!v14)
          return v7;
LABEL_30:
        CFRelease(v14);
        return v7;
      }
    }
    valuePtr = a3;
    v15 = CFNumberCreate(0, kCFNumberFloatType, &valuePtr);
    v14 = v15;
    if (a2)
    {
      if (a2 != 2)
      {
        if (a2 != 1)
        {
          v7 = 0;
          if (!v15)
            return v7;
          goto LABEL_30;
        }
        v13 = image[26];
        if (!v13)
        {
          set_content_headroom_to_conversion_info((uint64_t)image, CFSTR("kCGImageHeadroom"), v14);
          goto LABEL_29;
        }
        goto LABEL_28;
      }
      v16 = CFSTR("kCGImageEstimatedHeadroom");
    }
    else
    {
      v16 = CFSTR("kCGImageUnknownHeadroom");
    }
    set_content_headroom_to_conversion_info((uint64_t)image, v16, v15);
    v13 = image[26];
    if (!v13)
      goto LABEL_29;
    goto LABEL_28;
  }
  v11 = fabsf(a3 + -1.0);
  return v11 <= 0.00001;
}

void set_content_headroom_to_conversion_info(uint64_t a1, const void *a2, const void *a3)
{
  pthread_mutex_t *v6;
  unint64_t *v7;
  uint64_t v8;
  _DWORD *v9;

  v6 = (pthread_mutex_t *)(a1 + 80);
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
  v8 = *(_QWORD *)(a1 + 224);
  v7 = (unint64_t *)(a1 + 224);
  if (!v8)
  {
    v9 = CGPropertiesCreate();
    while (!__ldxr(v7))
    {
      if (!__stxr((unint64_t)v9, v7))
        goto LABEL_7;
    }
    __clrex();
    CGPropertiesRelease((uint64_t)v9);
  }
LABEL_7:
  pthread_mutex_unlock(v6);
  CGPropertiesSetProperty(*v7, a2, a3);
}

__CFString *image_copy_format_description(uint64_t a1)
{
  const __CFAllocator *v2;
  __CFString *Mutable;
  uint64_t v4;
  const void *Property;
  const char *v6;
  uint64_t v7;
  const void *v8;
  const void *v9;
  CFTypeID v10;
  uint64_t v11;
  const void *v12;
  const void *v13;
  CFTypeID v14;
  CGColorSpaceRef ColorSpace;
  CFStringRef v16;
  float HeadroomInfo;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  CGBitmapInfo BitmapInfo;
  size_t v25;
  unsigned int v26;
  const char *v27;
  size_t v28;
  unsigned int v29;
  const char *v30;
  size_t v31;
  int v32;
  const char *v33;
  const char *v34;
  const char *v35;
  const char *v36;
  const char *v37;
  int v39;
  char __s[256];
  uint64_t v41;

  v41 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator((CFTypeRef)a1);
  Mutable = CFStringCreateMutable(v2, 0);
  v4 = *(_QWORD *)(a1 + 208);
  if (!v4)
    goto LABEL_5;
  Property = *(const void **)(v4 + 120);
  if (Property)
    Property = CGPropertiesGetProperty((uint64_t)Property, CFSTR("kCGImageWrappingIOSurface"));
  if (Property == (const void *)*MEMORY[0x1E0C9AE50])
    v6 = "(IP-S)";
  else
LABEL_5:
    v6 = "(IP)";
  if (!*(_QWORD *)(a1 + 208))
    v6 = "(DP)";
  CFStringAppendFormat(Mutable, 0, CFSTR("<CGImage %p> %s"), a1, v6);
  v7 = *(_QWORD *)(a1 + 216);
  if (v7)
  {
    v8 = CGPropertiesGetProperty(v7, CFSTR("kCGImageFileFormat"));
    if (v8)
    {
      v9 = v8;
      v10 = CFGetTypeID(v8);
      if (v10 == CFStringGetTypeID())
        CFStringAppendFormat(Mutable, 0, CFSTR(" <%@>"), v9);
    }
    v11 = *(_QWORD *)(a1 + 216);
    if (v11)
    {
      v12 = CGPropertiesGetProperty(v11, CFSTR("kCGImageHDRFileFormat"));
      if (v12)
      {
        v13 = v12;
        v14 = CFGetTypeID(v12);
        if (v14 == CFStringGetTypeID())
          CFStringAppendFormat(Mutable, 0, CFSTR(" <%@>"), v13);
      }
    }
  }
  ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  v16 = CFCopyDescription(ColorSpace);
  CFStringAppendFormat(Mutable, 0, CFSTR("\n\t<%@>"), v16);
  if (v16)
    CFRelease(v16);
  v39 = 0;
  HeadroomInfo = CGImageGetHeadroomInfo((CGImage *)a1, &v39);
  if (v39 && HeadroomInfo != 0.0)
  {
    if (v39 == 2)
      v18 = " (estimated)";
    else
      v18 = " ";
    CFStringAppendFormat(Mutable, 0, CFSTR("\n\t\theadroom = %f %s"), HeadroomInfo, v18);
  }
  v19 = *(_QWORD *)(a1 + 40);
  v20 = *(_QWORD *)(a1 + 48);
  v21 = *(_QWORD *)(a1 + 56);
  v22 = *(_QWORD *)(a1 + 64);
  v23 = *(_QWORD *)(a1 + 72);
  BitmapInfo = CGImageGetBitmapInfo((CGImageRef)a1);
  if ((BitmapInfo & 0x1F) <= 7)
    __sprintf_chk(__s, 0, 0x100uLL, "%s | ", off_1E165F5B8[BitmapInfo & 0x1F]);
  v25 = strlen(__s);
  v26 = (BitmapInfo >> 12) & 7;
  if (v26 > 4)
    v27 = "? (unknown byte order)";
  else
    v27 = off_1E165F6D8[v26];
  sprintf(&__s[v25], "%s ", v27);
  v28 = strlen(__s);
  v29 = HIWORD(BitmapInfo) & 0xF;
  if (v29 > 4)
    v30 = " | ? (unknown pixel format)";
  else
    v30 = off_1E1644D78[v29];
  sprintf(&__s[v28], "%s ", v30);
  if ((BitmapInfo & 0x100) != 0)
  {
    v31 = strlen(__s);
    sprintf(&__s[v31], "%s ", "| kCGBitmapFloatComponents");
  }
  CFStringAppendFormat(Mutable, 0, CFSTR("\n\t\twidth = %ld, height = %ld, bpc = %ld, bpp = %ld, row bytes = %ld \n\t\t%s"), v19, v20, v21, v22, v23, __s);
  v32 = *(_DWORD *)(a1 + 36);
  if ((v32 & 0x2000000) != 0)
    v33 = "Yes";
  else
    v33 = "No";
  if (*(_QWORD *)(a1 + 168))
    v34 = "Yes";
  else
    v34 = "No";
  if (*(_QWORD *)(a1 + 176))
    v35 = "Yes";
  else
    v35 = "No";
  if (*(_QWORD *)(a1 + 184))
    v36 = "Yes";
  else
    v36 = "No";
  if ((v32 & 0x1000000) != 0)
    v37 = "Yes";
  else
    v37 = "No";
  CFStringAppendFormat(Mutable, 0, CFSTR("\n\t\tis mask? %s, has masking color? %s, has soft mask? %s, has matte? %s, should interpolate? %s"), v33, v34, v35, v36, v37);
  return Mutable;
}

float CGImageGetHeadroomInfo(CGImage *a1, _DWORD *a2)
{
  CGColorSpaceRef ColorSpace;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  float ContentHeadroom;
  float v9;
  uint64_t v10;
  const __CFNumber *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *v20;
  uint64_t v21;
  const void *v22;
  uint64_t v23;
  const void *v24;
  uint64_t v25;
  const __CFNumber *Property;
  const __CFNumber *v27;
  CFTypeID v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  CFTypeID v36;
  const __CFNumber *v37;
  CFTypeID v38;
  CFTypeID v39;
  float valuePtr;
  uint64_t v42;

  v42 = 0;
  ColorSpace = CGImageGetColorSpace(a1);
  if (!ColorSpace)
    goto LABEL_41;
  v5 = ColorSpace;
  v6 = *((_QWORD *)ColorSpace + 3);
  if (*(_DWORD *)(v6 + 24) != 1)
    goto LABEL_41;
  if (!*(_BYTE *)(v6 + 16) && !*(_BYTE *)(v6 + 17) && !*(_BYTE *)(v6 + 13))
  {
    v42 = 0x13F800000;
    if (!a2)
      return *(float *)&v42;
    goto LABEL_42;
  }
  if (CGColorSpaceContainsFlexGTCInfo((_BOOL8)ColorSpace))
  {
    LODWORD(v42) = CGColorSpaceGetHeadroomInfo(v5, (int *)&v42 + 1);
    goto LABEL_40;
  }
  v7 = *((_QWORD *)a1 + 26);
  if (v7)
  {
    ContentHeadroom = CGImageProviderGetContentHeadroom(v7);
    if (ContentHeadroom >= 0.0)
    {
      v9 = ContentHeadroom;
      *(float *)&v42 = ContentHeadroom;
      if (ContentHeadroom <= 0.0)
      {
        HIDWORD(v42) = 1;
        v25 = *((_QWORD *)a1 + 28);
        if (!v25)
          goto LABEL_41;
        Property = (const __CFNumber *)CGPropertiesGetProperty(v25, CFSTR("kCGImageUnknownHeadroom"));
        if (Property)
        {
          v27 = Property;
          v28 = CFGetTypeID(Property);
          if (v28 == CFNumberGetTypeID())
          {
            valuePtr = 0.0;
            CFNumberGetValue(v27, kCFNumberFloatType, &valuePtr);
            if (vabds_f32(valuePtr, v9) > 0.00001)
              CGPostError((uint64_t)"%s: image and image provider have different unknown origin values: %f, %f", v29, v30, v31, v32, v33, v34, v35, (char)"CGImageGetHeadroomInfo");
          }
        }
      }
      else
      {
        v10 = *((_QWORD *)a1 + 28);
        if (!v10 || (v11 = (const __CFNumber *)CGPropertiesGetProperty(v10, CFSTR("kCGImageEstimatedHeadroom"))) == 0)
        {
          HIDWORD(v42) = 1;
          if (!a2)
            return *(float *)&v42;
          goto LABEL_42;
        }
        HIDWORD(v42) = 1;
        valuePtr = 0.0;
        CFNumberGetValue(v11, kCFNumberFloatType, &valuePtr);
        if (vabds_f32(valuePtr, v9) > 0.00001)
          CGPostError((uint64_t)"%s: image and image provider have different estimated values: %f, %f", v12, v13, v14, v15, v16, v17, v18, (char)"CGImageGetHeadroomInfo");
      }
    }
    goto LABEL_40;
  }
  v19 = *((_QWORD *)a1 + 28);
  if (!v19)
    goto LABEL_40;
  v20 = CGPropertiesGetProperty(v19, CFSTR("kCGImageHeadroom"));
  v21 = *((_QWORD *)a1 + 28);
  if (v21)
  {
    v22 = CGPropertiesGetProperty(v21, CFSTR("kCGImageEstimatedHeadroom"));
    v23 = *((_QWORD *)a1 + 28);
    if (v23)
    {
      v24 = CGPropertiesGetProperty(v23, CFSTR("kCGImageUnknownHeadroom"));
      goto LABEL_30;
    }
  }
  else
  {
    v22 = 0;
  }
  v24 = 0;
LABEL_30:
  if (v20)
  {
    v36 = CFGetTypeID(v20);
    if (v36 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 1;
      v37 = (const __CFNumber *)v20;
LABEL_39:
      CFNumberGetValue(v37, kCFNumberFloatType, &v42);
      goto LABEL_40;
    }
  }
  if (v22)
  {
    v38 = CFGetTypeID(v22);
    if (v38 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 2;
      v37 = (const __CFNumber *)v22;
      goto LABEL_39;
    }
  }
  if (v24)
  {
    v39 = CFGetTypeID(v24);
    if (v39 == CFNumberGetTypeID())
    {
      HIDWORD(v42) = 0;
      v37 = (const __CFNumber *)v24;
      goto LABEL_39;
    }
  }
LABEL_40:
  if (!HIDWORD(v42))
  {
    if (*(_BYTE *)(v5[3] + 13))
    {
      LODWORD(v42) = 0;
      if (!a2)
        return *(float *)&v42;
    }
    else
    {
      LODWORD(v42) = CGColorSpaceGetHeadroomInfo(v5, (int *)&v42 + 1);
      if (!a2)
        return *(float *)&v42;
    }
    goto LABEL_42;
  }
LABEL_41:
  if (a2)
LABEL_42:
    *a2 = HIDWORD(v42);
  return *(float *)&v42;
}

BOOL linked_on_sydro_or_later()
{
  BOOL v0;

  if (linked_on_sydro_or_later_predicate != -1)
    dispatch_once(&linked_on_sydro_or_later_predicate, &__block_literal_global_236);
  if (linked_on_sydro_or_later_linked_on_rome_or_later)
    v0 = 0;
  else
    v0 = linked_on_sydro_or_later_linked_on_sydney_or_later == 0;
  return !v0
      || linked_on_sydro_or_later_linked_on_paris_or_later != 0
      || linked_on_sydro_or_later_linked_on_kincaid_or_later != 0
      || linked_on_sydro_or_later_linked_on_borealis_or_later != 0;
}

uint64_t __linked_on_dawnburst_or_later_block_invoke()
{
  uint64_t result;

  linked_on_dawnburst_or_later_linked_on_macOS14_or_later = dyld_program_sdk_at_least();
  linked_on_dawnburst_or_later_linked_on_iOS17_or_later = dyld_program_sdk_at_least();
  linked_on_dawnburst_or_later_linked_on_tvOS17_or_later = dyld_program_sdk_at_least();
  linked_on_dawnburst_or_later_linked_on_watchOS10_or_later = dyld_program_sdk_at_least();
  result = dyld_program_sdk_at_least();
  linked_on_dawnburst_or_later_linked_on_borealis_or_later = result;
  return result;
}

uint64_t __linked_on_sydro_or_later_block_invoke()
{
  uint64_t result;

  linked_on_sydro_or_later_linked_on_rome_or_later = dyld_program_sdk_at_least();
  linked_on_sydro_or_later_linked_on_sydney_or_later = dyld_program_sdk_at_least();
  linked_on_sydro_or_later_linked_on_paris_or_later = dyld_program_sdk_at_least();
  linked_on_sydro_or_later_linked_on_kincaid_or_later = dyld_program_sdk_at_least();
  result = dyld_program_sdk_at_least();
  linked_on_sydro_or_later_linked_on_borealis_or_later = result;
  return result;
}

__CFData *compress_data(char *a1, vImagePixelCount a2, vImagePixelCount a3, uint64_t a4, uint64_t a5, size_t a6, int a7)
{
  __CFData *Mutable;
  __CFData *v15;
  UInt8 *MutableBytePtr;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  char v26;
  uint64_t v27;
  UInt8 *v28;
  vImagePixelCount v29;
  UInt8 v30;
  uint64_t v32;
  vImage_Error v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  vImage_Buffer dest;
  vImage_Buffer src;

  Mutable = CFDataCreateMutable(0, 0);
  v15 = Mutable;
  if (Mutable)
  {
    CFDataSetLength(Mutable, ((a4 * a2 + 7) >> 3) * a3);
    MutableBytePtr = CFDataGetMutableBytePtr(v15);
    switch(a4)
    {
      case 1:
        v20 = (uint64_t)a1;
        v21 = a2;
        v22 = a3;
        v23 = 1;
        v24 = a6;
        v25 = (a4 * a2 + 7) >> 3;
        v26 = 7;
        goto LABEL_13;
      case 2:
        v20 = (uint64_t)a1;
        v21 = a2;
        v22 = a3;
        v23 = 2;
        v24 = a6;
        v25 = (a4 * a2 + 7) >> 3;
        v26 = 6;
        goto LABEL_13;
      case 4:
        v20 = (uint64_t)a1;
        v21 = a2;
        v22 = a3;
        v23 = 4;
        v24 = a6;
        v25 = (a4 * a2 + 7) >> 3;
        v26 = 4;
LABEL_13:
        compress_data_with_shift((uint64_t)MutableBytePtr, v20, v21, v22, v23, v24, v25, v26);
        break;
      case 8:
        if (a5 == 32)
        {
          src.data = a1;
          src.height = a3;
          src.width = a2;
          src.rowBytes = a6;
          dest.data = MutableBytePtr;
          dest.height = a3;
          if ((a7 & 0xFFFFFFFD) == 1)
            v32 = 3;
          else
            v32 = 0;
          dest.width = a2;
          dest.rowBytes = a2;
          v33 = vImageExtractChannel_ARGB8888(&src, &dest, v32, 0);
          if (v33)
            _CGHandleAssert("compress_data_to_8_bit", 906, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "err == kvImageNoError", "Unhandled vImage error %ld", v34, v35, v36, v33);
        }
        else
        {
          if (a5 != 16)
            _CGHandleAssert("compress_data_to_8_bit", 908, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "", "Unimplemented", v17, v18, v19, v37);
          v27 = 0;
          do
          {
            v28 = (UInt8 *)&a1[v27 * a6];
            v29 = a2;
            do
            {
              v30 = *v28;
              v28 += 2;
              *MutableBytePtr++ = v30;
              --v29;
            }
            while (v29);
            ++v27;
          }
          while (v27 != a3);
        }
        break;
      default:
        _CGHandleAssert("compress_data", 946, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "", "Unimplemented", v17, v18, v19, v37);
    }
  }
  return v15;
}

uint64_t compress_data_with_shift(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, uint64_t a6, uint64_t a7, char a8)
{
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t v11;
  _BYTE *v12;
  unsigned __int8 *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;

  v8 = 0;
  do
  {
    v9 = 0;
    v10 = 0;
    v11 = 0;
    v12 = (_BYTE *)(result + v8 * a7);
    v13 = (unsigned __int8 *)(a2 + v8 * a6);
    do
    {
      v15 = *v13++;
      v14 = v15;
      v16 = v10 - 8;
      if (v10 >= 8)
      {
        do
        {
          *v12++ = v11 >> v16;
          v16 -= 8;
          v10 -= 8;
        }
        while (v10 > 7);
      }
      v11 = (v11 << a5) | (v14 >> a8) & ~(-1 << a5);
      v10 += a5;
      ++v9;
    }
    while (v9 != a3);
    if (v12 && v10)
    {
      do
      {
        v17 = v10;
        v18 = v10 - 8;
        if (v10 >= 8)
        {
          do
          {
            *v12++ = v11 >> v18;
            v18 -= 8;
            v17 -= 8;
          }
          while (v17 > 7);
        }
        v19 = -v10 & 7;
        v11 <<= v19;
        v10 = v17 + v19;
      }
      while (v10);
    }
    ++v8;
  }
  while (v8 != a4);
  return result;
}

uint64_t CGImageCopyHeadroomFromOriginal(uint64_t *a1, CGImage *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  float HeadroomInfo;
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;

  if (!a1 || !a2)
  {
    if (!a2)
      CGPostError((uint64_t)"%s no original image to copy headroom from", 0, a3, a4, a5, a6, a7, a8, (char)"CGImageCopyHeadroomFromOriginal");
    return 0;
  }
  v18 = 0;
  HeadroomInfo = CGImageGetHeadroomInfo(a2, &v18);
  result = 0;
  if (v18 && HeadroomInfo != 0.0)
  {
    if (CGImageSetHeadroom(a1, v18, HeadroomInfo))
      return 1;
    CGPostError((uint64_t)"%s failed to copy headroom", v11, v12, v13, v14, v15, v16, v17, (char)"CGImageCopyHeadroomFromOriginal");
    return 0;
  }
  return result;
}

BOOL CGImageGetShouldInterpolate(CGImageRef image)
{
  CGImageRef v1;
  CFTypeID v2;

  if (image)
  {
    v1 = image;
    v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v2 == CGImageGetTypeID_image_type_id)
      LOBYTE(image) = *((_BYTE *)v1 + 39) & 1;
    else
      LOBYTE(image) = 0;
  }
  return (char)image;
}

void add_headroom_info_from_image_provider(_QWORD *a1)
{
  CFTypeID v2;
  _QWORD *ImageProvider;
  uint64_t v4;
  CGColorSpaceRef ColorSpace;
  uint64_t v6;
  const void *Property;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float ContentHeadroom;
  int v15;
  uint64_t v16;
  const void *v17;
  CGColorSpaceRef v18;
  int v19;

  v2 = CFGetTypeID(a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  if (v2 == CGImageGetTypeID_image_type_id)
  {
    ImageProvider = CGImageGetImageProvider(a1);
    if (ImageProvider)
    {
      v4 = (uint64_t)ImageProvider;
      ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
      if (ColorSpace)
      {
        v6 = *((_QWORD *)ColorSpace + 3);
        if (*(_DWORD *)(v6 + 24) == 1)
        {
          v19 = 0;
          if (*(_BYTE *)(v6 + 16) || *(_BYTE *)(v6 + 17) || *(_BYTE *)(v6 + 13))
          {
            Property = *(const void **)(v4 + 120);
            if (Property)
              Property = CGPropertiesGetProperty((uint64_t)Property, CFSTR("kCGImageCalculateHeadroom"));
            if (Property == (const void *)*MEMORY[0x1E0C9AE50])
            {
              ContentHeadroom = calculate_headroom((uint64_t)a1, &v19);
              v15 = v19;
            }
            else
            {
              ContentHeadroom = CGImageProviderGetContentHeadroom(v4);
              v15 = ContentHeadroom != 0.0;
              v19 = v15;
              v16 = *(_QWORD *)(v4 + 120);
              if (!v16
                || (v17 = CGPropertiesGetProperty(v16, CFSTR("kCGImageProviderColorSpaceChangedOnImageCopy"))) == 0)
              {
                v17 = *(const void **)(v4 + 40);
              }
              if ((verify_headroom_and_colorspace((uint64_t)v17, (uint64_t)"add_headroom_info_from_image_provider", v8, v9, v10, v11, v12, v13, ContentHeadroom) & 1) == 0)
              {
                v18 = CGImageGetColorSpace((CGImageRef)a1);
                if (v18)
                {
                  if (*(_BYTE *)(*((_QWORD *)v18 + 3) + 13))
                  {
                    v15 = 0;
                    v19 = 0;
                    ContentHeadroom = 0.0;
                  }
                }
              }
            }
          }
          else
          {
            v15 = 1;
            v19 = 1;
            ContentHeadroom = 1.0;
          }
          CGImageSetHeadroom(a1, v15, ContentHeadroom);
        }
      }
    }
  }
}

float calculate_headroom(uint64_t a1, int *a2)
{
  CGColorSpaceRef ColorSpace;
  size_t v5;
  size_t v6;
  CGContext *v7;
  __int16 *Data;
  size_t BytesPerRow;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v18;
  size_t v20;
  CGRect v33;

  CGImageSetCachingFlags((_BYTE *)a1, 1);
  ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  if (ColorSpace && *(_BYTE *)(*((_QWORD *)ColorSpace + 3) + 13))
  {
    v5 = *(_QWORD *)(a1 + 40);
    v6 = *(_QWORD *)(a1 + 48);
    v7 = CGBitmapContextCreateWithData(0, v5, v6, 0x10uLL, 0, ColorSpace, 0x1105u, 0, 0);
    v33.size.width = (double)v5;
    v33.size.height = (double)v6;
    v33.origin.x = 0.0;
    v33.origin.y = 0.0;
    CGContextDrawImage(v7, v33, (CGImageRef)a1);
    Data = (__int16 *)CGBitmapContextGetData(v7);
    BytesPerRow = CGBitmapContextGetBytesPerRow(v7);
    if (!Data)
    {
      CGPostError((uint64_t)"%s: failed to evaluate content headroom", v10, v11, v12, v13, v14, v15, v16, (char)"calculate_headroom");
      _S8 = 0.0;
      if (!v7)
        goto LABEL_23;
      goto LABEL_22;
    }
    if (v6)
    {
      v18 = 0;
      _H0 = 0;
      do
      {
        if (v5)
        {
          v20 = 0;
          _H1 = *Data;
          LOWORD(_S2) = Data[1];
          LOWORD(_S3) = Data[2];
          __asm
          {
            FCVT            S4, H3
            FCVT            S5, H2
          }
          if (_S5 <= _S4)
            _S2 = _S3;
          do
          {
            __asm
            {
              FCVT            S3, H2
              FCVT            S4, H1
            }
            if (_S4 <= _S3)
            {
              __asm { FCVT            S4, H0 }
              if (_S4 <= _S3)
                _H0 = LOWORD(_S2);
            }
            else
            {
              __asm { FCVT            S3, H0 }
              if (_S3 <= _S4)
                _H0 = *Data;
            }
            v20 += 4;
          }
          while (v20 < v5);
        }
        Data = (__int16 *)((char *)Data + BytesPerRow);
        ++v18;
      }
      while (v18 != v6);
    }
    else
    {
      _H0 = 0;
    }
    __asm { FCVT            S8, H0 }
    *a2 = 1;
    if (v7)
LABEL_22:
      CFRelease(v7);
  }
  else
  {
    _S8 = CGColorSpaceGetHeadroomInfo(ColorSpace, a2);
  }
LABEL_23:
  CGImageSetCachingFlags((_BYTE *)a1, 0);
  return _S8;
}

uint64_t verify_headroom_and_colorspace(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, float a9)
{
  _BYTE *v10;
  uint64_t result;

  if (a9 != 0.0 && a9 < 1.0)
  {
    CGPostError((uint64_t)"%s: invalid headroom value: %f", a2, a3, a4, a5, a6, a7, a8, (char)"verify_headroom_and_colorspace");
    return 0;
  }
  if (!a1 || (v10 = *(_BYTE **)(a1 + 24), !v10[16]) && !v10[17] && !v10[13])
  {
    CGPostError((uint64_t)"%s: invalid color space for image with headroom", a2, a3, a4, a5, a6, a7, a8, (char)"verify_headroom_and_colorspace");
    return 0;
  }
  result = 1;
  if (a9 != 0.0 && a9 != 1.0 && !(v10[13] | v10[16]) && !v10[17])
  {
    CGPostError((uint64_t)"%s: specified color space cannot be used for CGImage with content headroom %f", a2, a3, a4, a5, a6, a7, a8, a2);
    return 0;
  }
  return result;
}

CGImageRef CGImageCreateWithCGPDFStream(uint64_t a1, uint64_t a2)
{
  CGImage *v3;
  CGImageRef ImageForRenderingSize;

  v3 = (CGImage *)CGPDFImageCreate(a1);
  ImageForRenderingSize = CGPDFImageCreateImageForRenderingSize(v3, a2, 0.0, 0.0);
  if (v3)
    CFRelease(v3);
  return ImageForRenderingSize;
}

uint64_t CGImageIsOptimizedForSharing(void *a1)
{
  CFTypeID v2;
  CGColorSpace *ColorSpace;
  uint64_t IsOptimizedForSharing_f_38;
  CFDataRef v6;
  const void *IsOptimizedForSharing_f;

  if (!a1)
    return 0;
  v2 = CFGetTypeID(a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  if (v2 != CGImageGetTypeID_image_type_id)
    return 0;
  if (CGImageIsOptimizedForSharing_predicate != -1)
    dispatch_once(&CGImageIsOptimizedForSharing_predicate, &__block_literal_global_4668);
  ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  if (CGColorSpaceEqualToColorSpace((uint64_t)ColorSpace, CGImageIsOptimizedForSharing_sRGB))
    return 1;
  v6 = CGColorSpaceCopyICCData(ColorSpace);
  if (CGImageIsOptimizedForSharing_cglibrarypredicate != -1)
    dispatch_once(&CGImageIsOptimizedForSharing_cglibrarypredicate, &__block_literal_global_36);
  IsOptimizedForSharing_f = (const void *)CGImageIsOptimizedForSharing_f(v6, 0);
  if (CGImageIsOptimizedForSharing_cglibrarypredicate_39 != -1)
    dispatch_once(&CGImageIsOptimizedForSharing_cglibrarypredicate_39, &__block_literal_global_41_4669);
  IsOptimizedForSharing_f_38 = CGImageIsOptimizedForSharing_f_38(IsOptimizedForSharing_f, CFSTR("aapy"));
  if (v6)
    CFRelease(v6);
  if (IsOptimizedForSharing_f)
    CFRelease(IsOptimizedForSharing_f);
  return IsOptimizedForSharing_f_38;
}

uint64_t colorsync_smart_null_4674()
{
  return 0;
}

uint64_t *CGImageCreateWithContentHeadroom(size_t a1, size_t a2, size_t a3, size_t a4, size_t a5, CGColorSpace *a6, uint64_t a7, CGDataProvider *a8, float a9, CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  CGBitmapInfo v13;
  float v20;
  CGImageRef v21;
  uint64_t *v22;
  int v23;
  _BOOL4 v25;

  v13 = a7;
  v20 = a9;
  if (!verify_headroom_and_colorspace((uint64_t)a6, (uint64_t)"CGImageCreateWithContentHeadroom", a3, a4, a5, (uint64_t)a6, a7, (uint64_t)a8, a9))return 0;
  v21 = CGImageCreate(a1, a2, a3, a4, a5, a6, v13, a8, decode, shouldInterpolate, intent);
  v22 = (uint64_t *)v21;
  if (v21)
  {
    v25 = v20 != 0.0;
    if (v20 == 0.0)
    {
      v20 = calculate_headroom((uint64_t)v21, (int *)&v25);
      v23 = v25;
    }
    else
    {
      v23 = 1;
    }
    CGImageSetHeadroom(v22, v23, v20);
  }
  return v22;
}

uint64_t *CGImageCreateCopyWithContentHeadroom(CGImage *a1, float a2)
{
  CGColorSpaceRef ColorSpace;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  CGImageRef Copy;
  uint64_t *v12;
  int v13;
  _BOOL4 v15;

  ColorSpace = CGImageGetColorSpace(a1);
  if (!verify_headroom_and_colorspace((uint64_t)ColorSpace, (uint64_t)"CGImageCreateCopyWithContentHeadroom", v5, v6, v7, v8, v9, v10, a2))return 0;
  Copy = CGImageCreateCopy(a1);
  v12 = (uint64_t *)Copy;
  if (Copy)
  {
    v15 = a2 != 0.0;
    if (a2 == 0.0)
    {
      a2 = calculate_headroom((uint64_t)Copy, (int *)&v15);
      v13 = v15;
    }
    else
    {
      v13 = 1;
    }
    CGImageSetHeadroom(v12, v13, a2);
  }
  return v12;
}

uint64_t CGImageCreateCopyWithImageProvider(char *image, uint64_t a2)
{
  CGColorSpaceRef ColorSpace;
  uint64_t v5;
  const void *Property;
  uint64_t v7;
  CGBitmapInfo BitmapInfo;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t *v19;
  uint64_t v20;
  unsigned int *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;

  if (!image || (image[39] & 2) != 0)
    return 0;
  ColorSpace = CGImageGetColorSpace((CGImageRef)image);
  if (a2)
  {
    v5 = *(_QWORD *)(a2 + 120);
    if (!v5 || (Property = CGPropertiesGetProperty(v5, CFSTR("kCGImageProviderColorSpaceChangedOnImageCopy"))) == 0)
      Property = *(const void **)(a2 + 40);
  }
  else
  {
    Property = 0;
  }
  if (!CGColorSpaceEqualToColorSpace((uint64_t)ColorSpace, (uint64_t)Property))
    return 0;
  v7 = CGImageCreateWithImageProvider(a2, *((_QWORD *)image + 20), HIBYTE(*((_DWORD *)image + 9)) & 1, ((__int16)*((_DWORD *)image + 9) >> 8));
  if (!v7)
    return v7;
  BitmapInfo = CGImageGetBitmapInfo((CGImageRef)image);
  if (BitmapInfo != CGImageGetBitmapInfo((CGImageRef)v7))
    goto LABEL_38;
  if (!*((_QWORD *)image + 21))
    goto LABEL_19;
  v9 = *(_QWORD *)(v7 + 144);
  v10 = v9 ? *(_QWORD *)(*(_QWORD *)(v9 + 24) + 40) : 0;
  v11 = malloc_type_malloc(16 * v10, 0x705560E0uLL);
  *(_QWORD *)(v7 + 168) = v11;
  if (!v11)
  {
LABEL_38:
    CFRelease((CFTypeRef)v7);
    return 0;
  }
  v12 = 2 * v10;
  if (2 * v10)
  {
    v13 = (uint64_t *)*((_QWORD *)image + 21);
    do
    {
      v14 = *v13++;
      *v11++ = v14;
      --v12;
    }
    while (v12);
  }
LABEL_19:
  *(_DWORD *)(v7 + 36) = *(_DWORD *)(v7 + 36) & 0xF7FFFFFF | (((*((_DWORD *)image + 9) >> 27) & 1) << 27);
  v15 = *((_QWORD *)image + 22);
  if (v15)
    CFRetain(*((CFTypeRef *)image + 22));
  *(_QWORD *)(v7 + 176) = v15;
  if (!*((_QWORD *)image + 23))
    goto LABEL_29;
  v16 = *(_QWORD *)(v7 + 144);
  if (v16)
    v17 = *(_QWORD *)(*(_QWORD *)(v16 + 24) + 40);
  else
    v17 = 0;
  v18 = malloc_type_malloc(8 * v17, 0x705560E0uLL);
  *(_QWORD *)(v7 + 184) = v18;
  if (!v18)
    goto LABEL_38;
  if (v17)
  {
    v19 = (uint64_t *)*((_QWORD *)image + 23);
    do
    {
      v20 = *v19++;
      *v18++ = v20;
      --v17;
    }
    while (v17);
  }
LABEL_29:
  v21 = (unsigned int *)*((_QWORD *)image + 24);
  if (v21)
  {
    do
      v22 = __ldxr(v21);
    while (__stxr(v22 + 1, v21));
  }
  *(_QWORD *)(v7 + 192) = v21;
  v23 = *((_QWORD *)image + 25);
  if (v23)
    CFRetain(*((CFTypeRef *)image + 25));
  *(_QWORD *)(v7 + 200) = v23;
  v24 = *((_QWORD *)image + 30);
  if (v24)
    CFRetain(*((CFTypeRef *)image + 30));
  *(_QWORD *)(v7 + 240) = v24;
  *(_OWORD *)(v7 + 248) = *(_OWORD *)(image + 248);
  v25 = (unsigned int *)*((_QWORD *)image + 27);
  if (v25)
  {
    do
      v26 = __ldxr(v25);
    while (__stxr(v26 + 1, v25));
  }
  *(_QWORD *)(v7 + 216) = v25;
  return v7;
}

CGImageRef CGImageCreateCopyWithClipPath(CGImageRef image, CFTypeRef cf)
{
  CGImageRef Copy;
  CFTypeID v5;
  const void *v6;

  Copy = 0;
  if (image && cf)
  {
    if (CGPathDisableTypeValidation || (v5 = CFGetTypeID(cf), v5 == CGPathGetTypeID()))
    {
      Copy = CGImageCreateCopy(image);
      if (Copy)
      {
        v6 = (const void *)*((_QWORD *)image + 25);
        if (v6)
          CFRelease(v6);
        CFRetain(cf);
        *((_QWORD *)image + 25) = cf;
      }
    }
    else
    {
      return 0;
    }
  }
  return Copy;
}

CGImageRef CGImageCreateCopyWithRenderingIntent(CGImageRef cf, unsigned int a2)
{
  char v2;
  _DWORD *v3;
  int v4;

  if (cf)
  {
    v2 = a2;
    v3 = cf;
    cf = 0;
    if (a2 <= 4)
    {
      v4 = v3[9];
      if ((v4 & 0x2000000) == 0)
      {
        if (a2 == (__int16)v4 >> 8)
        {
          CFRetain(v3);
          return (CGImageRef)v3;
        }
        else
        {
          cf = CGImageCreateCopy((CGImageRef)v3);
          if (cf)
            *((_BYTE *)cf + 37) = v2;
        }
      }
    }
  }
  return cf;
}

unsigned __int8 *CGImageCreateCopyWithOrientation(unsigned __int8 *cf, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 *v8;
  char v9;
  CGImageRef Copy;

  v8 = cf;
  if (cf)
  {
    v9 = a2;
    if (cf[38] == a2)
    {
      CFRetain(cf);
    }
    else if ((a2 - 9) > 0xFFFFFFF7)
    {
      Copy = CGImageCreateCopy((CGImageRef)cf);
      v8 = (unsigned __int8 *)Copy;
      if (Copy)
        *((_BYTE *)Copy + 38) = v9;
    }
    else
    {
      CGLog(1, (uint64_t)"%s %s", a3, a4, a5, a6, a7, a8, (char)"CGImageCreateCopyWithOrientation");
      return 0;
    }
  }
  return v8;
}

CGImage *CGImageCreateCopyWithProtectedDataProvider(CGImage *a1)
{
  CGImage *v1;
  uint64_t v2;
  uint64_t v4;
  UInt8 *v5;
  unint64_t v6;
  const __CFData *protected_copy;
  CGDataProvider *v8;
  CGImageRef Copy;

  v1 = a1;
  if (a1)
  {
    v2 = *((_QWORD *)a1 + 19);
    if (!v2
      || *(uint64_t (**)(uint64_t))(v2 + 80) != data_get_byte_pointer
      || *(_QWORD *)(*(_QWORD *)(v2 + 24) + 24))
    {
      return 0;
    }
    if (use_protected_copy_predicate != -1)
      dispatch_once(&use_protected_copy_predicate, &__block_literal_global_282);
    if (!use_protected_copy_status)
      return 0;
    v4 = *((_QWORD *)v1 + 19);
    v5 = (UInt8 *)CGDataProviderRetainBytePtr(v4);
    if (!v5)
      return 0;
    v6 = v4 ? *(_QWORD *)(v4 + 32) : -1;
    protected_copy = create_protected_copy(v5, v6);
    v8 = CGDataProviderCreateWithCFData(protected_copy);
    CGDataProviderReleaseBytePtr(v4);
    if (protected_copy)
      CFRelease(protected_copy);
    if (v8)
    {
      Copy = CGImageCreateCopy(v1);
      v1 = Copy;
      if (Copy)
      {
        CGDataProviderRelease(*((CGDataProviderRef *)Copy + 19));
        *((_QWORD *)v1 + 19) = v8;
      }
      else
      {
        CGDataProviderRelease(v8);
      }
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

const void *__use_protected_copy_block_invoke()
{
  return get_BOOLean_property("CG_USE_PROTECTED_COPY", (const void *(*)(const char *))copy_local_domain_value, (BOOL *)&use_protected_copy_status);
}

CGImageRef CGImageCreateCopyByApplyingxtendedRangeToneMapping(_QWORD *a1, CGColorSpace *a2, const void *a3)
{
  CFTypeID v6;
  CGImageRef v7;
  CFTypeID v8;
  const __CFDictionary *Value;
  CGColorSpaceRef ColorSpace;
  __int16 v11;
  CGColorSpace *Linearized;
  CFDictionaryRef ResolveExtendedRangeToneMappingOptions;
  char *DataProviderInternal;
  CFDataRef v15;
  const __CFData *v16;
  size_t v17;
  size_t v18;
  uint64_t v19;
  size_t v20;
  uint64_t NumberOfComponents;
  CGColorSpace *v22;
  size_t v23;
  size_t v24;
  void *v25;
  void *v26;
  CGColorSpace *CopyWithStandardRange;
  const UInt8 *BytePtr;
  CGDataProvider *v30;
  CGDataProvider *v31;
  size_t v32;
  size_t v33;
  size_t v34;
  CGBitmapInfo bitmapInfo;
  _QWORD v36[2];
  CGBitmapInfo v37;
  int v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD v43[2];
  CGBitmapInfo v44;
  int v45;
  size_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;

  if (!a1)
    return 0;
  v6 = CFGetTypeID(a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  v7 = 0;
  if (a3 && v6 == CGImageGetTypeID_image_type_id)
  {
    v8 = CFGetTypeID(a3);
    if (v8 == CFDictionaryGetTypeID())
    {
      Value = (const __CFDictionary *)CFDictionaryGetValue((CFDictionaryRef)a3, CFSTR("kCGImageExtendedRangeToneMappingInfo"));
      ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
      v11 = CGImageGetBitmapInfo((CGImageRef)a1);
      if (ColorSpace)
      {
        v7 = 0;
        if (!*(_BYTE *)(*((_QWORD *)ColorSpace + 3) + 13) || (v11 & 0xF00) != 0x100)
          return v7;
        Linearized = CGColorSpaceCreateLinearized(ColorSpace);
        if (Linearized)
        {
          v7 = 0;
          if (!CGColorConversionInfoIterateColorSpaceFunctionsWithCallbacks((uint64_t)ColorSpace, Linearized, 0, (uint64_t)&__block_literal_global_24_20946, 0, 0, 0, 5u, 0))return v7;
          ResolveExtendedRangeToneMappingOptions = CGColorTransformCreateResolveExtendedRangeToneMappingOptions(Value);
          if (ResolveExtendedRangeToneMappingOptions)
          {
            CFRelease(ResolveExtendedRangeToneMappingOptions);
            DataProviderInternal = CGImageGetDataProviderInternal((char *)a1, 0);
            if (DataProviderInternal)
            {
              v15 = CGDataProviderCopyData((CGDataProviderRef)DataProviderInternal);
              if (v15)
              {
                v16 = v15;
                v18 = a1[5];
                v17 = a1[6];
                v19 = a1[9];
                v20 = a1[7];
                v33 = a1[8];
                NumberOfComponents = CGImageGetNumberOfComponents((uint64_t)a1);
                bitmapInfo = CGImageGetBitmapInfo((CGImageRef)a1);
                v22 = CGImageGetColorSpace((CGImageRef)a1);
                v34 = v18;
                v23 = (v20 >> 3) * v18 * NumberOfComponents;
                v24 = v23 * v17;
                v25 = malloc_type_calloc(1uLL, v23 * v17, 0x5FFA5F21uLL);
                if (v25)
                {
                  v26 = v25;
                  v32 = v23;
                  if (a2)
                    CopyWithStandardRange = 0;
                  else
                    CopyWithStandardRange = CGColorSpaceCreateCopyWithStandardRange(v22);
                  if (CopyWithStandardRange)
                    a2 = CopyWithStandardRange;
                  BytePtr = CFDataGetBytePtr(v16);
                  v48 = 0;
                  v49 = 0;
                  v41 = 0;
                  v42 = 0;
                  v43[0] = 0;
                  v43[1] = a2;
                  v44 = bitmapInfo;
                  v45 = 0;
                  v46 = v20;
                  v47 = v19;
                  v36[0] = 0;
                  v36[1] = v22;
                  v37 = bitmapInfo;
                  v38 = 0;
                  v39 = v20;
                  v40 = v19;
                  v7 = 0;
                  if (convert_color_data_with_format(0, v34, (CGDataProvider *)v17, (char *)v26, (uint64_t)v43, BytePtr, (uint64_t)v36, (const __CFDictionary *)a3))
                  {
                    v30 = CGDataProviderCreateWithData(0, v26, v24, (CGDataProviderReleaseDataCallback)free_data);
                    if (v30)
                    {
                      v31 = v30;
                      v7 = CGImageCreate(v34, v17, v20, v33, v32, a2, bitmapInfo, v30, 0, 0, kCGRenderingIntentDefault);
                      CFRelease(v31);
                    }
                    else
                    {
                      v7 = 0;
                    }
                  }
                  CGColorSpaceRelease(CopyWithStandardRange);
                }
                else
                {
                  v7 = 0;
                }
                CFRelease(v16);
                return v7;
              }
            }
          }
        }
      }
    }
    return 0;
  }
  return v7;
}

uint64_t CGImageGetNumberOfComponents(uint64_t image)
{
  CGImage *v1;
  CGColorSpaceRef ColorSpace;
  uint64_t v3;

  if (image)
  {
    v1 = (CGImage *)image;
    if ((*(_BYTE *)(image + 39) & 2) != 0)
    {
      return 1;
    }
    else
    {
      ColorSpace = CGImageGetColorSpace((CGImageRef)image);
      if (ColorSpace)
        v3 = *(_QWORD *)(*((_QWORD *)ColorSpace + 3) + 40);
      else
        v3 = 0;
      if (CGImageGetAlphaInfo(v1))
        return v3 + 1;
      else
        return v3;
    }
  }
  return image;
}

void free_data(int a1, void *a2)
{
  free(a2);
}

uint64_t CGImageCreateCopyWithResolvedOptions(uint64_t a1, const __CFDictionary *cf)
{
  const __CFDictionary *v2;
  CFTypeID v4;
  const void *Value;
  CFTypeID v6;
  _BOOL4 v7;
  unint64_t v8;
  const __CFDictionary *v9;
  CGImage *v10;
  CGImageRef Copy;
  const void *v13;
  const void *v14;
  CFTypeID v15;
  _BOOL4 v16;
  const void *v17;
  const void *v18;
  CFTypeID v19;
  _QWORD *ImageProvider;
  _QWORD *v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  CFTypeID v30;
  uint64_t Instance;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  int v42;
  int v43;
  void (*v44)(uint64_t);
  void (*v45)(uint64_t);
  void *v46;
  _BYTE *CopyWithImageProvider;
  char v48;
  uint64_t v49;
  char v50;
  int v51;
  CFMutableDataRef Mutable;
  uint64_t CopyWithResolvedOptions_f;
  const void *v54;
  CFMutableDictionaryRef v55;
  __CFDictionary *v56;
  const void *v57;
  __CFDictionary *v58;
  CGDataProviderRef v59;
  const __CFData *CopyWithResolvedOptions_f_68;
  char *DataProviderInternal;
  const __CFData *v62;
  int v63;
  CFTypeRef v64;
  unsigned int *v65;
  unsigned int v66;
  CFMutableDictionaryRef v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  char v75;
  char v76;
  CFIndex v77;
  CFIndex Length;
  CGDataProvider *provider;
  const __CFData *v80;
  __CFDictionary *v81;
  _QWORD context[3];

  v2 = cf;
  if (!cf)
  {
    v8 = 0;
    v9 = 0;
    goto LABEL_7;
  }
  v4 = CFGetTypeID(cf);
  if (v4 != CFDictionaryGetTypeID())
  {
    v8 = 0;
    v9 = 0;
    v2 = 0;
    goto LABEL_7;
  }
  Value = CFDictionaryGetValue(v2, CFSTR("kCGImageDestinationLossyCompressionQuality"));
  if (Value)
  {
    v6 = CFGetTypeID(Value);
    v7 = v6 == CFNumberGetTypeID();
  }
  else
  {
    v7 = 0;
  }
  v13 = CFDictionaryGetValue(v2, CFSTR("kCGImageForceConversion"));
  v16 = v13
     && (v14 = v13, v15 = CFGetTypeID(v13), v15 == CFBooleanGetTypeID())
     && v14 == (const void *)*MEMORY[0x1E0C9AE50];
  v17 = CFDictionaryGetValue(v2, CFSTR("kCGImagePreferGPUForColorConversion"));
  if (!v17 || (v18 = v17, v19 = CFGetTypeID(v17), v19 != CFBooleanGetTypeID()))
  {
    CopyWithImageProvider = 0;
    v48 = 1;
LABEL_45:
    v9 = (const __CFDictionary *)CFDictionaryGetValue(v2, CFSTR("kCGColorConversionInfoOptions"));
    v8 = (unint64_t)CFDictionaryGetValue(v2, CFSTR("kCGColorConversionInfoPayload"));
    v49 = *(_QWORD *)(a1 + 192);
    if (v49)
      v50 = v16;
    else
      v50 = 1;
    if ((v48 & 1) == 0 && (v50 & 1) == 0)
    {
      if (CopyWithImageProvider)
        CFRelease(CopyWithImageProvider);
      return 0;
    }
    if (v49)
      v51 = v16;
    else
      v51 = 1;
    if ((v7 & v51) == 1)
    {
      Mutable = CFDataCreateMutable(0, 0);
      if (CGImageCreateCopyWithResolvedOptions_predicate != -1)
        dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate, &__block_literal_global_54_4695);
      CopyWithResolvedOptions_f = CGImageCreateCopyWithResolvedOptions_f(Mutable, CFSTR("public.jpeg"), 1, 0);
      if (CopyWithResolvedOptions_f)
      {
        v54 = (const void *)CopyWithResolvedOptions_f;
        v55 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v55)
        {
          v80 = Mutable;
          v56 = v55;
          v57 = CFDictionaryGetValue(v2, CFSTR("kCGImageDestinationLossyCompressionQuality"));
          v81 = v56;
          CFDictionarySetValue(v56, CFSTR("kCGImageDestinationLossyCompressionQuality"), v57);
          if (CGImageCreateCopyWithResolvedOptions_predicate_59 != -1)
            dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_59, &__block_literal_global_61_4697);
          v58 = v56;
          CGImageCreateCopyWithResolvedOptions_f_58(v54, a1, v56);
          Mutable = v80;
          if (CGImageCreateCopyWithResolvedOptions_predicate_64 != -1)
            dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_64, &__block_literal_global_66);
          if (CGImageCreateCopyWithResolvedOptions_f_63(v54)
            && (v59 = CGDataProviderCreateWithCFData(v80)) != 0)
          {
            provider = v59;
            v2 = CGImageCreateWithJPEGDataProvider2((uint64_t)v59, 0, 0, 1, 0);
            if (v2)
            {
              if (is_jpg_image(a1))
              {
                if (CGImageCreateCopyWithResolvedOptions_predicate_69 != -1)
                  dispatch_once(&CGImageCreateCopyWithResolvedOptions_predicate_69, &__block_literal_global_71_4698);
                CopyWithResolvedOptions_f_68 = (const __CFData *)CGImageCreateCopyWithResolvedOptions_f_68(a1);
              }
              else
              {
                DataProviderInternal = CGImageGetDataProviderInternal((char *)a1, 0);
                CopyWithResolvedOptions_f_68 = CGDataProviderCopyData((CGDataProviderRef)DataProviderInternal);
              }
              v62 = CopyWithResolvedOptions_f_68;
              if (CopyWithResolvedOptions_f_68
                && ((Length = CFDataGetLength(CopyWithResolvedOptions_f_68),
                     v77 = CFDataGetLength(v80),
                     CFRelease(v62),
                     Length > v77)
                  ? (v63 = 1)
                  : (v63 = v16),
                    v63 != 1))
              {
                CFRelease(v2);
                v2 = 0;
              }
              else
              {
                copy_image_mask_and_matte((uint64_t)v2, (uint64_t **)a1);
              }
              v58 = v81;
            }
            CGDataProviderRelease(provider);
          }
          else
          {
            v2 = 0;
          }
          CFRelease(v58);
        }
        else
        {
          v2 = 0;
        }
        CFRelease(v54);
      }
      else
      {
        v2 = 0;
      }
      if (Mutable)
        CFRelease(Mutable);
    }
    else
    {
      v2 = 0;
    }
    if ((v48 & 1) == 0)
    {
      if (v2)
      {
        if (CopyWithImageProvider)
          CFRelease(CopyWithImageProvider);
      }
      else
      {
        v2 = (const __CFDictionary *)CopyWithImageProvider;
      }
    }
LABEL_7:
    if (!((unint64_t)v9 | v8))
    {
      a1 = (uint64_t)v2;
LABEL_21:
      CGImageSetCachingFlags((_BYTE *)a1, 1);
      return a1;
    }
    if (v2)
      v10 = v2;
    else
      v10 = (CGImage *)a1;
    Copy = CGImageCreateCopy(v10);
    a1 = (uint64_t)Copy;
    if (v9)
    {
      if (CGImageSetColorConversionInfoOptions((uint64_t)Copy, v9))
      {
LABEL_19:
        if (v2)
          CFRelease(v2);
        goto LABEL_21;
      }
    }
    else if ((CGImageSetColorConversionInfoPayload((uint64_t)Copy, (const void *)v8) & 1) != 0)
    {
      goto LABEL_19;
    }
    if (a1)
      CFRelease((CFTypeRef)a1);
    a1 = 0;
    goto LABEL_19;
  }
  ImageProvider = CGImageGetImageProvider((_QWORD *)a1);
  if (v18 == (const void *)*MEMORY[0x1E0C9AE40])
  {
    v21 = ImageProvider;
    if (ImageProvider)
    {
      v22 = ImageProvider[15];
      if (v22)
      {
        if (CGPropertiesGetProperty(v22, CFSTR("kCGImagePreferGPUForColorConversion")))
        {
          if (get_disable_GPU_provider_options_predicate != -1)
            dispatch_once(&get_disable_GPU_provider_options_predicate, &__block_literal_global_285);
          v23 = (const void *)get_disable_GPU_provider_options_options_singleton;
          v30 = CFGetTypeID(v21);
          if (kCGImageProviderContentHeadroom_block_invoke_once != -1)
            dispatch_once(&kCGImageProviderContentHeadroom_block_invoke_once, &__block_literal_global_69_3132);
          if (v30 != CGImageProviderGetTypeID_image_provider_type_id)
            return 0;
          Instance = CGTypeCreateInstance(CGImageProviderGetTypeID_image_provider_type_id, 152, v24, v25, v26, v27, v28, v29);
          if (!Instance)
            return 0;
          v39 = Instance;
          *(_QWORD *)(Instance + 56) = Instance;
          *(_OWORD *)(Instance + 16) = *((_OWORD *)v21 + 1);
          *(_QWORD *)(Instance + 32) = v21[4];
          v40 = v21[5];
          if (v40)
            CFRetain((CFTypeRef)v21[5]);
          *(_QWORD *)(v39 + 40) = v40;
          *(_QWORD *)(v39 + 48) = v21[6];
          v41 = 0uLL;
          switch(*((_DWORD *)v21 + 16))
          {
            case 0:
              CGPostError((uint64_t)"We should not need CGImageProviderCreateCopyWithOptions with version 0", v32, v33, v34, v35, v36, v37, v38, v76);
              v41 = 0uLL;
              v42 = 0;
              v43 = 0;
              v44 = 0;
              v45 = copy_with_options_release_info;
              v46 = copy_with_options_copy_block_set;
              break;
            case 1:
              v43 = 0;
              v44 = 0;
              v45 = copy_with_options_release_info;
              v42 = 1;
              v46 = copy_with_options_copy_block_set_with_options;
              break;
            case 2:
              v44 = 0;
              v43 = *((_DWORD *)v21 + 17);
              *(_QWORD *)&v41 = copy_with_options_release_info;
              v45 = (void (*)(uint64_t))v21[10];
              v46 = copy_with_options_copy_block_set_with_options;
              v42 = 2;
              break;
            case 3:
              v43 = *((_DWORD *)v21 + 17);
              v45 = (void (*)(uint64_t))v21[10];
              v44 = copy_with_options_release_info;
              v42 = 3;
              v46 = copy_with_options_copy_block_set_with_options;
              v41 = *(_OWORD *)(v21 + 11);
              break;
            default:
              v42 = 0;
              v43 = 0;
              v46 = 0;
              v45 = 0;
              v44 = 0;
              break;
          }
          *(_DWORD *)(v39 + 64) = v42;
          *(_DWORD *)(v39 + 68) = v43;
          *(_QWORD *)(v39 + 72) = v46;
          *(_QWORD *)(v39 + 80) = v45;
          *(_OWORD *)(v39 + 88) = v41;
          *(_QWORD *)(v39 + 104) = v44;
          if (v23)
            v64 = CFRetain(v23);
          else
            v64 = 0;
          *(_QWORD *)(v39 + 112) = v64;
          v65 = (unsigned int *)v21[15];
          if (v65)
          {
            do
              v66 = __ldxr(v65);
            while (__stxr(v66 + 1, v65));
          }
          *(_QWORD *)(v39 + 120) = v65;
          *(_WORD *)(v39 + 128) = *((_WORD *)v21 + 64);
          CFRetain(v21);
          *(_QWORD *)(v39 + 144) = v21;
          *(_DWORD *)(v39 + 132) = *((_DWORD *)v21 + 33);
          v67 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          *(_QWORD *)(v39 + 160) = v67;
          context[0] = 0;
          context[1] = v21;
          context[2] = v67;
          if (v23)
          {
            CFDictionaryApplyFunction((CFDictionaryRef)v23, (CFDictionaryApplierFunction)find_supported_options, context);
            v75 = context[0];
          }
          else
          {
            v75 = 0;
          }
          *(_BYTE *)(v39 + 152) = v75;
          *(_QWORD *)(v39 + 136) = create_debug_string(v39, v68, v69, v70, v71, v72, v73, v74);
          CopyWithImageProvider = (_BYTE *)CGImageCreateCopyWithImageProvider((char *)a1, v39);
          CGImageSetCachingFlags(CopyWithImageProvider, 1);
          CFRelease((CFTypeRef)v39);
          v48 = 0;
          a1 = (uint64_t)CopyWithImageProvider;
          goto LABEL_45;
        }
      }
    }
  }
  if (a1)
    CFRetain((CFTypeRef)a1);
  return a1;
}

CGImageRef CGImageCreateWithJPEGDataProvider2(uint64_t a1, CGColorSpace *a2, double *a3, int a4, unsigned __int8 a5)
{
  uint64_t v10;
  const void *v11;
  const void *v12;
  CFDictionaryRef v13;
  uint64_t v14;
  int v15;
  CGImageRef CopyWithColorSpace;
  CGColorSpaceRef ColorSpace;
  unint64_t v19;
  const void *v20;
  void *keys;

  if (CGImageCreateWithJPEGDataProvider2_predicate[0] != -1)
    dispatch_once(CGImageCreateWithJPEGDataProvider2_predicate, &__block_literal_global_74_4712);
  v10 = CGImageCreateWithJPEGDataProvider2_f(a1, 0);
  if (!v10)
    return 0;
  v11 = (const void *)v10;
  if (CGImageCreateWithJPEGDataProvider2_predicate_77 != -1)
    dispatch_once(&CGImageCreateWithJPEGDataProvider2_predicate_77, &__block_literal_global_79);
  v12 = (const void *)CGImageCreateWithJPEGDataProvider2_f_76(v11);
  if (!v12 || !CFEqual(v12, CFSTR("public.jpeg")))
  {
    CFRelease(v11);
    return 0;
  }
  v20 = (const void *)*MEMORY[0x1E0C9AE40];
  keys = CFSTR("kCGImageSourceShouldCache");
  v13 = CFDictionaryCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (const void **)&keys, &v20, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (CGImageCreateWithJPEGDataProvider2_predicate_84 != -1)
    dispatch_once(&CGImageCreateWithJPEGDataProvider2_predicate_84, &__block_literal_global_86_4714);
  v14 = CGImageCreateWithJPEGDataProvider2_f_83(v11, 0, v13);
  CFRelease(v13);
  CFRelease(v11);
  if (v14)
  {
    if (a4)
      v15 = 0x1000000;
    else
      v15 = 0;
    *(_DWORD *)(v14 + 36) = v15 & 0xFFFF00FF | (a5 << 8) | *(_DWORD *)(v14 + 36) & 0xFEFF00FF;
    if (a2)
    {
      cgimage_set_decode_array((void **)v14, a3, *(_QWORD *)(*((_QWORD *)a2 + 3) + 40));
      CopyWithColorSpace = CGImageCreateCopyWithColorSpace((CGImageRef)v14, a2);
      CFRelease((CFTypeRef)v14);
      return CopyWithColorSpace;
    }
    if (a3 || !*(_QWORD *)(v14 + 160))
    {
      ColorSpace = CGImageGetColorSpace((CGImageRef)v14);
      if (ColorSpace)
        v19 = *(_QWORD *)(*((_QWORD *)ColorSpace + 3) + 40);
      else
        v19 = 0;
      cgimage_set_decode_array((void **)v14, a3, v19);
    }
  }
  return (CGImageRef)v14;
}

BOOL is_jpg_image(uint64_t a1)
{
  uint64_t v1;
  const void *Property;
  _BOOL8 result;

  result = 0;
  if (a1)
  {
    v1 = *(_QWORD *)(a1 + 216);
    if (v1)
    {
      Property = CGPropertiesGetProperty(v1, CFSTR("com.apple.ImageIO.imageSourceTypeIdentifier"));
      if (Property)
      {
        if (CFEqual(Property, CFSTR("public.jpeg")))
          return 1;
      }
    }
  }
  return result;
}

_QWORD *copy_image_mask_and_matte(uint64_t a1, uint64_t **image)
{
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;

  result = CGImageGetColorSpace((CGImageRef)image);
  if (result)
    v5 = *(_QWORD *)(result[3] + 40);
  else
    v5 = 0;
  if (image[21])
  {
    result = malloc_type_malloc(16 * v5, 0x100004000313F17uLL);
    *(_QWORD *)(a1 + 168) = result;
    if (result)
    {
      v6 = 2 * v5;
      if (2 * v5)
      {
        v7 = image[21];
        do
        {
          v8 = *v7++;
          *result++ = v8;
          --v6;
        }
        while (v6);
      }
    }
  }
  if (image[23])
  {
    result = malloc_type_malloc(8 * v5, 0x100004000313F17uLL);
    *(_QWORD *)(a1 + 184) = result;
    if (result)
    {
      if (v5)
      {
        v9 = image[23];
        do
        {
          v10 = *v9++;
          *result++ = v10;
          --v5;
        }
        while (v5);
      }
    }
  }
  *(_DWORD *)(a1 + 36) = *(_DWORD *)(a1 + 36) & 0xF7FFFFFF | (((*((_DWORD *)image + 9) >> 27) & 1) << 27);
  v11 = image[22];
  if (v11)
    result = CFRetain(v11);
  *(_QWORD *)(a1 + 176) = v11;
  return result;
}

BOOL CGImageSetColorConversionInfoOptions(uint64_t a1, const __CFDictionary *a2)
{
  CFTypeID v4;
  unint64_t *v5;
  _DWORD *v6;
  _BOOL8 v8;
  CGColorSpaceRef ColorSpace;
  __int16 BitmapInfo;
  CFDictionaryRef v11;
  CFDictionaryRef v12;
  BOOL v13;
  CFDictionaryRef v14;
  uint64_t v15;

  if (!a1)
    return 0;
  v4 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  if (v4 != CGImageGetTypeID_image_type_id)
    return 0;
  pthread_mutex_lock((pthread_mutex_t *)(a1 + 80));
  v5 = (unint64_t *)(a1 + 224);
  if (!*(_QWORD *)(a1 + 224))
  {
    v6 = CGPropertiesCreate();
    while (!__ldxr(v5))
    {
      if (!__stxr((unint64_t)v6, v5))
        goto LABEL_12;
    }
    __clrex();
    CGPropertiesRelease((uint64_t)v6);
  }
LABEL_12:
  pthread_mutex_unlock((pthread_mutex_t *)(a1 + 80));
  ColorSpace = CGImageGetColorSpace((CGImageRef)a1);
  BitmapInfo = CGImageGetBitmapInfo((CGImageRef)a1);
  v11 = CGColorConversionInfoResolveOptions((uint64_t)ColorSpace, BitmapInfo, a2);
  v12 = v11;
  if (v11)
    v13 = 1;
  else
    v13 = a2 == 0;
  if (v13)
    v14 = v11;
  else
    v14 = 0;
  v8 = v14 != 0;
  v15 = *(_QWORD *)(a1 + 224);
  if (!v14)
  {
    CGPropertiesRemoveProperty(v15, CFSTR("kCGColorConversionInfoOptions"));
    if (!v12)
      return v8;
    goto LABEL_20;
  }
  CGPropertiesSetProperty(v15, CFSTR("kCGColorConversionInfoOptions"), v14);
  if (v12)
LABEL_20:
    CFRelease(v12);
  return v8;
}

uint64_t CGImageSetColorConversionInfoPayload(uint64_t result, const void *a2)
{
  uint64_t v3;
  CFTypeID v4;
  pthread_mutex_t *v5;
  unint64_t *v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t v10;

  if (result)
  {
    v3 = result;
    v4 = CFGetTypeID((CFTypeRef)result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v4 == CGImageGetTypeID_image_type_id)
    {
      v5 = (pthread_mutex_t *)(v3 + 80);
      pthread_mutex_lock((pthread_mutex_t *)(v3 + 80));
      v7 = *(_QWORD *)(v3 + 224);
      v6 = (unint64_t *)(v3 + 224);
      if (!v7)
      {
        v8 = CGPropertiesCreate();
        while (!__ldxr(v6))
        {
          if (!__stxr((unint64_t)v8, v6))
            goto LABEL_11;
        }
        __clrex();
        CGPropertiesRelease((uint64_t)v8);
      }
LABEL_11:
      pthread_mutex_unlock(v5);
      v10 = *v6;
      if (a2)
      {
        CGPropertiesSetProperty(v10, CFSTR("kCGColorConversionInfoPayload"), a2);
        return 1;
      }
      CGPropertiesRemoveProperty(v10, CFSTR("kCGColorConversionInfoPayload"));
    }
    return 0;
  }
  return result;
}

CGImageRef CGImageCreateWithJPEGDataProvider(CGDataProviderRef source, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return CGImageCreateWithJPEGDataProvider2((uint64_t)source, 0, (double *)decode, shouldInterpolate, intent);
}

CGImageRef CGImageCreateWithMaskAndMatte(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  CGImageRef v3;
  int v8;
  uint64_t v9;
  CGColorSpace *DeviceGray;
  CGImageRef v11;
  CGFloat *v12;
  CGFloat v13;
  CGImageRef CopyWithColorSpace;
  CGImageRef Copy;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  CGFloat decode[3];

  v3 = 0;
  decode[2] = *(CGFloat *)MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return v3;
  if ((*(_BYTE *)(a1 + 39) & 0xA) != 0 || *(_QWORD *)(a1 + 192))
    return 0;
  v8 = *(_DWORD *)(a2 + 36);
  if ((v8 & 0x2000000) != 0)
  {
    v12 = *(CGFloat **)(a2 + 160);
    if (v12)
    {
      decode[0] = v12[1];
      v13 = *v12;
    }
    else
    {
      decode[0] = 1.0;
      v13 = 0.0;
    }
    decode[1] = v13;
    DeviceGray = CGColorSpaceCreateDeviceGray();
    CopyWithColorSpace = CGImageCreate(*(_QWORD *)(a2 + 40), *(_QWORD *)(a2 + 48), *(_QWORD *)(a2 + 56), *(_QWORD *)(a2 + 64), *(_QWORD *)(a2 + 72), DeviceGray, 0, *(CGDataProviderRef *)(a2 + 152), decode, *(_DWORD *)(a2 + 36) & 0x1000000, kCGRenderingIntentDefault);
    goto LABEL_17;
  }
  if ((v8 & 0xC000000) != 0)
    return 0;
  v9 = *(_QWORD *)(a2 + 144);
  if (!v9 || *(_DWORD *)(*(_QWORD *)(v9 + 24) + 24))
    return 0;
  DeviceGray = CGColorSpaceCreateDeviceGray();
  if (!CGColorSpaceEqualToColorSpace(*(_QWORD *)(a2 + 144), (uint64_t)DeviceGray))
  {
    CopyWithColorSpace = CGImageCreateCopyWithColorSpace((CGImageRef)a2, DeviceGray);
LABEL_17:
    v11 = CopyWithColorSpace;
    goto LABEL_18;
  }
  CFRetain((CFTypeRef)a2);
  v11 = (CGImageRef)a2;
LABEL_18:
  CGColorSpaceRelease(DeviceGray);
  if (a3 && (*(_QWORD *)(a1 + 40) != *(_QWORD *)(a2 + 40) || *(_QWORD *)(a1 + 48) != *(_QWORD *)(a2 + 48))
    || (Copy = CGImageCreateCopy((CGImageRef)a1)) == 0)
  {
    if (v11)
      CFRelease(v11);
    return 0;
  }
  v3 = Copy;
  *((_QWORD *)Copy + 22) = v11;
  *((_DWORD *)Copy + 9) |= 0x8000000u;
  if (a3)
  {
    v16 = *((_QWORD *)Copy + 18);
    if (v16)
      v17 = *(_QWORD *)(*(_QWORD *)(v16 + 24) + 40);
    else
      v17 = 0;
    v18 = malloc_type_malloc(8 * v17, 0x705560E0uLL);
    for (*((_QWORD *)v3 + 23) = v18; v17; --v17)
    {
      v19 = *a3++;
      *v18++ = v19;
    }
  }
  return v3;
}

CGImageRef CGImageCreateWithMaskingColor(CGImage *a1, uint64_t a2, __n128 a3)
{
  CGImageRef v3;
  uint64_t v6;
  unint64_t v7;
  CGFloat *v8;
  CGFloat *v9;
  uint64_t v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  _QWORD v16[2];

  v3 = 0;
  v16[1] = *MEMORY[0x1E0C80C00];
  if (!a1 || !a2)
    return v3;
  if (*((_QWORD *)a1 + 24))
    return 0;
  v6 = *((_QWORD *)a1 + 18);
  if (v6)
  {
    v7 = *(_QWORD *)(*(_QWORD *)(v6 + 24) + 40);
    if (v7 >> 61)
    {
      MEMORY[0x1E0C80A78](a1, a3);
      v8 = (CGFloat *)&v15;
      v9 = 0;
      goto LABEL_17;
    }
    v10 = 8 * v7;
  }
  else
  {
    v7 = 0;
    v10 = 0;
  }
  v11 = MEMORY[0x1E0C80A78](v10, a3);
  v8 = (CGFloat *)((char *)v16 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  if (v7 <= 0x1FFFFFFFFFFFFFFELL)
    v9 = (CGFloat *)((char *)v16 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0));
  else
    v9 = 0;
  if (v7 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000022)
  {
    v9 = (CGFloat *)malloc_type_malloc(v11, 0x14038CB1uLL);
  }
  else if (!v7)
  {
    goto LABEL_19;
  }
LABEL_17:
  v13 = 0;
  do
  {
    v9[v13] = (double)*(int *)(a2 + 4 * v13);
    ++v13;
  }
  while (v7 != v13);
LABEL_19:
  v3 = CGImageCreateWithMaskingColors(a1, v9);
  if (v9 != v8)
    free(v9);
  return v3;
}

CGImageRef CGImageCreateWithMaskingColors(CGImageRef image, const CGFloat *components)
{
  CGImageRef v2;
  const CGFloat *v3;
  CGImageRef Copy;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;

  v2 = 0;
  if (image)
  {
    v3 = components;
    if (components)
    {
      if ((*((_BYTE *)image + 39) & 0xE) != 0 || *((_QWORD *)image + 24))
        return 0;
      Copy = CGImageCreateCopy(image);
      v2 = Copy;
      if (!Copy)
        return v2;
      v6 = *((_QWORD *)Copy + 18);
      if (v6)
        v7 = *(_QWORD *)(*(_QWORD *)(v6 + 24) + 40);
      else
        v7 = 0;
      v8 = malloc_type_malloc(16 * v7, 0x705560E0uLL);
      if (!v8)
      {
        CFRelease(v2);
        return 0;
      }
      v9 = 2 * v7;
      if (2 * v7)
      {
        v10 = v8;
        do
        {
          v11 = *(_QWORD *)v3++;
          *v10++ = v11;
          --v9;
        }
        while (v9);
      }
      *((_QWORD *)v2 + 21) = v8;
      *((_DWORD *)v2 + 9) |= 0x8000000u;
    }
  }
  return v2;
}

uint64_t CGImageCreateWithEPSDataProvider(CGDataProvider *a1, uint64_t a2)
{
  uint64_t image_base;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  double v14;
  uint64_t v15;
  uint64_t v16;

  if (!a1)
    return 0;
  if ((*(_BYTE *)(a2 + 39) & 2) != 0)
    return 0;
  if (*(_QWORD *)(a2 + 192))
    return 0;
  v4 = CGImageEPSRepCreate(a1, (const void *)a2);
  if (!v4)
    return 0;
  v12 = (uint64_t)v4;
  image_base = create_image_base((uint64_t)v4, v5, v6, v7, v8, v9, v10, v11);
  if (image_base)
  {
    v13 = *(double *)(v12 + 40);
    v14 = *(double *)(v12 + 48);
    if (v13 < 0.0 || v14 < 0.0)
    {
      v15 = *(_QWORD *)(v12 + 24);
      v16 = *(_QWORD *)(v12 + 32);
      *(CGRect *)(&v13 - 2) = CGRectStandardize(*(CGRect *)(&v13 - 2));
    }
    *(_QWORD *)(image_base + 40) = (unint64_t)v13;
    *(_QWORD *)(image_base + 48) = (unint64_t)v14;
    *(_DWORD *)(image_base + 32) = 0;
    *(_QWORD *)(image_base + 192) = v12;
    *(_WORD *)(image_base + 36) = 1;
    *(_OWORD *)(image_base + 232) = 0u;
    *(_OWORD *)(image_base + 248) = 0u;
  }
  else
  {
    CGImageEPSRepRelease(v12);
  }
  return image_base;
}

CGImageRef CGImageCreateWithMask(CGImageRef image, CGImageRef mask)
{
  return CGImageCreateWithMaskAndMatte((uint64_t)image, (uint64_t)mask, 0);
}

uint64_t create_subsampled_image_provider(uint64_t a1, int a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v12;
  const __CFString *v13;
  const __CFDictionary *v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  CFNumberRef v18;
  const CGSize *v19;
  double v20;
  double *p_height;
  uint64_t v22;
  CFIndex Count;
  __n128 v24;
  CFIndex v25;
  unint64_t v26;
  unint64_t v27;
  const void **v28;
  size_t v29;
  uint64_t v30;
  __n128 v31;
  const void **v32;
  const void *v33;
  const void *v34;
  const void *v35;
  _BYTE v37[4];
  int valuePtr;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  if (a4)
  {
    v12 = *(_QWORD *)(a4 + 120);
    if (!v12)
      goto LABEL_10;
    v13 = CFSTR("kCGImageProviderAlphaIsNotPremultiplied");
    values = (void *)CGPropertiesGetProperty(v12, CFSTR("kCGImageProviderAlphaIsNotPremultiplied"));
    if (values
      || (v15 = *(_QWORD *)(a4 + 120)) != 0
      && ((v13 = CFSTR("kCGImageProviderAlphaIsPremultiplied"),
           (values = (void *)CGPropertiesGetProperty(v15, CFSTR("kCGImageProviderAlphaIsPremultiplied"))) != 0)
       || (v16 = *(_QWORD *)(a4 + 120)) != 0
       && (v13 = CFSTR("kCGImageProviderAlphaIsOne"),
           (values = (void *)CGPropertiesGetProperty(v16, CFSTR("kCGImageProviderAlphaIsOne"))) != 0)))
    {
      keys[0] = (void *)v13;
      v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    }
    else
    {
LABEL_10:
      v14 = 0;
    }
    v17 = *(_DWORD *)(a4 + 36);
    valuePtr = v17;
    if (!v14)
    {
      if (v17)
      {
        v18 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
        values = v18;
        keys[0] = CFSTR("kCGImageProviderBitmapInfo");
        v14 = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
        if (v18)
          CFRelease(v18);
      }
    }
  }
  else
  {
    v14 = 0;
    valuePtr = 0;
  }
  v19 = (const CGSize *)(a1 + 16);
  if (!a1)
    v19 = &CGSizeZero;
  v20 = fabs(round(v19->width));
  p_height = (double *)(a1 + 24);
  if (!a1)
    p_height = &CGSizeZero.height;
  v22 = CGImageProviderCreate(a2, a3, a1, (uint64_t)&subsampled_image_callbacks, v14, a6, a7, a8, (double)(unint64_t)v20, (double)(unint64_t)fabs(round(*p_height)));
  if (v14)
  {
    Count = CFDictionaryGetCount(v14);
    if (Count)
    {
      v25 = Count;
      v26 = 8 * Count;
      MEMORY[0x1E0C80A78](Count, v24);
      v27 = (v26 + 15) & 0xFFFFFFFFFFFFFFF0;
      v28 = (const void **)&v37[-v27];
      if (v26 >= 0x200)
        v29 = 512;
      else
        v29 = v26;
      bzero(&v37[-v27], v29);
      MEMORY[0x1E0C80A78](v30, v31);
      v32 = (const void **)&v37[-v27];
      bzero(&v37[-v27], v29);
      CFDictionaryGetKeysAndValues(v14, (const void **)&v37[-v27], (const void **)&v37[-v27]);
      do
      {
        v34 = *v28++;
        v33 = v34;
        v35 = *v32++;
        CGImageProviderSetProperty(v22, v33, v35);
        --v25;
      }
      while (v25);
    }
    CFRelease(v14);
  }
  return v22;
}

unsigned int *subsampled_image_copy_image_block_set(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v4;

  v3 = 0;
  if (a2 && !a3 && a1)
  {
    do
      v4 = __ldxr(a1);
    while (__stxr(v4 + 1, a1));
    return a1;
  }
  return (unsigned int *)v3;
}

CFDictionaryRef __block_set_options_block_invoke()
{
  CFDictionaryRef result;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  keys[0] = CFSTR("kCGImageBlockSingletonRequest");
  values = (void *)*MEMORY[0x1E0C9AE50];
  result = CFDictionaryCreate(0, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  block_set_options_options_singleton = (uint64_t)result;
  return result;
}

CGImageByteOrderInfo CGImageGetByteOrderInfo(CGImageRef image)
{
  CGImageRef v1;
  CFTypeID v2;

  if (image)
  {
    v1 = image;
    v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v2 == CGImageGetTypeID_image_type_id)
      LODWORD(image) = *((_DWORD *)v1 + 8) & 0x7000;
    else
      LODWORD(image) = 0;
  }
  return image;
}

CGImagePixelFormatInfo CGImageGetPixelFormatInfo(CGImageRef image)
{
  CGImageRef v1;
  CFTypeID v2;

  if (image)
  {
    v1 = image;
    v2 = CFGetTypeID(image);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v2 == CGImageGetTypeID_image_type_id)
      LODWORD(image) = *((_DWORD *)v1 + 8) & 0xF0000;
    else
      LODWORD(image) = 0;
  }
  return image;
}

CFStringRef CGImageGetUTType(CGImageRef image)
{
  CFTypeID v2;
  uint64_t v3;

  if (!image)
    return 0;
  v2 = CFGetTypeID(image);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  if (v2 == CGImageGetTypeID_image_type_id && (v3 = *((_QWORD *)image + 27)) != 0)
    return (CFStringRef)CGPropertiesGetProperty(v3, CFSTR("com.apple.ImageIO.imageSourceTypeIdentifier"));
  else
    return 0;
}

char *CGImageGetData(char *result, uint64_t a2, unint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6)
{
  char *v10;
  CFTypeID v11;
  unint64_t v12;
  CGDataProvider *v13;
  int v14;
  CGDataProvider *v15;
  uint64_t *i;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  int v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int v36;
  unint64_t v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  _BYTE *v43;
  char *v44;
  uint64_t v45;
  unint64_t v46;
  int v47;
  unint64_t v48;
  BOOL v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  unsigned int v56;
  unint64_t v57;
  uint64_t v58;
  _BYTE v60[256];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  if (result)
  {
    v10 = result;
    v11 = CFGetTypeID(result);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v11 != CGImageGetTypeID_image_type_id)
      return 0;
    result = 0;
    v12 = *((_QWORD *)v10 + 7);
    if (v12 > a4 || v12 - 9 < 0xFFFFFFFFFFFFFFF8)
      return result;
    if (*((_QWORD *)v10 + 6) <= a3)
      return 0;
    if (*((_QWORD *)v10 + 19) || (result = CGImageGetDataProviderInternal(v10, 0)) != 0)
    {
      if ((*((_DWORD *)v10 + 8) & 0x7000) == 0x2000)
      {
        v13 = (CGDataProvider *)*((_QWORD *)v10 + 19);
        v14 = 4;
      }
      else
      {
        if ((*((_DWORD *)v10 + 8) & 0x7000) != 0x1000)
        {
          v15 = (CGDataProvider *)*((_QWORD *)v10 + 19);
          CGDataProviderRetain(v15);
          goto LABEL_18;
        }
        v13 = (CGDataProvider *)*((_QWORD *)v10 + 19);
        v14 = 2;
      }
      v15 = CGDataProviderCreateWithSwappedProvider(v13, v14);
LABEL_18:
      for (i = CGAccessSessionCreate(v15); a3; --a3)
        CGAccessSessionSkipForward((uint64_t)i, *((_QWORD *)v10 + 9));
      if ((v10[39] & 2) != 0)
      {
        v22 = 1;
      }
      else
      {
        v17 = *((_QWORD *)v10 + 18);
        if (v17)
          v17 = *(_QWORD *)(*(_QWORD *)(v17 + 24) + 40);
        v18 = *((_DWORD *)v10 + 8) & 0x1F;
        v19 = v18 > 6;
        v20 = (1 << v18) & 0x61;
        if (v19 || v20 == 0)
          v22 = v17 + 1;
        else
          v22 = v17;
      }
      v28 = (char *)malloc_type_malloc(*((_QWORD *)v10 + 9), 0x2062DE7BuLL);
      if (!a2)
        goto LABEL_86;
      v29 = 0;
      while (1)
      {
        CGAccessSessionGetBytes(i, v28, *((_QWORD *)v10 + 9), v23, v24, v25, v26, v27);
        v30 = 0;
        v31 = 0;
        v32 = *((_QWORD *)v10 + 7);
        v33 = 0xFFFFFFFF >> -(char)v32;
        do
        {
          v60[v31++] = v30 / v33;
          v30 += 0xFFFFFFFF >> -(char)a4;
        }
        while (v33 + 1 != v31);
        if (!*((_QWORD *)v10 + 5))
          goto LABEL_85;
        v34 = 0;
        v35 = 0;
        v36 = 0;
        v37 = 0;
        v38 = 0;
        v39 = v32 * v22;
        v40 = *((_QWORD *)v10 + 8);
        v41 = v40 - v32 * v22;
        v42 = &v28[*((_QWORD *)v10 + 9)];
        v43 = (_BYTE *)(a6 + v29 * a5);
        v44 = v28;
        do
        {
          if (v22)
          {
            v45 = 0;
            while (1)
            {
              v46 = *((_QWORD *)v10 + 7);
              if (v46 < 0x19)
                break;
              if (v37 > 0x17)
              {
                v48 = v37;
              }
              else
              {
                do
                {
                  v38 <<= 8;
                  if (v44 < v42)
                  {
                    v47 = *v44++;
                    v38 |= v47;
                  }
                  v48 = v37 + 8;
                  v49 = v37 >= 0x10;
                  v37 += 8;
                }
                while (!v49);
              }
              v46 -= 24;
              v37 = v48 - 24;
              v50 = ((v38 >> (v48 - 24)) & 0xFFFFFF) << v46;
              if (v46)
                goto LABEL_53;
LABEL_55:
              v52 = v60[v46 | v50];
              if (a4 >= 0x19)
              {
                if (v34 >= 8)
                {
                  do
                  {
                    v34 -= 8;
                    *v43++ = v36 >> v34;
                  }
                  while (v34 > 7);
                }
                v36 = (v52 >> (a4 - 24)) | (v36 << 24);
                v34 |= 0x18uLL;
                v24 = a4 - 24;
                do
                {
LABEL_60:
                  v34 -= 8;
                  *v43++ = v36 >> v34;
                }
                while (v34 > 7);
                v25 = 0xFFFFFFFF >> -(char)v24;
                v26 = v24;
                goto LABEL_62;
              }
              v24 = a4;
              v25 = 0xFFFFFFFF >> -(char)a4;
              v26 = a4;
              if (v34 >= 8)
                goto LABEL_60;
LABEL_62:
              v23 = v25 & v52;
              v36 = (v36 << v26) | v23;
              v34 += v24;
              if (++v45 == v22)
                goto LABEL_63;
            }
            v50 = 0;
            if (!v46)
              goto LABEL_55;
LABEL_53:
            while (v37 < v46)
            {
              v38 <<= 8;
              if (v44 < v42)
              {
                v51 = *v44++;
                v38 |= v51;
              }
              v37 += 8;
            }
            v37 -= v46;
            LODWORD(v46) = (v38 >> v37) & (0xFFFFFFFF >> -(char)v46);
            goto LABEL_55;
          }
LABEL_63:
          if (v40 != v39)
          {
            if (v41 < 0x19)
            {
              v55 = v41;
              if (!v41)
                goto LABEL_80;
LABEL_75:
              while (v37 < v55)
              {
                v38 <<= 8;
                if (v44 < v42)
                {
                  v56 = *v44++;
                  v23 = v56;
                  v38 |= v56;
                }
                v37 += 8;
              }
              v37 -= v55;
              goto LABEL_80;
            }
            if (v37 > 0x17)
            {
              v54 = v37;
            }
            else
            {
              do
              {
                v38 <<= 8;
                if (v44 < v42)
                {
                  v53 = *v44++;
                  v38 |= v53;
                }
                v54 = v37 + 8;
                v49 = v37 >= 0x10;
                v37 += 8;
              }
              while (!v49);
            }
            v37 = v54 - 24;
            v55 = v40 - v39 - 24;
            if (v40 - v39 != 24)
              goto LABEL_75;
          }
LABEL_80:
          ++v35;
        }
        while (v35 < *((_QWORD *)v10 + 5));
        for (; v34; v34 = v57 + v58)
        {
          v57 = v34;
          if (v34 >= 8)
          {
            do
            {
              v57 -= 8;
              *v43++ = v36 >> v57;
            }
            while (v57 > 7);
          }
          v58 = -(int)v34 & 7;
          v36 <<= v58;
        }
LABEL_85:
        if (++v29 == a2)
        {
LABEL_86:
          free(v28);
          CGAccessSessionRelease(i);
          CGDataProviderRelease(v15);
          return (char *)a2;
        }
      }
    }
  }
  return result;
}

uint64_t CGImageGetOrientation(uint64_t a1)
{
  if (a1)
    return *(unsigned __int8 *)(a1 + 38);
  else
    return 1;
}

double CGImageGetTransformForOrientation@<D0>(uint64_t a1@<X0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, CGAffineTransform *a8@<X8>)
{
  if (a1)
    return CGImageGetTransformForOrientationAndSize(*(unsigned __int8 *)(a1 + 38), a2, a3, a4, a5, a6, a7, (uint64_t)a8, (double)*(unint64_t *)(a1 + 40), (double)*(unint64_t *)(a1 + 48));
  *a8 = CGAffineTransformIdentity;
  return CGAffineTransformIdentity.tx;
}

double CGImageGetTransformForOrientationAndSize@<D0>(int a1@<W0>, uint64_t a2@<X2>, uint64_t a3@<X3>, uint64_t a4@<X4>, uint64_t a5@<X5>, uint64_t a6@<X6>, uint64_t a7@<X7>, uint64_t a8@<X8>, double a9@<D0>, double a10@<D1>)
{
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _QWORD v16[11];
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  double v21;
  double v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  __int128 v26;
  double v27;
  __int128 v28;
  __int128 v29;
  double v30;
  double v31;
  __int128 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  double v36;
  __int128 v37;
  uint64_t v38;
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  __int128 v42;
  double v43;
  uint64_t v44;
  uint64_t v45;

  v45 = *MEMORY[0x1E0C80C00];
  if ((a1 - 9) <= 0xFFFFFFF7 || a9 == 0.0 || a10 == 0.0)
  {
    CGLog(1, (uint64_t)"%s %s", a2, a3, a4, a5, a6, a7, (char)"CGImageGetTransformForOrientationAndSize");
    *(CGAffineTransform *)a8 = CGAffineTransformIdentity;
    *(CGFloat *)&v13 = CGAffineTransformIdentity.tx;
  }
  else
  {
    v16[0] = 0x3FF0000000000000;
    v16[1] = 0;
    v16[2] = 0;
    v16[3] = 0x3FF0000000000000;
    v16[4] = 0;
    v16[5] = 0;
    v16[6] = 0xBFF0000000000000;
    v16[7] = 0;
    v16[8] = 0;
    v16[9] = 0x3FF0000000000000;
    *(double *)&v16[10] = a9;
    v17 = xmmword_185004C40;
    v18 = 0;
    v19 = 0;
    v20 = 0xBFF0000000000000;
    v21 = a9;
    v22 = a10;
    v24 = 0;
    v25 = 0;
    v23 = 0x3FF0000000000000;
    v26 = xmmword_185004C50;
    v27 = a10;
    v28 = xmmword_185004C40;
    v29 = xmmword_185004C50;
    v30 = a10;
    v31 = a9;
    v32 = xmmword_185004C40;
    v34 = 0;
    v35 = 0;
    v33 = 0x3FF0000000000000;
    v36 = a9;
    v37 = xmmword_185004A20;
    v40 = 0u;
    v39 = 0u;
    v38 = 0x3FF0000000000000;
    v41 = 0x3FF0000000000000;
    v42 = xmmword_185004C50;
    v43 = a10;
    v44 = 0;
    v11 = (__int128 *)&v16[6 * (a1 - 1)];
    v12 = v11[2];
    v14 = *v11;
    v13 = v11[1];
    *(_OWORD *)(a8 + 16) = v13;
    *(_OWORD *)(a8 + 32) = v12;
    *(_OWORD *)a8 = v14;
  }
  return *(double *)&v13;
}

double CGImageGetSizeAfterOrientation(uint64_t a1)
{
  double result;

  if (!a1)
    return 0.0;
  result = (double)*(unint64_t *)(a1 + 40);
  if (*(unsigned __int8 *)(a1 + 38) << 16 > 0x40000u)
    return (double)*(unint64_t *)(a1 + 48);
  return result;
}

uint64_t CGClassifyRectilinearTransform(_OWORD *a1)
{
  __int128 v1;
  double v2;
  float v3;
  float v4;
  CGAffineTransform v6;
  CGAffineTransformComponents v7;

  v1 = a1[1];
  *(_OWORD *)&v6.a = *a1;
  *(_OWORD *)&v6.c = v1;
  *(_OWORD *)&v6.tx = a1[2];
  memset(&v7, 0, sizeof(v7));
  CGAffineTransformDecompose(&v7, &v6);
  v2 = (v7.rotation + v7.rotation) / 3.14159265;
  v3 = v2;
  v4 = rintf(v3);
  if (vabdd_f64(v2, v4) <= 1.42108547e-14 && fabs(v7.horizontalShear) <= 1.42108547e-14)
    return CGClassifyRectilinearTransform_rotations[2 * ((int)v4 & 3) + (v7.scale.width < 0.0)];
  else
    return 0;
}

const void *CGImageGetColorConversionInfoOptions(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 224)) != 0)
    return CGPropertiesGetProperty(v1, CFSTR("kCGColorConversionInfoOptions"));
  else
    return 0;
}

const void *CGImageGetColorConversionInfoPayload(uint64_t a1)
{
  uint64_t v1;

  if (a1 && (v1 = *(_QWORD *)(a1 + 224)) != 0)
    return CGPropertiesGetProperty(v1, CFSTR("kCGColorConversionInfoPayload"));
  else
    return 0;
}

CGColorSpaceRef CGImageGetNumberOfColorComponents(CGColorSpaceRef result)
{
  if (result)
  {
    if ((*((_BYTE *)result + 39) & 2) != 0)
    {
      return (CGColorSpaceRef)1;
    }
    else
    {
      result = CGImageGetColorSpace(result);
      if (result)
        return *(CGColorSpaceRef *)(*((_QWORD *)result + 3) + 40);
    }
  }
  return result;
}

unint64_t CGImageGetSize(_QWORD *a1)
{
  unint64_t v1;
  _QWORD *Mask;

  if (!a1)
    return 0;
  v1 = a1[5];
  Mask = CGImageGetMask(a1);
  if (Mask && Mask[5] > v1)
    return Mask[5];
  return v1;
}

CFStringRef CGImageCreateFileNameForBufferReader(CGImage *a1, char *__s)
{
  size_t v4;
  unsigned int v5;
  CGColorSpaceRef ColorSpace;
  uint64_t v7;
  CGBitmapInfo BitmapInfo;
  unsigned int v9;
  double *Matte;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  const char *v26;
  char v28;
  char __str[1024];
  char v30[1024];
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  if (!__s)
    return 0;
  v4 = strlen(__s);
  __strlcpy_chk();
  v5 = filename_ends_with_br2_extension(__s);
  if (v5)
    v30[v4 - 4] = 0;
  ColorSpace = CGImageGetColorSpace(a1);
  if (ColorSpace)
    v7 = *(int *)(*((_QWORD *)ColorSpace + 3) + 24);
  else
    v7 = -1;
  BitmapInfo = CGImageGetBitmapInfo(a1);
  if (CGImageGetPixelFormatInfo(a1) == kCGImagePixelFormatRGBCIF10 && CGImageGetMask(a1))
  {
    v9 = BitmapInfo & 0xFFFFFFE0;
    Matte = (double *)CGImageGetMatte(a1);
    if (!Matte)
    {
      BitmapInfo = v9 | 9;
      if (a1)
        goto LABEL_15;
      goto LABEL_17;
    }
    if (*Matte != 0.0 || Matte[1] != 0.0 || Matte[2] != 0.0)
      _CGHandleAssert("CGImageCreateFileNameForBufferReader", 4022, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Images/CGImage.c", "matte[0] == 0.0 && matte[1] == 0.0 && matte[2] == 0.0", "matte: {%f, %f, %f}", v11, v12, v13, *(_QWORD *)Matte);
    BitmapInfo = v9 | 8;
  }
  if (a1)
  {
LABEL_15:
    v14 = *((_QWORD *)a1 + 5);
    v15 = *((_QWORD *)a1 + 6);
    v16 = *((_QWORD *)a1 + 9);
    v17 = *((_QWORD *)a1 + 7);
    goto LABEL_18;
  }
LABEL_17:
  v16 = 0;
  v14 = 0;
  v15 = 0;
  v17 = 0;
LABEL_18:
  v18 = snprintf(__str, 0x400uLL, "%s_w=%ld,h=%ld,rb=%ld,cs=%ld,bpc=%ld,bmi=0x%08X", v30, v14, v15, v16, v7, v17, BitmapInfo);
  if (v18 >= 1025)
  {
    v26 = "Failed to format string because name is too long";
LABEL_25:
    CGPostError((uint64_t)v26, v19, v20, v21, v22, v23, v24, v25, v28);
    return 0;
  }
  if (v18 < 0)
  {
    v26 = "snprintf failed";
    goto LABEL_25;
  }
  if (v5)
    __strlcat_chk();
  return CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], __str, 0x8000100u);
}

const char *filename_ends_with_br2_extension(const char *result)
{
  const char *v1;
  size_t v2;

  if (result)
  {
    v1 = result;
    v2 = strlen(result);
    if (v2 < 4)
      return 0;
    else
      return (const char *)(strcmp(&v1[v2 - 4], ".br2") == 0);
  }
  return result;
}

void CGImageDumpToFile(uint64_t a1, char *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeID v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  std::__fs::filesystem::path *v17;
  __CFDictionary *Mutable;
  uint64_t v19;
  uint64_t v20;
  std::__fs::filesystem::path *v21;
  FILE *v22;
  FILE *v23;
  const void *v24;
  unint64_t v25;
  size_t v26;
  size_t v27;
  uint64_t v28;
  std::error_code *v29;
  int v30;
  char *v31;
  char *v32;
  uint64_t *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  const char *v39;
  FILE *v40;
  FILE *v41;
  const __CFString *FileNameForBufferReader;
  const __CFString *v43;
  __IOSurface *v44;
  __IOSurface *v45;
  size_t BytesPerRow;
  size_t Height;
  CGImage *Mask;
  char *v49;
  const __CFString *v50;
  const __CFString *v51;
  void *BaseAddress;
  const char *v53;
  int v54;
  int v55;
  const char *v56;
  char __s2[16];
  __int128 v58;
  __int128 v59;
  __int128 v60;
  std::__fs::filesystem::path __s[42];
  char buffer[1024];
  char __str[1025];
  uint64_t v64;

  v64 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return;
  bzero(__str, 0x401uLL);
  if (!a2)
    goto LABEL_31;
  v10 = CFGetTypeID((CFTypeRef)a1);
  if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
    dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
  if (v10 != CGImageGetTypeID_image_type_id)
  {
LABEL_31:
    CGLog(1, (uint64_t)"%s %s %s", v4, v5, v6, v7, v8, v9, (char)"CGImageDumpToFile");
    return;
  }
  if (*a2 == 42 && a2[1] == 47)
  {
    if (CGGetTempDirPath_predicate != -1)
      dispatch_once(&CGGetTempDirPath_predicate, &__block_literal_global_113);
    v56 = a2 + 2;
    a2 = __str;
    snprintf(__str, 0x400uLL, "%s%s", &CGGetTempDirPath_tempDirPath, v56);
  }
  if ((uint64_t)strlen(a2) >= 5
    && filename_ends_with_br2_extension(a2)
    && !strstr(a2, "w=")
    && (FileNameForBufferReader = CGImageCreateFileNameForBufferReader((CGImage *)a1, a2)) != 0)
  {
    v43 = FileNameForBufferReader;
    v17 = (std::__fs::filesystem::path *)buffer;
    CFStringGetCString(FileNameForBufferReader, buffer, 1024, 0x8000100u);
    CFRelease(v43);
  }
  else
  {
    v17 = 0;
  }
  if (!*(_QWORD *)(a1 + 208))
  {
    if (*(_QWORD *)(a1 + 152))
    {
      v31 = (char *)malloc_type_calloc(*(_QWORD *)(a1 + 72), *(_QWORD *)(a1 + 48), 0xCAD4762EuLL);
      if (v31)
      {
        v32 = v31;
        v33 = CGAccessSessionCreate(*(CGDataProvider **)(a1 + 152));
        CGAccessSessionGetBytes(v33, v32, *(_QWORD *)(a1 + 48) * *(_QWORD *)(a1 + 72), v34, v35, v36, v37, v38);
        CGAccessSessionRelease(v33);
        if (v17)
          v39 = (const char *)v17;
        else
          v39 = a2;
        v40 = fopen(v39, "w");
        if (v40)
        {
          v41 = v40;
          fwrite(v32, *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 72), v40);
          fclose(v41);
        }
        free(v32);
      }
    }
    goto LABEL_52;
  }
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CFDictionarySetValue(Mutable, CFSTR("kCGImageBlockSingletonRequest"), (const void *)*MEMORY[0x1E0C9AE50]);
  v19 = CGImageProviderCopyImageBlockSetWithOptions(*(_QWORD *)(a1 + 208), (uint64_t)Mutable);
  if (v19 || (v19 = CGImageProviderCopyImageBlockSetWithOptions(*(_QWORD *)(a1 + 208), 0)) != 0)
  {
    if (*(_QWORD *)(v19 + 120) == 1)
    {
      v20 = *(_QWORD *)(v19 + 128);
      if (v20)
      {
        v21 = v17 ? v17 : (std::__fs::filesystem::path *)a2;
        v22 = fopen((const char *)v21, "w");
        if (v22)
        {
          v23 = v22;
          v24 = *(const void **)v20;
          if (*(_QWORD *)v20)
          {
            v25 = *(_QWORD *)(v20 + 40);
            v26 = (unint64_t)((*(double *)(v20 + 24) * (double)*(unint64_t *)(a1 + 64) + 7.0) * 0.125
                                   + (*(double *)(v20 + 32) + -1.0) * (double)v25);
            v27 = fwrite(v24, 1uLL, v26, v23);
            fclose(v23);
            if (v27 == v26)
            {
              v28 = *(_QWORD *)(a1 + 72);
              if (v25 != v28)
              {
                v59 = 0u;
                v60 = 0u;
                *(_OWORD *)__s2 = 0u;
                v58 = 0u;
                snprintf(__s2, 0x3FuLL, "rb=%zu", v28);
                if (strstr((char *)v21, __s2))
                {
                  strlen(__s2);
                  __s[0].__pn_.__r_.__value_.__s.__data_[0] = 0;
                  __strncat_chk();
                  snprintf(__s2, 0x3FuLL, "rb=%zu", v25);
                  strlen((const char *)__s);
                  __strncat_chk();
                  strlen((const char *)__s);
                  __strncat_chk();
                  rename(v21, __s, v29);
                  if (!v30)
                    v17 = __s;
                }
              }
            }
          }
          else
          {
            fclose(v23);
          }
        }
      }
    }
    CGImageBlockSetRelease(v19);
  }
  else
  {
    v44 = (__IOSurface *)CGImageProviderCopyIOSurface(*(_QWORD *)(a1 + 208));
    if (!v44)
    {
      CFRelease(Mutable);
      goto LABEL_52;
    }
    v45 = v44;
    if (IOSurfaceGetPixelFormat(v44) == 1279340600)
    {
      BytesPerRow = IOSurfaceGetBytesPerRow(v45);
      Height = IOSurfaceGetHeight(v45);
      if (!IOSurfaceLock(v45, 1u, 0))
      {
        BaseAddress = IOSurfaceGetBaseAddress(v45);
        if (v17)
          v53 = (const char *)v17;
        else
          v53 = a2;
        v54 = open(v53, 1538, 511);
        if (v54 != -1)
        {
          v55 = v54;
          write(v54, BaseAddress, Height * BytesPerRow);
          close(v55);
        }
        IOSurfaceUnlock(v45, 1u, 0);
      }
    }
    CFRelease(v45);
  }
  CFRelease(Mutable);
LABEL_52:
  CGLog(1, (uint64_t)"%s %s %s", v11, v12, v13, v14, v15, v16, (char)"CGImageDumpToFile");
  if (CGImageGetPixelFormatInfo((CGImageRef)a1) == kCGImagePixelFormatRGBCIF10)
  {
    if (CGImageGetMask((_QWORD *)a1))
    {
      Mask = (CGImage *)CGImageGetMask((_QWORD *)a1);
      v49 = strstr((char *)v17, "w=");
      if (v49)
      {
        snprintf(v49, buffer - v49 + 1024, "(alpha).br2");
        v50 = CGImageCreateFileNameForBufferReader(Mask, (char *)v17);
        if (v50)
        {
          v51 = v50;
          CFStringGetCString(v50, buffer, 1024, 0x8000100u);
          CFRelease(v51);
          CGImageDumpToFile(Mask, buffer);
        }
      }
    }
  }
}

uint64_t CGImageWriteToFile(const void *a1, char *a2)
{
  uint64_t v4;
  CFTypeID v5;
  char *v6;
  const char *v7;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  char *v11;
  BOOL v12;
  BOOL v13;
  char *v14;
  uint64_t v15;
  const __CFString *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  const void *v25;
  int v26;
  const char *v28;
  char __dst[10];
  char __s[765];
  int v31;
  char v32;
  char __str[1025];
  uint64_t v34;

  v34 = *MEMORY[0x1E0C80C00];
  memset(__dst, 0, 7);
  bzero(__str, 0x401uLL);
  v4 = 0;
  if (a1 && a2)
  {
    v5 = CFGetTypeID(a1);
    if (kCGDefaultHDRImageContentHeadroom_block_invoke_once != -1)
      dispatch_once(&kCGDefaultHDRImageContentHeadroom_block_invoke_once, &__block_literal_global_211);
    if (v5 == CGImageGetTypeID_image_type_id)
    {
      if (*a2 == 42 && a2[1] == 47)
      {
        if (CGGetTempDirPath_predicate != -1)
          dispatch_once(&CGGetTempDirPath_predicate, &__block_literal_global_113);
        v28 = a2 + 2;
        a2 = __str;
        snprintf(__str, 0x400uLL, "%s%s", &CGGetTempDirPath_tempDirPath, v28);
      }
      v6 = strrchr(a2, 46);
      if (v6)
      {
        v7 = v6;
        v8 = strlen(v6);
        if (v8 <= 5)
        {
          v9 = v8;
          strncpy(__dst, v7, 6uLL);
          if (v9 >= 2)
          {
            v10 = v9 - 1;
            v11 = &__dst[1];
            do
            {
              *v11 = __tolower(*v11);
              ++v11;
              --v10;
            }
            while (v10);
          }
        }
      }
      if (!(*(_DWORD *)__dst ^ 0x6669742E | __dst[4])
        || (*(_DWORD *)__dst == 1718187054 ? (v12 = *(unsigned __int16 *)&__dst[4] == 102) : (v12 = 0), v12))
      {
        v16 = CFSTR("public.tiff");
      }
      else if (!(*(_DWORD *)__dst ^ 0x67706A2E | __dst[4])
             || (*(_DWORD *)__dst == 1701866030 ? (v13 = *(unsigned __int16 *)&__dst[4] == 103) : (v13 = 0), v13))
      {
        v16 = CFSTR("public.jpeg");
      }
      else
      {
        if (*(_DWORD *)__dst ^ 0x676E702E | __dst[4])
        {
          if (*(_DWORD *)__dst ^ 0x6664702E | __dst[4])
          {
            v32 = 0;
            v31 = 0;
            strncpy(__s, a2, 0x3FCuLL);
            strcat(__s, ".pdf");
            v14 = __s;
            v15 = (uint64_t)a1;
          }
          else
          {
            v15 = (uint64_t)a1;
            v14 = a2;
          }
          if (write_to_pdf_context(v15, v14))
          {
LABEL_48:
            v4 = 1;
LABEL_49:
            CGLog(1, (uint64_t)"%s %s %s", v18, v19, v20, v21, v22, v23, (char)"CGImageWriteToFile");
            return v4;
          }
LABEL_43:
          v4 = 0;
          goto LABEL_49;
        }
        v16 = CFSTR("public.png");
      }
      v17 = strlen(a2);
      v4 = (uint64_t)CFURLCreateFromFileSystemRepresentation(0, (const UInt8 *)a2, v17, 0);
      if (!v4)
        goto LABEL_49;
      if (CGImageWriteToFile_predicate != -1)
        dispatch_once(&CGImageWriteToFile_predicate, &__block_literal_global_185_4854);
      v24 = CGImageWriteToFile_f(v4, v16, 1, 0);
      if (v24)
      {
        v25 = (const void *)v24;
        if (CGImageWriteToFile_predicate_188 != -1)
          dispatch_once(&CGImageWriteToFile_predicate_188, &__block_literal_global_190_4855);
        CGImageWriteToFile_f_187(v25, a1, 0);
        if (CGImageWriteToFile_predicate_192 != -1)
          dispatch_once(&CGImageWriteToFile_predicate_192, &__block_literal_global_194);
        v26 = CGImageWriteToFile_f_191(v25);
        CFRelease(v25);
        CFRelease((CFTypeRef)v4);
        if (v26)
          goto LABEL_48;
      }
      else
      {
        CFRelease((CFTypeRef)v4);
      }
      goto LABEL_43;
    }
    return 0;
  }
  return v4;
}

BOOL write_to_pdf_context(uint64_t a1, char *cStr)
{
  CGSize v3;
  CGContext *v4;
  CGContext *v5;
  CGRect v7;

  v3 = (CGSize)vcvtq_f64_u64(*(uint64x2_t *)(a1 + 40));
  v7.origin.x = 0.0;
  v7.origin.y = 0.0;
  v7.size = v3;
  v4 = CGPDFContextCreateWithFilename(cStr, &v7, 0);
  v5 = v4;
  if (v4)
  {
    CGContextBeginPage(v4, 0);
    CGContextDrawImage(v5, v7, (CGImageRef)a1);
    CGContextEndPage(v5);
    CFRelease(v5);
  }
  return v5 != 0;
}

__CFData *CGImageCreateMaskFromAlpha(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __CFData *v8;
  CGDataProvider *v9;
  int v10;
  CGDataProvider *v11;
  __int128 v13;
  uint64_t v14;

  v8 = (__CFData *)a1;
  v14 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    if ((*(_BYTE *)(a1 + 39) & 4) != 0)
    {
      if (*(_QWORD *)(a1 + 56) == 8 && *(_QWORD *)(a1 + 64) == 32)
      {
        if (*(_QWORD *)(a1 + 152) || CGImageGetDataProviderInternal((char *)a1, 0))
        {
          if ((*((_DWORD *)v8 + 8) & 0x7000) == 0x2000)
          {
            v9 = (CGDataProvider *)*((_QWORD *)v8 + 19);
            v10 = 4;
          }
          else
          {
            if ((*((_DWORD *)v8 + 8) & 0x7000) != 0x1000)
            {
              v11 = (CGDataProvider *)*((_QWORD *)v8 + 19);
              CGDataProviderRetain(v11);
              goto LABEL_15;
            }
            v9 = (CGDataProvider *)*((_QWORD *)v8 + 19);
            v10 = 2;
          }
          v11 = CGDataProviderCreateWithSwappedProvider(v9, v10);
LABEL_15:
          v13 = xmmword_185000460;
          v8 = mask_create(*((_QWORD *)v8 + 5), *((_QWORD *)v8 + 6), *((_QWORD *)v8 + 7), *((_QWORD *)v8 + 8), *((_QWORD *)v8 + 9), v11, (double *)&v13, 0, *((_DWORD *)v8 + 8) & 0x1F);
          CGDataProviderRelease(v11);
          return v8;
        }
      }
      else
      {
        CGPostError((uint64_t)"%s: Unsupported bitsPerComponent (%zu, must be 8) or bitsPerPixel (%zu, must be 32)", a2, a3, a4, a5, a6, a7, a8, (char)"CGImageCreateMaskFromAlpha");
      }
    }
    return 0;
  }
  return v8;
}

BOOL CGImageGetHeadroom(CGImage *a1, float *a2)
{
  float HeadroomInfo;
  int v5;

  v5 = 0;
  HeadroomInfo = CGImageGetHeadroomInfo(a1, &v5);
  if (a2)
    *a2 = HeadroomInfo;
  return v5 == 1;
}

float CGImageGetContentHeadroom(CGImage *a1)
{
  return CGImageGetHeadroomInfo(a1, 0);
}

BOOL CGImageShouldToneMap(CGImage *a1)
{
  return CGImageGetHeadroomInfo(a1, 0) > 1.0;
}

BOOL CGImageContainsImageSpecificToneMappingMetadata(CGImage *a1)
{
  CGColorSpaceRef ColorSpace;

  ColorSpace = CGImageGetColorSpace(a1);
  return CGColorSpaceContainsFlexGTCInfo((_BOOL8)ColorSpace);
}

uint64_t CGImageGetEDRHeadroomDefault()
{
  if (CGImageGetEDRHeadroomDefault_predicate != -1)
    dispatch_once(&CGImageGetEDRHeadroomDefault_predicate, &__block_literal_global_203_4868);
  return CGImageGetEDRHeadroomDefault_default_headroom;
}

uint64_t CGImageDefaultReferenceWhite()
{
  if (CGImageDefaultReferenceWhite_once != -1)
    dispatch_once(&CGImageDefaultReferenceWhite_once, &__block_literal_global_205);
  return CGImageDefaultReferenceWhite_media_white;
}

uint64_t CGImageGetDecodeType(CGImage *a1)
{
  CGColorSpaceRef ColorSpace;
  _QWORD *v3;
  uint64_t v4;
  uint64_t result;
  double *v6;
  unint64_t v7;
  double v8;
  uint64_t v9;
  double v10;

  ColorSpace = CGImageGetColorSpace(a1);
  v3 = ColorSpace;
  if (ColorSpace)
    v4 = *(_QWORD *)(*((_QWORD *)ColorSpace + 3) + 40);
  else
    v4 = 0;
  result = (uint64_t)CGImageGetDecode(a1);
  if (!result)
    return result;
  v6 = (double *)result;
  if ((unint64_t)(v4 - 3) >= 2)
  {
    if (v4 == 1)
    {
      if (CGColorSpaceGetType(v3) == 7)
      {
        if (v3 && (v9 = v3[3], *(_DWORD *)(v9 + 24) == 5))
          v10 = (double)*(unint64_t *)(*(_QWORD *)(v9 + 88) + 8);
        else
          v10 = 1.84467441e19;
        if (*v6 == 0.0 && v6[1] == v10)
          return 0;
        if (*v6 == v10)
        {
LABEL_31:
          if (v6[1] == 0.0)
            return 1;
        }
      }
      else
      {
        if (*v6 == 0.0 && v6[1] == 1.0)
          return 0;
        if (*v6 == 1.0)
          goto LABEL_31;
      }
    }
    return 2;
  }
  v7 = 0;
  result = 2;
  do
  {
    v8 = v6[v7];
    if (v8 == 0.0 && v6[v7 + 1] == 1.0)
    {
      if ((_DWORD)result == 1)
        return 2;
      result = 0;
    }
    else if (v8 == 1.0 && v6[v7 + 1] == 0.0)
    {
      if (!(_DWORD)result)
        return 2;
      result = 1;
    }
    v7 += 2;
  }
  while (v7 < 2 * v4 - 1);
  return result;
}

uint64_t Wf_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  unsigned int v42;
  unint64_t v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  unsigned __int8 *v50;
  unsigned __int8 *v51;
  unsigned __int8 *v52;
  unsigned int v53;
  unsigned __int8 *v54;
  unsigned __int8 *v55;
  unint64_t v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  int v62;
  int v63;
  char v64;
  unsigned int v65;
  unsigned int v66;
  unsigned __int8 *v67;
  unsigned int v68;
  unsigned __int8 *v69;
  unsigned __int8 *v70;
  int v71;
  unsigned __int8 *v72;
  int v73;
  int v74;
  uint64_t v75;
  _DWORD *v76;
  uint64_t v77;
  uint64_t v78;
  unsigned __int8 *v79;
  unsigned __int8 *v80;
  unint64_t v81;
  uint64_t v82;
  int v83;
  unsigned int v84;
  int v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v86 = *(_QWORD *)(result + 80);
  v88 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 8;
  v12 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v13 = 0;
  else
    v13 = -16777216;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  v17 = v4 + v15 + (v14 * v6) - 1;
  v87 = *(_QWORD *)(result + 64);
  v85 = *(_DWORD *)(result + 188);
  v89 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v89)
      {
        if (a3 <= v88)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v87;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v88;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_43;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v87;
          v27 = v25 | v85;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v89 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_43;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v87;
        v27 = v21 | v85;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v30 = *(_QWORD *)(result + 192);
      v31 = v29 - *(_QWORD *)(result + 200);
      v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v85;
        v33 = v31 + 0x1000000;
        v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 8;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v86)
    {
      v34 = ((unint64_t)a2 >> 26) & 0x3C;
      v33 = a2;
      goto LABEL_29;
    }
    v35 = *(_QWORD *)(result + 192);
    v36 = *(_QWORD *)(result + 200) + v86;
    v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1)
      goto LABEL_43;
    if (v37 < v35)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v85;
    v33 = v36 - 0x1000000;
    v34 = 28;
LABEL_29:
    if (v27 < 0x400000)
      goto LABEL_43;
    v38 = v28 >> 32;
    v39 = v4 + (int)v38 * (uint64_t)v6 + (v33 >> 32);
    v40 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v39)
      v41 = (unsigned __int8 *)(v4 + (int)v38 * (uint64_t)v6 + (v33 >> 32));
    else
      v41 = (unsigned __int8 *)v17;
    if (v41 < v40)
      v41 = *(unsigned __int8 **)(result + 32);
    v42 = *v41;
    if (v5)
    {
      v43 = v5 + (int)v38 * (uint64_t)v7 + (v33 >> 32);
      v44 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v43)
        v45 = (unsigned __int8 *)v43;
      else
        v45 = v16;
      if (v45 >= v44)
        v44 = v45;
      v42 |= *v44 << 24;
      if (!v8)
        goto LABEL_103;
    }
    else
    {
      v43 = 0;
      if (!v8)
        goto LABEL_103;
    }
    v46 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    v47 = v46 & 0xF;
    switch(v47)
    {
      case 1:
        v67 = (unsigned __int8 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
        if (v17 < (unint64_t)v67)
          v67 = (unsigned __int8 *)v17;
        if (v67 < v40)
          v67 = v40;
        v68 = *v67;
        if (v5)
        {
          v69 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
          if (v16 < v69)
            v69 = v16;
          if ((unint64_t)v69 < *(_QWORD *)(result + 40))
            v69 = *(unsigned __int8 **)(result + 40);
          v68 |= *v69 << 24;
        }
        v42 = v42
            - ((interpolate_8888_19472[HIBYTE(v46) & 3] & v42) >> ((HIBYTE(v46) & 3) + 1))
            + ((interpolate_8888_19472[HIBYTE(v46) & 3] & v68) >> ((HIBYTE(v46) & 3) + 1));
        break;
      case 2:
        v70 = (unsigned __int8 *)(v39 + SBYTE2(v46));
        if (v17 < (unint64_t)v70)
          v70 = (unsigned __int8 *)v17;
        if (v70 < v40)
          v70 = v40;
        v71 = *v70;
        if (v5)
        {
          v72 = (unsigned __int8 *)(v43 + SBYTE2(v46));
          if (v16 < v72)
            v72 = v16;
          if ((unint64_t)v72 < *(_QWORD *)(result + 40))
            v72 = *(unsigned __int8 **)(result + 40);
          v71 |= *v72 << 24;
        }
        v73 = (v46 >> 28) & 3;
        v74 = interpolate_8888_19472[v73];
        v64 = v73 + 1;
        v65 = v42 - ((v74 & v42) >> v64);
        v66 = v74 & v71;
        goto LABEL_102;
      case 3:
        v83 = HIBYTE(v46) & 3;
        v48 = (unsigned __int8 *)(v39 + SBYTE2(v46));
        if (v17 < (unint64_t)v48)
          v48 = (unsigned __int8 *)v17;
        if (v48 < v40)
          v48 = v40;
        v49 = *v48;
        v50 = (unsigned __int8 *)(v39 + SBYTE1(v46) * (uint64_t)v6);
        if (v17 >= (unint64_t)v50)
          v51 = v50;
        else
          v51 = (unsigned __int8 *)v17;
        if (v51 < v40)
          v51 = v40;
        v84 = *v51;
        v52 = &v50[SBYTE2(v46)];
        if (v17 < (unint64_t)v52)
          v52 = (unsigned __int8 *)v17;
        if (v52 < v40)
          v52 = v40;
        v53 = *v52;
        if (v5)
        {
          v54 = (unsigned __int8 *)(v43 + SBYTE2(v46));
          v55 = *(unsigned __int8 **)(result + 40);
          if (v16 < v54)
            v54 = v16;
          if (v54 < v55)
            v54 = *(unsigned __int8 **)(result + 40);
          v49 |= *v54 << 24;
          v56 = v43 + SBYTE1(v46) * (uint64_t)v7;
          if ((unint64_t)v16 >= v56)
            v57 = (unsigned __int8 *)(v43 + SBYTE1(v46) * (uint64_t)v7);
          else
            v57 = v16;
          if (v57 < v55)
            v57 = *(unsigned __int8 **)(result + 40);
          v84 |= *v57 << 24;
          v58 = (unsigned __int8 *)(v56 + SBYTE2(v46));
          if (v16 < v58)
            v58 = v16;
          if (v58 >= v55)
            v55 = v58;
          v53 |= *v55 << 24;
        }
        v59 = interpolate_8888_19472[v83];
        v60 = v42 - ((v59 & v42) >> (v83 + 1)) + ((v59 & v84) >> (v83 + 1));
        v61 = v49 - ((v59 & v49) >> (v83 + 1)) + ((v59 & v53) >> (v83 + 1));
        v62 = (v46 >> 28) & 3;
        v63 = interpolate_8888_19472[v62];
        v64 = v62 + 1;
        v65 = v60 - ((v60 & v63) >> v64);
        v66 = v61 & v63;
LABEL_102:
        v42 = v65 + (v66 >> v64);
        break;
    }
LABEL_103:
    *(_DWORD *)(v11 + 8) = _blt_float[v42];
    *(_DWORD *)(v11 + 12) = _blt_float[(v42 | v13) >> 24];
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v75 = 0;
    v76 = (_DWORD *)(v11 + 20);
    a2 += v10;
    v77 = v86 - a2;
    a3 += v9;
    v78 = v88 - a3;
    while ((((a2 - v87) | v77 | (a3 - v89) | v78) & 0x8000000000000000) == 0)
    {
      v39 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
      v40 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v39)
        v79 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
      else
        v79 = (unsigned __int8 *)v17;
      if (v79 < v40)
        v79 = *(unsigned __int8 **)(result + 32);
      v42 = *v79;
      if (v5)
      {
        v43 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        v80 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v43)
          v81 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        else
          v81 = (unint64_t)v16;
        if (v81 >= (unint64_t)v80)
          v80 = (unsigned __int8 *)v81;
        v42 |= *v80 << 24;
      }
      if (v8)
      {
        v46 = *(_DWORD *)(v8 + (((unint64_t)a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v46 & 0xF) != 0)
        {
          v12 += v75 + 1;
          v11 = (uint64_t)(v76 - 3);
          a4 += ~(_DWORD)v75;
          v27 = -1;
          goto LABEL_48;
        }
      }
      *(v76 - 1) = _blt_float[v42];
      *v76 = _blt_float[(v42 | v13) >> 24];
      v76 += 2;
      v82 = v12 + v75++;
      a2 += v10;
      *(_BYTE *)(v82 + 2) = -1;
      v77 -= v10;
      a3 += v9;
      v78 -= v9;
      if (a4 - 1 == (_DWORD)v75)
        return result;
    }
    v12 += v75 + 1;
    v11 = (uint64_t)(v76 - 3);
    a4 += ~(_DWORD)v75;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_W16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unint64_t v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  unsigned int v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unsigned int v55;
  unsigned __int16 *v56;
  unsigned int v57;
  uint64_t v58;
  unsigned __int16 *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned __int16 *v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  unsigned __int16 *v75;
  unsigned int v76;
  unsigned __int16 *v77;
  uint64_t v78;
  uint64_t v79;
  float *v80;
  uint64_t v81;
  unint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned __int16 *v85;
  unsigned int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v89 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 8;
  v91 = *(_QWORD *)(result + 88);
  v92 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v12 = 0;
  else
    v12 = -65536;
  v13 = *(_DWORD *)(result + 260) - 1;
  v14 = *(unsigned int *)(result + 256);
  v15 = v5 + (v13 * v7) + 2 * (v14 - 1);
  v16 = v4 + (v13 * v6) + 2 * v14 - 2;
  v87 = *(_DWORD *)(result + 188);
  v90 = *(_QWORD *)(result + 72);
  v88 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v90)
    {
      if (a3 <= v91)
      {
        v25 = ((unint64_t)a3 >> 22) & 0x3C0;
        v26 = 0x3FFFFFFF;
        v27 = a3;
        v28 = v88;
      }
      else
      {
        v21 = *(_QWORD *)(result + 216);
        v22 = *(_QWORD *)(result + 224) + v91;
        v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1)
          goto LABEL_42;
        if (v23 >= v21)
          LODWORD(v24) = 0x3FFFFFFF;
        else
          v24 = (unint64_t)(*(_QWORD *)(result + 232) * v23) >> 32;
        v28 = v88;
        v26 = v24 | v87;
        v27 = v22 - 0x1000000;
        v25 = 448;
      }
    }
    else
    {
      v17 = *(_QWORD *)(result + 216);
      v18 = v90 - *(_QWORD *)(result + 224);
      v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1)
        goto LABEL_42;
      if (v19 >= v17)
        LODWORD(v20) = 0x3FFFFFFF;
      else
        v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
      v28 = v88;
      v26 = v20 | v87;
      v27 = v18 + 0x1000000;
      v25 = 512;
    }
    if (a2 >= v28)
      break;
    v29 = *(_QWORD *)(result + 192);
    v30 = v28 - *(_QWORD *)(result + 200);
    v31 = a2 - v30 + (v29 >> 1);
    if (v31 >= 1)
    {
      if (v31 < v29)
        v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v87;
      v32 = v30 + 0x1000000;
      v33 = 32;
      goto LABEL_29;
    }
LABEL_42:
    --a4;
    a2 += v10;
    a3 += v9;
    v11 += 8;
    *(_BYTE *)++v92 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v89)
  {
    v33 = ((unint64_t)a2 >> 26) & 0x3C;
    v32 = a2;
    goto LABEL_29;
  }
  v34 = *(_QWORD *)(result + 192);
  v35 = *(_QWORD *)(result + 200) + v89;
  v36 = v35 - a2 + (v34 >> 1);
  if (v36 < 1)
    goto LABEL_42;
  if (v36 < v34)
    v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v87;
  v32 = v35 - 0x1000000;
  v33 = 28;
LABEL_29:
  if (v26 < 0x400000)
    goto LABEL_42;
  v37 = v27 >> 32;
  v38 = v4 + (int)v37 * (uint64_t)v6;
  v39 = (v32 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  v40 = v38 + v39;
  v41 = *(unsigned __int16 **)(result + 32);
  if (v16 >= v38 + v39)
    v42 = (unsigned __int16 *)(v38 + v39);
  else
    v42 = (unsigned __int16 *)v16;
  if (v42 < v41)
    v42 = *(unsigned __int16 **)(result + 32);
  v43 = bswap32(*v42) >> 16;
  if (v5)
  {
    v44 = v5 + (int)v37 * (uint64_t)v7 + v39;
    v45 = *(unsigned __int16 **)(result + 40);
    if (v15 >= v44)
      v46 = (unsigned __int16 *)v44;
    else
      v46 = (unsigned __int16 *)v15;
    if (v46 >= v45)
      v45 = v46;
    v43 |= bswap32(*v45) & 0xFFFF0000;
  }
  else
  {
    v44 = 0;
  }
  v47 = v89;
  if (!v8)
    goto LABEL_104;
  v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_48:
  v49 = v48 & 0xF;
  v50 = HIBYTE(v48) & 3;
  switch(v49)
  {
    case 1:
      v71 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v71)
        v71 = (unsigned __int16 *)v16;
      if (v71 < v41)
        v71 = v41;
      v72 = bswap32(*v71) >> 16;
      if (v5)
      {
        v73 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v73)
          v73 = (unsigned __int16 *)v15;
        if ((unint64_t)v73 < *(_QWORD *)(result + 40))
          v73 = *(unsigned __int16 **)(result + 40);
        v72 |= bswap32(*v73) & 0xFFFF0000;
      }
      v74 = interpolate_1616[v50];
      v69 = v43 - ((v74 & v43) >> (v50 + 1));
      v70 = (v74 & v72) >> (v50 + 1);
LABEL_91:
      v43 = v69 + v70;
      goto LABEL_103;
    case 2:
      v75 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v75)
        v75 = (unsigned __int16 *)v16;
      if (v75 < v41)
        v75 = v41;
      v76 = bswap32(*v75) >> 16;
      if (v5)
      {
        v77 = (unsigned __int16 *)(v44 + 2 * SBYTE2(v48));
        if (v15 < (unint64_t)v77)
          v77 = (unsigned __int16 *)v15;
        if ((unint64_t)v77 < *(_QWORD *)(result + 40))
          v77 = *(unsigned __int16 **)(result + 40);
        v76 |= bswap32(*v77) & 0xFFFF0000;
      }
      v43 = v43
          - ((interpolate_1616[(v48 >> 28) & 3] & v43) >> (((v48 >> 28) & 3) + 1))
          + ((interpolate_1616[(v48 >> 28) & 3] & v76) >> (((v48 >> 28) & 3) + 1));
LABEL_103:
      v47 = v89;
      break;
    case 3:
      v86 = HIBYTE(v48) & 3;
      v51 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v51)
        v51 = (unsigned __int16 *)v16;
      if (v51 < v41)
        v51 = v41;
      v52 = bswap32(*v51) >> 16;
      v53 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 >= (unint64_t)v53)
        v54 = v53;
      else
        v54 = (unsigned __int16 *)v16;
      if (v54 < v41)
        v54 = v41;
      v55 = bswap32(*v54) >> 16;
      v56 = &v53[SBYTE2(v48)];
      if (v16 < (unint64_t)v56)
        v56 = (unsigned __int16 *)v16;
      if (v56 < v41)
        v56 = v41;
      v57 = bswap32(*v56) >> 16;
      if (v5)
      {
        v58 = 2 * SBYTE2(v48);
        v59 = (unsigned __int16 *)(v44 + v58);
        v60 = *(_QWORD *)(result + 40);
        if (v15 < v44 + v58)
          v59 = (unsigned __int16 *)v15;
        if ((unint64_t)v59 < v60)
          v59 = *(unsigned __int16 **)(result + 40);
        v52 |= bswap32(*v59) & 0xFFFF0000;
        v61 = v44 + SBYTE1(v48) * (uint64_t)v7;
        if (v15 >= v61)
          v62 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        else
          v62 = (unsigned __int16 *)v15;
        if ((unint64_t)v62 < v60)
          v62 = *(unsigned __int16 **)(result + 40);
        v55 |= bswap32(*v62) & 0xFFFF0000;
        v63 = (unsigned __int16 *)(v61 + v58);
        if (v15 < v61 + v58)
          v63 = (unsigned __int16 *)v15;
        if ((unint64_t)v63 < v60)
          v63 = *(unsigned __int16 **)(result + 40);
        v57 |= bswap32(*v63) & 0xFFFF0000;
      }
      v64 = interpolate_1616[v86];
      v65 = v43 - ((v64 & v43) >> (v86 + 1)) + ((v64 & v55) >> (v86 + 1));
      v66 = v52 - ((v64 & v52) >> (v86 + 1)) + ((v64 & v57) >> (v86 + 1));
      v67 = (v48 >> 28) & 3;
      v68 = interpolate_1616[v67];
      LOBYTE(v67) = v67 + 1;
      v69 = v65 - ((v65 & v68) >> v67);
      v70 = (v66 & v68) >> v67;
      goto LABEL_91;
  }
LABEL_104:
  v78 = 0;
  a2 += v10;
  v79 = v47 - a2;
  v80 = (float *)(v11 + 12);
  a3 += v9;
  v81 = v91 - a3;
  while (1)
  {
    *(v80 - 1) = *(float *)&_blt_float[v43 | 0x100] + *(float *)&_blt_float[BYTE1(v43) | 0x200];
    *v80 = *(float *)&_blt_float[((v43 | v12) >> 16) | 0x100]
         + *(float *)&_blt_float[((v43 | v12) >> 24) | 0x200];
    *(_BYTE *)(v92 + 1 + v78) = v26 >> 22;
    if (a4 - 1 == (_DWORD)v78)
      return result;
    if ((v81 | v79 | (a3 - v90) | (a2 - v88)) < 0)
    {
      v92 += v78 + 1;
      v11 = (uint64_t)(v80 - 1);
      a4 += ~(_DWORD)v78;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v82 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v82;
    v41 = *(unsigned __int16 **)(result + 32);
    if (v16 >= v40)
      v83 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v82);
    else
      v83 = (unsigned __int16 *)v16;
    if (v83 < v41)
      v83 = *(unsigned __int16 **)(result + 32);
    v43 = bswap32(*v83) >> 16;
    if (v5)
    {
      v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      v84 = *(unsigned __int16 **)(result + 40);
      if (v15 >= v44)
        v85 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v82);
      else
        v85 = (unsigned __int16 *)v15;
      if (v85 >= v84)
        v84 = v85;
      v43 |= bswap32(*v84) & 0xFFFF0000;
    }
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        v92 += v78 + 1;
        v11 = (uint64_t)(v80 - 1);
        a4 += ~(_DWORD)v78;
        v26 = -1;
        v47 = v89;
        goto LABEL_48;
      }
    }
    ++v78;
    v79 -= v10;
    v80 += 2;
    a3 += v9;
    v81 -= v9;
    a2 += v10;
    v26 = -1;
  }
}

uint64_t Wf_sample_w16(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  unint64_t v40;
  unsigned __int16 *v41;
  unsigned __int16 *v42;
  unsigned int v43;
  unint64_t v44;
  unsigned __int16 *v45;
  unsigned __int16 *v46;
  uint64_t v47;
  unsigned int v48;
  int v49;
  int v50;
  unsigned __int16 *v51;
  unsigned int v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unsigned int v55;
  unsigned __int16 *v56;
  unsigned int v57;
  uint64_t v58;
  unsigned __int16 *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned __int16 *v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  unsigned __int16 *v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  unsigned __int16 *v75;
  unsigned int v76;
  unsigned __int16 *v77;
  uint64_t v78;
  uint64_t v79;
  float *v80;
  uint64_t v81;
  unint64_t v82;
  unsigned __int16 *v83;
  unsigned __int16 *v84;
  unsigned __int16 *v85;
  int v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v89 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 8;
  v91 = *(_QWORD *)(result + 88);
  v92 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v12 = 0;
  else
    v12 = -65536;
  v13 = *(_DWORD *)(result + 260) - 1;
  v14 = *(unsigned int *)(result + 256);
  v15 = v5 + (v13 * v7) + 2 * (v14 - 1);
  v16 = v4 + (v13 * v6) + 2 * v14 - 2;
  v87 = *(_DWORD *)(result + 188);
  v90 = *(_QWORD *)(result + 72);
  v88 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_5:
    if (a3 >= v90)
    {
      if (a3 <= v91)
      {
        v25 = ((unint64_t)a3 >> 22) & 0x3C0;
        v26 = 0x3FFFFFFF;
        v27 = a3;
        v28 = v88;
      }
      else
      {
        v21 = *(_QWORD *)(result + 216);
        v22 = *(_QWORD *)(result + 224) + v91;
        v23 = v22 - a3 + (v21 >> 1);
        if (v23 < 1)
          goto LABEL_42;
        if (v23 >= v21)
          LODWORD(v24) = 0x3FFFFFFF;
        else
          v24 = (unint64_t)(*(_QWORD *)(result + 232) * v23) >> 32;
        v28 = v88;
        v26 = v24 | v87;
        v27 = v22 - 0x1000000;
        v25 = 448;
      }
    }
    else
    {
      v17 = *(_QWORD *)(result + 216);
      v18 = v90 - *(_QWORD *)(result + 224);
      v19 = a3 - v18 + (v17 >> 1);
      if (v19 < 1)
        goto LABEL_42;
      if (v19 >= v17)
        LODWORD(v20) = 0x3FFFFFFF;
      else
        v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
      v28 = v88;
      v26 = v20 | v87;
      v27 = v18 + 0x1000000;
      v25 = 512;
    }
    if (a2 >= v28)
      break;
    v29 = *(_QWORD *)(result + 192);
    v30 = v28 - *(_QWORD *)(result + 200);
    v31 = a2 - v30 + (v29 >> 1);
    if (v31 >= 1)
    {
      if (v31 < v29)
        v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v31) >> 32) >> 15)) | v87;
      v32 = v30 + 0x1000000;
      v33 = 32;
      goto LABEL_29;
    }
LABEL_42:
    --a4;
    a2 += v10;
    a3 += v9;
    v11 += 8;
    *(_BYTE *)++v92 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v89)
  {
    v33 = ((unint64_t)a2 >> 26) & 0x3C;
    v32 = a2;
    goto LABEL_29;
  }
  v34 = *(_QWORD *)(result + 192);
  v35 = *(_QWORD *)(result + 200) + v89;
  v36 = v35 - a2 + (v34 >> 1);
  if (v36 < 1)
    goto LABEL_42;
  if (v36 < v34)
    v26 = ((v26 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v87;
  v32 = v35 - 0x1000000;
  v33 = 28;
LABEL_29:
  if (v26 < 0x400000)
    goto LABEL_42;
  v37 = v27 >> 32;
  v38 = v4 + (int)v37 * (uint64_t)v6;
  v39 = (v32 >> 31) & 0xFFFFFFFFFFFFFFFELL;
  v40 = v38 + v39;
  v41 = *(unsigned __int16 **)(result + 32);
  if (v16 >= v38 + v39)
    v42 = (unsigned __int16 *)(v38 + v39);
  else
    v42 = (unsigned __int16 *)v16;
  if (v42 < v41)
    v42 = *(unsigned __int16 **)(result + 32);
  v43 = *v42;
  if (v5)
  {
    v44 = v5 + (int)v37 * (uint64_t)v7 + v39;
    v45 = *(unsigned __int16 **)(result + 40);
    if (v15 >= v44)
      v46 = (unsigned __int16 *)v44;
    else
      v46 = (unsigned __int16 *)v15;
    if (v46 >= v45)
      v45 = v46;
    v43 |= *v45 << 16;
  }
  else
  {
    v44 = 0;
  }
  v47 = v89;
  if (!v8)
    goto LABEL_104;
  v48 = *(_DWORD *)(v8 + (v33 | v25));
LABEL_48:
  v49 = v48 & 0xF;
  v50 = HIBYTE(v48) & 3;
  switch(v49)
  {
    case 1:
      v71 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 < (unint64_t)v71)
        v71 = (unsigned __int16 *)v16;
      if (v71 < v41)
        v71 = v41;
      v72 = *v71;
      if (v5)
      {
        v73 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        if (v15 < (unint64_t)v73)
          v73 = (unsigned __int16 *)v15;
        if ((unint64_t)v73 < *(_QWORD *)(result + 40))
          v73 = *(unsigned __int16 **)(result + 40);
        v72 |= *v73 << 16;
      }
      v74 = interpolate_1616[v50];
      v69 = v43 - ((v74 & v43) >> (v50 + 1));
      v70 = (v74 & v72) >> (v50 + 1);
LABEL_91:
      v43 = v69 + v70;
      goto LABEL_103;
    case 2:
      v75 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v75)
        v75 = (unsigned __int16 *)v16;
      if (v75 < v41)
        v75 = v41;
      v76 = *v75;
      if (v5)
      {
        v77 = (unsigned __int16 *)(v44 + 2 * SBYTE2(v48));
        if (v15 < (unint64_t)v77)
          v77 = (unsigned __int16 *)v15;
        if ((unint64_t)v77 < *(_QWORD *)(result + 40))
          v77 = *(unsigned __int16 **)(result + 40);
        v76 |= *v77 << 16;
      }
      v43 = v43
          - ((interpolate_1616[(v48 >> 28) & 3] & v43) >> (((v48 >> 28) & 3) + 1))
          + ((interpolate_1616[(v48 >> 28) & 3] & v76) >> (((v48 >> 28) & 3) + 1));
LABEL_103:
      v47 = v89;
      break;
    case 3:
      v86 = HIBYTE(v48) & 3;
      v51 = (unsigned __int16 *)(v40 + 2 * SBYTE2(v48));
      if (v16 < (unint64_t)v51)
        v51 = (unsigned __int16 *)v16;
      if (v51 < v41)
        v51 = v41;
      v52 = *v51;
      v53 = (unsigned __int16 *)(v40 + SBYTE1(v48) * (uint64_t)v6);
      if (v16 >= (unint64_t)v53)
        v54 = v53;
      else
        v54 = (unsigned __int16 *)v16;
      if (v54 < v41)
        v54 = v41;
      v55 = *v54;
      v56 = &v53[SBYTE2(v48)];
      if (v16 < (unint64_t)v56)
        v56 = (unsigned __int16 *)v16;
      if (v56 < v41)
        v56 = v41;
      v57 = *v56;
      if (v5)
      {
        v58 = 2 * SBYTE2(v48);
        v59 = (unsigned __int16 *)(v44 + v58);
        v60 = *(_QWORD *)(result + 40);
        if (v15 < v44 + v58)
          v59 = (unsigned __int16 *)v15;
        if ((unint64_t)v59 < v60)
          v59 = *(unsigned __int16 **)(result + 40);
        v52 |= *v59 << 16;
        v61 = v44 + SBYTE1(v48) * (uint64_t)v7;
        if (v15 >= v61)
          v62 = (unsigned __int16 *)(v44 + SBYTE1(v48) * (uint64_t)v7);
        else
          v62 = (unsigned __int16 *)v15;
        if ((unint64_t)v62 < v60)
          v62 = *(unsigned __int16 **)(result + 40);
        v55 |= *v62 << 16;
        v63 = (unsigned __int16 *)(v61 + v58);
        if (v15 < v61 + v58)
          v63 = (unsigned __int16 *)v15;
        if ((unint64_t)v63 < v60)
          v63 = *(unsigned __int16 **)(result + 40);
        v57 |= *v63 << 16;
      }
      v64 = interpolate_1616[v86];
      v65 = v43 - ((v64 & v43) >> (v86 + 1)) + ((v64 & v55) >> (v86 + 1));
      v66 = v52 - ((v64 & v52) >> (v86 + 1)) + ((v64 & v57) >> (v86 + 1));
      v67 = (v48 >> 28) & 3;
      v68 = interpolate_1616[v67];
      LOBYTE(v67) = v67 + 1;
      v69 = v65 - ((v65 & v68) >> v67);
      v70 = (v66 & v68) >> v67;
      goto LABEL_91;
  }
LABEL_104:
  v78 = 0;
  a2 += v10;
  v79 = v47 - a2;
  v80 = (float *)(v11 + 12);
  a3 += v9;
  v81 = v91 - a3;
  while (1)
  {
    *(v80 - 1) = *(float *)&_blt_float[v43 | 0x100] + *(float *)&_blt_float[BYTE1(v43) | 0x200];
    *v80 = *(float *)&_blt_float[((v43 | v12) >> 16) | 0x100]
         + *(float *)&_blt_float[((v43 | v12) >> 24) | 0x200];
    *(_BYTE *)(v92 + 1 + v78) = v26 >> 22;
    if (a4 - 1 == (_DWORD)v78)
      return result;
    if ((v81 | v79 | (a3 - v90) | (a2 - v88)) < 0)
    {
      v11 = (uint64_t)(v80 - 1);
      v92 += v78 + 1;
      a4 += ~(_DWORD)v78;
      if (a4)
        goto LABEL_5;
      return result;
    }
    v82 = (a2 >> 31) & 0xFFFFFFFFFFFFFFFELL;
    v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + v82;
    v41 = *(unsigned __int16 **)(result + 32);
    if (v16 >= v40)
      v83 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + v82);
    else
      v83 = (unsigned __int16 *)v16;
    if (v83 < v41)
      v83 = *(unsigned __int16 **)(result + 32);
    v43 = *v83;
    if (v5)
    {
      v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + v82;
      v84 = *(unsigned __int16 **)(result + 40);
      if (v15 >= v44)
        v85 = (unsigned __int16 *)(v5 + SHIDWORD(a3) * (uint64_t)v7 + v82);
      else
        v85 = (unsigned __int16 *)v15;
      if (v85 >= v84)
        v84 = v85;
      v43 |= *v84 << 16;
    }
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v48 & 0xF) != 0)
      {
        v11 = (uint64_t)(v80 - 1);
        v92 += v78 + 1;
        a4 += ~(_DWORD)v78;
        v26 = -1;
        v47 = v89;
        goto LABEL_48;
      }
    }
    v79 -= v10;
    v80 += 2;
    ++v78;
    a3 += v9;
    v81 -= v9;
    a2 += v10;
    v26 = -1;
  }
}

uint64_t Wf_sample_WF_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  unsigned int *v48;
  unsigned int *v49;
  unint64_t v50;
  unsigned int *v51;
  unsigned int *v52;
  float v53;
  float v54;
  unsigned int v55;
  int v56;
  uint64_t v57;
  unsigned int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unsigned int *v71;
  float v72;
  unsigned int *v73;
  float v74;
  float v75;
  float v76;
  unint64_t v77;
  unint64_t v78;
  unsigned int *v79;
  unsigned int *v80;
  float v81;
  float v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unsigned int *v87;
  float v88;
  float v89;
  unsigned int *v90;
  float *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned int *v96;
  unsigned int *v97;
  float v98;
  uint64_t v99;
  float *v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  unsigned int *v114;
  unsigned int *v115;
  unsigned int *v116;
  unsigned int v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  int v126;
  uint64_t v127;

  v4 = *(_DWORD *)(result + 24);
  v126 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v125 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v125 = v5 % v6;
  }
  else
  {
    v125 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v127 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v124 = v11;
  }
  else
  {
    v124 = 0;
  }
  v120 = *(_QWORD *)(result + 80);
  v121 = *(_QWORD *)(result + 64);
  v122 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 8;
  v13 = *(_QWORD *)(result + 144) - 1;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = v9 + (v14 * v126) + 4 * (v15 - 1);
  v119 = *(_DWORD *)(result + 188);
  v17 = v127 + (v14 * v4) + 4 * v15 - 4;
  v123 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 < v123)
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v123 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_57;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v28 = v119 | v21;
        v29 = v19 + 0x1000000;
        v26 = a3 - (v19 + 0x1000000);
        v27 = 512;
        goto LABEL_22;
      }
      if (a3 <= v122)
      {
        v26 = 0;
        v27 = ((unint64_t)a3 >> 22) & 0x3C0;
        v28 = 0x3FFFFFFF;
        v29 = a3;
LABEL_22:
        v30 = v121;
        goto LABEL_25;
      }
      v22 = *(_QWORD *)(result + 216);
      v23 = *(_QWORD *)(result + 224) + v122;
      v24 = v23 - a3 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_57;
      if (v24 >= v22)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
      v30 = v121;
      v28 = v119 | v25;
      v29 = v23 - 0x1000000;
      v26 = a3 - (v23 - 0x1000000);
      v27 = 448;
LABEL_25:
      if (a2 >= v30)
        break;
      v31 = *(_QWORD *)(result + 192);
      v32 = v30 - *(_QWORD *)(result + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31)
          v28 = ((v28 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v119;
        v34 = v32 + 0x1000000;
        v35 = a2 - (v32 + 0x1000000);
        v36 = 32;
        goto LABEL_36;
      }
LABEL_57:
      --a4;
      a2 += v5;
      a3 += v10;
      v12 += 8;
      *(_BYTE *)++v13 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v120)
    {
      v35 = 0;
      v36 = ((unint64_t)a2 >> 26) & 0x3C;
      v34 = a2;
      goto LABEL_36;
    }
    v37 = *(_QWORD *)(result + 192);
    v38 = *(_QWORD *)(result + 200) + v120;
    v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1)
      goto LABEL_57;
    if (v39 < v37)
      v28 = ((v28 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v39) >> 32) >> 15)) | v119;
    v34 = v38 - 0x1000000;
    v35 = a2 - (v38 - 0x1000000);
    v36 = 28;
LABEL_36:
    if (v28 < 0x400000)
      goto LABEL_57;
    if (v6)
    {
      v40 = (v7 & ((v29 % v7) >> 63)) + v29 % v7;
      v41 = (v6 & ((v34 % v6) >> 63)) + v34 % v6;
      if (v40 >= v7)
        v42 = v7;
      else
        v42 = 0;
      v29 = v40 - v42;
      if (v41 >= v6)
        v43 = v6;
      else
        v43 = 0;
      v34 = v41 - v43;
      v26 += v29;
      v35 += v34;
    }
    v44 = v29 >> 32;
    v45 = v127 + SHIDWORD(v29) * (uint64_t)v4;
    v46 = (v34 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v47 = v45 + v46;
    v48 = *(unsigned int **)(result + 32);
    if (v17 >= v45 + v46)
      v49 = (unsigned int *)(v45 + v46);
    else
      v49 = (unsigned int *)v17;
    if (v49 < v48)
      v49 = *(unsigned int **)(result + 32);
    if (v9)
    {
      v50 = v9 + (int)v44 * (uint64_t)v126 + v46;
      v51 = *(unsigned int **)(result + 40);
      if (v16 >= v50)
        v52 = (unsigned int *)v50;
      else
        v52 = (unsigned int *)v16;
      if (v52 >= v51)
        v51 = v52;
      v53 = COERCE_FLOAT(bswap32(*v51));
    }
    else
    {
      v50 = 0;
      v53 = 1.0;
    }
    v54 = COERCE_FLOAT(bswap32(*v49));
    if (!v8)
      goto LABEL_128;
    v55 = *(_DWORD *)(v8 + (v36 | v27));
LABEL_63:
    v56 = v55 & 0xF;
    v57 = v55 >> 8;
    v58 = HIBYTE(v55) & 3;
    if (v56 == 1)
    {
      LODWORD(v83) = SBYTE1(v55);
      if (v6)
      {
        v84 = v26 + ((uint64_t)SBYTE1(v55) << 32);
        v85 = v7 & (v84 >> 63);
        if (v85 + v84 >= v7)
          v86 = v7;
        else
          v86 = 0;
        v83 = (v85 + ((uint64_t)(char)v57 << 32) - v86) >> 32;
      }
      v87 = (unsigned int *)(v47 + (int)v83 * (uint64_t)v4);
      if (v17 < (unint64_t)v87)
        v87 = (unsigned int *)v17;
      if (v87 < v48)
        v87 = v48;
      v88 = COERCE_FLOAT(bswap32(*v87));
      v89 = 1.0;
      if (v9)
      {
        v90 = (unsigned int *)(v50 + (int)v83 * (uint64_t)v126);
        if (v16 < (unint64_t)v90)
          v90 = (unsigned int *)v16;
        if ((unint64_t)v90 < *(_QWORD *)(result + 40))
          v90 = *(unsigned int **)(result + 40);
        v89 = COERCE_FLOAT(bswap32(*v90));
      }
      v91 = &interpolate_waf[2 * v58];
    }
    else
    {
      if (v56 != 2)
      {
        if (v56 == 3)
        {
          LODWORD(v59) = SBYTE1(v55);
          v60 = SBYTE2(v55);
          if (v6)
          {
            v61 = v57 << 56;
            v62 = (unint64_t)HIWORD(v55) << 56;
            v63 = v26 + ((uint64_t)SBYTE1(v55) << 32);
            v64 = v35 + (v62 >> 24);
            v65 = v7 & (v63 >> 63);
            v66 = v6 & (v64 >> 63);
            v67 = v66 + v64;
            if (v65 + v63 >= v7)
              v68 = v7;
            else
              v68 = 0;
            if (v67 >= v6)
              v69 = v6;
            else
              v69 = 0;
            v59 = (v65 + (v61 >> 24) - v68) >> 32;
            v60 = (v66 + (v62 >> 24) - v69) >> 32;
          }
          v70 = v47 + 4 * v60;
          if (v17 >= v70)
            v71 = (unsigned int *)(v47 + 4 * v60);
          else
            v71 = (unsigned int *)v17;
          if (v71 < v48)
            v71 = v48;
          v72 = COERCE_FLOAT(bswap32(*v71));
          v73 = (unsigned int *)(v70 + (int)v59 * (uint64_t)v4);
          if (v17 < (unint64_t)v73)
            v73 = (unsigned int *)v17;
          if (v73 < v48)
            v73 = v48;
          v74 = COERCE_FLOAT(bswap32(*v73));
          v75 = 1.0;
          v76 = 1.0;
          if (v9)
          {
            v77 = v50 + 4 * v60;
            v78 = *(_QWORD *)(result + 40);
            if (v16 >= v77)
              v79 = (unsigned int *)(v50 + 4 * v60);
            else
              v79 = (unsigned int *)v16;
            if ((unint64_t)v79 < v78)
              v79 = *(unsigned int **)(result + 40);
            v76 = COERCE_FLOAT(bswap32(*v79));
            v80 = (unsigned int *)(v77 + (int)v59 * (uint64_t)v126);
            if (v16 < (unint64_t)v80)
              v80 = (unsigned int *)v16;
            if ((unint64_t)v80 < v78)
              v80 = *(unsigned int **)(result + 40);
            v75 = COERCE_FLOAT(bswap32(*v80));
          }
          v81 = interpolate_waf[2 * v58 + 1];
          v82 = interpolate_waf[2 * ((v55 >> 28) & 3) + 1];
          v54 = (float)((float)((float)(v54 - (float)(v54 * v81)) + (float)(v72 * v81))
                      - (float)((float)((float)(v54 - (float)(v54 * v81)) + (float)(v72 * v81)) * v82))
              + (float)((float)((float)(v72 - (float)(v72 * v81)) + (float)(v74 * v81)) * v82);
          v53 = (float)((float)((float)(v53 - (float)(v53 * v81)) + (float)(v76 * v81))
                      - (float)((float)((float)(v53 - (float)(v53 * v81)) + (float)(v76 * v81)) * v82))
              + (float)((float)((float)(v76 - (float)(v76 * v81)) + (float)(v75 * v81)) * v82);
        }
        goto LABEL_128;
      }
      v92 = SBYTE2(v55);
      if (v6)
      {
        v93 = v35 + ((uint64_t)SBYTE2(v55) << 32);
        v94 = v6 & (v93 >> 63);
        if (v94 + v93 >= v6)
          v95 = v6;
        else
          v95 = 0;
        v92 = (v94 + ((uint64_t)((unint64_t)HIWORD(v55) << 56) >> 24) - v95) >> 32;
      }
      v96 = (unsigned int *)(v47 + 4 * v92);
      if (v17 < (unint64_t)v96)
        v96 = (unsigned int *)v17;
      if (v96 < v48)
        v96 = v48;
      v88 = COERCE_FLOAT(bswap32(*v96));
      v89 = 1.0;
      if (v9)
      {
        v97 = (unsigned int *)(v50 + 4 * v92);
        if (v16 < (unint64_t)v97)
          v97 = (unsigned int *)v16;
        if ((unint64_t)v97 < *(_QWORD *)(result + 40))
          v97 = *(unsigned int **)(result + 40);
        v89 = COERCE_FLOAT(bswap32(*v97));
      }
      v91 = &interpolate_waf[2 * ((v55 >> 28) & 3)];
    }
    v98 = v91[1];
    v54 = (float)(v54 - (float)(v54 * v98)) + (float)(v88 * v98);
    v53 = (float)(v53 - (float)(v53 * v98)) + (float)(v89 * v98);
LABEL_128:
    *(float *)(v12 + 8) = v54;
    *(float *)(v12 + 12) = v53;
    *(_BYTE *)(v13 + 1) = v28 >> 22;
    if (a4 == 1)
      break;
    v99 = 0;
    v100 = (float *)(v12 + 20);
    a2 += v5;
    v101 = v120 - a2;
    a3 += v10;
    v102 = v122 - a3;
    v103 = --a4;
    while (1)
    {
      v104 = v13 + v99 + 1;
      v12 = (uint64_t)(v100 - 3);
      if ((v102 | v101 | (a3 - v123) | (a2 - v121)) < 0)
        break;
      if (v6)
      {
        v105 = (v7 & ((v26 + v124) >> 63)) + v26 + v124;
        v106 = (v6 & ((v35 + v125) >> 63)) + v35 + v125;
        if (v105 >= v7)
          v107 = v7;
        else
          v107 = 0;
        v108 = v105 - v107;
        if (v106 >= v6)
          v109 = v6;
        else
          v109 = 0;
        v110 = v106 - v109;
        v35 = v110;
        v26 = v108;
      }
      else
      {
        v110 = a2;
        v108 = a3;
      }
      v111 = v108 >> 32;
      v112 = v127 + SHIDWORD(v108) * (uint64_t)v4;
      v113 = (v110 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      v47 = v112 + v113;
      v48 = *(unsigned int **)(result + 32);
      if (v17 >= v112 + v113)
        v114 = (unsigned int *)(v112 + v113);
      else
        v114 = (unsigned int *)v17;
      if (v114 < v48)
        v114 = *(unsigned int **)(result + 32);
      if (v9)
      {
        v50 = v9 + (int)v111 * (uint64_t)v126 + v113;
        v115 = *(unsigned int **)(result + 40);
        if (v16 >= v50)
          v116 = (unsigned int *)v50;
        else
          v116 = (unsigned int *)v16;
        if (v116 >= v115)
          v115 = v116;
        v53 = COERCE_FLOAT(bswap32(*v115));
      }
      else
      {
        v53 = 1.0;
      }
      v117 = bswap32(*v114);
      if (v8)
      {
        v55 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v55 & 0xF) != 0)
        {
          v54 = *(float *)&v117;
          v28 = -1;
          v13 = v104;
          goto LABEL_63;
        }
      }
      --a4;
      *((_DWORD *)v100 - 1) = v117;
      *v100 = v53;
      v100 += 2;
      v118 = v13 + v99++;
      a2 += v5;
      *(_BYTE *)(v118 + 2) = -1;
      v101 -= v5;
      a3 += v10;
      v102 -= v10;
      if (v103 == (_DWORD)v99)
        return result;
    }
    v13 += v99 + 1;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_Wf_inner(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  float *v47;
  float *v48;
  float *v49;
  unint64_t v50;
  float *v51;
  float *v52;
  float v53;
  int v54;
  float v55;
  unsigned int v56;
  int v57;
  uint64_t v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  float *v72;
  float v73;
  float *v74;
  float v75;
  float v76;
  float v77;
  float *v78;
  unint64_t v79;
  float *v80;
  float *v81;
  float v82;
  float v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  float *v88;
  float v89;
  float v90;
  float *v91;
  float *v92;
  uint64_t v93;
  int64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float *v98;
  float *v99;
  float v100;
  uint64_t v101;
  float *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  unint64_t v113;
  float *v114;
  float *v115;
  float *v116;
  uint64_t v117;
  int v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  int v125;

  v4 = *(_DWORD *)(result + 24);
  v125 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v124 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v124 = v5 % v6;
  }
  else
  {
    v124 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v10 = *(_QWORD *)(result + 32);
  v9 = *(_QWORD *)(result + 40);
  v11 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v12 = v11 % v7;
    if (v11 <= v7)
      v12 = *(_QWORD *)(result + 120);
    v123 = v12;
  }
  else
  {
    v123 = 0;
  }
  v119 = *(_QWORD *)(result + 80);
  v120 = *(_QWORD *)(result + 64);
  v121 = *(_QWORD *)(result + 88);
  v13 = *(_QWORD *)(result + 152) - 8;
  v14 = *(_QWORD *)(result + 144) - 1;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v17 = v9 + (v15 * v125) + 4 * (v16 - 1);
  v118 = *(_DWORD *)(result + 188);
  v18 = v10 + (v15 * v4) + 4 * v16 - 4;
  v122 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 < v122)
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v122 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      if (v21 < 1)
        goto LABEL_57;
      if (v21 >= v19)
        LODWORD(v22) = 0x3FFFFFFF;
      else
        v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v29 = v118 | v22;
      v30 = v20 + 0x1000000;
      v27 = a3 - (v20 + 0x1000000);
      v28 = 512;
      goto LABEL_22;
    }
    if (a3 <= v121)
    {
      v27 = 0;
      v28 = ((unint64_t)a3 >> 22) & 0x3C0;
      v29 = 0x3FFFFFFF;
      v30 = a3;
LABEL_22:
      v31 = v120;
      goto LABEL_25;
    }
    v23 = *(_QWORD *)(result + 216);
    v24 = *(_QWORD *)(result + 224) + v121;
    v25 = v24 - a3 + (v23 >> 1);
    if (v25 < 1)
      goto LABEL_57;
    if (v25 >= v23)
      LODWORD(v26) = 0x3FFFFFFF;
    else
      v26 = (unint64_t)(*(_QWORD *)(result + 232) * v25) >> 32;
    v31 = v120;
    v29 = v118 | v26;
    v30 = v24 - 0x1000000;
    v27 = a3 - (v24 - 0x1000000);
    v28 = 448;
LABEL_25:
    if (a2 >= v31)
      break;
    v32 = *(_QWORD *)(result + 192);
    v33 = v31 - *(_QWORD *)(result + 200);
    v34 = a2 - v33 + (v32 >> 1);
    if (v34 >= 1)
    {
      if (v34 < v32)
        v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v118;
      v35 = v33 + 0x1000000;
      v36 = a2 - (v33 + 0x1000000);
      v37 = 32;
      goto LABEL_36;
    }
LABEL_57:
    v54 = a4 - 1;
    a2 += v5;
    a3 += v11;
    v13 += 8;
    *(_BYTE *)++v14 = 0;
LABEL_58:
    a4 = v54;
    if (!v54)
      return result;
  }
  if (a2 <= v119)
  {
    v36 = 0;
    v37 = ((unint64_t)a2 >> 26) & 0x3C;
    v35 = a2;
    goto LABEL_36;
  }
  v38 = *(_QWORD *)(result + 192);
  v39 = *(_QWORD *)(result + 200) + v119;
  v40 = v39 - a2 + (v38 >> 1);
  if (v40 < 1)
    goto LABEL_57;
  if (v40 < v38)
    v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v118;
  v35 = v39 - 0x1000000;
  v36 = a2 - (v39 - 0x1000000);
  v37 = 28;
LABEL_36:
  if (v29 < 0x400000)
    goto LABEL_57;
  if (v6)
  {
    v41 = (v7 & ((v30 % v7) >> 63)) + v30 % v7;
    v42 = (v6 & ((v35 % v6) >> 63)) + v35 % v6;
    if (v41 >= v7)
      v43 = v7;
    else
      v43 = 0;
    v30 = v41 - v43;
    if (v42 >= v6)
      v44 = v6;
    else
      v44 = 0;
    v35 = v42 - v44;
    v27 += v30;
    v36 += v35;
  }
  v45 = v30 >> 32;
  v46 = (v35 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v47 = (float *)(v10 + SHIDWORD(v30) * (uint64_t)v4 + v46);
  v48 = *(float **)(result + 32);
  if (v18 >= (unint64_t)v47)
    v49 = v47;
  else
    v49 = (float *)v18;
  if (v49 < v48)
    v49 = *(float **)(result + 32);
  if (v9)
  {
    v50 = v9 + (int)v45 * (uint64_t)v125 + v46;
    v51 = *(float **)(result + 40);
    if (v17 >= v50)
      v52 = (float *)v50;
    else
      v52 = (float *)v17;
    if (v52 >= v51)
      v51 = v52;
    v53 = *v51;
  }
  else
  {
    v50 = 0;
    v53 = 1.0;
  }
  v55 = *v49;
  if (v8)
  {
    v56 = *(_DWORD *)(v8 + (v37 | v28));
LABEL_64:
    v57 = v56 & 0xF;
    v58 = v56 >> 8;
    v59 = HIBYTE(v56) & 3;
    if (v57 == 1)
    {
      LODWORD(v84) = SBYTE1(v56);
      if (v6)
      {
        v85 = v27 + ((uint64_t)SBYTE1(v56) << 32);
        v86 = v7 & (v85 >> 63);
        if (v86 + v85 >= v7)
          v87 = v7;
        else
          v87 = 0;
        v84 = (v86 + ((uint64_t)(char)v58 << 32) - v87) >> 32;
      }
      v88 = (float *)((char *)v47 + (int)v84 * (uint64_t)v4);
      if (v18 < (unint64_t)v88)
        v88 = (float *)v18;
      if (v88 < v48)
        v88 = v48;
      v89 = *v88;
      v90 = 1.0;
      if (v9)
      {
        v91 = (float *)(v50 + (int)v84 * (uint64_t)v125);
        if (v17 < (unint64_t)v91)
          v91 = (float *)v17;
        if ((unint64_t)v91 < *(_QWORD *)(result + 40))
          v91 = *(float **)(result + 40);
        v90 = *v91;
      }
      v92 = &interpolate_waf[2 * v59];
    }
    else
    {
      if (v57 != 2)
      {
        if (v57 == 3)
        {
          LODWORD(v60) = SBYTE1(v56);
          v61 = SBYTE2(v56);
          if (v6)
          {
            v62 = v58 << 56;
            v63 = v27 + ((uint64_t)SBYTE1(v56) << 32);
            v64 = v36 + ((uint64_t)SBYTE2(v56) << 32);
            v65 = v7 & (v63 >> 63);
            v66 = v6 & (v64 >> 63);
            v67 = v66 + v64;
            if (v65 + v63 >= v7)
              v68 = v7;
            else
              v68 = 0;
            if (v67 >= v6)
              v69 = v6;
            else
              v69 = 0;
            v60 = (v65 + (v62 >> 24) - v68) >> 32;
            v70 = v66 + ((uint64_t)((unint64_t)HIWORD(v56) << 56) >> 24) - v69;
            v59 = HIBYTE(v56) & 3;
            v61 = v70 >> 32;
          }
          v71 = (unint64_t)&v47[v61];
          if (v18 >= v71)
            v72 = &v47[v61];
          else
            v72 = (float *)v18;
          if (v72 < v48)
            v72 = v48;
          v73 = *v72;
          v74 = (float *)(v71 + (int)v60 * (uint64_t)v4);
          if (v18 < (unint64_t)v74)
            v74 = (float *)v18;
          if (v74 < v48)
            v74 = v48;
          v75 = *v74;
          v76 = 1.0;
          v77 = 1.0;
          if (v9)
          {
            v78 = (float *)(v50 + 4 * v61);
            v79 = *(_QWORD *)(result + 40);
            if (v17 >= (unint64_t)v78)
              v80 = v78;
            else
              v80 = (float *)v17;
            if ((unint64_t)v80 < v79)
              v80 = *(float **)(result + 40);
            v76 = *v80;
            v81 = (float *)((char *)v78 + (int)v60 * (uint64_t)v125);
            if (v17 < (unint64_t)v81)
              v81 = (float *)v17;
            if ((unint64_t)v81 < v79)
              v81 = *(float **)(result + 40);
            v77 = *v81;
          }
          v82 = interpolate_waf[2 * v59 + 1];
          v83 = interpolate_waf[2 * ((v56 >> 28) & 3) + 1];
          v55 = (float)((float)((float)(v55 - (float)(v55 * v82)) + (float)(v73 * v82))
                      - (float)((float)((float)(v55 - (float)(v55 * v82)) + (float)(v73 * v82)) * v83))
              + (float)((float)((float)(v73 - (float)(v73 * v82)) + (float)(v75 * v82)) * v83);
          v53 = (float)((float)((float)(v53 - (float)(v53 * v82)) + (float)(v76 * v82))
                      - (float)((float)((float)(v53 - (float)(v53 * v82)) + (float)(v76 * v82)) * v83))
              + (float)((float)((float)(v76 - (float)(v76 * v82)) + (float)(v77 * v82)) * v83);
        }
        goto LABEL_129;
      }
      v93 = SBYTE2(v56);
      if (v6)
      {
        v94 = (unint64_t)HIWORD(v56) << 56;
        v95 = v36 + (v94 >> 24);
        v96 = v6 & (v95 >> 63);
        if (v96 + v95 >= v6)
          v97 = v6;
        else
          v97 = 0;
        v93 = (v96 + (v94 >> 24) - v97) >> 32;
      }
      v98 = &v47[v93];
      if (v18 < (unint64_t)v98)
        v98 = (float *)v18;
      if (v98 < v48)
        v98 = v48;
      v89 = *v98;
      v90 = 1.0;
      if (v9)
      {
        v99 = (float *)(v50 + 4 * v93);
        if (v17 < (unint64_t)v99)
          v99 = (float *)v17;
        if ((unint64_t)v99 < *(_QWORD *)(result + 40))
          v99 = *(float **)(result + 40);
        v90 = *v99;
      }
      v92 = &interpolate_waf[2 * ((v56 >> 28) & 3)];
    }
    v100 = v92[1];
    v55 = (float)(v55 - (float)(v55 * v100)) + (float)(v89 * v100);
    v53 = (float)(v53 - (float)(v53 * v100)) + (float)(v90 * v100);
  }
LABEL_129:
  *(float *)(v13 + 8) = v55;
  *(float *)(v13 + 12) = v53;
  *(_BYTE *)(v14 + 1) = v29 >> 22;
  if (a4 != 1)
  {
    v101 = 0;
    v102 = (float *)(v13 + 20);
    a2 += v5;
    v103 = v119 - a2;
    a3 += v11;
    v104 = v121 - a3;
    while (((v104 | v103 | (a3 - v122) | (a2 - v120)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v105 = (v7 & ((v27 + v123) >> 63)) + v27 + v123;
        v106 = (v6 & ((v36 + v124) >> 63)) + v36 + v124;
        if (v105 >= v7)
          v107 = v7;
        else
          v107 = 0;
        v27 = v105 - v107;
        if (v106 >= v6)
          v108 = v6;
        else
          v108 = 0;
        v36 = v106 - v108;
        v109 = v27;
        v110 = v36;
      }
      else
      {
        v109 = a3;
        v110 = a2;
      }
      v111 = v109 >> 32;
      v112 = v10 + (int)v111 * (uint64_t)v4;
      v113 = (v110 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
      v47 = (float *)(v112 + v113);
      v48 = *(float **)(result + 32);
      if (v18 >= v112 + v113)
        v114 = (float *)(v112 + v113);
      else
        v114 = (float *)v18;
      if (v114 < v48)
        v114 = *(float **)(result + 32);
      if (v9)
      {
        v50 = v9 + (int)v111 * (uint64_t)v125 + v113;
        v115 = *(float **)(result + 40);
        if (v17 >= v50)
          v116 = (float *)v50;
        else
          v116 = (float *)v17;
        if (v116 >= v115)
          v115 = v116;
        v53 = *v115;
      }
      else
      {
        v53 = 1.0;
      }
      v55 = *v114;
      if (v8)
      {
        v56 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v56 & 0xF) != 0)
        {
          v14 += v101 + 1;
          v13 = (uint64_t)(v102 - 3);
          a4 += ~(_DWORD)v101;
          v29 = -1;
          goto LABEL_64;
        }
      }
      *(v102 - 1) = v55;
      *v102 = v53;
      v117 = v14 + v101++;
      v102 += 2;
      a2 += v5;
      *(_BYTE *)(v117 + 2) = -1;
      v103 -= v5;
      a3 += v11;
      v104 -= v11;
      if (a4 - 1 == (_DWORD)v101)
        return result;
    }
    v14 += v101 + 1;
    v13 = (uint64_t)(v102 - 3);
    v54 = ~(_DWORD)v101 + a4;
    goto LABEL_58;
  }
  return result;
}

uint64_t Wf_sample_RGBF(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float32x2_t v12;
  float32x2_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  int8x8_t *v48;
  int8x8_t *v49;
  float32x2_t v50;
  float v51;
  unsigned int v52;
  float v53;
  int v54;
  unsigned int v55;
  unint64_t v56;
  int8x8_t *v57;
  float v58;
  int8x8_t *v59;
  float32x2_t v60;
  float32x2_t v61;
  int8x8_t *v62;
  float v63;
  uint64_t v64;
  float *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int8x8_t *v69;
  float v70;
  uint64_t v71;
  int v72;

  v14 = *(_QWORD *)(result + 32);
  v15 = *(_DWORD *)(result + 24);
  v16 = *(_QWORD *)(result + 176);
  v17 = *(_QWORD *)(result + 64);
  v18 = *(_QWORD *)(result + 72);
  v19 = *(_QWORD *)(result + 80);
  v20 = *(_QWORD *)(result + 88);
  v21 = *(_QWORD *)(result + 112);
  v22 = *(_QWORD *)(result + 120);
  v72 = *(_DWORD *)(result + 188);
  v23 = *(_QWORD *)(result + 152) - 8;
  v24 = *(_QWORD *)(result + 144) - 1;
  v25 = v14
      + ((*(_DWORD *)(result + 260) - 1) * v15)
      + 4 * (3 * *(_DWORD *)(result + 256))
      - 12;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v18)
      {
        if ((uint64_t)a3 <= v20)
        {
          v34 = (a3 >> 22) & 0x3C0;
          v35 = 0x3FFFFFFF;
          HIDWORD(v36) = HIDWORD(a3);
        }
        else
        {
          v30 = *(_QWORD *)(result + 216);
          v31 = *(_QWORD *)(result + 224) + v20;
          v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1)
            goto LABEL_34;
          if (v32 >= v30)
            LODWORD(v33) = 0x3FFFFFFF;
          else
            v33 = (unint64_t)(*(_QWORD *)(result + 232) * v32) >> 32;
          v35 = v33 | v72;
          v36 = v31 - 0x1000000;
          v34 = 448;
        }
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = v18 - *(_QWORD *)(result + 224);
        v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1)
          goto LABEL_34;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v35 = v29 | v72;
        v36 = v27 + 0x1000000;
        v34 = 512;
      }
      if (a2 >= v17)
        break;
      v37 = *(_QWORD *)(result + 192);
      v38 = v17 - *(_QWORD *)(result + 200);
      v39 = a2 - v38 + (v37 >> 1);
      if (v39 >= 1)
      {
        if (v39 < v37)
          v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v39) >> 32) >> 15)) | v72;
        v40 = v38 + 0x1000000;
        v41 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v21;
      a3 += v22;
      v23 += 8;
      *(_BYTE *)++v24 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v19)
    {
      v41 = ((unint64_t)a2 >> 26) & 0x3C;
      v40 = a2;
      goto LABEL_26;
    }
    v42 = *(_QWORD *)(result + 192);
    v43 = *(_QWORD *)(result + 200) + v19;
    v44 = v43 - a2 + (v42 >> 1);
    if (v44 < 1)
      goto LABEL_34;
    if (v44 < v42)
      v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v44) >> 32) >> 15)) | v72;
    v40 = v43 - 0x1000000;
    v41 = 28;
LABEL_26:
    if (v35 < 0x400000)
      goto LABEL_34;
    v45 = v40 >> 32;
    v46 = v14 + SHIDWORD(v36) * (uint64_t)v15;
    v47 = v46 + 12 * (int)v45;
    v48 = *(int8x8_t **)(result + 32);
    if (v25 >= v47)
      v49 = (int8x8_t *)(v46 + 12 * (int)v45);
    else
      v49 = (int8x8_t *)v25;
    if (v49 < v48)
      v49 = *(int8x8_t **)(result + 32);
    v50 = (float32x2_t)vrev32_s8(*v49);
    v51 = COERCE_FLOAT(bswap32(v49[1].u32[0]));
    if (v16)
    {
      v52 = *(_DWORD *)(v16 + (v41 | v34));
LABEL_38:
      v54 = v52 & 0xF;
      v55 = HIBYTE(v52) & 3;
      switch(v54)
      {
        case 1:
          v62 = (int8x8_t *)(v47 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v62)
            v62 = (int8x8_t *)v25;
          if (v62 < v48)
            v62 = v48;
          v63 = COERCE_FLOAT(bswap32(v62[1].u32[0]));
          break;
        case 2:
          v62 = (int8x8_t *)(v47 + 12 * SBYTE2(v52));
          if (v25 < (unint64_t)v62)
            v62 = (int8x8_t *)v25;
          if (v62 < v48)
            v62 = v48;
          v63 = COERCE_FLOAT(bswap32(v62[1].u32[0]));
          v55 = (v52 >> 28) & 3;
          break;
        case 3:
          v56 = v47 + 12 * SBYTE2(v52);
          if (v25 >= v56)
            v57 = (int8x8_t *)(v47 + 12 * SBYTE2(v52));
          else
            v57 = (int8x8_t *)v25;
          if (v57 < v48)
            v57 = v48;
          v58 = COERCE_FLOAT(bswap32(v57[1].u32[0]));
          v59 = (int8x8_t *)(v56 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v59)
            v59 = (int8x8_t *)v25;
          if (v59 < v48)
            v59 = v48;
          v12.i32[0] = interpolate_rgbaf_19467[4 * v55 + 3];
          v13.i32[0] = interpolate_rgbaf_19467[4 * ((v52 >> 28) & 3) + 3];
          v51 = (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v58 * v12.f32[0]))
                      - (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v58 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v58 - (float)(v58 * v12.f32[0]))
                              + (float)(COERCE_FLOAT(bswap32(v59[1].u32[0])) * v12.f32[0]))
                      * v13.f32[0]);
          v60 = (float32x2_t)vrev32_s8(*v57);
          v61 = vmla_n_f32(vmls_lane_f32(v50, v50, v12, 0), v60, v12.f32[0]);
          a12 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(v60, v60, v12, 0), (float32x2_t)vrev32_s8(*v59), v12.f32[0]));
          v50 = vmla_n_f32(vmls_lane_f32(v61, v61, v13, 0), *(float32x2_t *)&a12, v13.f32[0]);
          v53 = (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0]))
                      - (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]))
              + (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      LODWORD(a12) = interpolate_rgbaf_19467[4 * v55 + 3];
      v12 = (float32x2_t)vrev32_s8(*v62);
      v50 = vmla_n_f32(vmls_lane_f32(v50, v50, *(float32x2_t *)&a12, 0), v12, *(float *)&a12);
      v51 = (float)(v51 - (float)(v51 * *(float *)&a12)) + (float)(v63 * *(float *)&a12);
      v53 = *(float *)&a12 + (float)(1.0 - *(float *)&a12);
      goto LABEL_62;
    }
LABEL_36:
    v53 = 1.0;
LABEL_62:
    *(float *)(v23 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
    *(float *)(v23 + 12) = v53;
    *(_BYTE *)(v24 + 1) = v35 >> 22;
    if (a4 == 1)
      break;
    v64 = 0;
    v65 = (float *)(v23 + 20);
    a2 += v21;
    v66 = v19 - a2;
    a3 += v22;
    v67 = v20 - a3;
    while ((((a2 - v17) | v66 | (a3 - v18) | v67) & 0x8000000000000000) == 0)
    {
      v68 = v14 + SHIDWORD(a3) * (uint64_t)v15;
      v47 = v68 + 12 * SHIDWORD(a2);
      v48 = *(int8x8_t **)(result + 32);
      if (v25 >= v47)
        v69 = (int8x8_t *)(v68 + 12 * SHIDWORD(a2));
      else
        v69 = (int8x8_t *)v25;
      if (v69 < v48)
        v69 = *(int8x8_t **)(result + 32);
      v50 = (float32x2_t)vrev32_s8(*v69);
      v70 = COERCE_FLOAT(bswap32(v69[1].u32[0]));
      v51 = v70;
      if (v16)
      {
        v52 = *(_DWORD *)(v16 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v52 & 0xF) != 0)
        {
          v24 += v64 + 1;
          v23 = (uint64_t)(v65 - 3);
          a4 += ~(_DWORD)v64;
          v35 = -1;
          goto LABEL_38;
        }
      }
      *(v65 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v70 * 0.11);
      *v65 = 1.0;
      v65 += 2;
      v71 = v24 + v64++;
      a2 += v21;
      *(_BYTE *)(v71 + 2) = -1;
      v66 -= v21;
      a3 += v22;
      v67 -= v22;
      if (a4 - 1 == (_DWORD)v64)
        return result;
    }
    v24 += v64 + 1;
    v23 = (uint64_t)(v65 - 3);
    a4 += ~(_DWORD)v64;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBf(uint64_t result, uint64_t a2, unint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float32x2_t v12;
  float32x2_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  float32x2_t *v48;
  float32x2_t *v49;
  float32x2_t v50;
  float v51;
  unsigned int v52;
  float v53;
  int v54;
  int v55;
  unint64_t v56;
  float32x2_t *v57;
  float32x2_t *v58;
  float32x2_t v59;
  float32x2_t *v60;
  float v61;
  float32x2_t *v62;
  uint64_t v63;
  float *v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  int v69;

  v14 = *(_QWORD *)(result + 32);
  v15 = *(_DWORD *)(result + 24);
  v16 = *(_QWORD *)(result + 176);
  v17 = *(_QWORD *)(result + 64);
  v18 = *(_QWORD *)(result + 72);
  v19 = *(_QWORD *)(result + 80);
  v20 = *(_QWORD *)(result + 88);
  v21 = *(_QWORD *)(result + 112);
  v22 = *(_QWORD *)(result + 120);
  v69 = *(_DWORD *)(result + 188);
  v23 = *(_QWORD *)(result + 152) - 8;
  v24 = *(_QWORD *)(result + 144) - 1;
  v25 = v14
      + ((*(_DWORD *)(result + 260) - 1) * v15)
      + 4 * (3 * *(_DWORD *)(result + 256))
      - 12;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v18)
      {
        if ((uint64_t)a3 <= v20)
        {
          v34 = (a3 >> 22) & 0x3C0;
          v35 = 0x3FFFFFFF;
          HIDWORD(v36) = HIDWORD(a3);
        }
        else
        {
          v30 = *(_QWORD *)(result + 216);
          v31 = *(_QWORD *)(result + 224) + v20;
          v32 = v31 - a3 + (v30 >> 1);
          if (v32 < 1)
            goto LABEL_34;
          if (v32 >= v30)
            LODWORD(v33) = 0x3FFFFFFF;
          else
            v33 = (unint64_t)(*(_QWORD *)(result + 232) * v32) >> 32;
          v35 = v33 | v69;
          v36 = v31 - 0x1000000;
          v34 = 448;
        }
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = v18 - *(_QWORD *)(result + 224);
        v28 = a3 - v27 + (v26 >> 1);
        if (v28 < 1)
          goto LABEL_34;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v35 = v29 | v69;
        v36 = v27 + 0x1000000;
        v34 = 512;
      }
      if (a2 >= v17)
        break;
      v37 = *(_QWORD *)(result + 192);
      v38 = v17 - *(_QWORD *)(result + 200);
      v39 = a2 - v38 + (v37 >> 1);
      if (v39 >= 1)
      {
        if (v39 < v37)
          v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v39) >> 32) >> 15)) | v69;
        v40 = v38 + 0x1000000;
        v41 = 32;
        goto LABEL_26;
      }
LABEL_34:
      --a4;
      a2 += v21;
      a3 += v22;
      v23 += 8;
      *(_BYTE *)++v24 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v19)
    {
      v41 = ((unint64_t)a2 >> 26) & 0x3C;
      v40 = a2;
      goto LABEL_26;
    }
    v42 = *(_QWORD *)(result + 192);
    v43 = *(_QWORD *)(result + 200) + v19;
    v44 = v43 - a2 + (v42 >> 1);
    if (v44 < 1)
      goto LABEL_34;
    if (v44 < v42)
      v35 = ((v35 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v44) >> 32) >> 15)) | v69;
    v40 = v43 - 0x1000000;
    v41 = 28;
LABEL_26:
    if (v35 < 0x400000)
      goto LABEL_34;
    v45 = v40 >> 32;
    v46 = v14 + SHIDWORD(v36) * (uint64_t)v15;
    v47 = v46 + 12 * (int)v45;
    v48 = *(float32x2_t **)(result + 32);
    if (v25 >= v47)
      v49 = (float32x2_t *)(v46 + 12 * (int)v45);
    else
      v49 = (float32x2_t *)v25;
    if (v49 < v48)
      v49 = *(float32x2_t **)(result + 32);
    v50 = *v49;
    v51 = v49[1].f32[0];
    if (v16)
    {
      v52 = *(_DWORD *)(v16 + (v41 | v34));
LABEL_38:
      v54 = v52 & 0xF;
      v55 = HIBYTE(v52) & 3;
      switch(v54)
      {
        case 1:
          v60 = (float32x2_t *)(v47 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v60)
            v60 = (float32x2_t *)v25;
          if (v60 < v48)
            v60 = v48;
          v61 = v60[1].f32[0];
          LODWORD(a12) = interpolate_rgbaf_19467[4 * v55 + 3];
          v12 = *v60;
          break;
        case 2:
          v62 = (float32x2_t *)(v47 + 12 * SBYTE2(v52));
          if (v25 < (unint64_t)v62)
            v62 = (float32x2_t *)v25;
          if (v62 < v48)
            v62 = v48;
          v61 = v62[1].f32[0];
          LODWORD(a12) = interpolate_rgbaf_19467[4 * ((v52 >> 28) & 3) + 3];
          v12 = *v62;
          break;
        case 3:
          v56 = v47 + 12 * SBYTE2(v52);
          if (v25 >= v56)
            v57 = (float32x2_t *)(v47 + 12 * SBYTE2(v52));
          else
            v57 = (float32x2_t *)v25;
          if (v57 < v48)
            v57 = v48;
          v58 = (float32x2_t *)(v56 + SBYTE1(v52) * (uint64_t)v15);
          if (v25 < (unint64_t)v58)
            v58 = (float32x2_t *)v25;
          if (v58 < v48)
            v58 = v48;
          v12.i32[0] = interpolate_rgbaf_19467[4 * v55 + 3];
          v13.i32[0] = interpolate_rgbaf_19467[4 * ((v52 >> 28) & 3) + 3];
          v51 = (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v57[1].f32[0] * v12.f32[0]))
                      - (float)((float)((float)(v51 - (float)(v51 * v12.f32[0])) + (float)(v57[1].f32[0] * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v57[1].f32[0] - (float)(v57[1].f32[0] * v12.f32[0]))
                              + (float)(v58[1].f32[0] * v12.f32[0]))
                      * v13.f32[0]);
          v59 = vmla_n_f32(vmls_lane_f32(v50, v50, v12, 0), *v57, v12.f32[0]);
          a12 = COERCE_DOUBLE(vmla_n_f32(vmls_lane_f32(*v57, *v57, v12, 0), *v58, v12.f32[0]));
          v50 = vmla_n_f32(vmls_lane_f32(v59, v59, v13, 0), *(float32x2_t *)&a12, v13.f32[0]);
          v53 = (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0]))
                      - (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]))
              + (float)((float)(v12.f32[0] + (float)(1.0 - v12.f32[0])) * v13.f32[0]);
          goto LABEL_62;
        default:
          goto LABEL_36;
      }
      v50 = vmla_n_f32(vmls_lane_f32(v50, v50, *(float32x2_t *)&a12, 0), v12, *(float *)&a12);
      v51 = (float)(v51 - (float)(v51 * *(float *)&a12)) + (float)(v61 * *(float *)&a12);
      v53 = *(float *)&a12 + (float)(1.0 - *(float *)&a12);
      goto LABEL_62;
    }
LABEL_36:
    v53 = 1.0;
LABEL_62:
    *(float *)(v23 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
    *(float *)(v23 + 12) = v53;
    *(_BYTE *)(v24 + 1) = v35 >> 22;
    if (a4 == 1)
      break;
    v63 = 0;
    v64 = (float *)(v23 + 20);
    a2 += v21;
    v65 = v19 - a2;
    a3 += v22;
    v66 = v20 - a3;
    while ((((a2 - v17) | v65 | (a3 - v18) | v66) & 0x8000000000000000) == 0)
    {
      v47 = v14 + SHIDWORD(a3) * (uint64_t)v15 + 12 * SHIDWORD(a2);
      v48 = *(float32x2_t **)(result + 32);
      if (v25 >= v47)
        v67 = v14 + SHIDWORD(a3) * (uint64_t)v15 + 12 * SHIDWORD(a2);
      else
        v67 = v25;
      if (v67 < (unint64_t)v48)
        v67 = *(_QWORD *)(result + 32);
      v50 = *(float32x2_t *)v67;
      v51 = *(float *)(v67 + 8);
      if (v16)
      {
        v52 = *(_DWORD *)(v16 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v52 & 0xF) != 0)
        {
          v24 += v63 + 1;
          v23 = (uint64_t)(v64 - 3);
          a4 += ~(_DWORD)v63;
          v35 = -1;
          goto LABEL_38;
        }
      }
      *(v64 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v50, 1), 0.3, v50.f32[0]) + (float)(v51 * 0.11);
      *v64 = 1.0;
      v64 += 2;
      v68 = v24 + v63++;
      a2 += v21;
      *(_BYTE *)(v68 + 2) = -1;
      v65 -= v21;
      a3 += v22;
      v66 -= v22;
      if (a4 - 1 == (_DWORD)v63)
        return result;
    }
    v24 += v63 + 1;
    v23 = (uint64_t)(v64 - 3);
    a4 += ~(_DWORD)v63;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBAF(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  int8x8_t *v42;
  int8x8_t *v43;
  int8x8_t *v44;
  float v45;
  float32x2_t v46;
  float v47;
  unsigned int v48;
  int v49;
  int v50;
  int8x8_t *v51;
  int8x8_t *v52;
  float32x2_t v53;
  float v54;
  float v55;
  float v56;
  unint64_t v57;
  int8x8_t *v58;
  float32x2_t v59;
  float v60;
  float32x2_t v61;
  int8x8_t *v62;
  int8x8_t *v63;
  float32x2_t v64;
  float v65;
  float v66;
  _DWORD *v67;
  int8x8_t *v68;
  int8x8_t *v69;
  uint64_t v70;
  float *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  int8x8_t *v75;
  int8x8_t *v76;
  float v77;
  uint64_t v78;
  int v79;

  v7 = *(_DWORD *)(result + 24);
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 64);
  v10 = *(_QWORD *)(result + 72);
  v11 = *(_QWORD *)(result + 80);
  v12 = *(_QWORD *)(result + 88);
  v13 = *(_QWORD *)(result + 112);
  v14 = *(_QWORD *)(result + 120);
  v79 = *(_DWORD *)(result + 188);
  v15 = *(_QWORD *)(result + 152) - 8;
  v16 = *(_QWORD *)(result + 144) - 1;
  v18 = *(_QWORD *)(result + 32);
  v17 = *(_QWORD *)(result + 40);
  v19 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v7)
      + 4 * (4 * *(_DWORD *)(result + 256))
      - 16;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v10)
      {
        if ((uint64_t)a3 <= v12)
        {
          v28 = (a3 >> 22) & 0x3C0;
          v29 = 0x3FFFFFFF;
          HIDWORD(v30) = HIDWORD(a3);
        }
        else
        {
          v24 = *(_QWORD *)(result + 216);
          v25 = *(_QWORD *)(result + 224) + v12;
          v26 = v25 - a3 + (v24 >> 1);
          if (v26 < 1)
            goto LABEL_35;
          if (v26 >= v24)
            LODWORD(v27) = 0x3FFFFFFF;
          else
            v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
          v29 = v27 | v79;
          v30 = v25 - 0x1000000;
          v28 = 448;
        }
      }
      else
      {
        v20 = *(_QWORD *)(result + 216);
        v21 = v10 - *(_QWORD *)(result + 224);
        v22 = a3 - v21 + (v20 >> 1);
        if (v22 < 1)
          goto LABEL_35;
        if (v22 >= v20)
          LODWORD(v23) = 0x3FFFFFFF;
        else
          v23 = (unint64_t)(*(_QWORD *)(result + 232) * v22) >> 32;
        v29 = v23 | v79;
        v30 = v21 + 0x1000000;
        v28 = 512;
      }
      if (a2 >= v9)
        break;
      v31 = *(_QWORD *)(result + 192);
      v32 = v9 - *(_QWORD *)(result + 200);
      v33 = a2 - v32 + (v31 >> 1);
      if (v33 >= 1)
      {
        if (v33 < v31)
          v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v33) >> 32) >> 15)) | v79;
        v34 = v32 + 0x1000000;
        v35 = 32;
        goto LABEL_26;
      }
LABEL_35:
      --a4;
      a2 += v13;
      a3 += v14;
      v15 += 8;
      *(_BYTE *)++v16 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v11)
    {
      v35 = ((unint64_t)a2 >> 26) & 0x3C;
      v34 = a2;
      goto LABEL_26;
    }
    v36 = *(_QWORD *)(result + 192);
    v37 = *(_QWORD *)(result + 200) + v11;
    v38 = v37 - a2 + (v36 >> 1);
    if (v38 < 1)
      goto LABEL_35;
    if (v38 < v36)
      v29 = ((v29 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v38) >> 32) >> 15)) | v79;
    v34 = v37 - 0x1000000;
    v35 = 28;
LABEL_26:
    if (v29 < 0x400000)
      goto LABEL_35;
    v39 = v18 + SHIDWORD(v30) * (uint64_t)v7;
    v40 = v34 >> 32;
    v41 = v39 + 16 * v40;
    v42 = *(int8x8_t **)(result + 32);
    if (v19 >= v41)
      v43 = (int8x8_t *)(v39 + 16 * v40);
    else
      v43 = (int8x8_t *)v19;
    if (v43 >= v42)
      v44 = v43;
    else
      v44 = *(int8x8_t **)(result + 32);
    if (v17)
      v45 = COERCE_FLOAT(bswap32(v44[1].u32[1]));
    else
      v45 = 1.0;
    v46 = (float32x2_t)vrev32_s8(*v44);
    v47 = COERCE_FLOAT(bswap32(v44[1].u32[0]));
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (v35 | v28));
LABEL_41:
      v49 = v48 & 0xF;
      v50 = HIBYTE(v48) & 3;
      if (v49 == 1)
      {
        v62 = (int8x8_t *)(v41 + SBYTE1(v48) * (uint64_t)v7);
        if (v19 < (unint64_t)v62)
          v62 = (int8x8_t *)v19;
        if (v62 >= v42)
          v63 = v62;
        else
          v63 = v42;
        v64 = (float32x2_t)vrev32_s8(*v63);
        v65 = COERCE_FLOAT(bswap32(v63[1].u32[0]));
        v66 = 1.0;
        if (v17)
          v66 = COERCE_FLOAT(bswap32(v63[1].u32[1]));
        v67 = &interpolate_rgbaf_19467[4 * v50];
      }
      else
      {
        if (v49 != 2)
        {
          if (v49 == 3)
          {
            v51 = (int8x8_t *)(v41 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52));
            if (v19 < (unint64_t)v51)
              v51 = (int8x8_t *)v19;
            if (v51 >= v42)
              v52 = v51;
            else
              v52 = v42;
            v53 = (float32x2_t)vrev32_s8(*v52);
            v54 = COERCE_FLOAT(bswap32(v52[1].u32[0]));
            v55 = 1.0;
            v56 = 1.0;
            if (v17)
              v56 = COERCE_FLOAT(bswap32(v52[1].u32[1]));
            v57 = v41 + SBYTE1(v48) * (uint64_t)v7 + 16 * SBYTE2(v48);
            if (v19 < v57)
              v57 = v19;
            if (v57 >= (unint64_t)v42)
              v58 = (int8x8_t *)v57;
            else
              v58 = v42;
            v59 = (float32x2_t)vrev32_s8(*v58);
            v60 = COERCE_FLOAT(bswap32(v58[1].u32[0]));
            if (v17)
              v55 = COERCE_FLOAT(bswap32(v58[1].u32[1]));
            v5.i32[0] = interpolate_rgbaf_19467[4 * v50 + 3];
            v6.i32[0] = interpolate_rgbaf_19467[4 * ((v48 >> 28) & 3) + 3];
            v47 = (float)((float)((float)(v47 - (float)(v47 * v5.f32[0])) + (float)(v54 * v5.f32[0]))
                        - (float)((float)((float)(v47 - (float)(v47 * v5.f32[0])) + (float)(v54 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v54 - (float)(v54 * v5.f32[0])) + (float)(v60 * v5.f32[0])) * v6.f32[0]);
            v61 = vmla_n_f32(vmls_lane_f32(v46, v46, v5, 0), v53, v5.f32[0]);
            v46 = vmla_n_f32(vmls_lane_f32(v61, v61, v6, 0), vmla_n_f32(vmls_lane_f32(v53, v53, v5, 0), v59, v5.f32[0]), v6.f32[0]);
            v45 = (float)((float)((float)(v45 - (float)(v45 * v5.f32[0])) + (float)(v56 * v5.f32[0]))
                        - (float)((float)((float)(v45 - (float)(v45 * v5.f32[0])) + (float)(v56 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v56 - (float)(v56 * v5.f32[0])) + (float)(v55 * v5.f32[0])) * v6.f32[0]);
          }
          goto LABEL_76;
        }
        v68 = (int8x8_t *)(v41 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52));
        if (v19 < (unint64_t)v68)
          v68 = (int8x8_t *)v19;
        if (v68 >= v42)
          v69 = v68;
        else
          v69 = v42;
        v64 = (float32x2_t)vrev32_s8(*v69);
        v65 = COERCE_FLOAT(bswap32(v69[1].u32[0]));
        v66 = 1.0;
        if (v17)
          v66 = COERCE_FLOAT(bswap32(v69[1].u32[1]));
        v67 = &interpolate_rgbaf_19467[4 * ((v48 >> 28) & 3)];
      }
      v4.i32[0] = v67[3];
      v46 = vmla_n_f32(vmls_lane_f32(v46, v46, v4, 0), v64, v4.f32[0]);
      v47 = (float)(v47 - (float)(v47 * v4.f32[0])) + (float)(v65 * v4.f32[0]);
      v45 = (float)(v45 - (float)(v45 * v4.f32[0])) + (float)(v66 * v4.f32[0]);
    }
LABEL_76:
    *(float *)(v15 + 8) = vmlas_n_f32(vmuls_lane_f32(0.59, v46, 1), 0.3, v46.f32[0]) + (float)(v47 * 0.11);
    *(float *)(v15 + 12) = v45;
    *(_BYTE *)(v16 + 1) = v29 >> 22;
    if (a4 == 1)
      break;
    v70 = 0;
    v71 = (float *)(v15 + 20);
    a2 += v13;
    v72 = v11 - a2;
    a3 += v14;
    v73 = v12 - a3;
    while ((((a2 - v9) | v72 | (a3 - v10) | v73) & 0x8000000000000000) == 0)
    {
      v74 = v18 + SHIDWORD(a3) * (uint64_t)v7;
      v41 = v74 + 16 * (a2 >> 32);
      v42 = *(int8x8_t **)(result + 32);
      if (v19 >= v41)
        v75 = (int8x8_t *)(v74 + 16 * (a2 >> 32));
      else
        v75 = (int8x8_t *)v19;
      if (v75 >= v42)
        v76 = v75;
      else
        v76 = *(int8x8_t **)(result + 32);
      if (v17)
        v45 = COERCE_FLOAT(bswap32(v76[1].u32[1]));
      else
        v45 = 1.0;
      v46 = (float32x2_t)vrev32_s8(*v76);
      v77 = COERCE_FLOAT(bswap32(v76[1].u32[0]));
      v47 = v77;
      if (v8)
      {
        v48 = *(_DWORD *)(v8 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          v16 += v70 + 1;
          v15 = (uint64_t)(v71 - 3);
          a4 += ~(_DWORD)v70;
          v29 = -1;
          goto LABEL_41;
        }
      }
      *(v71 - 1) = vmlas_n_f32(vmuls_lane_f32(0.59, v46, 1), 0.3, v46.f32[0]) + (float)(v77 * 0.11);
      *v71 = v45;
      v78 = v16 + v70++;
      v71 += 2;
      a2 += v13;
      *(_BYTE *)(v78 + 2) = -1;
      v72 -= v13;
      a3 += v14;
      v73 -= v14;
      if (a4 - 1 == (_DWORD)v70)
        return result;
    }
    v16 += v70 + 1;
    v15 = (uint64_t)(v71 - 3);
    a4 += ~(_DWORD)v70;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_RGBAf(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  float v46;
  unsigned int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  unint64_t v54;
  float32x2_t v55;
  float v56;
  unint64_t v57;
  unint64_t v58;
  float v59;
  unint64_t v60;
  unint64_t v61;
  float32x2_t v62;
  float v63;
  _DWORD *v64;
  unint64_t v65;
  unint64_t v66;
  unint64_t v67;
  float32x2_t v68;
  uint64_t v74;
  float *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v82;
  int v83;

  v7 = *(_DWORD *)(result + 24);
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 64);
  v10 = *(_QWORD *)(result + 72);
  v11 = *(_QWORD *)(result + 80);
  v12 = *(_QWORD *)(result + 88);
  v13 = *(_QWORD *)(result + 112);
  v14 = *(_QWORD *)(result + 120);
  v83 = *(_DWORD *)(result + 188);
  v15 = *(_QWORD *)(result + 152) - 8;
  v16 = *(_QWORD *)(result + 144) - 1;
  v18 = *(_QWORD *)(result + 32);
  v17 = *(_QWORD *)(result + 40);
  v19 = v18
      + ((*(_DWORD *)(result + 260) - 1) * v7)
      + 4 * (4 * *(_DWORD *)(result + 256))
      - 16;
  _S2 = 1038174126;
  do
  {
    while (1)
    {
      if ((uint64_t)a3 >= v10)
      {
        if ((uint64_t)a3 <= v12)
        {
          v29 = (a3 >> 22) & 0x3C0;
          v30 = 0x3FFFFFFF;
          HIDWORD(v31) = HIDWORD(a3);
        }
        else
        {
          v25 = *(_QWORD *)(result + 216);
          v26 = *(_QWORD *)(result + 224) + v12;
          v27 = v26 - a3 + (v25 >> 1);
          if (v27 < 1)
            goto LABEL_35;
          if (v27 >= v25)
            LODWORD(v28) = 0x3FFFFFFF;
          else
            v28 = (unint64_t)(*(_QWORD *)(result + 232) * v27) >> 32;
          v30 = v28 | v83;
          v31 = v26 - 0x1000000;
          v29 = 448;
        }
      }
      else
      {
        v21 = *(_QWORD *)(result + 216);
        v22 = v10 - *(_QWORD *)(result + 224);
        v23 = a3 - v22 + (v21 >> 1);
        if (v23 < 1)
          goto LABEL_35;
        if (v23 >= v21)
          LODWORD(v24) = 0x3FFFFFFF;
        else
          v24 = (unint64_t)(*(_QWORD *)(result + 232) * v23) >> 32;
        v30 = v24 | v83;
        v31 = v22 + 0x1000000;
        v29 = 512;
      }
      if (a2 >= v9)
        break;
      v32 = *(_QWORD *)(result + 192);
      v33 = v9 - *(_QWORD *)(result + 200);
      v34 = a2 - v33 + (v32 >> 1);
      if (v34 >= 1)
      {
        if (v34 < v32)
          v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v83;
        v35 = v33 + 0x1000000;
        v36 = 32;
        goto LABEL_26;
      }
LABEL_35:
      --a4;
      a2 += v13;
      a3 += v14;
      v15 += 8;
      *(_BYTE *)++v16 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v11)
    {
      v36 = ((unint64_t)a2 >> 26) & 0x3C;
      v35 = a2;
      goto LABEL_26;
    }
    v37 = *(_QWORD *)(result + 192);
    v38 = *(_QWORD *)(result + 200) + v11;
    v39 = v38 - a2 + (v37 >> 1);
    if (v39 < 1)
      goto LABEL_35;
    if (v39 < v37)
      v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v39) >> 32) >> 15)) | v83;
    v35 = v38 - 0x1000000;
    v36 = 28;
LABEL_26:
    if (v30 < 0x400000)
      goto LABEL_35;
    v40 = v18 + SHIDWORD(v31) * (uint64_t)v7;
    v41 = v35 >> 32;
    v42 = v40 + 16 * v41;
    v43 = *(_QWORD *)(result + 32);
    if (v19 >= v42)
      v44 = v40 + 16 * v41;
    else
      v44 = v19;
    if (v44 >= v43)
      v45 = v44;
    else
      v45 = *(_QWORD *)(result + 32);
    if (v17)
      v46 = *(float *)(v45 + 12);
    else
      v46 = 1.0;
    _D3 = *(float32x2_t *)(v45 + 4);
    if (v8)
    {
      v48 = *(_DWORD *)(v8 + (v36 | v29));
LABEL_41:
      v49 = v48 & 0xF;
      v50 = HIBYTE(v48) & 3;
      if (v49 == 1)
      {
        v60 = v42 + SBYTE1(v48) * (uint64_t)v7;
        if (v19 < v60)
          v60 = v19;
        if (v60 >= v43)
          v61 = v60;
        else
          v61 = v43;
        v62 = *(float32x2_t *)(v61 + 4);
        v63 = 1.0;
        if (v17)
          v63 = *(float *)(v61 + 12);
        v64 = &interpolate_rgbaf_19467[4 * v50];
      }
      else
      {
        if (v49 != 2)
        {
          if (v49 == 3)
          {
            v51 = SBYTE1(v48) * (uint64_t)v7;
            v52 = 16 * SBYTE2(v48);
            v53 = v42 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52);
            if (v19 < v53)
              v53 = v19;
            if (v53 >= v43)
              v54 = v53;
            else
              v54 = v43;
            v55 = *(float32x2_t *)(v54 + 4);
            if (v17)
            {
              v56 = *(float *)(v54 + 12);
              v57 = v42 + v51 + v52;
              if (v19 < v57)
                v57 = v19;
              if (v57 >= v43)
                v58 = v57;
              else
                v58 = v43;
              v59 = *(float *)(v58 + 12);
            }
            else
            {
              v67 = v42 + v51 + v52;
              if (v19 < v67)
                v67 = v19;
              if (v67 >= v43)
                v58 = v67;
              else
                v58 = v43;
              v56 = 1.0;
              v59 = 1.0;
            }
            v5.i32[0] = interpolate_rgbaf_19467[4 * v50 + 3];
            v6.i32[0] = interpolate_rgbaf_19467[4 * ((v48 >> 28) & 3) + 3];
            v68 = vmla_n_f32(vmls_lane_f32(_D3, _D3, v5, 0), v55, v5.f32[0]);
            _D3 = vmla_n_f32(vmls_lane_f32(v68, v68, v6, 0), vmla_n_f32(vmls_lane_f32(v55, v55, v5, 0), *(float32x2_t *)(v58 + 4), v5.f32[0]), v6.f32[0]);
            v46 = (float)((float)((float)(v46 - (float)(v46 * v5.f32[0])) + (float)(v56 * v5.f32[0]))
                        - (float)((float)((float)(v46 - (float)(v46 * v5.f32[0])) + (float)(v56 * v5.f32[0])) * v6.f32[0]))
                + (float)((float)((float)(v56 - (float)(v56 * v5.f32[0])) + (float)(v59 * v5.f32[0])) * v6.f32[0]);
          }
          goto LABEL_80;
        }
        v65 = v42 + ((uint64_t)((unint64_t)HIWORD(v48) << 56) >> 52);
        if (v19 < v65)
          v65 = v19;
        if (v65 >= v43)
          v66 = v65;
        else
          v66 = v43;
        v62 = *(float32x2_t *)(v66 + 4);
        v63 = 1.0;
        if (v17)
          v63 = *(float *)(v66 + 12);
        v64 = &interpolate_rgbaf_19467[4 * ((v48 >> 28) & 3)];
      }
      v4.i32[0] = v64[3];
      _D3 = vmla_n_f32(vmls_lane_f32(_D3, _D3, v4, 0), v62, v4.f32[0]);
      v46 = (float)(v46 - (float)(v46 * v4.f32[0])) + (float)(v63 * v4.f32[0]);
    }
LABEL_80:
    __asm { FMLA            S5, S2, V3.S[1] }
    *(_DWORD *)(v15 + 8) = _S5;
    *(float *)(v15 + 12) = v46;
    *(_BYTE *)(v16 + 1) = v30 >> 22;
    if (a4 == 1)
      break;
    v74 = 0;
    v75 = (float *)(v15 + 20);
    a2 += v13;
    v76 = v11 - a2;
    a3 += v14;
    v77 = v12 - a3;
    while ((((a2 - v9) | v76 | (a3 - v10) | v77) & 0x8000000000000000) == 0)
    {
      v78 = v18 + SHIDWORD(a3) * (uint64_t)v7;
      v42 = v78 + 16 * (a2 >> 32);
      v43 = *(_QWORD *)(result + 32);
      if (v19 >= v42)
        v79 = v78 + 16 * (a2 >> 32);
      else
        v79 = v19;
      if (v79 >= v43)
        v80 = v79;
      else
        v80 = *(_QWORD *)(result + 32);
      if (v17)
        v46 = *(float *)(v80 + 12);
      else
        v46 = 1.0;
      _D3 = *(float32x2_t *)(v80 + 4);
      if (v8)
      {
        v48 = *(_DWORD *)(v8 + ((a3 >> 22) & 0x3C0 | ((unint64_t)a2 >> 26) & 0x3C));
        if ((v48 & 0xF) != 0)
        {
          v16 += v74 + 1;
          v15 = (uint64_t)(v75 - 3);
          a4 += ~(_DWORD)v74;
          v30 = -1;
          goto LABEL_41;
        }
      }
      __asm { FMLA            S5, S2, V3.S[1] }
      *((_DWORD *)v75 - 1) = _S5;
      *v75 = v46;
      v82 = v16 + v74++;
      v75 += 2;
      a2 += v13;
      *(_BYTE *)(v82 + 2) = -1;
      v76 -= v13;
      a3 += v14;
      v77 -= v14;
      if (a4 - 1 == (_DWORD)v74)
        return result;
    }
    v16 += v74 + 1;
    v15 = (uint64_t)(v75 - 3);
    a4 += ~(_DWORD)v74;
  }
  while (a4);
  return result;
}

uint64_t Wf_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float32x2_t v12;
  float32x2_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int8x16_t *v52;
  int8x16_t *v53;
  unint64_t v54;
  unsigned int *v55;
  unsigned int *v56;
  float v57;
  float32x4_t v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  int64_t v62;
  unint64_t v63;
  int8x16_t *v64;
  int8x16_t *v65;
  float32x4_t v66;
  float32x4_t v67;
  float v68;
  float v69;
  unsigned int *v70;
  unint64_t v71;
  unsigned int *v72;
  unsigned int *v73;
  float32x4_t v74;
  int8x16_t *v75;
  float32x4_t v76;
  float v77;
  unsigned int *v78;
  int64_t v79;
  int8x16_t *v80;
  unsigned int *v81;
  uint64_t v82;
  uint64_t v83;
  float *v84;
  uint64_t v85;
  unint64_t v86;
  int8x16_t *v87;
  unsigned int *v88;
  unsigned int *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;

  v14 = *(_QWORD *)(result + 32);
  v15 = *(_QWORD *)(result + 40);
  v16 = *(_DWORD *)(result + 24);
  v17 = *(_DWORD *)(result + 28);
  v18 = *(_QWORD *)(result + 176);
  v19 = *(_QWORD *)(result + 72);
  v92 = *(_QWORD *)(result + 80);
  v93 = *(_QWORD *)(result + 88);
  v21 = *(_QWORD *)(result + 112);
  v20 = *(_QWORD *)(result + 120);
  v90 = *(_DWORD *)(result + 188);
  v22 = *(_QWORD *)(result + 152) - 8;
  v23 = *(_QWORD *)(result + 144) - 1;
  v24 = *(_DWORD *)(result + 260) - 1;
  v25 = *(_DWORD *)(result + 256);
  v26 = v15 + (v24 * v17) + 4 * (v25 - 1);
  v27 = v14 + (v24 * v16) + 4 * (4 * v25) - 16;
  v91 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v19)
    {
      if (a3 <= v93)
      {
        v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        v37 = 0x3FFFFFFF;
        v38 = a3;
        v39 = v91;
      }
      else
      {
        v32 = *(_QWORD *)(result + 216);
        v33 = *(_QWORD *)(result + 224) + v93;
        v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1)
          goto LABEL_39;
        if (v34 >= v32)
          LODWORD(v35) = 0x3FFFFFFF;
        else
          v35 = (unint64_t)(*(_QWORD *)(result + 232) * v34) >> 32;
        v39 = v91;
        v37 = v35 | v90;
        v38 = v33 - 0x1000000;
        v36 = 448;
      }
    }
    else
    {
      v28 = *(_QWORD *)(result + 216);
      v29 = v19 - *(_QWORD *)(result + 224);
      v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1)
        goto LABEL_39;
      if (v30 >= v28)
        LODWORD(v31) = 0x3FFFFFFF;
      else
        v31 = (unint64_t)(*(_QWORD *)(result + 232) * v30) >> 32;
      v39 = v91;
      v37 = v31 | v90;
      v38 = v29 + 0x1000000;
      v36 = 512;
    }
    if (a2 >= v39)
      break;
    v40 = *(_QWORD *)(result + 192);
    v41 = v39 - *(_QWORD *)(result + 200);
    v42 = a2 - v41 + (v40 >> 1);
    if (v42 >= 1)
    {
      if (v42 < v40)
        v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v90;
      v43 = v41 + 0x1000000;
      v44 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v21;
    a3 += v20;
    v22 += 8;
    *(_BYTE *)++v23 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v92)
  {
    v44 = ((unint64_t)a2 >> 26) & 0x3C;
    v43 = a2;
    goto LABEL_26;
  }
  v45 = *(_QWORD *)(result + 192);
  v46 = *(_QWORD *)(result + 200) + v92;
  v47 = v46 - a2 + (v45 >> 1);
  if (v47 < 1)
    goto LABEL_39;
  if (v47 < v45)
    v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v47) >> 32) >> 15)) | v90;
  v43 = v46 - 0x1000000;
  v44 = 28;
LABEL_26:
  if (v37 < 0x400000)
    goto LABEL_39;
  v48 = v38 >> 32;
  v49 = v14 + SHIDWORD(v38) * (uint64_t)v16;
  v50 = (v43 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v51 = v49 + 4 * v50;
  v52 = *(int8x16_t **)(result + 32);
  if (v27 >= v51)
    v53 = (int8x16_t *)(v49 + 4 * v50);
  else
    v53 = (int8x16_t *)v27;
  if (v53 < v52)
    v53 = *(int8x16_t **)(result + 32);
  if (v15)
  {
    v54 = v15 + (int)v48 * (uint64_t)v17 + v50;
    v55 = *(unsigned int **)(result + 40);
    if (v26 >= v54)
      v56 = (unsigned int *)(v15 + (int)v48 * (uint64_t)v17 + v50);
    else
      v56 = (unsigned int *)v26;
    if (v56 >= v55)
      v55 = v56;
    v57 = COERCE_FLOAT(bswap32(*v55));
  }
  else
  {
    v54 = 0;
    v57 = 1.0;
  }
  v58 = (float32x4_t)vrev32q_s8(*v53);
  if (v18)
  {
    v59 = *(_DWORD *)(v18 + (v44 | v36));
LABEL_45:
    v60 = v59 & 0xF;
    v61 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      v75 = (int8x16_t *)(v51 + SBYTE1(v59) * (uint64_t)v16);
      if (v27 < (unint64_t)v75)
        v75 = (int8x16_t *)v27;
      if (v75 < v52)
        v75 = v52;
      v76 = (float32x4_t)vrev32q_s8(*v75);
      v77 = 1.0;
      if (v15)
      {
        v78 = (unsigned int *)(v54 + SBYTE1(v59) * (uint64_t)v17);
        if (v26 < (unint64_t)v78)
          v78 = (unsigned int *)v26;
        if ((unint64_t)v78 < *(_QWORD *)(result + 40))
          v78 = *(unsigned int **)(result + 40);
        v77 = COERCE_FLOAT(bswap32(*v78));
      }
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          v62 = (unint64_t)HIWORD(v59) << 56;
          v63 = v51 + (v62 >> 52);
          if (v27 >= v63)
            v64 = (int8x16_t *)(v51 + (v62 >> 52));
          else
            v64 = (int8x16_t *)v27;
          if (v64 < v52)
            v64 = v52;
          v65 = (int8x16_t *)(v63 + SBYTE1(v59) * (uint64_t)v16);
          if (v27 < (unint64_t)v65)
            v65 = (int8x16_t *)v27;
          if (v65 < v52)
            v65 = v52;
          v66 = (float32x4_t)vrev32q_s8(*v64);
          v67 = (float32x4_t)vrev32q_s8(*v65);
          v68 = 1.0;
          v69 = 1.0;
          if (v15)
          {
            v70 = (unsigned int *)(v54 + (v62 >> 54));
            v71 = *(_QWORD *)(result + 40);
            if (v26 >= (unint64_t)v70)
              v72 = v70;
            else
              v72 = (unsigned int *)v26;
            if ((unint64_t)v72 < v71)
              v72 = *(unsigned int **)(result + 40);
            v69 = COERCE_FLOAT(bswap32(*v72));
            v73 = (unsigned int *)((char *)v70 + SBYTE1(v59) * (uint64_t)v17);
            if (v26 < (unint64_t)v73)
              v73 = (unsigned int *)v26;
            if ((unint64_t)v73 < v71)
              v73 = *(unsigned int **)(result + 40);
            v68 = COERCE_FLOAT(bswap32(*v73));
          }
          v12.i32[0] = interpolate_cmykaf[5 * v61 + 4];
          v13.i32[0] = interpolate_cmykaf[5 * ((v59 >> 28) & 3) + 4];
          v74 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, v12, 0), v66, v12.f32[0]);
          v58 = vmlaq_n_f32(vmlsq_lane_f32(v74, v74, v13, 0), vmlaq_n_f32(vmlsq_lane_f32(v66, v66, v12, 0), v67, v12.f32[0]), v13.f32[0]);
          v57 = (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v69 * v12.f32[0]))
                      - (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v69 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v69 - (float)(v69 * v12.f32[0])) + (float)(v68 * v12.f32[0])) * v13.f32[0]);
        }
        goto LABEL_91;
      }
      v79 = (unint64_t)HIWORD(v59) << 56;
      v80 = (int8x16_t *)(v51 + (v79 >> 52));
      if (v27 < (unint64_t)v80)
        v80 = (int8x16_t *)v27;
      if (v80 < v52)
        v80 = v52;
      v76 = (float32x4_t)vrev32q_s8(*v80);
      v77 = 1.0;
      if (v15)
      {
        v81 = (unsigned int *)(v54 + (v79 >> 54));
        if (v26 < (unint64_t)v81)
          v81 = (unsigned int *)v26;
        if ((unint64_t)v81 < *(_QWORD *)(result + 40))
          v81 = *(unsigned int **)(result + 40);
        v77 = COERCE_FLOAT(bswap32(*v81));
      }
      v61 = (v59 >> 28) & 3;
    }
    LODWORD(a12) = interpolate_cmykaf[5 * v61 + 4];
    v58 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, *(float32x2_t *)&a12, 0), v76, *(float *)&a12);
    v57 = (float)(v57 - (float)(v57 * *(float *)&a12)) + (float)(v77 * *(float *)&a12);
  }
LABEL_91:
  v82 = 0;
  a2 += v21;
  v83 = v92 - a2;
  v84 = (float *)(v22 + 12);
  a3 += v20;
  v85 = v93 - a3;
  while (1)
  {
    *(v84 - 1) = (float)((float)((float)((float)(v57 - v58.f32[1]) - v58.f32[3]) * 0.59)
                       + (float)((float)((float)(v57 - v58.f32[0]) - v58.f32[3]) * 0.3))
               + (float)((float)((float)(v57 - v58.f32[2]) - v58.f32[3]) * 0.11);
    *v84 = v57;
    *(_BYTE *)(v23 + 1 + v82) = v37 >> 22;
    if (a4 - 1 == (_DWORD)v82)
      return result;
    if ((v85 | v83 | (a3 - v19) | (a2 - v91)) < 0)
    {
      v23 += v82 + 1;
      v22 = (uint64_t)(v84 - 1);
      a4 += ~(_DWORD)v82;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v86 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v51 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86;
    v52 = *(int8x16_t **)(result + 32);
    if (v27 >= v51)
      v87 = (int8x16_t *)(v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86);
    else
      v87 = (int8x16_t *)v27;
    if (v87 < v52)
      v87 = *(int8x16_t **)(result + 32);
    if (v15)
    {
      v54 = v15 + SHIDWORD(a3) * (uint64_t)v17 + v86;
      v88 = *(unsigned int **)(result + 40);
      if (v26 >= v54)
        v89 = (unsigned int *)v54;
      else
        v89 = (unsigned int *)v26;
      if (v89 >= v88)
        v88 = v89;
      v57 = COERCE_FLOAT(bswap32(*v88));
    }
    else
    {
      v57 = 1.0;
    }
    v58 = (float32x4_t)vrev32q_s8(*v87);
    if (v18)
    {
      v59 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v59 & 0xF) != 0)
      {
        v23 += v82 + 1;
        v22 = (uint64_t)(v84 - 1);
        a4 += ~(_DWORD)v82;
        v37 = -1;
        goto LABEL_45;
      }
    }
    ++v82;
    v83 -= v21;
    v84 += 2;
    a3 += v20;
    v85 -= v20;
    a2 += v21;
    v37 = -1;
  }
}

uint64_t Wf_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  float32x2_t v12;
  float32x2_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  float32x4_t *v52;
  float32x4_t *v53;
  unint64_t v54;
  float *v55;
  float *v56;
  float v57;
  float32x4_t v58;
  unsigned int v59;
  int v60;
  int v61;
  int64_t v62;
  unint64_t v63;
  float32x4_t *v64;
  float32x4_t *v65;
  float32x4_t v66;
  float32x4_t v67;
  float v68;
  float v69;
  float *v70;
  unint64_t v71;
  float *v72;
  float *v73;
  float32x4_t v74;
  float32x4_t *v75;
  float32x4_t v76;
  float v77;
  float *v78;
  int64_t v79;
  float32x4_t *v80;
  float *v81;
  uint64_t v82;
  uint64_t v83;
  float *v84;
  uint64_t v85;
  unint64_t v86;
  float32x4_t *v87;
  float *v88;
  float *v89;
  int v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;

  v14 = *(_QWORD *)(result + 32);
  v15 = *(_QWORD *)(result + 40);
  v16 = *(_DWORD *)(result + 24);
  v17 = *(_DWORD *)(result + 28);
  v18 = *(_QWORD *)(result + 176);
  v19 = *(_QWORD *)(result + 72);
  v92 = *(_QWORD *)(result + 80);
  v93 = *(_QWORD *)(result + 88);
  v21 = *(_QWORD *)(result + 112);
  v20 = *(_QWORD *)(result + 120);
  v90 = *(_DWORD *)(result + 188);
  v22 = *(_QWORD *)(result + 152) - 8;
  v23 = *(_QWORD *)(result + 144) - 1;
  v24 = *(_DWORD *)(result + 260) - 1;
  v25 = *(_DWORD *)(result + 256);
  v26 = v15 + (v24 * v17) + 4 * (v25 - 1);
  v27 = v14 + (v24 * v16) + 4 * (4 * v25) - 16;
  v91 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v19)
    {
      if (a3 <= v93)
      {
        v36 = ((unint64_t)a3 >> 22) & 0x3C0;
        v37 = 0x3FFFFFFF;
        v38 = a3;
        v39 = v91;
      }
      else
      {
        v32 = *(_QWORD *)(result + 216);
        v33 = *(_QWORD *)(result + 224) + v93;
        v34 = v33 - a3 + (v32 >> 1);
        if (v34 < 1)
          goto LABEL_39;
        if (v34 >= v32)
          LODWORD(v35) = 0x3FFFFFFF;
        else
          v35 = (unint64_t)(*(_QWORD *)(result + 232) * v34) >> 32;
        v39 = v91;
        v37 = v35 | v90;
        v38 = v33 - 0x1000000;
        v36 = 448;
      }
    }
    else
    {
      v28 = *(_QWORD *)(result + 216);
      v29 = v19 - *(_QWORD *)(result + 224);
      v30 = a3 - v29 + (v28 >> 1);
      if (v30 < 1)
        goto LABEL_39;
      if (v30 >= v28)
        LODWORD(v31) = 0x3FFFFFFF;
      else
        v31 = (unint64_t)(*(_QWORD *)(result + 232) * v30) >> 32;
      v39 = v91;
      v37 = v31 | v90;
      v38 = v29 + 0x1000000;
      v36 = 512;
    }
    if (a2 >= v39)
      break;
    v40 = *(_QWORD *)(result + 192);
    v41 = v39 - *(_QWORD *)(result + 200);
    v42 = a2 - v41 + (v40 >> 1);
    if (v42 >= 1)
    {
      if (v42 < v40)
        v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v90;
      v43 = v41 + 0x1000000;
      v44 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v21;
    a3 += v20;
    v22 += 8;
    *(_BYTE *)++v23 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v92)
  {
    v44 = ((unint64_t)a2 >> 26) & 0x3C;
    v43 = a2;
    goto LABEL_26;
  }
  v45 = *(_QWORD *)(result + 192);
  v46 = *(_QWORD *)(result + 200) + v92;
  v47 = v46 - a2 + (v45 >> 1);
  if (v47 < 1)
    goto LABEL_39;
  if (v47 < v45)
    v37 = ((v37 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v47) >> 32) >> 15)) | v90;
  v43 = v46 - 0x1000000;
  v44 = 28;
LABEL_26:
  if (v37 < 0x400000)
    goto LABEL_39;
  v48 = v38 >> 32;
  v49 = v14 + SHIDWORD(v38) * (uint64_t)v16;
  v50 = (v43 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v51 = v49 + 4 * v50;
  v52 = *(float32x4_t **)(result + 32);
  if (v27 >= v51)
    v53 = (float32x4_t *)(v49 + 4 * v50);
  else
    v53 = (float32x4_t *)v27;
  if (v53 < v52)
    v53 = *(float32x4_t **)(result + 32);
  if (v15)
  {
    v54 = v15 + (int)v48 * (uint64_t)v17 + v50;
    v55 = *(float **)(result + 40);
    if (v26 >= v54)
      v56 = (float *)(v15 + (int)v48 * (uint64_t)v17 + v50);
    else
      v56 = (float *)v26;
    if (v56 >= v55)
      v55 = v56;
    v57 = *v55;
  }
  else
  {
    v54 = 0;
    v57 = 1.0;
  }
  v58 = *v53;
  if (v18)
  {
    v59 = *(_DWORD *)(v18 + (v44 | v36));
LABEL_45:
    v60 = v59 & 0xF;
    v61 = HIBYTE(v59) & 3;
    if (v60 == 1)
    {
      v75 = (float32x4_t *)(v51 + SBYTE1(v59) * (uint64_t)v16);
      if (v27 < (unint64_t)v75)
        v75 = (float32x4_t *)v27;
      if (v75 < v52)
        v75 = v52;
      v76 = *v75;
      v77 = 1.0;
      if (v15)
      {
        v78 = (float *)(v54 + SBYTE1(v59) * (uint64_t)v17);
        if (v26 < (unint64_t)v78)
          v78 = (float *)v26;
        if ((unint64_t)v78 < *(_QWORD *)(result + 40))
          v78 = *(float **)(result + 40);
        v77 = *v78;
      }
    }
    else
    {
      if (v60 != 2)
      {
        if (v60 == 3)
        {
          v62 = (unint64_t)HIWORD(v59) << 56;
          v63 = v51 + (v62 >> 52);
          if (v27 >= v63)
            v64 = (float32x4_t *)(v51 + (v62 >> 52));
          else
            v64 = (float32x4_t *)v27;
          if (v64 < v52)
            v64 = v52;
          v65 = (float32x4_t *)(v63 + SBYTE1(v59) * (uint64_t)v16);
          if (v27 < (unint64_t)v65)
            v65 = (float32x4_t *)v27;
          if (v65 < v52)
            v65 = v52;
          v66 = *v64;
          v67 = *v65;
          v68 = 1.0;
          v69 = 1.0;
          if (v15)
          {
            v70 = (float *)(v54 + (v62 >> 54));
            v71 = *(_QWORD *)(result + 40);
            if (v26 >= (unint64_t)v70)
              v72 = v70;
            else
              v72 = (float *)v26;
            if ((unint64_t)v72 < v71)
              v72 = *(float **)(result + 40);
            v68 = *v72;
            v73 = (float *)((char *)v70 + SBYTE1(v59) * (uint64_t)v17);
            if (v26 < (unint64_t)v73)
              v73 = (float *)v26;
            if ((unint64_t)v73 < v71)
              v73 = *(float **)(result + 40);
            v69 = *v73;
          }
          v12.i32[0] = interpolate_cmykaf[5 * v61 + 4];
          v13.i32[0] = interpolate_cmykaf[5 * ((v59 >> 28) & 3) + 4];
          v74 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, v12, 0), v66, v12.f32[0]);
          v58 = vmlaq_n_f32(vmlsq_lane_f32(v74, v74, v13, 0), vmlaq_n_f32(vmlsq_lane_f32(v66, v66, v12, 0), v67, v12.f32[0]), v13.f32[0]);
          v57 = (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v68 * v12.f32[0]))
                      - (float)((float)((float)(v57 - (float)(v57 * v12.f32[0])) + (float)(v68 * v12.f32[0]))
                              * v13.f32[0]))
              + (float)((float)((float)(v68 - (float)(v68 * v12.f32[0])) + (float)(v69 * v12.f32[0])) * v13.f32[0]);
        }
        goto LABEL_91;
      }
      v79 = (unint64_t)HIWORD(v59) << 56;
      v80 = (float32x4_t *)(v51 + (v79 >> 52));
      if (v27 < (unint64_t)v80)
        v80 = (float32x4_t *)v27;
      if (v80 < v52)
        v80 = v52;
      v76 = *v80;
      v77 = 1.0;
      if (v15)
      {
        v81 = (float *)(v54 + (v79 >> 54));
        if (v26 < (unint64_t)v81)
          v81 = (float *)v26;
        if ((unint64_t)v81 < *(_QWORD *)(result + 40))
          v81 = *(float **)(result + 40);
        v77 = *v81;
      }
      v61 = (v59 >> 28) & 3;
    }
    LODWORD(a12) = interpolate_cmykaf[5 * v61 + 4];
    v58 = vmlaq_n_f32(vmlsq_lane_f32(v58, v58, *(float32x2_t *)&a12, 0), v76, *(float *)&a12);
    v57 = (float)(v57 - (float)(v57 * *(float *)&a12)) + (float)(v77 * *(float *)&a12);
  }
LABEL_91:
  v82 = 0;
  a2 += v21;
  v83 = v92 - a2;
  v84 = (float *)(v22 + 12);
  a3 += v20;
  v85 = v93 - a3;
  while (1)
  {
    *(v84 - 1) = (float)((float)((float)((float)(v57 - v58.f32[1]) - v58.f32[3]) * 0.59)
                       + (float)((float)((float)(v57 - v58.f32[0]) - v58.f32[3]) * 0.3))
               + (float)((float)((float)(v57 - v58.f32[2]) - v58.f32[3]) * 0.11);
    *v84 = v57;
    *(_BYTE *)(v23 + 1 + v82) = v37 >> 22;
    if (a4 - 1 == (_DWORD)v82)
      return result;
    if ((v85 | v83 | (a3 - v19) | (a2 - v91)) < 0)
    {
      v23 += v82 + 1;
      v22 = (uint64_t)(v84 - 1);
      a4 += ~(_DWORD)v82;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v86 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v51 = v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86;
    v52 = *(float32x4_t **)(result + 32);
    if (v27 >= v51)
      v87 = (float32x4_t *)(v14 + SHIDWORD(a3) * (uint64_t)v16 + 4 * v86);
    else
      v87 = (float32x4_t *)v27;
    if (v87 < v52)
      v87 = *(float32x4_t **)(result + 32);
    if (v15)
    {
      v54 = v15 + SHIDWORD(a3) * (uint64_t)v17 + v86;
      v88 = *(float **)(result + 40);
      if (v26 >= v54)
        v89 = (float *)v54;
      else
        v89 = (float *)v26;
      if (v89 >= v88)
        v88 = v89;
      v57 = *v88;
    }
    else
    {
      v57 = 1.0;
    }
    v58 = *v87;
    if (v18)
    {
      v59 = *(_DWORD *)(v18 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v59 & 0xF) != 0)
      {
        v23 += v82 + 1;
        v22 = (uint64_t)(v84 - 1);
        a4 += ~(_DWORD)v82;
        v37 = -1;
        goto LABEL_45;
      }
    }
    ++v82;
    v83 -= v21;
    v84 += 2;
    a3 += v20;
    v85 -= v20;
    a2 += v21;
    v37 = -1;
  }
}

_DWORD *Wf_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float *a5, float a6)
{
  float *v9;
  float v10;
  float v11;
  float v12;
  int v13;
  float v14;
  char *v15;

  v9 = *(float **)(*(_QWORD *)a1 + 64);
  v11 = *v9;
  v10 = v9[1];
  if (!a2 || a3 <= 7)
  {
    a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL);
    if (!a2)
      return a2;
  }
  if (v11 <= a6)
    v12 = a6;
  else
    v12 = v11;
  if (v10 < a6)
    v12 = v10;
  if (a5)
    v13 = a4;
  else
    v13 = 0;
  switch(v13)
  {
    case 1:
      v14 = *a5;
      goto LABEL_18;
    case 4:
      v14 = (float)(v10 - (float)((float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4])))
          - a5[3];
      goto LABEL_18;
    case 3:
      v14 = (float)((float)(*a5 * v9[2]) + (float)(a5[1] * v9[3])) + (float)(a5[2] * v9[4]);
LABEL_18:
      v11 = v12 * v14;
      break;
  }
  *(_OWORD *)a2 = xmmword_185004C60;
  a2[6] = 0;
  *((_QWORD *)a2 + 2) = 1;
  *((float *)a2 + 12) = v11;
  *((float *)a2 + 13) = v12;
  v15 = (char *)(a2 + 13);
  if (v12 >= v10)
    v15 = 0;
  *((_QWORD *)a2 + 4) = a2 + 12;
  *((_QWORD *)a2 + 5) = v15;
  return a2;
}

uint64_t Wf_mark(uint64_t a1, __n128 a2)
{
  return Wf_mark_inner(*(_QWORD *)(*(_QWORD *)a1 + 56), a2);
}

uint64_t Wf_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  int32x2_t v5;
  int32x2_t v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint16x4_t *v16;
  int v17;
  int v18;
  float v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v29;
  unsigned int v30;
  size_t v31;
  _BYTE *v32;
  _BYTE *v33;
  unint64_t v34;
  _BYTE *v35;
  uint64_t v36;
  unint64_t v37;
  float *v38;
  int v39;
  int v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  float32x4_t *v44;
  unint64_t v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  int v52;
  float *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  char *v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  float *v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  float *v68;
  char *v69;
  void *v70;
  unint64_t v71;
  uint64_t v72;
  float *v73;
  unsigned int v74;
  uint64_t v75;
  char *v76;
  uint64_t v77;
  int v78;
  float *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  float *v86;
  int v87;
  float v88;
  float v89;
  float *v90;
  uint64_t v91;
  float *v92;
  uint64_t v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  int v97;
  float v98;
  float v99;
  float v100;
  float *v101;
  uint64_t v102;
  float *v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  float v108;
  float v109;
  float v110;
  float *v111;
  uint64_t v112;
  float *v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  uint64_t v117;
  float *v118;
  int v119;
  float v120;
  float v121;
  float v122;
  float *v123;
  uint64_t v124;
  float *v125;
  uint64_t v126;
  uint64_t v127;
  int v128;
  int v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float *v134;
  uint64_t v135;
  float *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  int v140;
  uint64_t v141;
  int v142;
  float v143;
  float *v144;
  uint64_t v145;
  float *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  int v150;
  uint64_t v151;
  int v152;
  float v153;
  float *v154;
  uint64_t v155;
  float *v156;
  uint64_t v157;
  uint64_t v158;
  int v159;
  uint64_t v160;
  int v161;
  float v162;
  float v163;
  float v164;
  float *v165;
  uint64_t v166;
  float *v167;
  uint64_t v168;
  uint64_t v169;
  int v170;
  uint64_t v171;
  int v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float *v177;
  uint64_t v178;
  float *v179;
  uint64_t v180;
  uint64_t v181;
  int v182;
  int v183;
  float v184;
  float v185;
  float v186;
  float v187;
  float *v188;
  uint64_t v189;
  float *v190;
  uint64_t v191;
  uint64_t v192;
  int v193;
  int v194;
  float v195;
  float v196;
  float *v197;
  uint64_t v198;
  float *v199;
  uint64_t v200;
  uint64_t v201;
  int v202;
  float *v203;
  int v204;
  float v205;
  float v206;
  float v207;
  float *v208;
  uint64_t v209;
  float *v210;
  uint64_t v211;
  uint64_t v212;
  int v213;
  int v214;
  float v215;
  float *v216;
  uint64_t v217;
  float *v218;
  uint64_t v219;
  uint64_t v220;
  uint64_t v221;
  int v222;
  uint64_t v223;
  uint64_t v224;
  int v225;
  float v226;
  float v227;
  float v228;
  int v229;
  float *v230;
  uint64_t v231;
  float *v232;
  uint64_t v233;
  uint64_t v234;
  int v235;
  int v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float *v241;
  uint64_t v242;
  float *v243;
  uint64_t v244;
  uint64_t v245;
  int v246;
  int v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float *v252;
  uint64_t v253;
  float *v254;
  uint64_t v255;
  uint64_t v256;
  uint64_t v257;
  int v258;
  uint64_t v259;
  uint64_t v260;
  int v261;
  float v262;
  float v263;
  float v264;
  int v265;
  float *v266;
  uint64_t v267;
  float *v268;
  uint64_t v269;
  uint64_t v270;
  uint64_t v271;
  int v272;
  uint64_t v273;
  uint64_t v274;
  int v275;
  float v276;
  float v277;
  float v278;
  int v279;
  float *v280;
  uint64_t v281;
  float *v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  int v286;
  uint64_t v287;
  uint64_t v288;
  int v289;
  float v290;
  float v291;
  float v292;
  int v293;
  float *v294;
  uint64_t v295;
  float *v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  int v300;
  uint64_t v301;
  uint64_t v302;
  int v303;
  float v304;
  float v305;
  float v306;
  int v307;
  float *v308;
  uint64_t v309;
  float *v310;
  uint64_t v311;
  uint64_t v312;
  int v313;
  int v314;
  float v315;
  float v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float *v323;
  uint64_t v324;
  float *v325;
  uint64_t v326;
  uint64_t v327;
  int v328;
  int v329;
  float v330;
  float v331;
  float v332;
  float *v333;
  uint64_t v334;
  float *v335;
  uint64_t v336;
  uint64_t v337;
  int v338;
  int v339;
  float v340;
  float v341;
  float v342;
  float v343;
  float v344;
  float v345;
  float *v346;
  uint64_t v347;
  float *v348;
  uint64_t v349;
  uint64_t v350;
  int v351;
  int v352;
  float v353;
  float v354;
  float v355;
  float v356;
  float v357;
  float v358;
  float *v359;
  uint64_t v360;
  float *v361;
  uint64_t v362;
  uint64_t v363;
  int v364;
  int v365;
  float v366;
  float v367;
  float v368;
  float v369;
  float v370;
  float v371;
  float *v372;
  uint64_t v373;
  float *v374;
  uint64_t v375;
  uint64_t v376;
  int v377;
  int v378;
  float v379;
  float v380;
  float v381;
  float v382;
  float v383;
  float v384;
  float *v385;
  uint64_t v386;
  float *v387;
  uint64_t v388;
  uint64_t v389;
  int v390;
  float *v391;
  int v392;
  float v393;
  float v394;
  float *v395;
  uint64_t v396;
  float *v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  int v401;
  int v402;
  float v403;
  float v404;
  BOOL v405;
  float v406;
  float *v407;
  uint64_t v408;
  float *v409;
  uint64_t v410;
  uint64_t v411;
  int v412;
  int v413;
  float v414;
  float v415;
  float *v416;
  uint64_t v417;
  float *v418;
  uint64_t v419;
  uint64_t v420;
  int v421;
  int v422;
  float v423;
  float v424;
  float *v425;
  uint64_t v426;
  float *v427;
  uint64_t v428;
  uint64_t v429;
  int v430;
  int v431;
  float v432;
  float *v433;
  uint64_t v434;
  float *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  int v439;
  int v440;
  float *v441;
  uint64_t v442;
  float *v443;
  uint64_t v444;
  uint64_t v445;
  uint8x8_t v446;
  int v447;
  float *v448;
  int v449;
  uint64_t v450;
  uint64_t v451;
  int v452;
  int v453;
  float *v454;
  uint64_t v455;
  float *v456;
  uint64_t v457;
  uint64_t v458;
  int v459;
  int v460;
  float *v461;
  uint64_t v462;
  float *v463;
  uint64_t v464;
  uint64_t v465;
  int v466;
  int v467;
  float *v468;
  uint64_t v469;
  float *v470;
  uint64_t v471;
  uint64_t v472;
  int v473;
  int v474;
  float *v475;
  unint64_t v476;
  int v477;
  int v478;
  unint64_t v479;
  uint64_t v480;
  unint64_t v481;
  unint64_t v482;
  int v483;
  uint64_t v484;
  char *v485;
  unint64_t v486;
  char *v487;
  uint64_t v488;
  int v489;
  int v490;
  int v491;
  uint64_t v492;
  char *v493;
  uint64_t v494;
  char *v495;
  unint64_t v496;
  uint64_t v497;
  uint64_t v498;
  char *v499;
  uint64_t v500;
  int v501;
  unint64_t v502;
  uint64_t v503;
  unsigned int v504;
  int v505;
  uint64_t v506;
  char *v507;
  uint64_t v508;
  uint64_t v509;
  int v510;
  int *v511;
  signed int v512;
  int *v513;
  int v514;
  unsigned int v515;
  uint64_t v516;
  unsigned int v517;
  unsigned int v518;
  int v519;
  unsigned int v520;
  int v521;
  int v522;
  float v523;
  int v524;
  int v525;
  float v526;
  int v527;
  int v528;
  float v529;
  int v530;
  int v531;
  float v532;
  float v533;
  float v534;
  int v535;
  uint64_t v536;
  int v537;
  int v538;
  int v539;
  uint64_t v540;
  int v541;
  int v542;
  int v543;
  int v544;
  float v545;
  float v546;
  int v547;
  int v548;
  float v549;
  float v550;
  float v551;
  int v552;
  uint64_t v553;
  int v554;
  float v555;
  float v556;
  int v557;
  int v558;
  uint64_t v559;
  int v560;
  float v561;
  int v562;
  int v563;
  int v564;
  float v565;
  float v566;
  int v567;
  int v568;
  float v569;
  int v570;
  float v571;
  float v572;
  float v573;
  int v574;
  float v575;
  float v576;
  int v577;
  int v578;
  float v579;
  float v580;
  float v581;
  int v582;
  int v583;
  float v584;
  float v585;
  float v586;
  int v587;
  float v588;
  float v589;
  int v590;
  float v591;
  float v592;
  float v594;
  int v595;
  float v596;
  int v597;
  float v598;
  int v599;
  float v600;
  float v601;
  int v602;
  float v603;
  float v604;
  float v605;
  int v606;
  float v607;
  float v608;
  float v609;
  int v610;
  float v611;
  float v612;
  int v613;
  int v614;
  float v615;
  float v616;
  float v617;
  float v618;
  float v619;
  int v620;
  int v621;
  float v622;
  int v623;
  int v624;
  float v625;
  float v626;
  float v627;
  int v628;
  int v629;
  float v630;
  float v631;
  float v632;
  int v633;
  int v634;
  float v635;
  float v636;
  float v637;
  float v638;
  int v639;
  int v640;
  float v641;
  float v642;
  float v643;
  float32x4_t v644;
  float32x4_t v645;
  unsigned int v646;
  unsigned int v647;
  int v648;
  unsigned int v649;
  uint64_t v650;
  float *v651;
  uint64_t v652;
  int v653;
  int v654;
  unint64_t v655;
  unint64_t v656;
  char *v657;
  int v658;
  int v659;
  uint64_t v660;
  uint64_t v661;
  unint64_t v662;
  int v663;
  int v664;
  int v665;
  int v666;
  int v667;
  unint64_t v668;
  int v669;
  int v670;
  int v671;
  int v672;
  int v673;
  uint64_t v674;
  float *v675;
  unint64_t v676;
  unint64_t v677;
  int v678[2];
  int v679[2];
  int v680[2];
  int v681[2];
  int v682[2];
  int v683;
  unsigned int v684;
  float *v685;
  unint64_t v686;
  unint64_t v687;
  uint64_t v688;
  unint64_t v689;
  unint64_t v690;
  unint64_t v691;
  int32x2_t v692;
  uint64_t v693;
  int32x2_t v694;
  uint64_t v695;
  uint64_t v696;
  int v697[4];
  __int128 v698;
  __int128 v699;
  __int128 v700;
  __int128 v701;
  __int128 v702;
  __int128 v703;
  __int128 v704;
  __int128 v705;
  __int128 v706;
  _DWORD v707[1024];
  uint64_t v708;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v708 = *MEMORY[0x1E0C80C00];
  v7 = *(float **)(v3 + 96);
  v8 = *(_QWORD *)(v3 + 48);
  v9 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
  if ((int)v9 > 27)
    return 0xFFFFFFFFLL;
  v11 = v3;
  v12 = *(unsigned int *)(v3 + 4);
  v13 = v12 - 1;
  if ((int)v12 < 1)
    return 0;
  v14 = *(_DWORD *)(v3 + 8);
  v15 = (v14 - 1);
  if (v14 < 1)
    return 0;
  v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    v18 = *(_DWORD *)v3 & 0xFF00;
    v652 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
    v650 = v3;
    if (v18 == 1024)
    {
      v707[0] = *(_DWORD *)(v3 + 4);
      v697[0] = v14;
      v19 = 1.0;
      if (v7)
        v19 = *v7;
      v20 = *(_QWORD *)(v3 + 40);
      v21 = (unint64_t)*(int *)(v3 + 28) >> 2;
      v23 = *(int *)(v3 + 12);
      v22 = *(int *)(v3 + 16);
      if (v8)
      {
        v690 = (unint64_t)*(int *)(v3 + 32) >> 2;
        v688 = v8 + 4 * (v23 + v690 * v22);
        v684 = 1;
      }
      else
      {
        v688 = 0;
        v690 = 0;
        v684 = 0;
      }
      v6.i32[0] = **(_DWORD **)(v3 + 88);
      *(float *)v5.i32 = 1.0 - v19;
      v34 = v20 + 4 * (v23 + v22 * v21);
      v692 = v5;
      v694 = v6;
      v677 = (unint64_t)*(int *)(v3 + 28) >> 2;
      v686 = v34;
      if (v16)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
        v33 = v35;
        v36 = v688;
        v37 = v690;
        if (v35)
          goto LABEL_1329;
        return 1;
      }
      v33 = 0;
      if (v8)
        v43 = v12;
      else
        v43 = 0;
      v36 = v688;
      v37 = v690 - v43;
      v44 = (float32x4_t *)(v20 + 4 * (v23 + v22 * v21));
      v45 = v12;
LABEL_972:
      v34 = v21 - v45;
      v501 = v12;
      switch((int)v9)
      {
        case 0:
          v502 = v21;
          v503 = v34 + (int)v12;
          v504 = v697[0];
          v505 = v12;
          v506 = v697[0] - 1;
          v507 = &v44->i8[4 * ((v503 * v506) & (v503 >> 63))];
          if (v503 < 0)
            v503 = -v503;
          CGBlt_fillBytes(4 * v505, v697[0], 0, v507, 4 * v503);
          if (v8)
          {
            v508 = v37 + v505;
            v36 += 4 * ((v508 * v506) & (v508 >> 63));
            if (v508 >= 0)
              v37 += v505;
            else
              v37 = -v508;
            CGBlt_fillBytes(4 * v505, v504, 0, (char *)v36, 4 * v37);
          }
          v21 = v502;
          goto LABEL_1326;
        case 1:
          v509 = v34 + (int)v12;
          if (v509 < 0)
          {
            v44 = (float32x4_t *)((char *)v44 + 4 * v509 * (v697[0] - 1));
            v509 = -v509;
          }
          v510 = 0;
          v511 = *(int **)(v650 + 88);
          if (v511)
            v510 = *v511;
          v512 = v697[0];
          CGBlt_fillBytes(4 * v12, v697[0], v510, (char *)v44, 4 * v509);
          if (v8)
          {
            v513 = *(int **)(v650 + 96);
            if (!v513)
              v513 = (int *)&_CMYK_float_alpha;
            v36 += 4 * (((v37 + (int)v12) * (v512 - 1)) & ((uint64_t)(v37 + (int)v12) >> 63));
            if ((uint64_t)(v37 + (int)v12) >= 0)
              v37 += (int)v12;
            else
              v37 = -(uint64_t)(v37 + (int)v12);
            CGBlt_fillBytes(4 * v12, v512, *v513, (char *)v36, 4 * v37);
          }
          LODWORD(v9) = v652;
          goto LABEL_1326;
        case 2:
          v514 = v697[0];
          v515 = v12 >> 2;
          v516 = 4 * v684;
          if (v8)
          {
            v517 = v515 + 1;
            do
            {
              if ((int)v12 < 4)
              {
                v519 = v12;
              }
              else
              {
                v518 = v517;
                do
                {
                  v44->f32[0] = *(float *)v6.i32 + (float)(v44->f32[0] * *(float *)v5.i32);
                  *(float *)v36 = v19 + (float)(*(float *)v36 * *(float *)v5.i32);
                  v44->f32[1] = *(float *)v6.i32 + (float)(v44->f32[1] * *(float *)v5.i32);
                  *(float *)(v36 + 4) = v19 + (float)(*(float *)(v36 + 4) * *(float *)v5.i32);
                  v44->f32[2] = *(float *)v6.i32 + (float)(v44->f32[2] * *(float *)v5.i32);
                  *(float *)(v36 + 8) = v19 + (float)(*(float *)(v36 + 8) * *(float *)v5.i32);
                  v44->f32[3] = *(float *)v6.i32 + (float)(v44->f32[3] * *(float *)v5.i32);
                  *(float *)(v36 + 12) = v19 + (float)(*(float *)(v36 + 12) * *(float *)v5.i32);
                  ++v44;
                  --v518;
                  v36 += 16 * v684;
                }
                while (v518 > 1);
                v519 = v12 & 3;
              }
              if (v519 >= 1)
              {
                v520 = v519 + 1;
                do
                {
                  v44->f32[0] = *(float *)v6.i32 + (float)(v44->f32[0] * *(float *)v5.i32);
                  v44 = (float32x4_t *)((char *)v44 + 4);
                  *(float *)v36 = v19 + (float)(*(float *)v36 * *(float *)v5.i32);
                  v36 += v516;
                  --v520;
                }
                while (v520 > 1);
              }
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v514;
            }
            while (v514);
          }
          else
          {
            v644 = (float32x4_t)vdupq_lane_s32(v5, 0);
            v645 = (float32x4_t)vdupq_lane_s32(v6, 0);
            v646 = v515 + 1;
            do
            {
              if ((int)v12 < 4)
              {
                v648 = v12;
              }
              else
              {
                v647 = v646;
                do
                {
                  *v44 = vmlaq_f32(v645, v644, *v44);
                  ++v44;
                  --v647;
                  v36 += 16 * v684;
                }
                while (v647 > 1);
                v648 = v12 & 3;
              }
              if (v648 >= 1)
              {
                v649 = v648 + 1;
                do
                {
                  v44->f32[0] = *(float *)v6.i32 + (float)(v44->f32[0] * *(float *)v5.i32);
                  v44 = (float32x4_t *)((char *)v44 + 4);
                  v36 += v516;
                  --v649;
                }
                while (v649 > 1);
              }
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v514;
            }
            while (v514);
          }
          goto LABEL_1325;
        case 3:
          v521 = v697[0];
          do
          {
            v522 = v12;
            do
            {
              v523 = *(float *)v36;
              if (*(float *)v36 <= 0.0)
              {
                *(_DWORD *)v36 = 0;
                v44->i32[0] = 0;
              }
              else if (v523 >= 1.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v44->f32[0] = *(float *)v6.i32 * v523;
                *(float *)v36 = v19 * v523;
              }
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v522;
            }
            while (v522);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v521;
          }
          while (v521);
          goto LABEL_1325;
        case 4:
          v524 = v697[0];
          do
          {
            v525 = v12;
            do
            {
              v526 = 1.0 - *(float *)v36;
              if (v526 <= 0.0)
              {
                *(_DWORD *)v36 = 0;
                v44->i32[0] = 0;
              }
              else if (v526 >= 1.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v44->f32[0] = *(float *)v6.i32 * v526;
                *(float *)v36 = v19 * v526;
              }
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v525;
            }
            while (v525);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v524;
          }
          while (v524);
          goto LABEL_1325;
        case 5:
          v527 = v697[0];
          do
          {
            v528 = v12;
            do
            {
              v529 = *(float *)v36;
              v44->f32[0] = (float)(*(float *)v5.i32 * v44->f32[0]) + (float)(*(float *)v6.i32 * *(float *)v36);
              v44 = (float32x4_t *)((char *)v44 + 4);
              *(float *)v36 = (float)(*(float *)v5.i32 * v529) + (float)(v19 * v529);
              v36 += 4 * v684;
              --v528;
            }
            while (v528);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v527;
          }
          while (v527);
          goto LABEL_1325;
        case 6:
          v530 = v697[0];
          while (1)
          {
            v531 = v12;
            do
            {
              v532 = *(float *)v36;
              v533 = 1.0 - *(float *)v36;
              if (v533 >= 1.0)
              {
                v44->i32[0] = v6.i32[0];
                v534 = v19;
              }
              else
              {
                if (v533 <= 0.0)
                  goto LABEL_1037;
                v44->f32[0] = v44->f32[0] + (float)(*(float *)v6.i32 * v533);
                v534 = v532 + (float)(v19 * v533);
              }
              *(float *)v36 = v534;
LABEL_1037:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v531;
            }
            while (v531);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v530)
            {
LABEL_1325:
              v697[0] = 0;
LABEL_1326:
              v34 = v686;
LABEL_1327:
              if (!v33)
                return 1;
              v696 = 0;
LABEL_1329:
              if (!shape_enum_clip_next((uint64_t)v33, (int *)&v696 + 1, &v696, v707, v697))
                goto LABEL_65;
              v44 = (float32x4_t *)(v34 + 4 * v21 * (int)v696 + 4 * SHIDWORD(v696));
              v45 = v707[0];
              if (v8)
              {
                v36 = v688 + 4 * v690 * (int)v696 + 4 * SHIDWORD(v696);
                v37 = v690 - v707[0];
              }
              LODWORD(v12) = v707[0];
              v5 = v692;
              v6 = v694;
              goto LABEL_972;
            }
          }
        case 7:
          v535 = v697[0];
          v536 = 4 * v684;
          if (v8)
          {
            do
            {
              v537 = v12;
              do
              {
                v44->f32[0] = v19 * v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                *(float *)v36 = v19 * *(float *)v36;
                v36 += v536;
                --v537;
              }
              while (v537);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v535;
            }
            while (v535);
          }
          else
          {
            do
            {
              v538 = v12;
              do
              {
                v44->f32[0] = v19 * v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                v36 += v536;
                --v538;
              }
              while (v538);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v535;
            }
            while (v535);
          }
          goto LABEL_1325;
        case 8:
          v539 = v697[0];
          v540 = 4 * v684;
          if (v8)
          {
            do
            {
              v541 = v12;
              do
              {
                v44->f32[0] = *(float *)v5.i32 * v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                *(float *)v36 = *(float *)v5.i32 * *(float *)v36;
                v36 += v540;
                --v541;
              }
              while (v541);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v539;
            }
            while (v539);
          }
          else
          {
            do
            {
              v542 = v12;
              do
              {
                v44->f32[0] = *(float *)v5.i32 * v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                v36 += v540;
                --v542;
              }
              while (v542);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v539;
            }
            while (v539);
          }
          goto LABEL_1325;
        case 9:
          v543 = v697[0];
          do
          {
            v544 = v12;
            do
            {
              v545 = *(float *)v36;
              v546 = 1.0 - *(float *)v36;
              v44->f32[0] = (float)(v19 * v44->f32[0]) + (float)(*(float *)v6.i32 * v546);
              v44 = (float32x4_t *)((char *)v44 + 4);
              *(float *)v36 = (float)(v19 * v545) + (float)(v19 * v546);
              v36 += 4 * v684;
              --v544;
            }
            while (v544);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v543;
          }
          while (v543);
          goto LABEL_1325;
        case 10:
          v547 = v697[0];
          do
          {
            v548 = v12;
            do
            {
              v549 = *(float *)v36;
              v550 = 1.0 - *(float *)v36;
              v44->f32[0] = (float)(*(float *)v5.i32 * v44->f32[0]) + (float)(*(float *)v6.i32 * v550);
              v44 = (float32x4_t *)((char *)v44 + 4);
              *(float *)v36 = (float)(*(float *)v5.i32 * v549) + (float)(v19 * v550);
              v36 += 4 * v684;
              --v548;
            }
            while (v548);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v547;
          }
          while (v547);
          goto LABEL_1325;
        case 11:
          v551 = v19 - *(float *)v6.i32;
          v552 = v697[0];
          v553 = 4 * v684;
          if (v8)
          {
            do
            {
              v554 = v12;
              do
              {
                v555 = v19 + *(float *)v36;
                v556 = v551 + (float)(*(float *)v36 - v44->f32[0]);
                if (v555 > 1.0)
                  v555 = 1.0;
                *(float *)v36 = v555;
                v44->f32[0] = v555 - v556;
                v44 = (float32x4_t *)((char *)v44 + 4);
                v36 += v553;
                --v554;
              }
              while (v554);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v552;
            }
            while (v552);
          }
          else
          {
            do
            {
              v557 = v12;
              do
              {
                v44->f32[0] = 1.0 - (float)(v551 + (float)(1.0 - v44->f32[0]));
                v44 = (float32x4_t *)((char *)v44 + 4);
                v36 += v553;
                --v557;
              }
              while (v557);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v552;
            }
            while (v552);
          }
          goto LABEL_1325;
        case 12:
          v558 = v697[0];
          v559 = 4 * v684;
          if (v8)
          {
            do
            {
              v560 = v12;
              do
              {
                v561 = v19 + *(float *)v36;
                if (v561 > 1.0)
                  v561 = 1.0;
                v44->f32[0] = *(float *)v6.i32 + v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                *(float *)v36 = v561;
                v36 += v559;
                --v560;
              }
              while (v560);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v558;
            }
            while (v558);
          }
          else
          {
            do
            {
              v562 = v12;
              do
              {
                v44->f32[0] = *(float *)v6.i32 + v44->f32[0];
                v44 = (float32x4_t *)((char *)v44 + 4);
                v36 += v559;
                --v562;
              }
              while (v562);
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v558;
            }
            while (v558);
          }
          goto LABEL_1325;
        case 13:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v563 = v697[0];
          while (1)
          {
            v564 = v12;
            do
            {
              if (v8)
              {
                v565 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1103;
                }
              }
              else
              {
                v565 = 1.0;
              }
              v566 = (float)(*(float *)v6.i32 * v44->f32[0]) + (float)(v44->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0)
                v566 = *(float *)v6.i32 * v44->f32[0];
              if (v565 != 1.0)
                v566 = v566 + (float)(*(float *)v6.i32 * (float)(1.0 - v565));
              v44->f32[0] = v566;
              if (v8)
                *(float *)v36 = (float)(v19 + v565) - (float)(v565 * v19);
LABEL_1103:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v564;
            }
            while (v564);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v563)
              goto LABEL_1325;
          }
        case 14:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v567 = v697[0];
          do
          {
            v568 = v12;
            do
            {
              if (v8)
              {
                v569 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                }
                else
                {
                  v44->f32[0] = v44->f32[0] + (float)(*(float *)v6.i32 * (float)(1.0 - v44->f32[0]));
                  *(float *)v36 = (float)(v19 + v569) - (float)(v569 * v19);
                }
              }
              else
              {
                v44->f32[0] = v44->f32[0] + (float)(*(float *)v6.i32 * (float)(1.0 - v44->f32[0]));
              }
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v568;
            }
            while (v568);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v567;
          }
          while (v567);
          goto LABEL_1325;
        case 15:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v570 = v697[0];
          v571 = *(float *)v6.i32 + *(float *)v6.i32;
          v572 = *(float *)v6.i32 * 0.0;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v36 <= 0.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v573 = PDAoverlayPDA(v44->f32[0], *(float *)v36, *(float *)v6.i32, v19);
                v5.i32[0] = v692.i32[0];
                v6.i32[0] = v694.i32[0];
                v44->f32[0] = v573;
                *(_DWORD *)v36 = v574;
              }
            }
            else
            {
              v575 = (float)(*(float *)v6.i32 * v44->f32[0]) + (float)(*(float *)v6.i32 * v44->f32[0]);
              v576 = (float)(v572 + (float)(v44->f32[0] * *(float *)v5.i32)) + v575;
              if (v44->f32[0] >= 0.5)
                v576 = (float)((float)(v571 + (float)(v44->f32[0] * (float)(v19 + 1.0))) - v575) - v19;
              v44->f32[0] = v576;
            }
            v44 = (float32x4_t *)((char *)v44 + 4);
            v36 += 4 * v684;
            LODWORD(v12) = v12 - 1;
            if (!(_DWORD)v12)
            {
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v570;
              LODWORD(v12) = v501;
              if (!v570)
                break;
            }
          }
          goto LABEL_1222;
        case 16:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v577 = v697[0];
          while (1)
          {
            v578 = v12;
            do
            {
              if (v8)
              {
                v579 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1144;
                }
              }
              else
              {
                v579 = 1.0;
              }
              v580 = v19 * v44->f32[0];
              if ((float)(*(float *)v6.i32 * v579) < v580)
                v580 = *(float *)v6.i32 * v579;
              v581 = v580 + (float)(v44->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0)
                v581 = v580;
              if (v579 != 1.0)
                v581 = v581 + (float)(*(float *)v6.i32 * (float)(1.0 - v579));
              v44->f32[0] = v581;
              if (v8)
                *(float *)v36 = (float)(v19 + v579) - (float)(v579 * v19);
LABEL_1144:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v578;
            }
            while (v578);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v577)
              goto LABEL_1325;
          }
        case 17:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v582 = v697[0];
          while (1)
          {
            v583 = v12;
            do
            {
              if (v8)
              {
                v584 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1162;
                }
              }
              else
              {
                v584 = 1.0;
              }
              v585 = v19 * v44->f32[0];
              if ((float)(*(float *)v6.i32 * v584) > v585)
                v585 = *(float *)v6.i32 * v584;
              v586 = v585 + (float)(v44->f32[0] * *(float *)v5.i32);
              if (v19 == 1.0)
                v586 = v585;
              if (v584 != 1.0)
                v586 = v586 + (float)(*(float *)v6.i32 * (float)(1.0 - v584));
              v44->f32[0] = v586;
              if (v8)
                *(float *)v36 = (float)(v19 + v584) - (float)(v584 * v19);
LABEL_1162:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v583;
            }
            while (v583);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v582)
              goto LABEL_1325;
          }
        case 18:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v587 = v697[0];
          v588 = v19 - *(float *)v6.i32;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v36 <= 0.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v589 = PDAcolordodgePDA(v44->f32[0], *(float *)v36, *(float *)v6.i32, v19);
                v5.i32[0] = v692.i32[0];
                v6.i32[0] = v694.i32[0];
                v44->f32[0] = v589;
                *(_DWORD *)v36 = v590;
              }
            }
            else
            {
              v591 = v44->f32[0];
              if (v44->f32[0] == 0.0)
                v592 = 0.0;
              else
                v592 = 1.0;
              if (v44->f32[0] != 0.0 && *(float *)v6.i32 != v19)
                v592 = (float)((float)(v19 * v19) * v591) / v588;
              v594 = v592 + (float)(v591 * *(float *)v5.i32);
              if (v19 == 1.0)
                v594 = v592;
              if (v594 > (float)((float)(v19 + 1.0) - v19))
                v594 = (float)(v19 + 1.0) - v19;
              v44->f32[0] = v594;
            }
            v44 = (float32x4_t *)((char *)v44 + 4);
            v36 += 4 * v684;
            LODWORD(v12) = v12 - 1;
            if (!(_DWORD)v12)
            {
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v587;
              LODWORD(v12) = v501;
              if (!v587)
                break;
            }
          }
          goto LABEL_1222;
        case 19:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v595 = v697[0];
          while (1)
          {
            if (v8)
            {
              if (*(float *)v36 <= 0.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v596 = PDAcolorburnPDA(v44->f32[0], *(float *)v36, *(float *)v6.i32, v19);
                v6.i32[0] = v694.i32[0];
                v44->f32[0] = v596;
                *(_DWORD *)v36 = v597;
              }
            }
            else
            {
              v598 = PDAcolorburnPDA(v44->f32[0], 1.0, *(float *)v6.i32, v19);
              v6.i32[0] = v694.i32[0];
              v44->f32[0] = v598;
            }
            v44 = (float32x4_t *)((char *)v44 + 4);
            v36 += 4 * v684;
            LODWORD(v12) = v12 - 1;
            if (!(_DWORD)v12)
            {
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v595;
              LODWORD(v12) = v501;
              if (!v595)
                break;
            }
          }
          goto LABEL_1222;
        case 20:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v599 = v697[0];
          v600 = (float)(*(float *)v6.i32 + *(float *)v6.i32) - v19;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v36 <= 0.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v601 = PDAsoftlightPDA(v44->f32[0], *(float *)v36, *(float *)v6.i32, v19);
                v5.i32[0] = v692.i32[0];
                v6.i32[0] = v694.i32[0];
                v44->f32[0] = v601;
                *(_DWORD *)v36 = v602;
              }
            }
            else
            {
              v603 = v44->f32[0];
              v604 = (float)((float)(*(float *)v6.i32 * v44->f32[0]) + (float)(*(float *)v6.i32 * v44->f32[0]))
                   - (float)(v600 * (float)(v603 * v603));
              if (v604 < 0.0)
                v604 = 0.0;
              v605 = v604 + (float)(v603 * *(float *)v5.i32);
              if (v19 == 1.0)
                v605 = v604;
              v44->f32[0] = v605;
            }
            v44 = (float32x4_t *)((char *)v44 + 4);
            v36 += 4 * v684;
            LODWORD(v12) = v12 - 1;
            if (!(_DWORD)v12)
            {
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v599;
              LODWORD(v12) = v501;
              if (!v599)
                break;
            }
          }
          goto LABEL_1222;
        case 21:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v606 = v697[0];
          v607 = *(float *)v6.i32 * 0.0;
          v608 = *(float *)v6.i32 + *(float *)v6.i32;
          while (1)
          {
            if (v8)
            {
              if (*(float *)v36 <= 0.0)
              {
                v44->i32[0] = v6.i32[0];
                *(float *)v36 = v19;
              }
              else
              {
                v609 = PDAhardlightPDA(v44->f32[0], *(float *)v36, *(float *)v6.i32, v19);
                v5.i32[0] = v692.i32[0];
                v6.i32[0] = v694.i32[0];
                v44->f32[0] = v609;
                *(_DWORD *)v36 = v610;
              }
            }
            else
            {
              v611 = (float)(*(float *)v6.i32 * v44->f32[0]) + (float)(*(float *)v6.i32 * v44->f32[0]);
              v612 = (float)((float)(v608 + (float)(v44->f32[0] * (float)(v19 + 1.0))) - v611) - v19;
              if (*(float *)v6.i32 <= (float)(v19 * 0.5))
                v612 = (float)(v607 + (float)(v44->f32[0] * *(float *)v5.i32)) + v611;
              v44->f32[0] = v612;
            }
            v44 = (float32x4_t *)((char *)v44 + 4);
            v36 += 4 * v684;
            LODWORD(v12) = v12 - 1;
            if (!(_DWORD)v12)
            {
              v44 = (float32x4_t *)((char *)v44 + 4 * v34);
              v36 += 4 * v37;
              --v606;
              LODWORD(v12) = v501;
              if (!v606)
                break;
            }
          }
LABEL_1222:
          v697[0] = 0;
          LODWORD(v9) = v652;
          v21 = v677;
          goto LABEL_1326;
        case 22:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v613 = v697[0];
          while (1)
          {
            v614 = v12;
            do
            {
              if (v8)
              {
                v615 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1234;
                }
              }
              else
              {
                v615 = 1.0;
              }
              v616 = v19 * v44->f32[0];
              v617 = (float)(*(float *)v6.i32 + v44->f32[0]) - v616;
              v618 = v616 - (float)(*(float *)v6.i32 * v615);
              v619 = v617 - (float)(*(float *)v6.i32 * v615);
              if (v618 < 0.0)
                v618 = -v618;
              v44->f32[0] = v619 + v618;
              if (v8)
                *(float *)v36 = (float)(v19 + v615) - (float)(v615 * v19);
LABEL_1234:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v614;
            }
            while (v614);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v613)
              goto LABEL_1325;
          }
        case 23:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v620 = v697[0];
          do
          {
            v621 = v12;
            do
            {
              if (v8)
              {
                v622 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                }
                else
                {
                  v44->f32[0] = (float)(*(float *)v6.i32 + v44->f32[0])
                              + (float)((float)(*(float *)v6.i32 * v44->f32[0]) * -2.0);
                  *(float *)v36 = (float)(v19 + v622) - (float)(v622 * v19);
                }
              }
              else
              {
                v44->f32[0] = (float)(*(float *)v6.i32 + v44->f32[0])
                            + (float)((float)(*(float *)v6.i32 * v44->f32[0]) * -2.0);
              }
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v621;
            }
            while (v621);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            --v620;
          }
          while (v620);
          goto LABEL_1325;
        case 24:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v623 = v697[0];
          while (1)
          {
            v624 = v12;
            do
            {
              if (v8)
              {
                v625 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1262;
                }
              }
              else
              {
                v625 = 1.0;
              }
              v626 = v44->f32[0];
              if (v19 == 1.0)
              {
                v627 = 0.0;
              }
              else
              {
                v626 = v19 * v44->f32[0];
                v627 = v44->f32[0] - v626;
              }
              if (v625 != 1.0)
                v627 = (float)(*(float *)v6.i32 + v627) - (float)(*(float *)v6.i32 * v625);
              v44->f32[0] = v626 + v627;
              if (v8)
                *(float *)v36 = (float)(v19 + v625) - (float)(v19 * v625);
LABEL_1262:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v624;
            }
            while (v624);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v623)
              goto LABEL_1325;
          }
        case 25:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v628 = v697[0];
          while (1)
          {
            v629 = v12;
            do
            {
              if (v8)
              {
                v630 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1279;
                }
              }
              else
              {
                v630 = 1.0;
              }
              v631 = v44->f32[0];
              if (v19 == 1.0)
              {
                v632 = 0.0;
              }
              else
              {
                v631 = v19 * v44->f32[0];
                v632 = v44->f32[0] - v631;
              }
              if (v630 != 1.0)
                v632 = (float)(*(float *)v6.i32 + v632) - (float)(*(float *)v6.i32 * v630);
              v44->f32[0] = v631 + v632;
              if (v8)
                *(float *)v36 = (float)(v19 + v630) - (float)(v19 * v630);
LABEL_1279:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v629;
            }
            while (v629);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v628)
              goto LABEL_1325;
          }
        case 26:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v633 = v697[0];
          while (1)
          {
            v634 = v12;
            do
            {
              if (v8)
              {
                v635 = *(float *)v36;
                if (*(float *)v36 <= 0.0)
                {
                  v44->i32[0] = v6.i32[0];
                  *(float *)v36 = v19;
                  goto LABEL_1295;
                }
              }
              else
              {
                v635 = 1.0;
              }
              v636 = v44->f32[0];
              v637 = *(float *)v6.i32 - (float)(*(float *)v6.i32 * v635);
              if (v635 == 1.0)
                v637 = 0.0;
              v638 = (float)(v636 + v637) - (float)(v19 * v636);
              if (v19 != 1.0)
              {
                v636 = v19 * v636;
                v637 = v638;
              }
              v44->f32[0] = v636 + v637;
              if (v8)
                *(float *)v36 = (float)(v19 + v635) - (float)(v19 * v635);
LABEL_1295:
              v44 = (float32x4_t *)((char *)v44 + 4);
              v36 += 4 * v684;
              --v634;
            }
            while (v634);
            v44 = (float32x4_t *)((char *)v44 + 4 * v34);
            v36 += 4 * v37;
            if (!--v633)
              goto LABEL_1325;
          }
        case 27:
          if (v19 <= 0.0)
            goto LABEL_1326;
          v639 = v697[0];
          break;
        default:
          goto LABEL_1327;
      }
LABEL_1300:
      v640 = v12;
      while (v8)
      {
        v641 = *(float *)v36;
        if (*(float *)v36 > 0.0)
          goto LABEL_1305;
        v44->i32[0] = v6.i32[0];
        *(float *)v36 = v19;
LABEL_1312:
        v44 = (float32x4_t *)((char *)v44 + 4);
        v36 += 4 * v684;
        if (!--v640)
        {
          v44 = (float32x4_t *)((char *)v44 + 4 * v34);
          v36 += 4 * v37;
          if (!--v639)
            goto LABEL_1325;
          goto LABEL_1300;
        }
      }
      v641 = 1.0;
LABEL_1305:
      v642 = v44->f32[0] - (float)(v19 * v44->f32[0]);
      if (v19 == 1.0)
        v642 = 0.0;
      v643 = *(float *)v6.i32 * v641;
      if (v641 == 1.0)
        v643 = *(float *)v6.i32;
      else
        v642 = (float)(*(float *)v6.i32 + v642) - (float)(*(float *)v6.i32 * v641);
      v44->f32[0] = v643 + v642;
      if (v8)
        *(float *)v36 = (float)(v19 + v641) - (float)(v19 * v641);
      goto LABEL_1312;
    }
    v707[0] = *(_DWORD *)(v3 + 4);
    v697[0] = v14;
    v25 = *(int *)(v3 + 12);
    v24 = *(int *)(v3 + 16);
    v668 = (unint64_t)*(int *)(v3 + 28) >> 2;
    if (v8)
    {
      v656 = (unint64_t)*(int *)(v3 + 32) >> 2;
      v657 = (char *)(v8 + 4 * (v25 + v656 * v24));
      v26 = 0xFFFFFFFFLL;
    }
    else
    {
      v656 = 0;
      v657 = 0;
      v26 = 0;
    }
    v38 = *(float **)(v3 + 88);
    v655 = *(_QWORD *)(v3 + 40) + 4 * (v25 + v24 * v668);
    v39 = *(_DWORD *)(v3 + 56);
    v40 = *(_DWORD *)(v3 + 60);
    v687 = (unint64_t)*(int *)(v3 + 76) >> 2;
    if (v18 == 256)
    {
      if (v7)
      {
        v689 = (unint64_t)*(int *)(v3 + 80) >> 2;
        v7 += v39 + v689 * v40;
        v41 = 0xFFFFFFFFLL;
      }
      else
      {
        v689 = 0;
        v41 = 0;
      }
      v38 += v39 + v40 * v687;
      if (v687 == v668 && (uint64_t)(v655 - (_QWORD)v38) >= 1)
      {
        if (v12 >= (v655 - (unint64_t)v38) >> 2)
        {
          v655 += 4 * v13;
          v38 += v13;
          v657 += 4 * (v26 & v13);
          v52 = -1;
          v687 = (unint64_t)*(int *)(v3 + 28) >> 2;
          v7 += v41 & v13;
          goto LABEL_48;
        }
        if (v655 <= (unint64_t)&v38[v668 * v15 + v13])
        {
          v655 += 4 * v668 * v15;
          v69 = &v657[4 * v656 * v15];
          v656 = -(uint64_t)v656;
          v657 = v69;
          v7 += v689 * v15;
          v26 &= 1u;
          v687 = -(uint64_t)v668;
          v689 = -(uint64_t)v689;
          v41 &= 1u;
          v52 = 1;
          v38 += v668 * v15;
          v668 = -(uint64_t)v668;
          goto LABEL_48;
        }
      }
      v26 &= 1u;
      v41 &= 1u;
      v52 = 1;
LABEL_48:
      v653 = *(_DWORD *)(v3 + 56);
      v654 = *(_DWORD *)(v3 + 60);
      if (v16)
      {
        v53 = v7;
        v693 = v41;
        v695 = v26;
        v675 = 0;
        v685 = 0;
        v54 = -1;
        v662 = v687;
        v659 = v689;
        goto LABEL_53;
      }
      v59 = v52 * (int)v12;
      v691 = v656 - (int)v26 * (int)v12;
      v60 = -1;
      v61 = v689;
      v658 = v52;
      v659 = v689;
      v62 = v687;
      v42 = v687;
LABEL_61:
      v66 = v9;
      v660 = 0;
      v661 = (uint64_t)v38;
      v675 = 0;
      v685 = 0;
      v687 = v62 - v59;
      v689 = v61 - (int)v41 * (int)v12;
      v67 = (uint64_t)v7;
      v57 = (char *)v7;
      v58 = v657;
      v68 = (float *)v655;
      goto LABEL_66;
    }
    v42 = *(unsigned int *)(v3 + 64);
    v659 = *(_DWORD *)(v3 + 68);
    if (v7)
    {
      v689 = (unint64_t)*(int *)(v3 + 80) >> 2;
      v41 = 1;
    }
    else
    {
      v689 = 0;
      v41 = 0;
    }
    v685 = &v38[v687 * v659];
    v26 &= 1u;
    if (v16)
    {
      v662 = *(unsigned int *)(v3 + 64);
      v53 = v7;
      v653 = *(_DWORD *)(v3 + 56);
      v654 = *(_DWORD *)(v3 + 60);
      v693 = v41;
      v695 = v26;
      v52 = 1;
      v675 = *(float **)(v3 + 88);
      v54 = (uint64_t)v675;
LABEL_53:
      v658 = v52;
      shape_enum_clip_alloc(v2, v3, (int *)v16, v52, v668, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
      v56 = v55;
      v7 = v53;
      v674 = (uint64_t)v53;
      v57 = (char *)v53;
      v58 = v657;
      v691 = v656;
      if (v55)
        goto LABEL_925;
      return 1;
    }
    v691 = v656 - (v26 * v12);
    if (!v38)
    {
      v653 = *(_DWORD *)(v3 + 56);
      v654 = *(_DWORD *)(v3 + 60);
      v60 = 0;
      v658 = 1;
      v59 = v12;
      v62 = (unint64_t)*(int *)(v3 + 76) >> 2;
      v61 = v689;
      goto LABEL_61;
    }
    v63 = v40 % v659;
    v654 = v40 % v659;
    v661 = *(_QWORD *)(v3 + 88);
    v64 = &v38[v687 * v63];
    v65 = v39 % (int)v42;
    v38 = &v64[v65];
    v60 = (unint64_t)&v64[(int)v42];
    v66 = v9;
    v653 = v65;
    v675 = v38;
    v660 = 0;
    if (v7)
    {
      v67 = (uint64_t)&v7[v689 * v63 + v65];
      v658 = 1;
      v41 = 1;
      v57 = (char *)v67;
    }
    else
    {
      v67 = 0;
      v57 = 0;
      v658 = 1;
    }
    v58 = v657;
    v68 = (float *)v655;
    v59 = v12;
LABEL_66:
    v695 = v26;
    v693 = v41;
    v662 = v42;
    v71 = v668 - v59;
    v676 = v668 - v59;
    switch((int)v66)
    {
      case 0:
        v651 = v7;
        v674 = v67;
        v9 = v66;
        v54 = v60;
        v72 = v71 - (int)v12;
        v73 = &v68[-(int)v12 + 1];
        if (v658 >= 0)
        {
          v73 = v68;
          v72 = v71 + (int)v12;
        }
        v74 = v697[0];
        v75 = v697[0] - 1;
        v76 = (char *)&v73[(v72 * v75) & (v72 >> 63)];
        if (v72 < 0)
          v72 = -v72;
        CGBlt_fillBytes(4 * v12, v697[0], 0, v76, 4 * v72);
        if ((_DWORD)v695)
        {
          if (v658 < 0)
          {
            v77 = v691 - (int)v12;
            v58 += -4 * (int)v12 + 4;
          }
          else
          {
            v77 = v691 + (int)v12;
          }
          v58 += 4 * ((v77 * v75) & (v77 >> 63));
          if (v77 < 0)
            v77 = -v77;
          v691 = v77;
          CGBlt_fillBytes(4 * v12, v74, 0, v58, 4 * v77);
        }
        goto LABEL_885;
      case 1:
        v78 = *(unsigned __int8 *)(v11 + 1);
        if (v78 == 2)
        {
          v79 = v675;
          if ((int)v12 >= 8 && (4 * v42) <= 0x40)
          {
            LODWORD(v4) = 4 * v42;
            v446 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4);
            v446.i16[0] = vaddlv_u8(v446);
            if (v446.i32[0] <= 1u)
            {
              v651 = v7;
              v674 = v67;
              v9 = v66;
              v54 = v60;
              v447 = v697[0];
              v448 = v68;
              v449 = 4 * v42;
              CGSFillDRAM64(v448, 4 * (v12 + v676), 4 * v12, v697[0], v661, 4 * v687, 4 * v42, v659, 4 * v653, v654);
              if ((_DWORD)v695)
              {
                if ((_DWORD)v693)
                  CGSFillDRAM64(v58, 4 * (v12 + v691), 4 * v12, v447, (uint64_t)v7, 4 * v689, v449, v659, 4 * v653, v654);
                else
                  CGBlt_fillBytes(4 * v12, v447, 1065353216, v58, 4 * (v12 + v691));
LABEL_558:
                v7 = v651;
                goto LABEL_922;
              }
              goto LABEL_885;
            }
          }
        }
        else
        {
          v79 = v675;
          if (v78 == 1)
          {
            v674 = v67;
            v9 = v66;
            v80 = (int)v12;
            v651 = v7;
            v54 = v60;
            if (v658 < 0)
            {
              v81 = v687 - (int)v12;
              v38 += -(int)v12 + 1;
              v82 = v676 - (int)v12;
              v68 += -(int)v12 + 1;
            }
            else
            {
              v81 = v687 + (int)v12;
              v82 = v676 + (int)v12;
            }
            v483 = v12;
            v484 = v697[0] - 1;
            v485 = (char *)&v38[(v81 * v484) & (v81 >> 63)];
            if (v81 >= 0)
              v486 = v81;
            else
              v486 = -v81;
            v487 = (char *)&v68[(v82 * v484) & (v82 >> 63)];
            if (v82 >= 0)
              LODWORD(v488) = v82;
            else
              v488 = -v82;
            v489 = v483;
            v490 = 4 * v483;
            v687 = v486;
            v683 = v697[0];
            CGBlt_copyBytes(4 * v483, v697[0], v485, v487, 4 * v486, 4 * v488);
            if ((_DWORD)v695)
            {
              v491 = v490;
              v38 = (float *)v661;
              if ((_DWORD)v693)
              {
                v492 = v689 - v80;
                v493 = &v57[-4 * v489 + 4];
                v494 = v691 - v80;
                v495 = &v58[-4 * v489 + 4];
                if (v658 >= 0)
                {
                  v493 = v57;
                  v495 = v58;
                  v492 = v689 + v80;
                  v494 = v691 + v80;
                }
                v57 = &v493[4 * ((v492 * v484) & (v492 >> 63))];
                if (v492 >= 0)
                  v496 = v492;
                else
                  v496 = -v492;
                v58 = &v495[4 * ((v494 * v484) & (v494 >> 63))];
                if (v494 >= 0)
                  v497 = v494;
                else
                  v497 = -v494;
                v689 = v496;
                v691 = v497;
                CGBlt_copyBytes(v491, v683, v57, v58, 4 * v496, 4 * v497);
              }
              else
              {
                v498 = v691 - v80;
                v499 = &v58[-4 * v489 + 4];
                if (v658 >= 0)
                {
                  v499 = v58;
                  v498 = v691 + v80;
                }
                v500 = (v498 * v484) & (v498 >> 63);
                v58 = &v499[4 * v500];
                if (v498 < 0)
                  v498 = -v498;
                v691 = v498;
                CGBlt_fillBytes(v491, v683, 1065353216, &v499[4 * v500], 4 * v498);
              }
              goto LABEL_886;
            }
LABEL_885:
            v38 = (float *)v661;
LABEL_886:
            v56 = v660;
            v7 = v651;
            goto LABEL_923;
          }
        }
        if ((_DWORD)v26)
        {
          v450 = 4 * (int)v26;
          v451 = 4 * v658;
          if ((_DWORD)v41)
          {
            v452 = v697[0];
            do
            {
              v453 = v12;
              do
              {
                *v68 = *v38;
                *(_DWORD *)v58 = *(_DWORD *)v57;
                v454 = &v38[v658];
                if ((unint64_t)v454 >= v60)
                  v455 = -(uint64_t)(int)v42;
                else
                  v455 = 0;
                v57 += 4 * (int)v41 + 4 * v455;
                v38 = &v454[v455];
                v58 += v450;
                v68 = (float *)((char *)v68 + v451);
                --v453;
              }
              while (v453);
              if (v685)
              {
                v456 = &v79[v687];
                if (v456 >= v685)
                  v457 = -(uint64_t)(v689 * v659);
                else
                  v457 = 0;
                v67 += 4 * v689 + 4 * v457;
                if (v456 >= v685)
                  v458 = -(uint64_t)(v687 * v659);
                else
                  v458 = 0;
                v79 = &v456[v458];
                v60 += 4 * v458 + 4 * v687;
                v57 = (char *)v67;
                v38 = v79;
              }
              else
              {
                v38 += v687;
                v57 += 4 * v689;
              }
              v68 += v676;
              v58 += 4 * v691;
              --v452;
            }
            while (v452);
          }
          else
          {
            v466 = v697[0];
            do
            {
              v467 = v12;
              do
              {
                *v68 = *v38;
                *(_DWORD *)v58 = 1065353216;
                v468 = &v38[v658];
                if ((unint64_t)v468 >= v60)
                  v469 = -(uint64_t)(int)v42;
                else
                  v469 = 0;
                v57 += 4 * v469;
                v38 = &v468[v469];
                v58 += v450;
                v68 = (float *)((char *)v68 + v451);
                --v467;
              }
              while (v467);
              if (v685)
              {
                v470 = &v79[v687];
                if (v470 >= v685)
                  v471 = -(uint64_t)(v689 * v659);
                else
                  v471 = 0;
                v67 += 4 * v689 + 4 * v471;
                if (v470 >= v685)
                  v472 = -(uint64_t)(v687 * v659);
                else
                  v472 = 0;
                v79 = &v470[v472];
                v60 += 4 * v472 + 4 * v687;
                v57 = (char *)v67;
                v38 = v79;
              }
              else
              {
                v38 += v687;
                v57 += 4 * v689;
              }
              v68 += v676;
              v58 += 4 * v691;
              --v466;
            }
            while (v466);
          }
        }
        else
        {
          v459 = v697[0];
          do
          {
            v460 = v12;
            do
            {
              *v68 = *v38;
              v461 = &v38[v658];
              if ((unint64_t)v461 >= v60)
                v462 = -(uint64_t)(int)v42;
              else
                v462 = 0;
              v57 += 4 * (int)v41 + 4 * v462;
              v38 = &v461[v462];
              v68 += v658;
              --v460;
            }
            while (v460);
            if (v685)
            {
              v463 = &v79[v687];
              if (v463 >= v685)
                v464 = -(uint64_t)(v689 * v659);
              else
                v464 = 0;
              v67 += 4 * v689 + 4 * v464;
              if (v463 >= v685)
                v465 = -(uint64_t)(v687 * v659);
              else
                v465 = 0;
              v79 = &v463[v465];
              v60 += 4 * v465 + 4 * v687;
              v57 = (char *)v67;
              v38 = v79;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v676;
            v58 += 4 * v691;
            --v459;
          }
          while (v459);
        }
        goto LABEL_920;
      case 2:
        v83 = (int)v41;
        if ((_DWORD)v26)
        {
          v84 = v697[0];
          v85 = 4 * (int)v26;
          v86 = v675;
          while (1)
          {
            v87 = v12;
            do
            {
              v88 = *(float *)v57;
              if (*(float *)v57 >= 1.0)
              {
                *v68 = *v38;
                v89 = *(float *)v57;
              }
              else
              {
                if (v88 <= 0.0)
                  goto LABEL_87;
                *v68 = *v38 + (float)(*v68 * (float)(1.0 - v88));
                v89 = v88 + (float)(*(float *)v58 * (float)(1.0 - v88));
              }
              *(float *)v58 = v89;
LABEL_87:
              v90 = &v38[v658];
              if ((unint64_t)v90 >= v60)
                v91 = -(uint64_t)(int)v42;
              else
                v91 = 0;
              v57 += 4 * (int)v41 + 4 * v91;
              v38 = &v90[v91];
              v58 += v85;
              v68 += v658;
              --v87;
            }
            while (v87);
            if (v685)
            {
              v92 = &v86[v687];
              if (v92 >= v685)
                v93 = -(uint64_t)(v689 * v659);
              else
                v93 = 0;
              v67 += 4 * v689 + 4 * v93;
              if (v92 >= v685)
                v94 = -(uint64_t)(v687 * v659);
              else
                v94 = 0;
              v86 = &v92[v94];
              v60 += 4 * v94 + 4 * v687;
              v57 = (char *)v67;
              v38 = v86;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            if (!--v84)
              goto LABEL_838;
          }
        }
        v390 = v697[0];
        v391 = v675;
LABEL_736:
        v392 = v12;
        while (1)
        {
          v393 = *(float *)v57;
          if (*(float *)v57 >= 1.0)
            break;
          if (v393 > 0.0)
          {
            v394 = *v38 + (float)(*v68 * (float)(1.0 - v393));
LABEL_741:
            *v68 = v394;
          }
          v395 = &v38[v658];
          if ((unint64_t)v395 >= v60)
            v396 = -(uint64_t)(int)v42;
          else
            v396 = 0;
          v57 += 4 * v83 + 4 * v396;
          v38 = &v395[v396];
          v68 += v658;
          if (!--v392)
          {
            if (v685)
            {
              v397 = &v391[v687];
              if (v397 >= v685)
                v398 = -(uint64_t)(v689 * v659);
              else
                v398 = 0;
              v67 += 4 * v689 + 4 * v398;
              if (v397 >= v685)
                v399 = -(uint64_t)(v687 * v659);
              else
                v399 = 0;
              v391 = &v397[v399];
              v60 += 4 * v399 + 4 * v687;
              v57 = (char *)v67;
              v38 = v391;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            if (!--v390)
            {
LABEL_855:
              v675 = v391;
              goto LABEL_921;
            }
            goto LABEL_736;
          }
        }
        v394 = *v38;
        goto LABEL_741;
      case 3:
        if ((_DWORD)v41)
        {
          v95 = v697[0];
          v96 = 4 * (int)v26;
          v86 = v675;
          do
          {
            v97 = v12;
            do
            {
              v98 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *(_DWORD *)v58 = 0;
                *v68 = 0.0;
              }
              else
              {
                v99 = *v38;
                if (v98 >= 1.0)
                {
                  *v68 = v99;
                  v100 = *(float *)v57;
                }
                else
                {
                  *v68 = v98 * v99;
                  v100 = v98 * *(float *)v57;
                }
                *(float *)v58 = v100;
              }
              v101 = &v38[v658];
              if ((unint64_t)v101 >= v60)
                v102 = -(uint64_t)(int)v42;
              else
                v102 = 0;
              v57 += 4 * (int)v41 + 4 * v102;
              v38 = &v101[v102];
              v58 += v96;
              v68 += v658;
              --v97;
            }
            while (v97);
            if (v685)
            {
              v103 = &v86[v687];
              if (v103 >= v685)
                v104 = -(uint64_t)(v689 * v659);
              else
                v104 = 0;
              v67 += 4 * v689 + 4 * v104;
              if (v103 >= v685)
                v105 = -(uint64_t)(v687 * v659);
              else
                v105 = 0;
              v86 = &v103[v105];
              v60 += 4 * v105 + 4 * v687;
              v57 = (char *)v67;
              v38 = v86;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            --v95;
          }
          while (v95);
          goto LABEL_838;
        }
        v400 = -(uint64_t)(int)v42;
        v401 = v697[0];
        v118 = v675;
        do
        {
          v402 = v12;
          do
          {
            v403 = *(float *)v58;
            v404 = 0.0;
            if (*(float *)v58 > 0.0)
            {
              v404 = *v38;
              v405 = v403 < 1.0;
              v406 = v403 * *v38;
              if (v405)
                v404 = v406;
            }
            *v68 = v404;
            v407 = &v38[v658];
            if ((unint64_t)v407 >= v60)
              v408 = v400;
            else
              v408 = 0;
            v57 += 4 * v408;
            v38 = &v407[v408];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v402;
          }
          while (v402);
          if (v685)
          {
            v409 = &v118[v687];
            if (v409 >= v685)
              v410 = -(uint64_t)(v689 * v659);
            else
              v410 = 0;
            v67 += 4 * v689 + 4 * v410;
            if (v409 >= v685)
              v411 = -(uint64_t)(v687 * v659);
            else
              v411 = 0;
            v118 = &v409[v411];
            v60 += 4 * v411 + 4 * v687;
            v57 = (char *)v67;
            v38 = v118;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          --v401;
        }
        while (v401);
LABEL_777:
        v675 = v118;
        goto LABEL_921;
      case 4:
        v106 = v697[0];
        v79 = v675;
        do
        {
          v107 = v12;
          do
          {
            v108 = 1.0 - *(float *)v58;
            if (v108 <= 0.0)
            {
              *(_DWORD *)v58 = 0;
              *v68 = 0.0;
            }
            else
            {
              if (v108 >= 1.0)
              {
                if ((_DWORD)v41)
                  v110 = *(float *)v57;
                else
                  v110 = 1.0;
              }
              else
              {
                *v68 = v108 * *v38;
                if ((_DWORD)v41)
                  v109 = *(float *)v57;
                else
                  v109 = 1.0;
                v110 = v108 * v109;
              }
              *(float *)v58 = v110;
            }
            v111 = &v38[v658];
            if ((unint64_t)v111 >= v60)
              v112 = -(uint64_t)(int)v42;
            else
              v112 = 0;
            v57 += 4 * (int)v41 + 4 * v112;
            v38 = &v111[v112];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v107;
          }
          while (v107);
          if (v685)
          {
            v113 = &v79[v687];
            if (v113 >= v685)
              v114 = -(uint64_t)(v689 * v659);
            else
              v114 = 0;
            v67 += 4 * v689 + 4 * v114;
            if (v113 >= v685)
              v115 = -(uint64_t)(v687 * v659);
            else
              v115 = 0;
            v79 = &v113[v115];
            v60 += 4 * v115 + 4 * v687;
            v57 = (char *)v67;
            v38 = v79;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          --v106;
        }
        while (v106);
        goto LABEL_920;
      case 5:
        v116 = v697[0];
        v117 = -(uint64_t)(int)v42;
        v118 = v675;
        do
        {
          v119 = v12;
          do
          {
            v120 = *(float *)v58;
            v121 = *(float *)v57;
            v122 = 1.0 - *(float *)v57;
            *v68 = (float)(v122 * *v68) + (float)(*v38 * *(float *)v58);
            *(float *)v58 = (float)(v120 * v122) + (float)(v121 * v120);
            v123 = &v38[v658];
            if ((unint64_t)v123 >= v60)
              v124 = v117;
            else
              v124 = 0;
            v57 += 4 * (int)v41 + 4 * v124;
            v38 = &v123[v124];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v119;
          }
          while (v119);
          if (v685)
          {
            v125 = &v118[v687];
            if (v125 >= v685)
              v126 = -(uint64_t)(v689 * v659);
            else
              v126 = 0;
            v67 += 4 * v689 + 4 * v126;
            if (v125 >= v685)
              v127 = -(uint64_t)(v687 * v659);
            else
              v127 = 0;
            v118 = &v125[v127];
            v60 += 4 * v127 + 4 * v687;
            v57 = (char *)v67;
            v38 = v118;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          --v116;
        }
        while (v116);
        goto LABEL_777;
      case 6:
        v128 = v697[0];
        v79 = v675;
        while (1)
        {
          v129 = v12;
          do
          {
            v130 = *(float *)v58;
            v131 = 1.0 - *(float *)v58;
            if (v131 >= 1.0)
            {
              *v68 = *v38;
              if ((_DWORD)v41)
                v133 = *(float *)v57;
              else
                v133 = 1.0;
            }
            else
            {
              if (v131 <= 0.0)
                goto LABEL_183;
              *v68 = *v68 + (float)(*v38 * v131);
              if ((_DWORD)v41)
                v132 = *(float *)v57;
              else
                v132 = 1.0;
              v133 = v130 + (float)(v132 * v131);
            }
            *(float *)v58 = v133;
LABEL_183:
            v134 = &v38[v658];
            if ((unint64_t)v134 >= v60)
              v135 = -(uint64_t)(int)v42;
            else
              v135 = 0;
            v57 += 4 * (int)v41 + 4 * v135;
            v38 = &v134[v135];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v129;
          }
          while (v129);
          if (v685)
          {
            v136 = &v79[v687];
            if (v136 >= v685)
              v137 = -(uint64_t)(v689 * v659);
            else
              v137 = 0;
            v67 += 4 * v689 + 4 * v137;
            if (v136 >= v685)
              v138 = -(uint64_t)(v687 * v659);
            else
              v138 = 0;
            v79 = &v136[v138];
            v60 += 4 * v138 + 4 * v687;
            v57 = (char *)v67;
            v38 = v79;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          if (!--v128)
          {
LABEL_920:
            v675 = v79;
LABEL_921:
            v674 = v67;
            v9 = v66;
            v54 = v60;
            v697[0] = 0;
LABEL_922:
            v56 = v660;
            v38 = (float *)v661;
LABEL_923:
            if (!v56)
              return 1;
            v696 = 0;
LABEL_925:
            if (!shape_enum_clip_next(v56, (int *)&v696 + 1, &v696, v707, v697))
            {
              v70 = (void *)v56;
LABEL_947:
              free(v70);
              return 1;
            }
            v660 = v56;
            v661 = (uint64_t)v38;
            if (v685)
            {
              v68 = (float *)(v655 + 4 * v668 * (int)v696 + 4 * SHIDWORD(v696));
              v473 = ((int)v696 + *(_DWORD *)(v11 + 60)) % v659;
              v59 = v707[0];
              v42 = v662;
              v474 = (HIDWORD(v696) + *(_DWORD *)(v11 + 56)) % (int)v662;
              v475 = &v38[v687 * v473];
              v38 = &v475[v474];
              v60 = (unint64_t)&v475[(int)v662];
              v26 = v695;
              if ((_DWORD)v695)
                v58 = &v657[4 * v656 * (int)v696 + 4 * SHIDWORD(v696)];
              v476 = v691;
              if ((_DWORD)v695)
                v476 = v656 - v707[0];
              v691 = v476;
              if ((_DWORD)v693)
                v41 = v693;
              else
                v41 = 0;
              v67 = v674;
              if ((_DWORD)v693)
              {
                v67 = (uint64_t)&v7[v689 * v473 + v474];
                v57 = (char *)v67;
              }
              LODWORD(v12) = v707[0];
              v675 = &v475[v474];
              v653 = (HIDWORD(v696) + *(_DWORD *)(v11 + 56)) % (int)v662;
              v654 = ((int)v696 + *(_DWORD *)(v11 + 60)) % v659;
              v66 = v9;
            }
            else
            {
              v477 = HIDWORD(v696) * v658;
              LODWORD(v12) = v707[0];
              v478 = v707[0] * v658;
              v68 = (float *)(v655 + 4 * v668 * (int)v696 + 4 * HIDWORD(v696) * v658);
              v59 = v707[0] * v658;
              v42 = v662;
              v38 += (int)v696 * (int)v662 + HIDWORD(v696) * v658;
              v685 = 0;
              v687 = (int)v662 - v707[0] * v658;
              v26 = v695;
              if ((_DWORD)v695)
                v58 = &v657[4 * v656 * (int)v696 + 4 * v477];
              v479 = v691;
              v41 = v693;
              if ((_DWORD)v695)
                v479 = v656 - v478;
              v480 = (uint64_t)&v7[(int)v696 * v659 + v477];
              v481 = v659 - v478;
              if ((_DWORD)v693)
                v57 = (char *)v480;
              v482 = v689;
              if ((_DWORD)v693)
                v482 = v481;
              v689 = v482;
              v691 = v479;
              v60 = v54;
              v66 = v9;
              v67 = v674;
            }
            goto LABEL_66;
          }
        }
      case 7:
        v139 = (int)v41;
        if ((_DWORD)v26)
        {
          v140 = v697[0];
          v141 = 4 * (int)v26;
          v86 = v675;
          do
          {
            v142 = v12;
            do
            {
              v143 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
              {
                *(_DWORD *)v58 = 0;
                *v68 = 0.0;
              }
              else if (v143 < 1.0)
              {
                *v68 = v143 * *v68;
                *(float *)v58 = v143 * *(float *)v58;
              }
              v144 = &v38[v658];
              if ((unint64_t)v144 >= v60)
                v145 = -(uint64_t)(int)v42;
              else
                v145 = 0;
              v57 += 4 * (int)v41 + 4 * v145;
              v38 = &v144[v145];
              v58 += v141;
              v68 += v658;
              --v142;
            }
            while (v142);
            if (v685)
            {
              v146 = &v86[v687];
              if (v146 >= v685)
                v147 = -(uint64_t)(v689 * v659);
              else
                v147 = 0;
              v67 += 4 * v689 + 4 * v147;
              if (v146 >= v685)
                v148 = -(uint64_t)(v687 * v659);
              else
                v148 = 0;
              v86 = &v146[v148];
              v60 += 4 * v148 + 4 * v687;
              v57 = (char *)v67;
              v38 = v86;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            --v140;
          }
          while (v140);
LABEL_838:
          v675 = v86;
          goto LABEL_921;
        }
        v412 = v697[0];
        v391 = v675;
LABEL_779:
        v413 = v12;
        while (1)
        {
          v414 = *(float *)v57;
          v415 = 0.0;
          if (*(float *)v57 <= 0.0)
            goto LABEL_783;
          if (v414 < 1.0)
            break;
LABEL_784:
          v416 = &v38[v658];
          if ((unint64_t)v416 >= v60)
            v417 = -(uint64_t)(int)v42;
          else
            v417 = 0;
          v57 += 4 * v139 + 4 * v417;
          v38 = &v416[v417];
          v68 += v658;
          if (!--v413)
          {
            if (v685)
            {
              v418 = &v391[v687];
              if (v418 >= v685)
                v419 = -(uint64_t)(v689 * v659);
              else
                v419 = 0;
              v67 += 4 * v689 + 4 * v419;
              if (v418 >= v685)
                v420 = -(uint64_t)(v687 * v659);
              else
                v420 = 0;
              v391 = &v418[v420];
              v60 += 4 * v420 + 4 * v687;
              v57 = (char *)v67;
              v38 = v391;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            if (!--v412)
              goto LABEL_855;
            goto LABEL_779;
          }
        }
        v415 = v414 * *v68;
LABEL_783:
        *v68 = v415;
        goto LABEL_784;
      case 8:
        v149 = (int)v41;
        if ((_DWORD)v26)
        {
          v150 = v697[0];
          v151 = 4 * (int)v26;
          v86 = v675;
          do
          {
            v152 = v12;
            do
            {
              v153 = 1.0 - *(float *)v57;
              if (v153 <= 0.0)
              {
                *(_DWORD *)v58 = 0;
                *v68 = 0.0;
              }
              else if (v153 < 1.0)
              {
                *v68 = v153 * *v68;
                *(float *)v58 = v153 * *(float *)v58;
              }
              v154 = &v38[v658];
              if ((unint64_t)v154 >= v60)
                v155 = -(uint64_t)(int)v42;
              else
                v155 = 0;
              v57 += 4 * (int)v41 + 4 * v155;
              v38 = &v154[v155];
              v58 += v151;
              v68 += v658;
              --v152;
            }
            while (v152);
            if (v685)
            {
              v156 = &v86[v687];
              if (v156 >= v685)
                v157 = -(uint64_t)(v689 * v659);
              else
                v157 = 0;
              v67 += 4 * v689 + 4 * v157;
              if (v156 >= v685)
                v158 = -(uint64_t)(v687 * v659);
              else
                v158 = 0;
              v86 = &v156[v158];
              v60 += 4 * v158 + 4 * v687;
              v57 = (char *)v67;
              v38 = v86;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            --v150;
          }
          while (v150);
          goto LABEL_838;
        }
        v421 = v697[0];
        v391 = v675;
LABEL_800:
        v422 = v12;
        while (1)
        {
          v423 = 1.0 - *(float *)v57;
          v424 = 0.0;
          if (v423 <= 0.0)
            goto LABEL_804;
          if (v423 < 1.0)
            break;
LABEL_805:
          v425 = &v38[v658];
          if ((unint64_t)v425 >= v60)
            v426 = -(uint64_t)(int)v42;
          else
            v426 = 0;
          v57 += 4 * v149 + 4 * v426;
          v38 = &v425[v426];
          v68 += v658;
          if (!--v422)
          {
            if (v685)
            {
              v427 = &v391[v687];
              if (v427 >= v685)
                v428 = -(uint64_t)(v689 * v659);
              else
                v428 = 0;
              v67 += 4 * v689 + 4 * v428;
              if (v427 >= v685)
                v429 = -(uint64_t)(v687 * v659);
              else
                v429 = 0;
              v391 = &v427[v429];
              v60 += 4 * v429 + 4 * v687;
              v57 = (char *)v67;
              v38 = v391;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            if (!--v421)
              goto LABEL_855;
            goto LABEL_800;
          }
        }
        v424 = v423 * *v68;
LABEL_804:
        *v68 = v424;
        goto LABEL_805;
      case 9:
        v159 = v697[0];
        v160 = -(uint64_t)(int)v42;
        v118 = v675;
        do
        {
          v161 = v12;
          do
          {
            v162 = *(float *)v58;
            v163 = *(float *)v57;
            v164 = 1.0 - *(float *)v58;
            *v68 = (float)(*(float *)v57 * *v68) + (float)(*v38 * v164);
            *(float *)v58 = (float)(v162 * v163) + (float)(v163 * v164);
            v165 = &v38[v658];
            if ((unint64_t)v165 >= v60)
              v166 = v160;
            else
              v166 = 0;
            v57 += 4 * (int)v41 + 4 * v166;
            v38 = &v165[v166];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v161;
          }
          while (v161);
          if (v685)
          {
            v167 = &v118[v687];
            if (v167 >= v685)
              v168 = -(uint64_t)(v689 * v659);
            else
              v168 = 0;
            v67 += 4 * v689 + 4 * v168;
            if (v167 >= v685)
              v169 = -(uint64_t)(v687 * v659);
            else
              v169 = 0;
            v118 = &v167[v169];
            v60 += 4 * v169 + 4 * v687;
            v57 = (char *)v67;
            v38 = v118;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          --v159;
        }
        while (v159);
        goto LABEL_777;
      case 10:
        v170 = v697[0];
        v171 = -(uint64_t)(int)v42;
        v118 = v675;
        do
        {
          v172 = v12;
          do
          {
            v173 = *(float *)v58;
            v174 = *(float *)v57;
            v175 = 1.0 - *(float *)v58;
            v176 = 1.0 - *(float *)v57;
            *v68 = (float)(v176 * *v68) + (float)(*v38 * v175);
            *(float *)v58 = (float)(v173 * v176) + (float)(v174 * v175);
            v177 = &v38[v658];
            if ((unint64_t)v177 >= v60)
              v178 = v171;
            else
              v178 = 0;
            v57 += 4 * (int)v41 + 4 * v178;
            v38 = &v177[v178];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v172;
          }
          while (v172);
          if (v685)
          {
            v179 = &v118[v687];
            if (v179 >= v685)
              v180 = -(uint64_t)(v689 * v659);
            else
              v180 = 0;
            v67 += 4 * v689 + 4 * v180;
            if (v179 >= v685)
              v181 = -(uint64_t)(v687 * v659);
            else
              v181 = 0;
            v118 = &v179[v181];
            v60 += 4 * v181 + 4 * v687;
            v57 = (char *)v67;
            v38 = v118;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          --v170;
        }
        while (v170);
        goto LABEL_777;
      case 11:
        if ((_DWORD)v26)
        {
          v182 = v697[0];
          v79 = v675;
          do
          {
            v183 = v12;
            do
            {
              if ((_DWORD)v41)
                v184 = *(float *)v57;
              else
                v184 = 1.0;
              v185 = *(float *)v58 + v184;
              v186 = (float)(*(float *)v58 - *v68) + (float)(v184 - *v38);
              if (v185 <= 1.0)
                v187 = v185;
              else
                v187 = 1.0;
              *(float *)v58 = v187;
              *v68 = v187 - v186;
              v188 = &v38[v658];
              if ((unint64_t)v188 >= v60)
                v189 = -(uint64_t)(int)v42;
              else
                v189 = 0;
              v57 += 4 * (int)v41 + 4 * v189;
              v38 = &v188[v189];
              v58 += 4 * (int)v26;
              v68 += v658;
              --v183;
            }
            while (v183);
            if (v685)
            {
              v190 = &v79[v687];
              if (v190 >= v685)
                v191 = -(uint64_t)(v689 * v659);
              else
                v191 = 0;
              v67 += 4 * v689 + 4 * v191;
              if (v190 >= v685)
                v192 = -(uint64_t)(v687 * v659);
              else
                v192 = 0;
              v79 = &v190[v192];
              v60 += 4 * v192 + 4 * v687;
              v57 = (char *)v67;
              v38 = v79;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v676;
            v58 += 4 * v691;
            --v182;
          }
          while (v182);
          goto LABEL_920;
        }
        v430 = v697[0];
        v86 = v675;
        do
        {
          v431 = v12;
          do
          {
            v432 = 1.0;
            if ((_DWORD)v41)
              v432 = *(float *)v57;
            *v68 = 1.0 - (float)((float)(1.0 - *v68) + (float)(v432 - *v38));
            v433 = &v38[v658];
            if ((unint64_t)v433 >= v60)
              v434 = -(uint64_t)(int)v42;
            else
              v434 = 0;
            v57 += 4 * (int)v41 + 4 * v434;
            v38 = &v433[v434];
            v68 += v658;
            --v431;
          }
          while (v431);
          if (v685)
          {
            v435 = &v86[v687];
            if (v435 >= v685)
              v436 = -(uint64_t)(v689 * v659);
            else
              v436 = 0;
            v67 += 4 * v689 + 4 * v436;
            if (v435 >= v685)
              v437 = -(uint64_t)(v687 * v659);
            else
              v437 = 0;
            v86 = &v435[v437];
            v60 += 4 * v437 + 4 * v687;
            v57 = (char *)v67;
            v38 = v86;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          --v430;
        }
        while (v430);
        goto LABEL_838;
      case 12:
        if (!(_DWORD)v26)
        {
          v438 = (int)v41;
          v439 = v697[0];
          v391 = v675;
          do
          {
            v440 = v12;
            do
            {
              *v68 = *v68 + *v38;
              v441 = &v38[v658];
              if ((unint64_t)v441 >= v60)
                v442 = -(uint64_t)(int)v42;
              else
                v442 = 0;
              v57 += 4 * v438 + 4 * v442;
              v38 = &v441[v442];
              v68 += v658;
              --v440;
            }
            while (v440);
            if (v685)
            {
              v443 = &v391[v687];
              if (v443 >= v685)
                v444 = -(uint64_t)(v689 * v659);
              else
                v444 = 0;
              v67 += 4 * v689 + 4 * v444;
              if (v443 >= v685)
                v445 = -(uint64_t)(v687 * v659);
              else
                v445 = 0;
              v391 = &v443[v445];
              v60 += 4 * v445 + 4 * v687;
              v57 = (char *)v67;
              v38 = v391;
            }
            else
            {
              v38 += v687;
              v57 += 4 * v689;
            }
            v68 += v71;
            v58 += 4 * v691;
            --v439;
          }
          while (v439);
          goto LABEL_855;
        }
        v193 = v697[0];
        v79 = v675;
        do
        {
          v194 = v12;
          do
          {
            if ((_DWORD)v41)
              v195 = *(float *)v57;
            else
              v195 = 1.0;
            v196 = *(float *)v58 + v195;
            if (v196 > 1.0)
              v196 = 1.0;
            *v68 = *v68 + *v38;
            *(float *)v58 = v196;
            v197 = &v38[v658];
            if ((unint64_t)v197 >= v60)
              v198 = -(uint64_t)(int)v42;
            else
              v198 = 0;
            v57 += 4 * (int)v41 + 4 * v198;
            v38 = &v197[v198];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v194;
          }
          while (v194);
          if (v685)
          {
            v199 = &v79[v687];
            if (v199 >= v685)
              v200 = -(uint64_t)(v689 * v659);
            else
              v200 = 0;
            v67 += 4 * v689 + 4 * v200;
            if (v199 >= v685)
              v201 = -(uint64_t)(v687 * v659);
            else
              v201 = 0;
            v79 = &v199[v201];
            v60 += 4 * v201 + 4 * v687;
            v57 = (char *)v67;
            v38 = v79;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          --v193;
        }
        while (v193);
        goto LABEL_920;
      case 13:
        v202 = v697[0];
        v203 = v675;
        while (1)
        {
          v204 = v12;
          do
          {
            v205 = 1.0;
            v206 = 1.0;
            if ((_DWORD)v41)
            {
              v206 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_338;
            }
            if ((_DWORD)v26)
            {
              v205 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_336;
              }
            }
            v207 = (float)(*v68 * *v38) + (float)(*v68 * (float)(1.0 - v206));
            if (v206 == 1.0)
              v207 = *v68 * *v38;
            if (v205 != 1.0)
              v207 = v207 + (float)(*v38 * (float)(1.0 - v205));
            if ((_DWORD)v26)
            {
              v206 = (float)(v206 + v205) - (float)(v205 * v206);
              *v68 = v207;
LABEL_336:
              *(float *)v58 = v206;
              goto LABEL_338;
            }
            *v68 = v207;
LABEL_338:
            v208 = &v38[v658];
            if ((unint64_t)v208 >= v60)
              v209 = -(uint64_t)(int)v42;
            else
              v209 = 0;
            v57 += 4 * (int)v41 + 4 * v209;
            v38 = &v208[v209];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v204;
          }
          while (v204);
          if (v685)
          {
            v210 = &v203[v687];
            if (v210 >= v685)
              v211 = -(uint64_t)(v689 * v659);
            else
              v211 = 0;
            v67 += 4 * v689 + 4 * v211;
            if (v210 >= v685)
              v212 = -(uint64_t)(v687 * v659);
            else
              v212 = 0;
            v203 = &v210[v212];
            v60 += 4 * v212 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v202)
          {
LABEL_734:
            v675 = v203;
            goto LABEL_921;
          }
        }
      case 14:
        v213 = v697[0];
        v203 = v675;
        while (1)
        {
          v214 = v12;
          do
          {
            if ((_DWORD)v41)
            {
              v215 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_364;
              if (!(_DWORD)v26)
              {
LABEL_361:
                *v68 = *v68 + (float)(*v38 * (float)(1.0 - *v68));
                goto LABEL_364;
              }
            }
            else
            {
              v215 = 1.0;
              if (!(_DWORD)v26)
                goto LABEL_361;
            }
            if (*(float *)v58 <= 0.0)
            {
              *v68 = *v38;
            }
            else
            {
              v215 = (float)(v215 + *(float *)v58) - (float)(*(float *)v58 * v215);
              *v68 = *v68 + (float)(*v38 * (float)(1.0 - *v68));
            }
            *(float *)v58 = v215;
LABEL_364:
            v216 = &v38[v658];
            if ((unint64_t)v216 >= v60)
              v217 = -(uint64_t)(int)v42;
            else
              v217 = 0;
            v57 += 4 * (int)v41 + 4 * v217;
            v38 = &v216[v217];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v214;
          }
          while (v214);
          if (v685)
          {
            v218 = &v203[v687];
            if (v218 >= v685)
              v219 = -(uint64_t)(v689 * v659);
            else
              v219 = 0;
            v67 += 4 * v689 + 4 * v219;
            if (v218 >= v685)
              v220 = -(uint64_t)(v687 * v659);
            else
              v220 = 0;
            v203 = &v218[v220];
            v60 += 4 * v220 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v213)
            goto LABEL_734;
        }
      case 15:
        v669 = v12;
        v674 = v67;
        v651 = v7;
        v221 = (int)v41;
        v222 = v697[0];
        v223 = 4 * (int)v26;
        v224 = -(uint64_t)(int)v42;
        *(_QWORD *)v678 = v224;
        do
        {
          v663 = v222;
          v225 = v669;
          do
          {
            v226 = 1.0;
            v227 = 1.0;
            if (!(_DWORD)v41 || (v227 = *(float *)v57, *(float *)v57 > 0.0))
            {
              if ((_DWORD)v26 && (v226 = *(float *)v58, *(float *)v58 <= 0.0))
              {
                *v68 = *v38;
                *(float *)v58 = v227;
              }
              else
              {
                v228 = PDAoverlayPDA(*v68, v226, *v38, v227);
                LODWORD(v26) = v695;
                *v68 = v228;
                if ((_DWORD)v695)
                  *(_DWORD *)v58 = v229;
                LODWORD(v41) = v693;
                v224 = *(_QWORD *)v678;
              }
            }
            v230 = &v38[v658];
            if ((unint64_t)v230 >= v60)
              v231 = v224;
            else
              v231 = 0;
            v57 += 4 * v221 + 4 * v231;
            v38 = &v230[v231];
            v58 += v223;
            v68 += v658;
            --v225;
          }
          while (v225);
          if (v685)
          {
            v232 = &v675[v687];
            v233 = -(uint64_t)(v689 * v659);
            if (v232 < v685)
              v233 = 0;
            v57 = (char *)(v674 + 4 * v689 + 4 * v233);
            v234 = -(uint64_t)(v687 * v659);
            if (v232 < v685)
              v234 = 0;
            v38 = &v232[v234];
            v60 += 4 * v234 + 4 * v687;
            v674 += 4 * v689 + 4 * v233;
            v675 = v38;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          v222 = v663 - 1;
        }
        while (v663 != 1);
        goto LABEL_557;
      case 16:
        v235 = v697[0];
        v203 = v675;
        while (1)
        {
          v236 = v12;
          do
          {
            v237 = 1.0;
            v238 = 1.0;
            if ((_DWORD)v41)
            {
              v238 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_419;
            }
            if ((_DWORD)v26)
            {
              v237 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_417;
              }
            }
            v239 = v238 * *v68;
            if ((float)(v237 * *v38) < v239)
              v239 = v237 * *v38;
            v240 = v239 + (float)(*v68 * (float)(1.0 - v238));
            if (v238 == 1.0)
              v240 = v239;
            if (v237 != 1.0)
              v240 = v240 + (float)(*v38 * (float)(1.0 - v237));
            if ((_DWORD)v26)
            {
              v238 = (float)(v238 + v237) - (float)(v237 * v238);
              *v68 = v240;
LABEL_417:
              *(float *)v58 = v238;
              goto LABEL_419;
            }
            *v68 = v240;
LABEL_419:
            v241 = &v38[v658];
            if ((unint64_t)v241 >= v60)
              v242 = -(uint64_t)(int)v42;
            else
              v242 = 0;
            v57 += 4 * (int)v41 + 4 * v242;
            v38 = &v241[v242];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v236;
          }
          while (v236);
          if (v685)
          {
            v243 = &v203[v687];
            if (v243 >= v685)
              v244 = -(uint64_t)(v689 * v659);
            else
              v244 = 0;
            v67 += 4 * v689 + 4 * v244;
            if (v243 >= v685)
              v245 = -(uint64_t)(v687 * v659);
            else
              v245 = 0;
            v203 = &v243[v245];
            v60 += 4 * v245 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v235)
            goto LABEL_734;
        }
      case 17:
        v246 = v697[0];
        v203 = v675;
        while (1)
        {
          v247 = v12;
          do
          {
            v248 = 1.0;
            v249 = 1.0;
            if ((_DWORD)v41)
            {
              v249 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_451;
            }
            if ((_DWORD)v26)
            {
              v248 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_449;
              }
            }
            v250 = v249 * *v68;
            if ((float)(v248 * *v38) > v250)
              v250 = v248 * *v38;
            v251 = v250 + (float)(*v68 * (float)(1.0 - v249));
            if (v249 == 1.0)
              v251 = v250;
            if (v248 != 1.0)
              v251 = v251 + (float)(*v38 * (float)(1.0 - v248));
            if ((_DWORD)v26)
            {
              v249 = (float)(v249 + v248) - (float)(v248 * v249);
              *v68 = v251;
LABEL_449:
              *(float *)v58 = v249;
              goto LABEL_451;
            }
            *v68 = v251;
LABEL_451:
            v252 = &v38[v658];
            if ((unint64_t)v252 >= v60)
              v253 = -(uint64_t)(int)v42;
            else
              v253 = 0;
            v57 += 4 * (int)v41 + 4 * v253;
            v38 = &v252[v253];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v247;
          }
          while (v247);
          if (v685)
          {
            v254 = &v203[v687];
            if (v254 >= v685)
              v255 = -(uint64_t)(v689 * v659);
            else
              v255 = 0;
            v67 += 4 * v689 + 4 * v255;
            if (v254 >= v685)
              v256 = -(uint64_t)(v687 * v659);
            else
              v256 = 0;
            v203 = &v254[v256];
            v60 += 4 * v256 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v246)
            goto LABEL_734;
        }
      case 18:
        v670 = v12;
        v674 = v67;
        v651 = v7;
        v257 = (int)v41;
        v258 = v697[0];
        v259 = 4 * (int)v26;
        v260 = -(uint64_t)(int)v42;
        *(_QWORD *)v679 = v260;
        do
        {
          v664 = v258;
          v261 = v670;
          do
          {
            v262 = 1.0;
            v263 = 1.0;
            if (!(_DWORD)v41 || (v263 = *(float *)v57, *(float *)v57 > 0.0))
            {
              if ((_DWORD)v26 && (v262 = *(float *)v58, *(float *)v58 <= 0.0))
              {
                *v68 = *v38;
                *(float *)v58 = v263;
              }
              else
              {
                v264 = PDAcolordodgePDA(*v68, v262, *v38, v263);
                LODWORD(v26) = v695;
                *v68 = v264;
                if ((_DWORD)v695)
                  *(_DWORD *)v58 = v265;
                LODWORD(v41) = v693;
                v260 = *(_QWORD *)v679;
              }
            }
            v266 = &v38[v658];
            if ((unint64_t)v266 >= v60)
              v267 = v260;
            else
              v267 = 0;
            v57 += 4 * v257 + 4 * v267;
            v38 = &v266[v267];
            v58 += v259;
            v68 += v658;
            --v261;
          }
          while (v261);
          if (v685)
          {
            v268 = &v675[v687];
            v269 = -(uint64_t)(v689 * v659);
            if (v268 < v685)
              v269 = 0;
            v57 = (char *)(v674 + 4 * v689 + 4 * v269);
            v270 = -(uint64_t)(v687 * v659);
            if (v268 < v685)
              v270 = 0;
            v38 = &v268[v270];
            v60 += 4 * v270 + 4 * v687;
            v674 += 4 * v689 + 4 * v269;
            v675 = v38;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          v258 = v664 - 1;
        }
        while (v664 != 1);
        goto LABEL_557;
      case 19:
        v671 = v12;
        v674 = v67;
        v651 = v7;
        v271 = (int)v41;
        v272 = v697[0];
        v273 = 4 * (int)v26;
        v274 = -(uint64_t)(int)v42;
        *(_QWORD *)v680 = v274;
        do
        {
          v665 = v272;
          v275 = v671;
          do
          {
            v276 = 1.0;
            v277 = 1.0;
            if (!(_DWORD)v41 || (v277 = *(float *)v57, *(float *)v57 > 0.0))
            {
              if ((_DWORD)v26 && (v276 = *(float *)v58, *(float *)v58 <= 0.0))
              {
                *v68 = *v38;
                *(float *)v58 = v277;
              }
              else
              {
                v278 = PDAcolorburnPDA(*v68, v276, *v38, v277);
                LODWORD(v26) = v695;
                *v68 = v278;
                if ((_DWORD)v695)
                  *(_DWORD *)v58 = v279;
                LODWORD(v41) = v693;
                v274 = *(_QWORD *)v680;
              }
            }
            v280 = &v38[v658];
            if ((unint64_t)v280 >= v60)
              v281 = v274;
            else
              v281 = 0;
            v57 += 4 * v271 + 4 * v281;
            v38 = &v280[v281];
            v58 += v273;
            v68 += v658;
            --v275;
          }
          while (v275);
          if (v685)
          {
            v282 = &v675[v687];
            v283 = -(uint64_t)(v689 * v659);
            if (v282 < v685)
              v283 = 0;
            v57 = (char *)(v674 + 4 * v689 + 4 * v283);
            v284 = -(uint64_t)(v687 * v659);
            if (v282 < v685)
              v284 = 0;
            v38 = &v282[v284];
            v60 += 4 * v284 + 4 * v687;
            v674 += 4 * v689 + 4 * v283;
            v675 = v38;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          v272 = v665 - 1;
        }
        while (v665 != 1);
        goto LABEL_557;
      case 20:
        v672 = v12;
        v674 = v67;
        v651 = v7;
        v285 = (int)v41;
        v286 = v697[0];
        v287 = 4 * (int)v26;
        v288 = -(uint64_t)(int)v42;
        *(_QWORD *)v681 = v288;
        do
        {
          v666 = v286;
          v289 = v672;
          do
          {
            v290 = 1.0;
            v291 = 1.0;
            if (!(_DWORD)v41 || (v291 = *(float *)v57, *(float *)v57 > 0.0))
            {
              if ((_DWORD)v26 && (v290 = *(float *)v58, *(float *)v58 <= 0.0))
              {
                *v68 = *v38;
                *(float *)v58 = v291;
              }
              else
              {
                v292 = PDAsoftlightPDA(*v68, v290, *v38, v291);
                LODWORD(v26) = v695;
                *v68 = v292;
                if ((_DWORD)v695)
                  *(_DWORD *)v58 = v293;
                LODWORD(v41) = v693;
                v288 = *(_QWORD *)v681;
              }
            }
            v294 = &v38[v658];
            if ((unint64_t)v294 >= v60)
              v295 = v288;
            else
              v295 = 0;
            v57 += 4 * v285 + 4 * v295;
            v38 = &v294[v295];
            v58 += v287;
            v68 += v658;
            --v289;
          }
          while (v289);
          if (v685)
          {
            v296 = &v675[v687];
            v297 = -(uint64_t)(v689 * v659);
            if (v296 < v685)
              v297 = 0;
            v57 = (char *)(v674 + 4 * v689 + 4 * v297);
            v298 = -(uint64_t)(v687 * v659);
            if (v296 < v685)
              v298 = 0;
            v38 = &v296[v298];
            v60 += 4 * v298 + 4 * v687;
            v674 += 4 * v689 + 4 * v297;
            v675 = v38;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          v286 = v666 - 1;
        }
        while (v666 != 1);
        goto LABEL_557;
      case 21:
        v673 = v12;
        v674 = v67;
        v651 = v7;
        v299 = (int)v41;
        v300 = v697[0];
        v301 = 4 * (int)v26;
        v302 = -(uint64_t)(int)v42;
        *(_QWORD *)v682 = v302;
        do
        {
          v667 = v300;
          v303 = v673;
          do
          {
            v304 = 1.0;
            v305 = 1.0;
            if (!(_DWORD)v41 || (v305 = *(float *)v57, *(float *)v57 > 0.0))
            {
              if ((_DWORD)v26 && (v304 = *(float *)v58, *(float *)v58 <= 0.0))
              {
                *v68 = *v38;
                *(float *)v58 = v305;
              }
              else
              {
                v306 = PDAhardlightPDA(*v68, v304, *v38, v305);
                LODWORD(v26) = v695;
                *v68 = v306;
                if ((_DWORD)v695)
                  *(_DWORD *)v58 = v307;
                LODWORD(v41) = v693;
                v302 = *(_QWORD *)v682;
              }
            }
            v308 = &v38[v658];
            if ((unint64_t)v308 >= v60)
              v309 = v302;
            else
              v309 = 0;
            v57 += 4 * v299 + 4 * v309;
            v38 = &v308[v309];
            v58 += v301;
            v68 += v658;
            --v303;
          }
          while (v303);
          if (v685)
          {
            v310 = &v675[v687];
            v311 = -(uint64_t)(v689 * v659);
            if (v310 < v685)
              v311 = 0;
            v57 = (char *)(v674 + 4 * v689 + 4 * v311);
            v312 = -(uint64_t)(v687 * v659);
            if (v310 < v685)
              v312 = 0;
            v38 = &v310[v312];
            v60 += 4 * v312 + 4 * v687;
            v674 += 4 * v689 + 4 * v311;
            v675 = v38;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v676;
          v58 += 4 * v691;
          v300 = v667 - 1;
        }
        while (v667 != 1);
LABEL_557:
        v54 = v60;
        v697[0] = 0;
        v9 = v652;
        v11 = v650;
        goto LABEL_558;
      case 22:
        v313 = v697[0];
        v203 = v675;
        while (1)
        {
          v314 = v12;
          do
          {
            v315 = 1.0;
            v316 = 1.0;
            if ((_DWORD)v41)
            {
              v316 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_572;
            }
            if ((_DWORD)v26)
            {
              v315 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_570;
              }
            }
            v317 = v316 * *v68;
            v318 = v315 * *v38;
            v319 = (float)(*v68 + *v38) - v317;
            v320 = v317 - v318;
            v321 = v319 - v318;
            if (v320 < 0.0)
              v320 = -v320;
            v322 = v321 + v320;
            if ((_DWORD)v26)
            {
              v316 = (float)(v316 + v315) - (float)(v315 * v316);
              *v68 = v322;
LABEL_570:
              *(float *)v58 = v316;
              goto LABEL_572;
            }
            *v68 = v322;
LABEL_572:
            v323 = &v38[v658];
            if ((unint64_t)v323 >= v60)
              v324 = -(uint64_t)(int)v42;
            else
              v324 = 0;
            v57 += 4 * (int)v41 + 4 * v324;
            v38 = &v323[v324];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v314;
          }
          while (v314);
          if (v685)
          {
            v325 = &v203[v687];
            if (v325 >= v685)
              v326 = -(uint64_t)(v689 * v659);
            else
              v326 = 0;
            v67 += 4 * v689 + 4 * v326;
            if (v325 >= v685)
              v327 = -(uint64_t)(v687 * v659);
            else
              v327 = 0;
            v203 = &v325[v327];
            v60 += 4 * v327 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v313)
            goto LABEL_734;
        }
      case 23:
        v328 = v697[0];
        v203 = v675;
        while (1)
        {
          v329 = v12;
          do
          {
            v330 = 1.0;
            v331 = 1.0;
            if ((_DWORD)v41)
            {
              v331 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_598;
            }
            if ((_DWORD)v26)
            {
              v330 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_596;
              }
            }
            v332 = (float)(*v68 + *v38) + (float)((float)(*v38 * *v68) * -2.0);
            if ((_DWORD)v26)
            {
              v331 = (float)(v331 + v330) - (float)(v330 * v331);
              *v68 = v332;
LABEL_596:
              *(float *)v58 = v331;
              goto LABEL_598;
            }
            *v68 = v332;
LABEL_598:
            v333 = &v38[v658];
            if ((unint64_t)v333 >= v60)
              v334 = -(uint64_t)(int)v42;
            else
              v334 = 0;
            v57 += 4 * (int)v41 + 4 * v334;
            v38 = &v333[v334];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v329;
          }
          while (v329);
          if (v685)
          {
            v335 = &v203[v687];
            if (v335 >= v685)
              v336 = -(uint64_t)(v689 * v659);
            else
              v336 = 0;
            v67 += 4 * v689 + 4 * v336;
            if (v335 >= v685)
              v337 = -(uint64_t)(v687 * v659);
            else
              v337 = 0;
            v203 = &v335[v337];
            v60 += 4 * v337 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v328)
            goto LABEL_734;
        }
      case 24:
        v338 = v697[0];
        v203 = v675;
        while (1)
        {
          v339 = v12;
          do
          {
            v340 = 1.0;
            v341 = 1.0;
            if ((_DWORD)v41)
            {
              v341 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_629;
            }
            if ((_DWORD)v26)
            {
              v340 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_627;
              }
            }
            v342 = *v68;
            if (v341 == 1.0)
            {
              v343 = 0.0;
            }
            else
            {
              v342 = v341 * *v68;
              v343 = *v68 - v342;
            }
            v344 = (float)(*v38 + v343) - (float)(v340 * *v38);
            if (v340 == 1.0)
              v344 = v343;
            v345 = v342 + v344;
            if ((_DWORD)v26)
            {
              v341 = (float)(v341 + v340) - (float)(v341 * v340);
              *v68 = v345;
LABEL_627:
              *(float *)v58 = v341;
              goto LABEL_629;
            }
            *v68 = v345;
LABEL_629:
            v346 = &v38[v658];
            if ((unint64_t)v346 >= v60)
              v347 = -(uint64_t)(int)v42;
            else
              v347 = 0;
            v57 += 4 * (int)v41 + 4 * v347;
            v38 = &v346[v347];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v339;
          }
          while (v339);
          if (v685)
          {
            v348 = &v203[v687];
            if (v348 >= v685)
              v349 = -(uint64_t)(v689 * v659);
            else
              v349 = 0;
            v67 += 4 * v689 + 4 * v349;
            if (v348 >= v685)
              v350 = -(uint64_t)(v687 * v659);
            else
              v350 = 0;
            v203 = &v348[v350];
            v60 += 4 * v350 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v338)
            goto LABEL_734;
        }
      case 25:
        v351 = v697[0];
        v203 = v675;
        while (1)
        {
          v352 = v12;
          do
          {
            v353 = 1.0;
            v354 = 1.0;
            if ((_DWORD)v41)
            {
              v354 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_660;
            }
            if ((_DWORD)v26)
            {
              v353 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_658;
              }
            }
            v355 = *v68;
            if (v354 == 1.0)
            {
              v356 = 0.0;
            }
            else
            {
              v355 = v354 * *v68;
              v356 = *v68 - v355;
            }
            v357 = (float)(*v38 + v356) - (float)(v353 * *v38);
            if (v353 == 1.0)
              v357 = v356;
            v358 = v355 + v357;
            if ((_DWORD)v26)
            {
              v354 = (float)(v354 + v353) - (float)(v354 * v353);
              *v68 = v358;
LABEL_658:
              *(float *)v58 = v354;
              goto LABEL_660;
            }
            *v68 = v358;
LABEL_660:
            v359 = &v38[v658];
            if ((unint64_t)v359 >= v60)
              v360 = -(uint64_t)(int)v42;
            else
              v360 = 0;
            v57 += 4 * (int)v41 + 4 * v360;
            v38 = &v359[v360];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v352;
          }
          while (v352);
          if (v685)
          {
            v361 = &v203[v687];
            if (v361 >= v685)
              v362 = -(uint64_t)(v689 * v659);
            else
              v362 = 0;
            v67 += 4 * v689 + 4 * v362;
            if (v361 >= v685)
              v363 = -(uint64_t)(v687 * v659);
            else
              v363 = 0;
            v203 = &v361[v363];
            v60 += 4 * v363 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v351)
            goto LABEL_734;
        }
      case 26:
        v364 = v697[0];
        v203 = v675;
        while (1)
        {
          v365 = v12;
          do
          {
            v366 = 1.0;
            v367 = 1.0;
            if ((_DWORD)v41)
            {
              v367 = *(float *)v57;
              if (*(float *)v57 <= 0.0)
                goto LABEL_690;
            }
            if ((_DWORD)v26)
            {
              v366 = *(float *)v58;
              if (*(float *)v58 <= 0.0)
              {
                *v68 = *v38;
                goto LABEL_688;
              }
            }
            v368 = *v68;
            v369 = *v38 - (float)(v366 * *v38);
            if (v366 == 1.0)
              v369 = 0.0;
            v370 = (float)(v368 + v369) - (float)(v367 * v368);
            if (v367 != 1.0)
            {
              v368 = v367 * v368;
              v369 = v370;
            }
            v371 = v368 + v369;
            if ((_DWORD)v26)
            {
              v367 = (float)(v367 + v366) - (float)(v367 * v366);
              *v68 = v371;
LABEL_688:
              *(float *)v58 = v367;
              goto LABEL_690;
            }
            *v68 = v371;
LABEL_690:
            v372 = &v38[v658];
            if ((unint64_t)v372 >= v60)
              v373 = -(uint64_t)(int)v42;
            else
              v373 = 0;
            v57 += 4 * (int)v41 + 4 * v373;
            v38 = &v372[v373];
            v58 += 4 * (int)v26;
            v68 += v658;
            --v365;
          }
          while (v365);
          if (v685)
          {
            v374 = &v203[v687];
            if (v374 >= v685)
              v375 = -(uint64_t)(v689 * v659);
            else
              v375 = 0;
            v67 += 4 * v689 + 4 * v375;
            if (v374 >= v685)
              v376 = -(uint64_t)(v687 * v659);
            else
              v376 = 0;
            v203 = &v374[v376];
            v60 += 4 * v376 + 4 * v687;
            v57 = (char *)v67;
            v38 = v203;
          }
          else
          {
            v38 += v687;
            v57 += 4 * v689;
          }
          v68 += v71;
          v58 += 4 * v691;
          if (!--v364)
            goto LABEL_734;
        }
      case 27:
        v377 = v697[0];
        v203 = v675;
        break;
      default:
        v674 = v67;
        v9 = v66;
        v54 = v60;
        goto LABEL_922;
    }
LABEL_706:
    v378 = v12;
    while (1)
    {
      v379 = 1.0;
      v380 = 1.0;
      if (!(_DWORD)v41 || (v380 = *(float *)v57, *(float *)v57 > 0.0))
      {
        if ((_DWORD)v26 && (v379 = *(float *)v58, *(float *)v58 <= 0.0))
        {
          *v68 = *v38;
        }
        else
        {
          v381 = *v38;
          v382 = *v68 - (float)(v380 * *v68);
          if (v380 == 1.0)
            v382 = 0.0;
          v383 = (float)(v381 + v382) - (float)(v379 * v381);
          if (v379 != 1.0)
          {
            v381 = v379 * v381;
            v382 = v383;
          }
          v384 = v381 + v382;
          if (!(_DWORD)v26)
          {
            *v68 = v384;
            goto LABEL_720;
          }
          v380 = (float)(v380 + v379) - (float)(v380 * v379);
          *v68 = v384;
        }
        *(float *)v58 = v380;
      }
LABEL_720:
      v385 = &v38[v658];
      if ((unint64_t)v385 >= v60)
        v386 = -(uint64_t)(int)v42;
      else
        v386 = 0;
      v57 += 4 * (int)v41 + 4 * v386;
      v38 = &v385[v386];
      v58 += 4 * (int)v26;
      v68 += v658;
      if (!--v378)
      {
        if (v685)
        {
          v387 = &v203[v687];
          if (v387 >= v685)
            v388 = -(uint64_t)(v689 * v659);
          else
            v388 = 0;
          v67 += 4 * v689 + 4 * v388;
          if (v387 >= v685)
            v389 = -(uint64_t)(v687 * v659);
          else
            v389 = 0;
          v203 = &v387[v389];
          v60 += 4 * v389 + 4 * v687;
          v57 = (char *)v67;
          v38 = v203;
        }
        else
        {
          v38 += v687;
          v57 += 4 * v689;
        }
        v68 += v71;
        v58 += 4 * v691;
        if (!--v377)
          goto LABEL_734;
        goto LABEL_706;
      }
    }
  }
  v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      Wf_mark_constmask(v3, v9, v4);
    else
      Wf_mark_pixelmask(v3, v9);
  }
  else
  {
    v27 = *(_DWORD *)(v3 + 112);
    v28 = *(_DWORD *)(v3 + 116);
    v29 = v3;
    v30 = (v27 + 15) & 0xFFFFFFF0;
    v31 = v30 * v28;
    if ((int)v31 <= 4096)
    {
      v33 = v707;
    }
    else
    {
      v32 = malloc_type_malloc(v31, 0x4E32AE95uLL);
      if (!v32)
        return 1;
      v33 = v32;
      v16 = *(uint16x4_t **)(v29 + 136);
      v17 = *(_DWORD *)(v29 + 128);
    }
    CGSConvertBitsToMask(v16, *(_DWORD *)(v29 + 124), v33, v30, v27, v28, v17);
    v46 = *(_OWORD *)(v29 + 112);
    v703 = *(_OWORD *)(v29 + 96);
    v704 = v46;
    v47 = *(_OWORD *)(v29 + 144);
    v705 = *(_OWORD *)(v29 + 128);
    v706 = v47;
    v48 = *(_OWORD *)(v29 + 48);
    v699 = *(_OWORD *)(v29 + 32);
    v700 = v48;
    v49 = *(_OWORD *)(v29 + 80);
    v701 = *(_OWORD *)(v29 + 64);
    v702 = v49;
    v50 = *(_OWORD *)v29;
    v51 = *(_OWORD *)(v29 + 16);
    *(_OWORD *)v697 = *(_OWORD *)v29;
    v698 = v51;
    HIDWORD(v704) = (v27 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v705 + 1) = v33;
    if (BYTE1(v697[0]) << 8 == 1024)
      Wf_mark_constmask((uint64_t)v697, v9, *(double *)&v50);
    else
      Wf_mark_pixelmask((uint64_t)v697, v9);
    if (v33 != (_BYTE *)v707)
    {
LABEL_65:
      v70 = v33;
      goto LABEL_947;
    }
  }
  return 1;
}

float PDAoverlayPDA(float a1, float a2, float a3, float a4)
{
  float v4;
  BOOL v5;
  float v6;
  float result;

  v4 = (float)(a1 * a3) + (float)(a1 * a3);
  v5 = a1 < (float)(a2 * 0.5);
  v6 = (float)((float)((float)((float)(a2 + 1.0) * a3) + (float)(a1 * (float)(a4 + 1.0))) - v4) - (float)(a2 * a4);
  result = (float)((float)((float)(1.0 - a2) * a3) + (float)(a1 * (float)(1.0 - a4))) + v4;
  if (!v5)
    return v6;
  return result;
}

float PDAcolordodgePDA(float a1, float a2, float a3, float a4)
{
  float v4;
  float result;
  float v6;
  float v7;

  v4 = 0.0;
  if (a1 != 0.0)
  {
    if (a3 == a4)
      v4 = 1.0;
    else
      v4 = (float)(a1 * (float)(a4 * a4)) / (float)(a4 - a3);
  }
  result = v4 + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0)
    result = v4;
  v6 = result + (float)(a3 * (float)(1.0 - a2));
  if (a2 != 1.0)
    result = v6;
  v7 = (float)(a2 + a4) - (float)(a2 * a4);
  if (result > v7)
    return v7;
  return result;
}

float PDAcolorburnPDA(float a1, float a2, float a3, float a4)
{
  float v5;
  float result;
  float v7;

  v5 = (float)(a2 * a4) + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0)
    v5 = a2 * a4;
  if (a2 == 1.0)
    result = v5;
  else
    result = v5 + (float)(a3 * (float)(1.0 - a2));
  v7 = a2 - a1;
  if (v7 != 0.0)
  {
    if (a3 == 0.0)
      return 0.0;
    result = result - (float)((float)(v7 * (float)(a4 * a4)) / a3);
    if (result < 0.0)
      return 0.0;
  }
  return result;
}

float PDAhardlightPDA(float a1, float a2, float a3, float a4)
{
  float v4;
  float v5;
  float result;

  v4 = (float)(a1 * a3) + (float)(a1 * a3);
  v5 = (float)((float)((float)(1.0 - a2) * a3) + (float)(a1 * (float)(1.0 - a4))) + v4;
  result = (float)((float)((float)((float)(a2 + 1.0) * a3) + (float)(a1 * (float)(a4 + 1.0))) - v4) - (float)(a2 * a4);
  if (a3 <= (float)(a4 * 0.5))
    return v5;
  return result;
}

float PDAsoftlightPDA(float a1, float a2, float a3, float a4)
{
  float v4;
  float result;
  float v6;

  v4 = 0.0;
  if (a2 != 0.0)
  {
    v4 = (float)((float)(a1 * a3) + (float)(a1 * a3))
       - (float)((float)((float)(a1 * a1) * (float)((float)(a3 + a3) - a4)) / a2);
    if (v4 < 0.0)
      v4 = 0.0;
  }
  result = v4 + (float)(a1 * (float)(1.0 - a4));
  if (a4 == 1.0)
    result = v4;
  v6 = result + (float)(a3 * (float)(1.0 - a2));
  if (a2 != 1.0)
    return v6;
  return result;
}

void Wf_mark_constmask(uint64_t a1, int a2, double a3)
{
  int32x2_t v3;
  uint64_t v4;
  uint64_t v5;
  float *v6;
  float v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float *v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  unint64_t v17;
  float *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  float v29;
  unsigned int v30;
  int v31;
  unsigned int *v32;
  uint64_t v33;
  float *v34;
  float *v35;
  char v36;
  int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned int *v43;
  uint64_t v44;
  float *v45;
  float *v46;
  char v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  float v55;
  float v56;
  float v57;
  float v58;
  float v59;
  uint64_t v60;
  int v61;
  unsigned int v62;
  float v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  uint64_t v70;
  int v71;
  float v72;
  float v73;
  float v74;
  float v75;
  uint64_t v76;
  int v77;
  unsigned int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  uint64_t v85;
  int v86;
  unsigned int v87;
  float v88;
  float v89;
  float v90;
  uint64_t v91;
  int v92;
  unsigned int v93;
  float v94;
  float v95;
  uint64_t v96;
  int v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  uint64_t v104;
  int v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  uint64_t v111;
  int v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float v117;
  float v118;
  uint64_t v119;
  int v120;
  float v121;
  float v122;
  float v123;
  float v124;
  uint64_t v125;
  int v126;
  float v127;
  float v128;
  float v129;
  float v130;
  float v131;
  uint64_t v132;
  int v133;
  float v134;
  float v135;
  float v136;
  float v137;
  uint64_t v138;
  int v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  uint64_t v146;
  int v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  uint64_t v154;
  int v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  uint64_t v162;
  int v163;
  float v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  uint64_t v170;
  int v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  uint64_t v178;
  int v179;
  float v180;
  float v181;
  float v182;
  float v183;
  float v184;
  float v185;
  uint64_t v186;
  int v187;
  float v188;
  float v189;
  float v190;
  float v191;
  float v192;
  float v193;
  uint64_t v194;
  int v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  float v204;
  float v205;
  uint64_t v206;
  int v207;
  float v208;
  float v209;
  float v210;
  float v211;
  uint64_t v212;
  int v213;
  float v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  float v220;
  uint64_t v221;
  int v222;
  float v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  uint64_t v230;
  int v231;
  float v232;
  float v233;
  float v234;
  float v235;
  float v236;
  float v237;
  float v238;
  uint64_t v239;
  int v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float v245;
  float v246;
  int v247;
  int v248;
  float v249;
  int v250;
  char v251;
  unsigned int *v252;
  float *v253;
  int v254;
  int v255;
  unsigned int v256;
  unsigned int v257;
  int v258;
  int v259;
  char v260;
  unsigned int *v261;
  float32x4_t *v262;
  int v263;
  unsigned int v264;
  unsigned int v265;
  int v266;
  unsigned int v267;
  float v268;
  int v269;
  unsigned int v270;
  float v271;
  int v272;
  int v273;
  uint64_t v274;
  unint64_t v275;
  int v276;
  unint64_t v277;
  unsigned int v278;
  int v279;
  unsigned int v280;
  float v281;
  float v282;
  float v283;
  float v284;
  float v285;
  float v286;
  float v287;
  float v288;
  float v289;
  float v290;
  float v291;
  float v292;
  float v293;
  float v294;
  float v295;
  unsigned int v296;
  float v297;
  float v298;
  float v299;
  float v300;
  int v301;
  uint64_t v302;
  unint64_t v303;
  int v304;
  unint64_t v305;
  unsigned int v306;
  int v307;
  unsigned int v308;
  float v309;
  float v310;
  float v311;
  float v312;
  float v313;
  float v314;
  float v315;
  float v316;
  float v317;
  float v318;
  unsigned int v319;
  float v320;
  float v321;
  float v322;
  int v323;
  uint64_t v324;
  int v325;
  int32x4_t v326;
  unint64_t v327;
  unsigned int v328;
  int v329;
  unsigned int v330;
  float v331;
  float v332;
  float v333;
  unsigned int v334;
  int v335;
  int v336;
  uint64_t v337;
  float32x4_t v338;
  float32x4_t v339;
  unint64_t v340;
  unsigned int v341;
  int v342;
  unsigned int v343;
  unsigned int v344;
  int v345;
  unint64_t v346;
  __int32 v347;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 136);
  v6 = *(float **)(a1 + 96);
  if (v6)
    v7 = *v6;
  else
    v7 = 1.0;
  v9 = *(int *)(a1 + 12);
  v8 = *(int *)(a1 + 16);
  if (v4)
  {
    v10 = (unint64_t)*(int *)(a1 + 32) >> 2;
    v11 = (float *)(v4 + 4 * (v9 + v10 * v8));
    v12 = 1;
    if (!v5)
      return;
  }
  else
  {
    v11 = 0;
    v10 = 0;
    v12 = 0;
    if (!v5)
      return;
  }
  v13 = *(_DWORD *)(a1 + 4);
  v14 = v10 - v13;
  if (v4)
    v15 = v10 - v13;
  else
    v15 = v10;
  v16 = *(_DWORD *)(a1 + 8);
  v17 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v3.i32[0] = **(_DWORD **)(a1 + 88);
  v18 = (float *)(*(_QWORD *)(a1 + 40) + 4 * (v9 + v17 * v8));
  v19 = *(int *)(a1 + 124);
  v20 = v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v19;
  v21 = v19 - v13;
  v22 = v17 - v13;
  v347 = v3.i32[0];
  v346 = v22;
  v23 = v21;
  v24 = v13;
  v25 = v15;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        v26 = 4 * v12;
        do
        {
          v27 = v13;
          do
          {
            v28 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              if (v28 == 255)
              {
                *v11 = 0.0;
                *v18 = 0.0;
              }
              else
              {
                v29 = (float)(v28 ^ 0xFFu) * 0.0039216;
                *v18 = v29 * *v18;
                *v11 = v29 * *v11;
              }
            }
            ++v20;
            ++v18;
            v11 = (float *)((char *)v11 + v26);
            --v27;
          }
          while (v27);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v247 = v13;
          do
          {
            v248 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              v249 = 0.0;
              if (v248 != 255)
                v249 = (float)((float)(v248 ^ 0xFFu) * 0.0039216) * *v18;
              *v18 = v249;
            }
            ++v20;
            ++v18;
            --v247;
          }
          while (v247);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 1:
      v30 = v20 & 3;
      if (!v4)
      {
        v250 = -1 << (8 * v30);
        if ((v20 & 3) != 0)
          v251 = v20 & 0xFC;
        else
          v251 = v20;
        if ((v20 & 3) != 0)
        {
          v252 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v250 = -1;
          v252 = (unsigned int *)v20;
        }
        if ((v20 & 3) != 0)
          v253 = &v18[-(v20 & 3)];
        else
          v253 = v18;
        if ((v20 & 3) != 0)
          v254 = v30 + v13;
        else
          v254 = v13;
        if ((((_BYTE)v254 + v251) & 3) != 0)
        {
          v255 = 4 - (((_BYTE)v254 + v251) & 3);
          v30 += v255;
          v256 = 0xFFFFFFFF >> (8 * v255);
          if (v254 >= 4)
            v257 = v256;
          else
            v257 = 0;
          if (v254 >= 4)
            v256 = -1;
          v250 &= v256;
        }
        else
        {
          v257 = 0;
        }
        v324 = v21 - v30;
        v325 = v254 >> 2;
        v326 = vdupq_lane_s32(v3, 0);
        v327 = v22 - v30;
        while (1)
        {
          v328 = *v252 & v250;
          v329 = v325;
          v330 = v257;
          if (!v328)
            goto LABEL_554;
LABEL_536:
          if (v328 == -1)
          {
            *(int32x4_t *)v253 = v326;
            goto LABEL_554;
          }
          while (1)
          {
            if ((_BYTE)v328)
            {
              v331 = *(float *)v3.i32;
              if (v328 != 255)
                v331 = (float)(*(float *)v3.i32 * (float)((float)v328 * 0.0039216))
                     + (float)(*v253 * (float)(1.0 - (float)((float)v328 * 0.0039216)));
              *v253 = v331;
            }
            if (BYTE1(v328))
            {
              v332 = *(float *)v3.i32;
              if (BYTE1(v328) != 255)
                v332 = (float)(*(float *)v3.i32 * (float)((float)BYTE1(v328) * 0.0039216))
                     + (float)(v253[1] * (float)(1.0 - (float)((float)BYTE1(v328) * 0.0039216)));
              v253[1] = v332;
            }
            if (BYTE2(v328))
            {
              v333 = *(float *)v3.i32;
              if (BYTE2(v328) != 255)
                v333 = (float)(*(float *)v3.i32 * (float)((float)BYTE2(v328) * 0.0039216))
                     + (float)(v253[2] * (float)(1.0 - (float)((float)BYTE2(v328) * 0.0039216)));
              v253[2] = v333;
            }
            v334 = HIBYTE(v328);
            if (v334 == 255)
            {
              v253[3] = *(float *)v3.i32;
            }
            else if (v334)
            {
              v253[3] = (float)(*(float *)v3.i32 * (float)((float)v334 * 0.0039216))
                      + (float)(v253[3] * (float)(1.0 - (float)((float)v334 * 0.0039216)));
            }
LABEL_554:
            while (1)
            {
              v335 = v329;
              v253 += 4;
              --v329;
              ++v252;
              if (v335 < 2)
                break;
              v328 = *v252;
              if (*v252)
                goto LABEL_536;
            }
            if (!v330)
              break;
            v330 = 0;
            v328 = *v252 & v257;
          }
          v252 = (unsigned int *)((char *)v252 + v324);
          v253 += v327;
          if (!--v16)
            return;
        }
      }
      v31 = -1 << (8 * v30);
      v32 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      v33 = 4 * (v20 & 3);
      v34 = &v18[v33 / 0xFFFFFFFFFFFFFFFCLL];
      v35 = &v11[v33 / 0xFFFFFFFFFFFFFFFCLL];
      if ((v20 & 3) != 0)
        v36 = v20 & 0xFC;
      else
        v36 = v20;
      if ((v20 & 3) != 0)
      {
        v37 = v30 + v13;
      }
      else
      {
        v31 = -1;
        v32 = (unsigned int *)v20;
        v35 = v11;
        v34 = v18;
        v37 = v13;
      }
      if ((((_BYTE)v37 + v36) & 3) != 0)
      {
        v38 = 4 - (((_BYTE)v37 + v36) & 3);
        v30 += v38;
        v39 = 0xFFFFFFFF >> (8 * v38);
        if (v37 >= 4)
          v40 = v39;
        else
          v40 = 0;
        if (v37 >= 4)
          v39 = -1;
        v31 &= v39;
      }
      else
      {
        v40 = 0;
      }
      v274 = v21 - v30;
      v275 = v22 - v30;
      v276 = v37 >> 2;
      v277 = v14 - v30;
      do
      {
        v278 = *v32 & v31;
        v279 = v276;
        v280 = v40;
        if (!v278)
          goto LABEL_505;
LABEL_484:
        if (v278 == -1)
        {
          *v34 = *(float *)v3.i32;
          *v35 = v7;
          v34[1] = *(float *)v3.i32;
          v35[1] = v7;
          v34[2] = *(float *)v3.i32;
          v35[2] = v7;
LABEL_502:
          v34[3] = *(float *)v3.i32;
          v35[3] = v7;
          goto LABEL_505;
        }
        while (1)
        {
          if ((_BYTE)v278)
          {
            if (v278 == 255)
            {
              *v34 = *(float *)v3.i32;
              v281 = v7;
            }
            else
            {
              v282 = (float)v278 * 0.0039216;
              v283 = *(float *)v3.i32 * v282;
              v284 = v7 * v282;
              v285 = 1.0 - v282;
              *v34 = v283 + (float)(*v34 * v285);
              v281 = v284 + (float)(*v35 * v285);
            }
            *v35 = v281;
          }
          if (BYTE1(v278))
          {
            if (BYTE1(v278) == 255)
            {
              v34[1] = *(float *)v3.i32;
              v286 = v7;
            }
            else
            {
              v287 = (float)BYTE1(v278) * 0.0039216;
              v288 = *(float *)v3.i32 * v287;
              v289 = v7 * v287;
              v290 = 1.0 - v287;
              v34[1] = v288 + (float)(v34[1] * v290);
              v286 = v289 + (float)(v35[1] * v290);
            }
            v35[1] = v286;
          }
          if (BYTE2(v278))
          {
            if (BYTE2(v278) == 255)
            {
              v34[2] = *(float *)v3.i32;
              v291 = v7;
            }
            else
            {
              v292 = (float)BYTE2(v278) * 0.0039216;
              v293 = *(float *)v3.i32 * v292;
              v294 = v7 * v292;
              v295 = 1.0 - v292;
              v34[2] = v293 + (float)(v34[2] * v295);
              v291 = v294 + (float)(v35[2] * v295);
            }
            v35[2] = v291;
          }
          v296 = HIBYTE(v278);
          if (v296 == 255)
            goto LABEL_502;
          if (v296)
          {
            v297 = (float)v296 * 0.0039216;
            v298 = *(float *)v3.i32 * v297;
            v299 = v7 * v297;
            v300 = 1.0 - v297;
            v34[3] = v298 + (float)(v34[3] * v300);
            v35[3] = v299 + (float)(v35[3] * v300);
          }
LABEL_505:
          while (1)
          {
            v301 = v279;
            v34 += 4;
            v35 += 4;
            --v279;
            ++v32;
            if (v301 < 2)
              break;
            v278 = *v32;
            if (*v32)
              goto LABEL_484;
          }
          if (!v280)
            break;
          v280 = 0;
          v278 = *v32 & v40;
        }
        v32 = (unsigned int *)((char *)v32 + v274);
        v34 += v275;
        v35 += v277;
        --v16;
      }
      while (v16);
      return;
    case 2:
      *(float *)&a3 = 1.0 - v7;
      v41 = v20 & 3;
      if (v4)
      {
        v42 = -1 << (8 * v41);
        v43 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
        v44 = 4 * (v20 & 3);
        v45 = &v18[v44 / 0xFFFFFFFFFFFFFFFCLL];
        v46 = &v11[v44 / 0xFFFFFFFFFFFFFFFCLL];
        if ((v20 & 3) != 0)
          v47 = v20 & 0xFC;
        else
          v47 = v20;
        if ((v20 & 3) != 0)
        {
          v48 = v41 + v13;
        }
        else
        {
          v42 = -1;
          v43 = (unsigned int *)v20;
          v46 = v11;
          v45 = v18;
          v48 = v13;
        }
        if ((((_BYTE)v48 + v47) & 3) != 0)
        {
          v49 = 4 - (((_BYTE)v48 + v47) & 3);
          v41 += v49;
          v50 = 0xFFFFFFFF >> (8 * v49);
          if (v48 >= 4)
            v51 = v50;
          else
            v51 = 0;
          if (v48 >= 4)
            v50 = -1;
          v42 &= v50;
        }
        else
        {
          v51 = 0;
        }
        v302 = v21 - v41;
        v303 = v22 - v41;
        v304 = v48 >> 2;
        v305 = v14 - v41;
        while (1)
        {
          v306 = *v43 & v42;
          v307 = v304;
          v308 = v51;
          if (!v306)
            goto LABEL_526;
LABEL_515:
          if (v306 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v306)
            {
              v310 = (float)v306 * 0.0039216;
              v311 = *(float *)v3.i32 * v310;
              v312 = v7 * v310;
              *v45 = v311 + (float)(*v45 * (float)(1.0 - v312));
              *v46 = v312 + (float)(*v46 * (float)(1.0 - v312));
            }
            if ((v306 & 0xFF00) != 0)
            {
              v313 = (float)BYTE1(v306) * 0.0039216;
              v314 = *(float *)v3.i32 * v313;
              v315 = v7 * v313;
              v45[1] = v314 + (float)(v45[1] * (float)(1.0 - v315));
              v46[1] = v315 + (float)(v46[1] * (float)(1.0 - v315));
            }
            if ((v306 & 0xFF0000) != 0)
            {
              v316 = (float)BYTE2(v306) * 0.0039216;
              v317 = *(float *)v3.i32 * v316;
              v318 = v7 * v316;
              v45[2] = v317 + (float)(v45[2] * (float)(1.0 - v318));
              v46[2] = v318 + (float)(v46[2] * (float)(1.0 - v318));
            }
            v319 = HIBYTE(v306);
            if (v319)
            {
              v320 = (float)v319 * 0.0039216;
              v321 = *(float *)v3.i32 * v320;
              v322 = v7 * v320;
              v45[3] = v321 + (float)(v45[3] * (float)(1.0 - v322));
              v309 = v322 + (float)(v46[3] * (float)(1.0 - v322));
              goto LABEL_525;
            }
LABEL_526:
            while (1)
            {
              v323 = v307;
              v45 += 4;
              v46 += 4;
              --v307;
              ++v43;
              if (v323 < 2)
                break;
              v306 = *v43;
              if (*v43)
                goto LABEL_515;
            }
            if (!v308)
              break;
            v308 = 0;
            v306 = *v43 & v51;
          }
          v43 = (unsigned int *)((char *)v43 + v302);
          v45 += v303;
          v46 += v305;
          if (!--v16)
            return;
        }
        *v45 = *(float *)v3.i32 + (float)(*v45 * *(float *)&a3);
        *v46 = v7 + (float)(*v46 * *(float *)&a3);
        v45[1] = *(float *)v3.i32 + (float)(v45[1] * *(float *)&a3);
        v46[1] = v7 + (float)(v46[1] * *(float *)&a3);
        v45[2] = *(float *)v3.i32 + (float)(v45[2] * *(float *)&a3);
        v46[2] = v7 + (float)(v46[2] * *(float *)&a3);
        v45[3] = *(float *)v3.i32 + (float)(v45[3] * *(float *)&a3);
        v309 = v7 + (float)(v46[3] * *(float *)&a3);
LABEL_525:
        v46[3] = v309;
        goto LABEL_526;
      }
      v258 = v41 + v13;
      v259 = -1 << (8 * v41);
      if ((v20 & 3) != 0)
        v260 = v20 & 0xFC;
      else
        v260 = v20;
      if ((v20 & 3) != 0)
      {
        v261 = (unsigned int *)(v20 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v259 = -1;
        v261 = (unsigned int *)v20;
      }
      if ((v20 & 3) != 0)
        v262 = (float32x4_t *)&v18[-(v20 & 3)];
      else
        v262 = (float32x4_t *)v18;
      if ((v20 & 3) == 0)
        v258 = v13;
      if ((((_BYTE)v258 + v260) & 3) != 0)
      {
        v263 = 4 - (((_BYTE)v258 + v260) & 3);
        v41 += v263;
        v264 = 0xFFFFFFFF >> (8 * v263);
        if (v258 >= 4)
          v265 = v264;
        else
          v265 = 0;
        if (v258 >= 4)
          v264 = -1;
        v259 &= v264;
      }
      else
      {
        v265 = 0;
      }
      v336 = v258 >> 2;
      v337 = v21 - v41;
      v338 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&a3, 0);
      v339 = (float32x4_t)vdupq_lane_s32(v3, 0);
      v340 = v22 - v41;
      do
      {
        v341 = *v261 & v259;
        v342 = v336;
        v343 = v265;
        if (!v341)
          goto LABEL_574;
LABEL_564:
        if (v341 == -1)
        {
          *v262 = vmlaq_f32(v339, v338, *v262);
          goto LABEL_574;
        }
        while (1)
        {
          if ((_BYTE)v341)
            v262->f32[0] = (float)(*(float *)v3.i32 * (float)((float)v341 * 0.0039216))
                         + (float)(v262->f32[0]
                                 * (float)(1.0 - (float)(v7 * (float)((float)v341 * 0.0039216))));
          if ((v341 & 0xFF00) != 0)
            v262->f32[1] = (float)(*(float *)v3.i32 * (float)((float)BYTE1(v341) * 0.0039216))
                         + (float)(v262->f32[1] * (float)(1.0 - (float)(v7 * (float)((float)BYTE1(v341) * 0.0039216))));
          if ((v341 & 0xFF0000) != 0)
            v262->f32[2] = (float)(*(float *)v3.i32 * (float)((float)BYTE2(v341) * 0.0039216))
                         + (float)(v262->f32[2] * (float)(1.0 - (float)(v7 * (float)((float)BYTE2(v341) * 0.0039216))));
          v344 = HIBYTE(v341);
          if (v344)
            v262->f32[3] = (float)(*(float *)v3.i32 * (float)((float)v344 * 0.0039216))
                         + (float)(v262->f32[3] * (float)(1.0 - (float)(v7 * (float)((float)v344 * 0.0039216))));
LABEL_574:
          while (1)
          {
            v345 = v342;
            ++v262;
            --v342;
            ++v261;
            if (v345 < 2)
              break;
            v341 = *v261;
            if (*v261)
              goto LABEL_564;
          }
          if (!v343)
            break;
          v343 = 0;
          v341 = *v261 & v265;
        }
        v261 = (unsigned int *)((char *)v261 + v337);
        v262 = (float32x4_t *)((char *)v262 + 4 * v340);
        --v16;
      }
      while (v16);
      return;
    case 3:
      v52 = 4 * v12;
      do
      {
        v53 = v13;
        do
        {
          v54 = *(unsigned __int8 *)v20;
          if (*(_BYTE *)v20)
          {
            if (v54 == 255)
            {
              v55 = v7 * *v11;
              *v18 = *(float *)v3.i32 * *v11;
            }
            else
            {
              v56 = (float)v54 * 0.0039216;
              v57 = *v11;
              v58 = v56 * *v11;
              v59 = 1.0 - v56;
              *v18 = (float)(*(float *)v3.i32 * v58) + (float)(*v18 * v59);
              v55 = (float)(v7 * v58) + (float)(v57 * v59);
            }
            *v11 = v55;
          }
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v52);
          --v53;
        }
        while (v53);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 4:
      v60 = 4 * v12;
      do
      {
        v61 = v13;
        do
        {
          v62 = *(unsigned __int8 *)v20;
          if (*(_BYTE *)v20)
          {
            if (v62 == 255)
            {
              v63 = 1.0 - *v11;
              v64 = *(float *)v3.i32 * v63;
              v65 = v7 * v63;
              *v18 = v64;
            }
            else
            {
              v66 = (float)v62 * 0.0039216;
              v67 = *v11;
              v68 = v66 * (float)(1.0 - *v11);
              v69 = 1.0 - v66;
              *v18 = (float)(*(float *)v3.i32 * v68) + (float)(*v18 * v69);
              v65 = (float)(v7 * v68) + (float)(v67 * v69);
            }
            *v11 = v65;
          }
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v60);
          --v61;
        }
        while (v61);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 5:
      v70 = 4 * v12;
      do
      {
        v71 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v72 = *v11;
            v73 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v74 = *(float *)v3.i32 * v73;
            v75 = v7 * v73;
            *v18 = (float)((float)(1.0 - v75) * *v18) + (float)(v74 * *v11);
            *v11 = (float)((float)(1.0 - v75) * v72) + (float)(v75 * v72);
          }
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v70);
          --v71;
        }
        while (v71);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 6:
      v76 = 4 * v12;
      while (1)
      {
        v77 = v13;
        do
        {
          v78 = *(unsigned __int8 *)v20;
          if (!*(_BYTE *)v20)
            goto LABEL_85;
          v79 = *v11;
          v80 = 1.0 - *v11;
          if (v80 >= 1.0)
          {
            v83 = (float)v78 * 0.0039216;
            v84 = *(float *)v3.i32 * v83;
            v82 = v7 * v83;
            *v18 = v84;
          }
          else
          {
            if (v80 <= 0.0)
              goto LABEL_85;
            v81 = (float)v78 * 0.0039216;
            *v18 = *v18 + (float)((float)(*(float *)v3.i32 * v81) * v80);
            v82 = v79 + (float)((float)(v7 * v81) * v80);
          }
          *v11 = v82;
LABEL_85:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v76);
          --v77;
        }
        while (v77);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 7:
      if (v4)
      {
        v85 = 4 * v12;
        do
        {
          v86 = v13;
          do
          {
            v87 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              if (v87 == 255)
              {
                v88 = v7 * *v18;
                v89 = v7;
              }
              else
              {
                v89 = (float)(v7 * (float)((float)v87 * 0.0039216)) + (float)(1.0 - (float)((float)v87 * 0.0039216));
                v88 = v89 * *v18;
              }
              *v18 = v88;
              *v11 = v89 * *v11;
            }
            ++v20;
            ++v18;
            v11 = (float *)((char *)v11 + v85);
            --v86;
          }
          while (v86);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v266 = v13;
          do
          {
            v267 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              if (v267 == 255)
                v268 = v7 * *v18;
              else
                v268 = (float)((float)(v7 * (float)((float)v267 * 0.0039216))
                             + (float)(1.0 - (float)((float)v267 * 0.0039216)))
                     * *v18;
              *v18 = v268;
            }
            ++v20;
            ++v18;
            --v266;
          }
          while (v266);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 8:
      v90 = 1.0 - v7;
      if (v4)
      {
        v91 = 4 * v12;
        do
        {
          v92 = v13;
          do
          {
            v93 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              if (v93 == 255)
              {
                v94 = v90 * *v18;
                v95 = 1.0 - v7;
              }
              else
              {
                v95 = (float)(v7 * (float)((float)v93 * -0.0039216)) + 1.0;
                v94 = v95 * *v18;
              }
              *v18 = v94;
              *v11 = v95 * *v11;
            }
            ++v20;
            ++v18;
            v11 = (float *)((char *)v11 + v91);
            --v92;
          }
          while (v92);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v269 = v13;
          do
          {
            v270 = *(unsigned __int8 *)v20;
            if (*(_BYTE *)v20)
            {
              if (v270 == 255)
                v271 = v90 * *v18;
              else
                v271 = (float)((float)(v7 * (float)((float)v270 * -0.0039216)) + 1.0) * *v18;
              *v18 = v271;
            }
            ++v20;
            ++v18;
            --v269;
          }
          while (v269);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 9:
      v96 = 4 * v12;
      do
      {
        v97 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v98 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v99 = *v11;
            v100 = *(float *)v3.i32 * v98;
            v101 = v7 * v98;
            v102 = 1.0 - *v11;
            v103 = (float)(1.0 - v98) + (float)(v7 * v98);
            *v18 = (float)(v103 * *v18) + (float)(v100 * v102);
            *v11 = (float)(v103 * v99) + (float)(v101 * v102);
          }
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v96);
          --v97;
        }
        while (v97);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 10:
      v104 = 4 * v12;
      do
      {
        v105 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v106 = *v11;
            v107 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v108 = *(float *)v3.i32 * v107;
            v109 = v7 * v107;
            v110 = 1.0 - *v11;
            *v18 = (float)((float)(1.0 - v109) * *v18) + (float)(v108 * v110);
            *v11 = (float)((float)(1.0 - v109) * v106) + (float)(v109 * v110);
          }
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v104);
          --v105;
        }
        while (v105);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        --v16;
      }
      while (v16);
      return;
    case 11:
      if (v4)
      {
        v111 = 4 * v12;
        do
        {
          v112 = v13;
          do
          {
            if (*(_BYTE *)v20)
            {
              v113 = (float)*(unsigned __int8 *)v20 * 0.0039216;
              v114 = *(float *)v3.i32 * v113;
              v115 = v7 * v113;
              v116 = v115 + *v11;
              v117 = (float)(v115 - v114) + (float)(*v11 - *v18);
              if (v116 <= 1.0)
                v118 = v116;
              else
                v118 = 1.0;
              *v11 = v118;
              *v18 = v118 - v117;
            }
            ++v20;
            ++v18;
            v11 = (float *)((char *)v11 + v111);
            --v112;
          }
          while (v112);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v272 = v13;
          do
          {
            if (*(_BYTE *)v20)
              *v18 = 1.0
                   - (float)((float)((float)(v7 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216))
                                   - (float)(*(float *)v3.i32 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216)))
                           + (float)(1.0 - *v18));
            ++v20;
            ++v18;
            --v272;
          }
          while (v272);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 12:
      if (v4)
      {
        v119 = 4 * v12;
        do
        {
          v120 = v13;
          do
          {
            if (*(_BYTE *)v20)
            {
              v121 = (float)*(unsigned __int8 *)v20 * 0.0039216;
              v122 = *(float *)v3.i32 * v121;
              v123 = (float)(v7 * v121) + *v11;
              v124 = v122 + *v18;
              if (v123 > 1.0)
                v123 = 1.0;
              *v18 = v124;
              *v11 = v123;
            }
            ++v20;
            ++v18;
            v11 = (float *)((char *)v11 + v119);
            --v120;
          }
          while (v120);
          v20 += v21;
          v18 += v22;
          v11 += v15;
          --v16;
        }
        while (v16);
      }
      else
      {
        do
        {
          v273 = v13;
          do
          {
            if (*(_BYTE *)v20)
              *v18 = (float)(*(float *)v3.i32 * (float)((float)*(unsigned __int8 *)v20 * 0.0039216)) + *v18;
            ++v20;
            ++v18;
            --v273;
          }
          while (v273);
          v20 += v21;
          v18 += v22;
          --v16;
        }
        while (v16);
      }
      return;
    case 13:
      v125 = 4 * v12;
      while (1)
      {
        v126 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v127 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v128 = v7 * v127;
            if ((float)(v7 * v127) > 0.0)
            {
              v129 = *(float *)v3.i32 * v127;
              if (v4)
              {
                v130 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_159;
              }
              else
              {
                v130 = 1.0;
              }
              v131 = (float)(v129 * *v18) + (float)(*v18 * (float)(1.0 - v128));
              if (v128 == 1.0)
                v131 = v129 * *v18;
              v129 = v131 + (float)(v129 * (float)(1.0 - v130));
              if (v130 == 1.0)
                v129 = v131;
              if (v4)
              {
                v128 = (float)(v128 + v130) - (float)(v130 * v128);
LABEL_159:
                *v18 = v129;
                *v11 = v128;
                goto LABEL_161;
              }
              *v18 = v129;
            }
          }
LABEL_161:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v125);
          --v126;
        }
        while (v126);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 14:
      v132 = 4 * v12;
      while (1)
      {
        v133 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v134 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v135 = v7 * v134;
            if ((float)(v7 * v134) > 0.0)
            {
              v136 = *(float *)v3.i32 * v134;
              if (v4)
              {
                v137 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_174;
              }
              else
              {
                v137 = 1.0;
              }
              v136 = *v18 + (float)(v136 * (float)(1.0 - *v18));
              if (v4)
              {
                v135 = (float)(v135 + v137) - (float)(v137 * v135);
LABEL_174:
                *v18 = v136;
                *v11 = v135;
                goto LABEL_176;
              }
              *v18 = v136;
            }
          }
LABEL_176:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v132);
          --v133;
        }
        while (v133);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 15:
      v138 = 4 * v12;
      while (1)
      {
        v139 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v140 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v141 = v7 * v140;
            if ((float)(v7 * v140) > 0.0)
            {
              v142 = *(float *)v3.i32 * v140;
              if (v4)
              {
                v143 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_189;
              }
              else
              {
                v143 = 1.0;
              }
              v144 = PDAoverlayPDA(*v18, v143, v142, v141);
              v142 = v144;
              if (v4)
              {
                v141 = v145;
                v3.i32[0] = v347;
LABEL_189:
                *v18 = v142;
                *v11 = v141;
                goto LABEL_191;
              }
              *v18 = v144;
              v3.i32[0] = v347;
            }
          }
LABEL_191:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v138);
          --v139;
        }
        while (v139);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        v13 = v24;
        if (!v16)
          return;
      }
    case 16:
      v146 = 4 * v12;
      while (1)
      {
        v147 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v148 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v149 = v7 * v148;
            if ((float)(v7 * v148) > 0.0)
            {
              v150 = *(float *)v3.i32 * v148;
              if (v4)
              {
                v151 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_210;
              }
              else
              {
                v151 = 1.0;
              }
              v152 = v149 * *v18;
              if ((float)(v150 * v151) < v152)
                v152 = v150 * v151;
              v153 = v152 + (float)(*v18 * (float)(1.0 - v149));
              if (v149 == 1.0)
                v153 = v152;
              v150 = v153 + (float)(v150 * (float)(1.0 - v151));
              if (v151 == 1.0)
                v150 = v153;
              if (v4)
              {
                v149 = (float)(v149 + v151) - (float)(v151 * v149);
LABEL_210:
                *v18 = v150;
                *v11 = v149;
                goto LABEL_212;
              }
              *v18 = v150;
            }
          }
LABEL_212:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v146);
          --v147;
        }
        while (v147);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 17:
      v154 = 4 * v12;
      while (1)
      {
        v155 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v156 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v157 = v7 * v156;
            if ((float)(v7 * v156) > 0.0)
            {
              v158 = *(float *)v3.i32 * v156;
              if (v4)
              {
                v159 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_231;
              }
              else
              {
                v159 = 1.0;
              }
              v160 = v157 * *v18;
              if ((float)(v158 * v159) > v160)
                v160 = v158 * v159;
              v161 = v160 + (float)(*v18 * (float)(1.0 - v157));
              if (v157 == 1.0)
                v161 = v160;
              v158 = v161 + (float)(v158 * (float)(1.0 - v159));
              if (v159 == 1.0)
                v158 = v161;
              if (v4)
              {
                v157 = (float)(v157 + v159) - (float)(v159 * v157);
LABEL_231:
                *v18 = v158;
                *v11 = v157;
                goto LABEL_233;
              }
              *v18 = v158;
            }
          }
LABEL_233:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v154);
          --v155;
        }
        while (v155);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 18:
      v162 = 4 * v12;
      while (1)
      {
        v163 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v164 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v165 = v7 * v164;
            if ((float)(v7 * v164) > 0.0)
            {
              v166 = *(float *)v3.i32 * v164;
              if (v4)
              {
                v167 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_246;
              }
              else
              {
                v167 = 1.0;
              }
              v168 = PDAcolordodgePDA(*v18, v167, v166, v165);
              v166 = v168;
              if (v4)
              {
                v165 = v169;
                v3.i32[0] = v347;
LABEL_246:
                *v18 = v166;
                *v11 = v165;
                goto LABEL_248;
              }
              *v18 = v168;
              v3.i32[0] = v347;
            }
          }
LABEL_248:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v162);
          --v163;
        }
        while (v163);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        v13 = v24;
        if (!v16)
          return;
      }
    case 19:
      v170 = 4 * v12;
      while (1)
      {
        v171 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v172 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v173 = v7 * v172;
            if ((float)(v7 * v172) > 0.0)
            {
              v174 = *(float *)v3.i32 * v172;
              if (v4)
              {
                v175 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_261;
              }
              else
              {
                v175 = 1.0;
              }
              v176 = PDAcolorburnPDA(*v18, v175, v174, v173);
              v174 = v176;
              if (v4)
              {
                v173 = v177;
                v3.i32[0] = v347;
LABEL_261:
                *v18 = v174;
                *v11 = v173;
                goto LABEL_263;
              }
              *v18 = v176;
              v3.i32[0] = v347;
            }
          }
LABEL_263:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v170);
          --v171;
        }
        while (v171);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        v13 = v24;
        if (!v16)
          return;
      }
    case 20:
      v178 = 4 * v12;
      while (1)
      {
        v179 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v180 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v181 = v7 * v180;
            if ((float)(v7 * v180) > 0.0)
            {
              v182 = *(float *)v3.i32 * v180;
              if (v4)
              {
                v183 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_276;
              }
              else
              {
                v183 = 1.0;
              }
              v184 = PDAsoftlightPDA(*v18, v183, v182, v181);
              v182 = v184;
              if (v4)
              {
                v181 = v185;
                v3.i32[0] = v347;
LABEL_276:
                *v18 = v182;
                *v11 = v181;
                goto LABEL_278;
              }
              *v18 = v184;
              v3.i32[0] = v347;
            }
          }
LABEL_278:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v178);
          --v179;
        }
        while (v179);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        v13 = v24;
        if (!v16)
          return;
      }
    case 21:
      v186 = 4 * v12;
      while (1)
      {
        v187 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v188 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v189 = v7 * v188;
            if ((float)(v7 * v188) > 0.0)
            {
              v190 = *(float *)v3.i32 * v188;
              if (v4)
              {
                v191 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_291;
              }
              else
              {
                v191 = 1.0;
              }
              v192 = PDAhardlightPDA(*v18, v191, v190, v189);
              v190 = v192;
              if (v4)
              {
                v189 = v193;
                v3.i32[0] = v347;
LABEL_291:
                *v18 = v190;
                *v11 = v189;
                goto LABEL_293;
              }
              *v18 = v192;
              v3.i32[0] = v347;
            }
          }
LABEL_293:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v186);
          --v187;
        }
        while (v187);
        v20 += v23;
        v18 += v346;
        v11 += v25;
        --v16;
        v13 = v24;
        if (!v16)
          return;
      }
    case 22:
      v194 = 4 * v12;
      while (1)
      {
        v195 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v196 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v197 = v7 * v196;
            if ((float)(v7 * v196) > 0.0)
            {
              v198 = *(float *)v3.i32 * v196;
              if (v4)
              {
                v199 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_308;
              }
              else
              {
                v199 = 1.0;
              }
              v200 = v198 + *v18;
              v201 = v197 * *v18;
              v202 = v198 * v199;
              v203 = v200 - v201;
              v204 = v201 - v202;
              v205 = v203 - v202;
              if (v204 < 0.0)
                v204 = -v204;
              v198 = v205 + v204;
              if (v4)
              {
                v197 = (float)(v197 + v199) - (float)(v199 * v197);
LABEL_308:
                *v18 = v198;
                *v11 = v197;
                goto LABEL_310;
              }
              *v18 = v198;
            }
          }
LABEL_310:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v194);
          --v195;
        }
        while (v195);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 23:
      v206 = 4 * v12;
      while (1)
      {
        v207 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v208 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v209 = v7 * v208;
            if ((float)(v7 * v208) > 0.0)
            {
              v210 = *(float *)v3.i32 * v208;
              if (v4)
              {
                v211 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_323;
              }
              else
              {
                v211 = 1.0;
              }
              v210 = (float)(v210 + *v18) + (float)((float)(v210 * *v18) * -2.0);
              if (v4)
              {
                v209 = (float)(v209 + v211) - (float)(v211 * v209);
LABEL_323:
                *v18 = v210;
                *v11 = v209;
                goto LABEL_325;
              }
              *v18 = v210;
            }
          }
LABEL_325:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v206);
          --v207;
        }
        while (v207);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 24:
      v212 = 4 * v12;
      while (1)
      {
        v213 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v214 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v215 = v7 * v214;
            if ((float)(v7 * v214) > 0.0)
            {
              v216 = *(float *)v3.i32 * v214;
              if (v4)
              {
                v217 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_343;
              }
              else
              {
                v217 = 1.0;
              }
              v218 = *v18;
              if (v215 == 1.0)
              {
                v219 = 0.0;
              }
              else
              {
                v218 = v215 * *v18;
                v219 = *v18 - v218;
              }
              v220 = (float)(v216 + v219) - (float)(v216 * v217);
              if (v217 == 1.0)
                v220 = v219;
              v216 = v218 + v220;
              if (v4)
              {
                v215 = (float)(v215 + v217) - (float)(v215 * v217);
LABEL_343:
                *v18 = v216;
                *v11 = v215;
                goto LABEL_345;
              }
              *v18 = v216;
            }
          }
LABEL_345:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v212);
          --v213;
        }
        while (v213);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 25:
      v221 = 4 * v12;
      while (1)
      {
        v222 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v223 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v224 = v7 * v223;
            if ((float)(v7 * v223) > 0.0)
            {
              v225 = *(float *)v3.i32 * v223;
              if (v4)
              {
                v226 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_363;
              }
              else
              {
                v226 = 1.0;
              }
              v227 = *v18;
              if (v224 == 1.0)
              {
                v228 = 0.0;
              }
              else
              {
                v227 = v224 * *v18;
                v228 = *v18 - v227;
              }
              v229 = (float)(v225 + v228) - (float)(v225 * v226);
              if (v226 == 1.0)
                v229 = v228;
              v225 = v227 + v229;
              if (v4)
              {
                v224 = (float)(v224 + v226) - (float)(v224 * v226);
LABEL_363:
                *v18 = v225;
                *v11 = v224;
                goto LABEL_365;
              }
              *v18 = v225;
            }
          }
LABEL_365:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v221);
          --v222;
        }
        while (v222);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 26:
      v230 = 4 * v12;
      while (1)
      {
        v231 = v13;
        do
        {
          if (*(_BYTE *)v20)
          {
            v232 = (float)*(unsigned __int8 *)v20 * 0.0039216;
            v233 = v7 * v232;
            if ((float)(v7 * v232) > 0.0)
            {
              v234 = *(float *)v3.i32 * v232;
              if (v4)
              {
                v235 = *v11;
                if (*v11 <= 0.0)
                  goto LABEL_382;
              }
              else
              {
                v235 = 1.0;
              }
              v236 = *v18;
              v237 = v234 - (float)(v234 * v235);
              if (v235 == 1.0)
                v237 = 0.0;
              v238 = (float)(v236 + v237) - (float)(v233 * v236);
              if (v233 != 1.0)
              {
                v236 = v233 * v236;
                v237 = v238;
              }
              v234 = v236 + v237;
              if (v4)
              {
                v233 = (float)(v233 + v235) - (float)(v233 * v235);
LABEL_382:
                *v18 = v234;
                *v11 = v233;
                goto LABEL_384;
              }
              *v18 = v234;
            }
          }
LABEL_384:
          ++v20;
          ++v18;
          v11 = (float *)((char *)v11 + v230);
          --v231;
        }
        while (v231);
        v20 += v21;
        v18 += v22;
        v11 += v15;
        if (!--v16)
          return;
      }
    case 27:
      v239 = 4 * v12;
      break;
    default:
      return;
  }
  do
  {
    v240 = v13;
    do
    {
      if (*(_BYTE *)v20)
      {
        v241 = (float)*(unsigned __int8 *)v20 * 0.0039216;
        v242 = v7 * v241;
        if ((float)(v7 * v241) > 0.0)
        {
          v243 = *(float *)v3.i32 * v241;
          if (v4)
          {
            v244 = *v11;
            if (*v11 <= 0.0)
              goto LABEL_401;
          }
          else
          {
            v244 = 1.0;
          }
          v245 = *v18 - (float)(v242 * *v18);
          if (v242 == 1.0)
            v245 = 0.0;
          v246 = (float)(v243 + v245) - (float)(v243 * v244);
          if (v244 != 1.0)
          {
            v243 = v243 * v244;
            v245 = v246;
          }
          v243 = v243 + v245;
          if (v4)
          {
            v242 = (float)(v242 + v244) - (float)(v242 * v244);
LABEL_401:
            *v18 = v243;
            *v11 = v242;
            goto LABEL_403;
          }
          *v18 = v243;
        }
      }
LABEL_403:
      ++v20;
      ++v18;
      v11 = (float *)((char *)v11 + v239);
      --v240;
    }
    while (v240);
    v20 += v21;
    v18 += v22;
    v11 += v15;
    --v16;
  }
  while (v16);
}

void Wf_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  float *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  float *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  char *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  unsigned int v35;
  float v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  float *v41;
  uint64_t v42;
  int v43;
  unsigned int v44;
  float v45;
  float v46;
  char *v47;
  float *v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  float *v58;
  int v59;
  unsigned int v60;
  float v61;
  float v62;
  float v63;
  char *v64;
  float *v65;
  uint64_t v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  float *v76;
  int v77;
  unsigned int v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  char *v86;
  float *v87;
  uint64_t v88;
  char *v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  float *v98;
  int v99;
  unsigned int v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float v107;
  char *v108;
  float *v109;
  uint64_t v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  float *v120;
  int v121;
  float v122;
  float v123;
  float v124;
  float v125;
  char *v126;
  float *v127;
  uint64_t v128;
  char *v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  float *v138;
  int v139;
  unsigned int v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  float v146;
  float v147;
  char *v148;
  float *v149;
  uint64_t v150;
  char *v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  float *v159;
  int v160;
  unsigned int v161;
  float v162;
  float v163;
  float v164;
  char *v165;
  float *v166;
  uint64_t v167;
  char *v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  float *v176;
  int v177;
  unsigned int v178;
  float v179;
  float v180;
  char *v181;
  float *v182;
  uint64_t v183;
  char *v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  float *v193;
  int v194;
  float v195;
  float v196;
  float v197;
  float v198;
  float v199;
  float v200;
  char *v201;
  float *v202;
  uint64_t v203;
  char *v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  float *v213;
  int v214;
  float v215;
  float v216;
  float v217;
  float v218;
  float v219;
  char *v220;
  float *v221;
  uint64_t v222;
  char *v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  uint64_t v230;
  float *v231;
  int v232;
  float v233;
  float v234;
  float v235;
  float v236;
  float v237;
  float v238;
  char *v239;
  float *v240;
  uint64_t v241;
  char *v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  uint64_t v246;
  uint64_t v247;
  uint64_t v248;
  uint64_t v249;
  float *v250;
  int v251;
  float v252;
  float v253;
  float v254;
  char *v255;
  float *v256;
  uint64_t v257;
  char *v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  uint64_t v265;
  uint64_t v266;
  float *v267;
  int v268;
  float v269;
  float v270;
  float v271;
  float v272;
  float v273;
  float v274;
  char *v275;
  float *v276;
  uint64_t v277;
  char *v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  float *v287;
  int v288;
  float v289;
  float v290;
  float v291;
  float v292;
  float v293;
  char *v294;
  float *v295;
  uint64_t v296;
  char *v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  float *v303;
  int v304;
  int v305;
  float v306;
  float v307;
  float v308;
  float v309;
  float v310;
  float v311;
  float v312;
  char *v313;
  uint64_t v314;
  char *v315;
  int v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  unint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  float *v327;
  int v328;
  float v329;
  float v330;
  float v331;
  float v332;
  float v333;
  float v334;
  float v335;
  char *v336;
  float *v337;
  uint64_t v338;
  char *v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  float *v348;
  int v349;
  float v350;
  float v351;
  float v352;
  float v353;
  float v354;
  float v355;
  float v356;
  char *v357;
  float *v358;
  uint64_t v359;
  char *v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  float *v366;
  int v367;
  int v368;
  float v369;
  float v370;
  float v371;
  float v372;
  float v373;
  float v374;
  float v375;
  char *v376;
  uint64_t v377;
  char *v378;
  int v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t v382;
  unint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  float *v387;
  int v388;
  int v389;
  float v390;
  float v391;
  float v392;
  float v393;
  float v394;
  float v395;
  float v396;
  char *v397;
  uint64_t v398;
  char *v399;
  int v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  unint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  float *v408;
  int v409;
  int v410;
  float v411;
  float v412;
  float v413;
  float v414;
  float v415;
  float v416;
  float v417;
  char *v418;
  uint64_t v419;
  char *v420;
  int v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  unint64_t v425;
  uint64_t v426;
  uint64_t v427;
  uint64_t v428;
  float *v429;
  int v430;
  int v431;
  float v432;
  float v433;
  float v434;
  float v435;
  float v436;
  float v437;
  float v438;
  char *v439;
  uint64_t v440;
  char *v441;
  int v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  unint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  float *v453;
  int v454;
  float v455;
  float v456;
  float v457;
  float v458;
  float v459;
  float v460;
  float v461;
  float v462;
  float v463;
  float v464;
  float v465;
  char *v466;
  float *v467;
  uint64_t v468;
  char *v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  float *v478;
  int v479;
  float v480;
  float v481;
  float v482;
  float v483;
  float v484;
  char *v485;
  float *v486;
  uint64_t v487;
  char *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  float *v497;
  int v498;
  float v499;
  float v500;
  float v501;
  float v502;
  float v503;
  float v504;
  float v505;
  float v506;
  char *v507;
  float *v508;
  uint64_t v509;
  char *v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  float *v519;
  int v520;
  float v521;
  float v522;
  float v523;
  float v524;
  float v525;
  float v526;
  float v527;
  float v528;
  char *v529;
  float *v530;
  uint64_t v531;
  char *v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  float *v541;
  int v542;
  float v543;
  float v544;
  float v545;
  float v546;
  float v547;
  float v548;
  float v549;
  float v550;
  char *v551;
  float *v552;
  uint64_t v553;
  char *v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  float *v563;
  int v564;
  float v565;
  float v566;
  float v567;
  float v568;
  float v569;
  float v570;
  float v571;
  char *v572;
  float *v573;
  uint64_t v574;
  char *v575;
  uint64_t v576;
  uint64_t v577;
  int v578;
  unsigned int v579;
  float v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  int v585;
  unsigned int v586;
  float v587;
  char *v588;
  uint64_t v589;
  char *v590;
  char *v591;
  uint64_t v592;
  char *v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  float *v599;
  int v600;
  unsigned int v601;
  float v602;
  float v603;
  float v604;
  float v605;
  char *v606;
  float *v607;
  uint64_t v608;
  char *v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  uint64_t v614;
  uint64_t v615;
  float *v616;
  int v617;
  unsigned int v618;
  float v619;
  char *v620;
  float *v621;
  uint64_t v622;
  char *v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  float *v630;
  int v631;
  unsigned int v632;
  float v633;
  char *v634;
  float *v635;
  uint64_t v636;
  char *v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  float *v644;
  int v645;
  float v646;
  char *v647;
  float *v648;
  uint64_t v649;
  char *v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  int v655;
  char *v656;
  uint64_t v657;
  char *v658;
  char *v659;
  uint64_t v660;
  char *v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  int v665;
  unsigned int v666;
  float v667;
  float v668;
  char *v669;
  uint64_t v670;
  char *v671;
  char *v672;
  uint64_t v673;
  char *v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  unint64_t v686;
  uint64_t v687;
  uint64_t v688;
  int v689;
  unint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  uint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  int v706;
  int v707;
  int v708;
  int v709;
  int v710;
  unint64_t v711;
  char *v712;
  int v713;
  int v714;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 136);
  v5 = *(int *)(a1 + 12);
  v4 = *(int *)(a1 + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(a1 + 32) >> 2;
    v7 = (float *)(v2 + 4 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return;
  }
  v10 = *(_DWORD *)(a1 + 4);
  v9 = *(_DWORD *)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 88);
  v11 = *(_QWORD *)(a1 + 96);
  v13 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v14 = (float *)(*(_QWORD *)(a1 + 40) + 4 * (v5 + v13 * v4));
  v15 = *(int *)(a1 + 124);
  v16 = (_BYTE *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(a1 + 56);
  v18 = *(int *)(a1 + 60);
  v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) == 0x100)
  {
    v20 = v19 >> 2;
    if (v11)
    {
      v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
      v11 += 4 * (v17 + v21 * v18);
      v713 = -1;
    }
    else
    {
      v21 = 0;
      v713 = 0;
    }
    v24 = (char *)(v12 + 4 * (v17 + v20 * v18));
    if (v20 == v13 && (char *)v14 - v24 >= 1)
    {
      if (v10 >= (uint64_t)((unint64_t)((char *)v14 - v24) >> 2))
      {
        v14 += v10 - 1;
        v24 += 4 * v10 - 4;
        v16 += v10 - 1;
        v7 += v8 & (v10 - 1);
        v26 = -1;
        v20 = (unint64_t)*(int *)(a1 + 28) >> 2;
        v11 += 4 * (v713 & (v10 - 1));
        goto LABEL_16;
      }
      v25 = v9 - 1;
      if (v14 <= (float *)&v24[4 * v13 * v25 - 4 + 4 * v10])
      {
        v14 += v13 * v25;
        v20 = -(uint64_t)v13;
        v16 += v15 * v25;
        v15 = -v15;
        v7 += v6 * v25;
        v6 = -(uint64_t)v6;
        v8 &= 1u;
        v11 += 4 * v21 * v25;
        v21 = -(uint64_t)v21;
        v713 &= 1u;
        v26 = 1;
        v24 += 4 * v13 * v25;
        v13 = -(uint64_t)v13;
        goto LABEL_16;
      }
    }
    v8 &= 1u;
    v713 &= 1u;
    v26 = 1;
LABEL_16:
    v27 = 0;
    v712 = 0;
    v12 = -1;
    v23 = v21;
    v22 = v20;
    goto LABEL_19;
  }
  v22 = *(_DWORD *)(a1 + 64);
  v23 = *(_DWORD *)(a1 + 68);
  v20 = v19 >> 2;
  if (v11)
  {
    v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
    v713 = 1;
  }
  else
  {
    v21 = 0;
    v713 = 0;
  }
  v27 = v12 + 4 * v20 * v23;
  v8 &= 1u;
  v26 = 1;
  v712 = *(char **)(a1 + 88);
  v24 = v712;
LABEL_19:
  v714 = v8;
  v28 = v26 * v10;
  if (v27)
  {
    v29 = (int)v18 % v23;
    v30 = &v24[4 * v20 * v29];
    v31 = (int)v17 % v22;
    v24 = &v30[4 * v31];
    v12 = (unint64_t)&v30[4 * v22];
    if ((v713 & 1) != 0)
      v11 += 4 * v21 * v29 + 4 * v31;
    v712 = &v30[4 * v31];
  }
  else
  {
    v20 -= v28;
    v21 -= v713 * v10;
  }
  v32 = v15 - v28;
  v33 = v13 - v28;
  v711 = v6 - v714 * v10;
  v688 = v20;
  v689 = v10;
  v686 = v33;
  v687 = v32;
  v690 = v27;
  switch(a2)
  {
    case 0:
      if (v714)
      {
        do
        {
          v34 = v10;
          do
          {
            v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *v7 = 0.0;
                *v14 = 0.0;
              }
              else
              {
                v36 = (float)((float)v35 * -0.0039216) + 1.0;
                *v14 = v36 * *v14;
                *v7 = v36 * *v7;
              }
            }
            v16 += v26;
            v7 += v714;
            v14 += v26;
            --v34;
          }
          while (v34);
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v578 = v10;
          do
          {
            v579 = *v16;
            if (*v16)
            {
              v580 = 0.0;
              if (v579 != 255)
                v580 = (float)((float)((float)v579 * -0.0039216) + 1.0) * *v14;
              *v14 = v580;
            }
            v16 += v26;
            v14 += v26;
            --v578;
          }
          while (v578);
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 1:
      if (v714)
      {
        v37 = v26;
        if (v713)
        {
          v38 = v23;
          v39 = -(v20 * v23);
          v40 = -(uint64_t)(v21 * v38);
          v41 = (float *)v11;
          v42 = -(uint64_t)v22;
          do
          {
            v43 = v10;
            do
            {
              v44 = *v16;
              if (*v16)
              {
                if (v44 == 255)
                {
                  *v14 = *(float *)v24;
                  v45 = *v41;
                }
                else
                {
                  v46 = (float)v44 * 0.0039216;
                  *v14 = (float)((float)(1.0 - v46) * *v14) + (float)(*(float *)v24 * v46);
                  v45 = (float)((float)(1.0 - v46) * *v7) + (float)(*v41 * v46);
                }
                *v7 = v45;
              }
              v16 += v37;
              v47 = &v24[4 * v37];
              v48 = &v41[v713];
              if ((unint64_t)v47 >= v12)
                v49 = v42;
              else
                v49 = 0;
              v41 = &v48[v49];
              v24 = &v47[4 * v49];
              v7 += v714;
              v14 += v37;
              --v43;
            }
            while (v43);
            if (v27)
            {
              v50 = &v712[4 * v20];
              if ((unint64_t)v50 >= v27)
                v51 = v40;
              else
                v51 = 0;
              v11 += 4 * v21 + 4 * v51;
              if ((unint64_t)v50 >= v27)
                v52 = v39;
              else
                v52 = 0;
              v24 = &v50[4 * v52];
              v12 += 4 * v52 + 4 * v20;
              v41 = (float *)v11;
              v712 = v24;
            }
            else
            {
              v24 += 4 * v20;
              v41 += v21;
            }
            v16 += v32;
            v14 += v33;
            v7 += v711;
            --v9;
          }
          while (v9);
        }
        else
        {
          v663 = -(uint64_t)v22;
          v664 = -(v20 * v23);
          do
          {
            v665 = v10;
            do
            {
              v666 = *v16;
              if (*v16)
              {
                if (v666 == 255)
                {
                  *v14 = *(float *)v24;
                  v667 = 1.0;
                }
                else
                {
                  v668 = (float)v666 * 0.0039216;
                  *v14 = (float)((float)(1.0 - v668) * *v14) + (float)(*(float *)v24 * v668);
                  v667 = v668 + (float)((float)(1.0 - v668) * *v7);
                }
                *v7 = v667;
              }
              v16 += v37;
              v669 = &v24[4 * v37];
              if ((unint64_t)v669 >= v12)
                v670 = v663;
              else
                v670 = 0;
              v24 = &v669[4 * v670];
              v7 += v714;
              v14 += v37;
              --v665;
            }
            while (v665);
            v16 += v32;
            v14 += v33;
            v671 = v712;
            v7 += v711;
            v672 = &v712[4 * v20];
            if ((unint64_t)v672 >= v27)
              v673 = v664;
            else
              v673 = 0;
            v674 = &v672[4 * v673];
            v675 = v12 + 4 * v673 + 4 * v20;
            if (v27)
            {
              v12 = v675;
              v671 = v674;
            }
            v712 = v671;
            if (v27)
              v24 = v674;
            else
              v24 += 4 * v20;
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        v581 = v26;
        v582 = -(uint64_t)v22;
        v583 = -(v20 * v23);
        v584 = 4 * v26;
        do
        {
          v585 = v10;
          do
          {
            v586 = *v16;
            if (*v16)
            {
              if (v586 == 255)
                v587 = *(float *)v24;
              else
                v587 = (float)((float)(1.0 - (float)((float)v586 * 0.0039216)) * *v14)
                     + (float)(*(float *)v24 * (float)((float)v586 * 0.0039216));
              *v14 = v587;
            }
            v16 += v581;
            v588 = &v24[4 * v581];
            if ((unint64_t)v588 >= v12)
              v589 = v582;
            else
              v589 = 0;
            v24 = &v588[4 * v589];
            v14 = (float *)((char *)v14 + v584);
            --v585;
          }
          while (v585);
          v16 += v32;
          v14 += v33;
          v590 = v712;
          v591 = &v712[4 * v20];
          if ((unint64_t)v591 >= v27)
            v592 = v583;
          else
            v592 = 0;
          v593 = &v591[4 * v592];
          v594 = v12 + 4 * v592 + 4 * v20;
          if (v27)
          {
            v12 = v594;
            v590 = v593;
          }
          v712 = v590;
          if (v27)
            v24 = v593;
          else
            v24 += 4 * v20;
          --v9;
        }
        while (v9);
      }
      return;
    case 2:
      v53 = v26;
      if (v714)
      {
        v54 = -(uint64_t)v22;
        v55 = v23;
        v56 = -(v20 * v23);
        v57 = -(uint64_t)(v21 * v55);
        v58 = (float *)v11;
        while (1)
        {
          v59 = v10;
          do
          {
            v60 = *v16;
            if (!*v16)
              goto LABEL_73;
            if (v60 == 255)
            {
              v61 = *v58;
              if (*v58 >= 1.0)
              {
                *v14 = *(float *)v24;
                goto LABEL_72;
              }
              if (v61 <= 0.0)
                goto LABEL_73;
              v62 = *(float *)v24;
            }
            else
            {
              v63 = (float)v60 * 0.0039216;
              v61 = v63 * *v58;
              if (v61 <= 0.0)
                goto LABEL_73;
              v62 = v63 * *(float *)v24;
            }
            *v14 = v62 + (float)(*v14 * (float)(1.0 - v61));
            v61 = v61 + (float)(*v7 * (float)(1.0 - v61));
LABEL_72:
            *v7 = v61;
LABEL_73:
            v16 += v53;
            v64 = &v24[4 * v53];
            v65 = &v58[v713];
            if ((unint64_t)v64 >= v12)
              v66 = v54;
            else
              v66 = 0;
            v58 = &v65[v66];
            v24 = &v64[4 * v66];
            v7 += v714;
            v14 += v53;
            --v59;
          }
          while (v59);
          if (v27)
          {
            v67 = &v712[4 * v20];
            if ((unint64_t)v67 >= v27)
              v68 = v57;
            else
              v68 = 0;
            v11 += 4 * v21 + 4 * v68;
            if ((unint64_t)v67 >= v27)
              v69 = v56;
            else
              v69 = 0;
            v24 = &v67[4 * v69];
            v12 += 4 * v69 + 4 * v20;
            v58 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v58 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          if (!--v9)
            return;
        }
      }
      v595 = -(uint64_t)v22;
      v596 = v23;
      v597 = -(v20 * v23);
      v598 = -(uint64_t)(v21 * v596);
      v599 = (float *)v11;
LABEL_830:
      v600 = v10;
      while (1)
      {
        v601 = *v16;
        if (*v16)
        {
          if (v601 == 255)
          {
            v602 = *v599;
            if (*v599 >= 1.0)
            {
              v603 = *(float *)v24;
              goto LABEL_839;
            }
            if (v602 > 0.0)
            {
              v603 = *(float *)v24 + (float)(*v14 * (float)(1.0 - v602));
LABEL_839:
              *v14 = v603;
            }
          }
          else
          {
            v604 = (float)v601 * 0.0039216;
            v605 = v604 * *v599;
            if (v605 > 0.0)
            {
              v603 = (float)(v604 * *(float *)v24) + (float)(*v14 * (float)(1.0 - v605));
              goto LABEL_839;
            }
          }
        }
        v16 += v53;
        v606 = &v24[4 * v53];
        v607 = &v599[v713];
        if ((unint64_t)v606 >= v12)
          v608 = v595;
        else
          v608 = 0;
        v599 = &v607[v608];
        v24 = &v606[4 * v608];
        v14 += v53;
        if (!--v600)
        {
          if (v27)
          {
            v609 = &v712[4 * v20];
            if ((unint64_t)v609 >= v27)
              v610 = v598;
            else
              v610 = 0;
            v11 += 4 * v21 + 4 * v610;
            if ((unint64_t)v609 >= v27)
              v611 = v597;
            else
              v611 = 0;
            v24 = &v609[4 * v611];
            v12 += 4 * v611 + 4 * v20;
            v599 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v599 += v21;
          }
          v16 += v32;
          v14 += v33;
          if (!--v9)
            return;
          goto LABEL_830;
        }
      }
    case 3:
      v70 = v26;
      v71 = v23;
      v72 = -(v20 * v23);
      v73 = -(uint64_t)(v21 * v71);
      v74 = 4 * v26;
      v75 = -(uint64_t)v22;
      v76 = (float *)v11;
      do
      {
        v77 = v10;
        do
        {
          v78 = *v16;
          if (*v16)
          {
            if (v78 == 255)
            {
              *v14 = *(float *)v24 * *v7;
              if (v713)
                v79 = *v76;
              else
                v79 = 1.0;
              v85 = v79 * *v7;
            }
            else
            {
              v80 = (float)v78 * 0.0039216;
              v81 = *v7;
              v82 = v80 * *v7;
              v83 = 1.0;
              v84 = 1.0 - v80;
              *v14 = (float)(v84 * *v14) + (float)(*(float *)v24 * v82);
              if (v713)
                v83 = *v76;
              v85 = (float)(v84 * v81) + (float)(v83 * v82);
            }
            *v7 = v85;
          }
          v16 += v70;
          v86 = &v24[4 * v70];
          v87 = &v76[v713];
          if ((unint64_t)v86 >= v12)
            v88 = v75;
          else
            v88 = 0;
          v76 = &v87[v88];
          v24 = &v86[4 * v88];
          v7 += v714;
          v14 = (float *)((char *)v14 + v74);
          --v77;
        }
        while (v77);
        if (v27)
        {
          v89 = &v712[4 * v20];
          if ((unint64_t)v89 >= v27)
            v90 = v73;
          else
            v90 = 0;
          v11 += 4 * v21 + 4 * v90;
          if ((unint64_t)v89 >= v27)
            v91 = v72;
          else
            v91 = 0;
          v24 = &v89[4 * v91];
          v12 += 4 * v91 + 4 * v20;
          v76 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v76 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 4:
      v92 = v26;
      v93 = v23;
      v94 = -(v20 * v23);
      v95 = -(uint64_t)(v21 * v93);
      v96 = 4 * v26;
      v97 = -(uint64_t)v22;
      v98 = (float *)v11;
      do
      {
        v99 = v10;
        do
        {
          v100 = *v16;
          if (*v16)
          {
            if (v100 == 255)
            {
              v101 = 1.0;
              *v14 = *(float *)v24 * (float)(1.0 - *v7);
              if (v713)
                v101 = *v98;
              v102 = v101 * (float)(1.0 - *v7);
            }
            else
            {
              v103 = (float)v100 * 0.0039216;
              v104 = *v7;
              v105 = 1.0;
              v106 = v103 * (float)(1.0 - *v7);
              v107 = 1.0 - v103;
              *v14 = (float)(v107 * *v14) + (float)(*(float *)v24 * v106);
              if (v713)
                v105 = *v98;
              v102 = (float)(v107 * v104) + (float)(v105 * v106);
            }
            *v7 = v102;
          }
          v16 += v92;
          v108 = &v24[4 * v92];
          v109 = &v98[v713];
          if ((unint64_t)v108 >= v12)
            v110 = v97;
          else
            v110 = 0;
          v98 = &v109[v110];
          v24 = &v108[4 * v110];
          v7 += v714;
          v14 = (float *)((char *)v14 + v96);
          --v99;
        }
        while (v99);
        if (v27)
        {
          v111 = &v712[4 * v20];
          if ((unint64_t)v111 >= v27)
            v112 = v95;
          else
            v112 = 0;
          v11 += 4 * v21 + 4 * v112;
          if ((unint64_t)v111 >= v27)
            v113 = v94;
          else
            v113 = 0;
          v24 = &v111[4 * v113];
          v12 += 4 * v113 + 4 * v20;
          v98 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v98 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 5:
      v114 = v26;
      v115 = v23;
      v116 = -(v20 * v23);
      v117 = -(uint64_t)(v21 * v115);
      v118 = 4 * v26;
      v119 = -(uint64_t)v22;
      v120 = (float *)v11;
      do
      {
        v121 = v10;
        do
        {
          if (*v16)
          {
            v122 = *v7;
            v123 = (float)*v16 * 0.0039216;
            v124 = v123 * *(float *)v24;
            v125 = v123 * *v120;
            *v14 = (float)(*v14 * (float)(1.0 - v125)) + (float)(v124 * *v7);
            *v7 = (float)(v122 * (float)(1.0 - v125)) + (float)(v125 * v122);
          }
          v16 += v114;
          v126 = &v24[4 * v114];
          v127 = &v120[v713];
          if ((unint64_t)v126 >= v12)
            v128 = v119;
          else
            v128 = 0;
          v120 = &v127[v128];
          v24 = &v126[4 * v128];
          v7 += v714;
          v14 = (float *)((char *)v14 + v118);
          --v121;
        }
        while (v121);
        if (v27)
        {
          v129 = &v712[4 * v20];
          if ((unint64_t)v129 >= v27)
            v130 = v117;
          else
            v130 = 0;
          v11 += 4 * v21 + 4 * v130;
          if ((unint64_t)v129 >= v27)
            v131 = v116;
          else
            v131 = 0;
          v24 = &v129[4 * v131];
          v12 += 4 * v131 + 4 * v20;
          v120 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v120 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 6:
      v132 = v26;
      v133 = v23;
      v134 = -(v20 * v23);
      v135 = -(uint64_t)(v21 * v133);
      v136 = 4 * v26;
      v137 = -(uint64_t)v22;
      v138 = (float *)v11;
      while (1)
      {
        v139 = v10;
        do
        {
          v140 = *v16;
          if (!*v16)
            goto LABEL_174;
          v141 = *v7;
          v142 = 1.0 - *v7;
          if (v142 >= 1.0)
          {
            v145 = (float)v140 * 0.0039216;
            *v14 = v145 * *(float *)v24;
            if (v713)
              v146 = *v138;
            else
              v146 = 1.0;
            v147 = v145 * v146;
          }
          else
          {
            if (v142 <= 0.0)
              goto LABEL_174;
            v143 = (float)((float)v140 * 0.0039216) * v142;
            *v14 = *v14 + (float)(*(float *)v24 * v143);
            if (v713)
              v144 = *v138;
            else
              v144 = 1.0;
            v147 = v141 + (float)(v144 * v143);
          }
          *v7 = v147;
LABEL_174:
          v16 += v132;
          v148 = &v24[4 * v132];
          v149 = &v138[v713];
          if ((unint64_t)v148 >= v12)
            v150 = v137;
          else
            v150 = 0;
          v138 = &v149[v150];
          v24 = &v148[4 * v150];
          v7 += v714;
          v14 = (float *)((char *)v14 + v136);
          --v139;
        }
        while (v139);
        if (v27)
        {
          v151 = &v712[4 * v20];
          if ((unint64_t)v151 >= v27)
            v152 = v135;
          else
            v152 = 0;
          v11 += 4 * v21 + 4 * v152;
          if ((unint64_t)v151 >= v27)
            v153 = v134;
          else
            v153 = 0;
          v24 = &v151[4 * v153];
          v12 += 4 * v153 + 4 * v20;
          v138 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v138 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 7:
      v154 = v26;
      if (v714)
      {
        v155 = v23;
        v156 = -(v20 * v23);
        v157 = -(uint64_t)(v21 * v155);
        v158 = -(uint64_t)v22;
        v159 = (float *)v11;
        do
        {
          v160 = v10;
          do
          {
            v161 = *v16;
            if (*v16)
            {
              if (v161 == 255)
              {
                *v14 = *v14 * *v159;
                v162 = *v7 * *v159;
              }
              else
              {
                v163 = (float)v161 * 0.0039216;
                v164 = *v7;
                *v14 = (float)((float)(1.0 - v163) * *v14) + (float)(*v14 * (float)(v163 * *v159));
                v162 = (float)((float)(1.0 - v163) * v164) + (float)(v164 * (float)(v163 * *v159));
              }
              *v7 = v162;
            }
            v16 += v154;
            v165 = &v24[4 * v154];
            v166 = &v159[v713];
            if ((unint64_t)v165 >= v12)
              v167 = v158;
            else
              v167 = 0;
            v159 = &v166[v167];
            v24 = &v165[4 * v167];
            v7 += v714;
            v14 += v154;
            --v160;
          }
          while (v160);
          if (v27)
          {
            v168 = &v712[4 * v20];
            if ((unint64_t)v168 >= v27)
              v169 = v157;
            else
              v169 = 0;
            v11 += 4 * v21 + 4 * v169;
            if ((unint64_t)v168 >= v27)
              v170 = v156;
            else
              v170 = 0;
            v24 = &v168[4 * v170];
            v12 += 4 * v170 + 4 * v20;
            v159 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v159 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        v612 = -(uint64_t)v22;
        v613 = v23;
        v614 = -(v20 * v23);
        v615 = -(uint64_t)(v21 * v613);
        v616 = (float *)v11;
        do
        {
          v617 = v10;
          do
          {
            v618 = *v16;
            if (*v16)
            {
              if (v618 == 255)
                v619 = *v14 * *v616;
              else
                v619 = (float)((float)(1.0 - (float)((float)v618 * 0.0039216)) * *v14)
                     + (float)(*v14 * (float)((float)((float)v618 * 0.0039216) * *v616));
              *v14 = v619;
            }
            v16 += v154;
            v620 = &v24[4 * v154];
            v621 = &v616[v713];
            if ((unint64_t)v620 >= v12)
              v622 = v612;
            else
              v622 = 0;
            v616 = &v621[v622];
            v24 = &v620[4 * v622];
            v14 += v154;
            --v617;
          }
          while (v617);
          if (v27)
          {
            v623 = &v712[4 * v20];
            if ((unint64_t)v623 >= v27)
              v624 = v615;
            else
              v624 = 0;
            v11 += 4 * v21 + 4 * v624;
            if ((unint64_t)v623 >= v27)
              v625 = v614;
            else
              v625 = 0;
            v24 = &v623[4 * v625];
            v12 += 4 * v625 + 4 * v20;
            v616 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v616 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 8:
      v171 = v26;
      if (v714)
      {
        v172 = -(uint64_t)v22;
        v173 = v23;
        v174 = -(v20 * v23);
        v175 = -(uint64_t)(v21 * v173);
        v176 = (float *)v11;
        do
        {
          v177 = v10;
          do
          {
            v178 = *v16;
            if (*v16)
            {
              if (v178 == 255)
              {
                *v14 = *v14 * (float)(1.0 - *v176);
                v179 = *v176;
              }
              else
              {
                v180 = (float)v178 * 0.0039216;
                *v14 = *v14 * (float)(1.0 - (float)(v180 * *v176));
                v179 = v180 * *v176;
              }
              *v7 = *v7 * (float)(1.0 - v179);
            }
            v16 += v171;
            v181 = &v24[4 * v171];
            v182 = &v176[v713];
            if ((unint64_t)v181 >= v12)
              v183 = v172;
            else
              v183 = 0;
            v176 = &v182[v183];
            v24 = &v181[4 * v183];
            v7 += v714;
            v14 += v171;
            --v177;
          }
          while (v177);
          if (v27)
          {
            v184 = &v712[4 * v20];
            if ((unint64_t)v184 >= v27)
              v185 = v175;
            else
              v185 = 0;
            v11 += 4 * v21 + 4 * v185;
            if ((unint64_t)v184 >= v27)
              v186 = v174;
            else
              v186 = 0;
            v24 = &v184[4 * v186];
            v12 += 4 * v186 + 4 * v20;
            v176 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v176 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        v626 = -(uint64_t)v22;
        v627 = v23;
        v628 = -(v20 * v23);
        v629 = -(uint64_t)(v21 * v627);
        v630 = (float *)v11;
        do
        {
          v631 = v10;
          do
          {
            v632 = *v16;
            if (*v16)
            {
              if (v632 == 255)
                v633 = *v630;
              else
                v633 = (float)((float)v632 * 0.0039216) * *v630;
              *v14 = *v14 * (float)(1.0 - v633);
            }
            v16 += v171;
            v634 = &v24[4 * v171];
            v635 = &v630[v713];
            if ((unint64_t)v634 >= v12)
              v636 = v626;
            else
              v636 = 0;
            v630 = &v635[v636];
            v24 = &v634[4 * v636];
            v14 += v171;
            --v631;
          }
          while (v631);
          if (v27)
          {
            v637 = &v712[4 * v20];
            if ((unint64_t)v637 >= v27)
              v638 = v629;
            else
              v638 = 0;
            v11 += 4 * v21 + 4 * v638;
            if ((unint64_t)v637 >= v27)
              v639 = v628;
            else
              v639 = 0;
            v24 = &v637[4 * v639];
            v12 += 4 * v639 + 4 * v20;
            v630 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v630 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 9:
      v187 = v26;
      v188 = v23;
      v189 = -(v20 * v23);
      v190 = -(uint64_t)(v21 * v188);
      v191 = 4 * v26;
      v192 = -(uint64_t)v22;
      v193 = (float *)v11;
      do
      {
        v194 = v10;
        do
        {
          if (*v16)
          {
            v195 = *v7;
            v196 = (float)*v16 * 0.0039216;
            v197 = v196 * *(float *)v24;
            v198 = v196 * *v193;
            v199 = 1.0 - *v7;
            v200 = (float)(1.0 - v196) + v198;
            *v14 = (float)(*v14 * v200) + (float)(v197 * v199);
            *v7 = (float)(v195 * v200) + (float)(v198 * v199);
          }
          v16 += v187;
          v201 = &v24[4 * v187];
          v202 = &v193[v713];
          if ((unint64_t)v201 >= v12)
            v203 = v192;
          else
            v203 = 0;
          v193 = &v202[v203];
          v24 = &v201[4 * v203];
          v7 += v714;
          v14 = (float *)((char *)v14 + v191);
          --v194;
        }
        while (v194);
        if (v27)
        {
          v204 = &v712[4 * v20];
          if ((unint64_t)v204 >= v27)
            v205 = v190;
          else
            v205 = 0;
          v11 += 4 * v21 + 4 * v205;
          if ((unint64_t)v204 >= v27)
            v206 = v189;
          else
            v206 = 0;
          v24 = &v204[4 * v206];
          v12 += 4 * v206 + 4 * v20;
          v193 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v193 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 10:
      v207 = v26;
      v208 = v23;
      v209 = -(v20 * v23);
      v210 = -(uint64_t)(v21 * v208);
      v211 = 4 * v26;
      v212 = -(uint64_t)v22;
      v213 = (float *)v11;
      do
      {
        v214 = v10;
        do
        {
          if (*v16)
          {
            v215 = *v7;
            v216 = (float)*v16 * 0.0039216;
            v217 = v216 * *(float *)v24;
            v218 = v216 * *v213;
            v219 = 1.0 - *v7;
            *v14 = (float)(*v14 * (float)(1.0 - v218)) + (float)(v217 * v219);
            *v7 = (float)(v215 * (float)(1.0 - v218)) + (float)(v218 * v219);
          }
          v16 += v207;
          v220 = &v24[4 * v207];
          v221 = &v213[v713];
          if ((unint64_t)v220 >= v12)
            v222 = v212;
          else
            v222 = 0;
          v213 = &v221[v222];
          v24 = &v220[4 * v222];
          v7 += v714;
          v14 = (float *)((char *)v14 + v211);
          --v214;
        }
        while (v214);
        if (v27)
        {
          v223 = &v712[4 * v20];
          if ((unint64_t)v223 >= v27)
            v224 = v210;
          else
            v224 = 0;
          v11 += 4 * v21 + 4 * v224;
          if ((unint64_t)v223 >= v27)
            v225 = v209;
          else
            v225 = 0;
          v24 = &v223[4 * v225];
          v12 += 4 * v225 + 4 * v20;
          v213 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v213 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        --v9;
      }
      while (v9);
      return;
    case 11:
      v226 = v26;
      if (v714)
      {
        v227 = v23;
        v228 = -(v20 * v23);
        v229 = -(uint64_t)(v21 * v227);
        v230 = -(uint64_t)v22;
        v231 = (float *)v11;
        do
        {
          v232 = v10;
          do
          {
            if (*v16)
            {
              if (v713)
                v233 = *v231;
              else
                v233 = 1.0;
              v234 = (float)*v16 * 0.0039216;
              v235 = v234 * v233;
              v236 = *v7 + v235;
              v237 = (float)(v235 - (float)(v234 * *(float *)v24)) + (float)(*v7 - *v14);
              if (v236 <= 1.0)
                v238 = v236;
              else
                v238 = 1.0;
              *v7 = v238;
              *v14 = v238 - v237;
            }
            v16 += v226;
            v239 = &v24[4 * v226];
            v240 = &v231[v713];
            if ((unint64_t)v239 >= v12)
              v241 = v230;
            else
              v241 = 0;
            v231 = &v240[v241];
            v24 = &v239[4 * v241];
            v7 += v714;
            v14 += v226;
            --v232;
          }
          while (v232);
          if (v27)
          {
            v242 = &v712[4 * v20];
            if ((unint64_t)v242 >= v27)
              v243 = v229;
            else
              v243 = 0;
            v11 += 4 * v21 + 4 * v243;
            if ((unint64_t)v242 >= v27)
              v244 = v228;
            else
              v244 = 0;
            v24 = &v242[4 * v244];
            v12 += 4 * v244 + 4 * v20;
            v231 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v231 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        v640 = -(uint64_t)v22;
        v641 = v23;
        v642 = -(v20 * v23);
        v643 = -(uint64_t)(v21 * v641);
        v644 = (float *)v11;
        do
        {
          v645 = v10;
          do
          {
            if (*v16)
            {
              if (v713)
                v646 = *v644;
              else
                v646 = 1.0;
              *v14 = 1.0
                   - (float)((float)(1.0 - *v14)
                           + (float)((float)((float)((float)*v16 * 0.0039216) * v646)
                                   - (float)((float)((float)*v16 * 0.0039216) * *(float *)v24)));
            }
            v16 += v226;
            v647 = &v24[4 * v226];
            v648 = &v644[v713];
            if ((unint64_t)v647 >= v12)
              v649 = v640;
            else
              v649 = 0;
            v644 = &v648[v649];
            v24 = &v647[4 * v649];
            v14 += v226;
            --v645;
          }
          while (v645);
          if (v27)
          {
            v650 = &v712[4 * v20];
            if ((unint64_t)v650 >= v27)
              v651 = v643;
            else
              v651 = 0;
            v11 += 4 * v21 + 4 * v651;
            if ((unint64_t)v650 >= v27)
              v652 = v642;
            else
              v652 = 0;
            v24 = &v650[4 * v652];
            v12 += 4 * v652 + 4 * v20;
            v644 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v644 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 12:
      v245 = v26;
      if (v714)
      {
        v246 = v23;
        v247 = -(v20 * v23);
        v248 = -(uint64_t)(v21 * v246);
        v249 = -(uint64_t)v22;
        v250 = (float *)v11;
        do
        {
          v251 = v10;
          do
          {
            if (*v16)
            {
              if (v713)
                v252 = *v250;
              else
                v252 = 1.0;
              v253 = (float)*v16 * 0.0039216;
              v254 = *v7 + (float)(v253 * v252);
              if (v254 > 1.0)
                v254 = 1.0;
              *v14 = (float)(v253 * *(float *)v24) + *v14;
              *v7 = v254;
            }
            v16 += v245;
            v255 = &v24[4 * v245];
            v256 = &v250[v713];
            if ((unint64_t)v255 >= v12)
              v257 = v249;
            else
              v257 = 0;
            v250 = &v256[v257];
            v24 = &v255[4 * v257];
            v7 += v714;
            v14 += v245;
            --v251;
          }
          while (v251);
          if (v27)
          {
            v258 = &v712[4 * v20];
            if ((unint64_t)v258 >= v27)
              v259 = v248;
            else
              v259 = 0;
            v11 += 4 * v21 + 4 * v259;
            if ((unint64_t)v258 >= v27)
              v260 = v247;
            else
              v260 = 0;
            v24 = &v258[4 * v260];
            v12 += 4 * v260 + 4 * v20;
            v250 = (float *)v11;
            v712 = v24;
          }
          else
          {
            v24 += 4 * v20;
            v250 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v711;
          --v9;
        }
        while (v9);
      }
      else
      {
        v653 = -(uint64_t)v22;
        v654 = -(v20 * v23);
        do
        {
          v655 = v10;
          do
          {
            if (*v16)
              *v14 = *v14 + (float)((float)((float)*v16 * 0.0039216) * *(float *)v24);
            v16 += v245;
            v656 = &v24[4 * v245];
            if ((unint64_t)v656 >= v12)
              v657 = v653;
            else
              v657 = 0;
            v24 = &v656[4 * v657];
            v14 += v245;
            --v655;
          }
          while (v655);
          v16 += v32;
          v14 += v33;
          v658 = v712;
          v659 = &v712[4 * v20];
          if ((unint64_t)v659 >= v27)
            v660 = v654;
          else
            v660 = 0;
          v661 = &v659[4 * v660];
          v662 = v12 + 4 * v660 + 4 * v20;
          if (v27)
          {
            v12 = v662;
            v658 = v661;
          }
          v712 = v658;
          if (v27)
            v24 = v661;
          else
            v24 += 4 * v20;
          --v9;
        }
        while (v9);
      }
      return;
    case 13:
      v261 = v26;
      v262 = v23;
      v263 = -(v20 * v23);
      v264 = -(uint64_t)(v21 * v262);
      v265 = 4 * v26;
      v266 = -(uint64_t)v22;
      v267 = (float *)v11;
      while (1)
      {
        v268 = v10;
        do
        {
          if (*v16)
          {
            v269 = v713 ? *v267 : 1.0;
            v270 = (float)*v16 * 0.0039216;
            v271 = v270 * v269;
            if (v271 > 0.0)
            {
              v272 = v270 * *(float *)v24;
              if (v714)
              {
                v273 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_341;
              }
              else
              {
                v273 = 1.0;
              }
              v274 = (float)(v272 * *v14) + (float)(*v14 * (float)(1.0 - v271));
              if (v271 == 1.0)
                v274 = v272 * *v14;
              v272 = v274 + (float)(v272 * (float)(1.0 - v273));
              if (v273 == 1.0)
                v272 = v274;
              if (v714)
              {
                v271 = (float)(v271 + v273) - (float)(v273 * v271);
LABEL_341:
                *v14 = v272;
                *v7 = v271;
                goto LABEL_343;
              }
              *v14 = v272;
            }
          }
LABEL_343:
          v16 += v261;
          v275 = &v24[4 * v261];
          v276 = &v267[v713];
          if ((unint64_t)v275 >= v12)
            v277 = v266;
          else
            v277 = 0;
          v267 = &v276[v277];
          v24 = &v275[4 * v277];
          v7 += v714;
          v14 = (float *)((char *)v14 + v265);
          --v268;
        }
        while (v268);
        if (v27)
        {
          v278 = &v712[4 * v20];
          if ((unint64_t)v278 >= v27)
            v279 = v264;
          else
            v279 = 0;
          v11 += 4 * v21 + 4 * v279;
          if ((unint64_t)v278 >= v27)
            v280 = v263;
          else
            v280 = 0;
          v24 = &v278[4 * v280];
          v12 += 4 * v280 + 4 * v20;
          v267 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v267 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 14:
      v281 = v26;
      v282 = v23;
      v283 = -(v20 * v23);
      v284 = -(uint64_t)(v21 * v282);
      v285 = 4 * v26;
      v286 = -(uint64_t)v22;
      v287 = (float *)v11;
      while (1)
      {
        v288 = v10;
        do
        {
          if (*v16)
          {
            v289 = v713 ? *v287 : 1.0;
            v290 = (float)*v16 * 0.0039216;
            v291 = v290 * v289;
            if (v291 > 0.0)
            {
              v292 = v290 * *(float *)v24;
              if (v714)
              {
                v293 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_371;
              }
              else
              {
                v293 = 1.0;
              }
              v292 = *v14 + (float)(v292 * (float)(1.0 - *v14));
              if (v714)
              {
                v291 = (float)(v291 + v293) - (float)(v293 * v291);
LABEL_371:
                *v14 = v292;
                *v7 = v291;
                goto LABEL_373;
              }
              *v14 = v292;
            }
          }
LABEL_373:
          v16 += v281;
          v294 = &v24[4 * v281];
          v295 = &v287[v713];
          if ((unint64_t)v294 >= v12)
            v296 = v286;
          else
            v296 = 0;
          v287 = &v295[v296];
          v24 = &v294[4 * v296];
          v7 += v714;
          v14 = (float *)((char *)v14 + v285);
          --v288;
        }
        while (v288);
        if (v27)
        {
          v297 = &v712[4 * v20];
          if ((unint64_t)v297 >= v27)
            v298 = v284;
          else
            v298 = 0;
          v11 += 4 * v21 + 4 * v298;
          if ((unint64_t)v297 >= v27)
            v299 = v283;
          else
            v299 = 0;
          v24 = &v297[4 * v299];
          v12 += 4 * v299 + 4 * v20;
          v287 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v287 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 15:
      v300 = v26;
      v676 = -(uint64_t)(v21 * v23);
      v681 = -(v20 * v23);
      v301 = 4 * v26;
      v302 = -(uint64_t)v22;
      v303 = (float *)v11;
      v691 = v302;
      v696 = v26;
      while (1)
      {
        v701 = v11;
        v706 = v9;
        v304 = v10;
        v305 = v713;
        do
        {
          if (*v16)
          {
            v306 = v305 ? *v303 : 1.0;
            v307 = (float)*v16 * 0.0039216;
            v308 = v307 * v306;
            if ((float)(v307 * v306) > 0.0)
            {
              v309 = v307 * *(float *)v24;
              if (v714)
              {
                v310 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_401;
              }
              else
              {
                v310 = 1.0;
              }
              v311 = PDAoverlayPDA(*v14, v310, v309, v308);
              v309 = v311;
              if (v714)
              {
                v308 = v312;
                v305 = v713;
                v302 = v691;
                v300 = v696;
LABEL_401:
                *v14 = v309;
                *v7 = v308;
                goto LABEL_403;
              }
              *v14 = v311;
              v305 = v713;
              v302 = v691;
              v300 = v696;
            }
          }
LABEL_403:
          v16 += v300;
          v313 = &v24[4 * v300];
          if ((unint64_t)v313 >= v12)
            v314 = v302;
          else
            v314 = 0;
          v303 += v713 + v314;
          v24 = &v313[4 * v314];
          v7 += v714;
          v14 = (float *)((char *)v14 + v301);
          --v304;
        }
        while (v304);
        if (v690)
        {
          v10 = v689;
          v315 = &v712[4 * v688];
          v316 = v706;
          v317 = v676;
          if ((unint64_t)v315 < v690)
            v317 = 0;
          v11 = v701 + 4 * v21 + 4 * v317;
          v318 = v681;
          if ((unint64_t)v315 < v690)
            v318 = 0;
          v24 = &v315[4 * v318];
          v12 += 4 * v318 + 4 * v688;
          v303 = (float *)(v701 + 4 * v21 + 4 * v317);
          v712 = v24;
          v320 = v686;
          v319 = v687;
        }
        else
        {
          v10 = v689;
          v24 += 4 * v688;
          v320 = v686;
          v303 += v21;
          v11 = v701;
          v316 = v706;
          v319 = v687;
        }
        v16 += v319;
        v14 += v320;
        v7 += v711;
        v9 = v316 - 1;
        if (!v9)
          return;
      }
    case 16:
      v321 = v26;
      v322 = v23;
      v323 = -(v20 * v23);
      v324 = -(uint64_t)(v21 * v322);
      v325 = 4 * v26;
      v326 = -(uint64_t)v22;
      v327 = (float *)v11;
      while (1)
      {
        v328 = v10;
        do
        {
          if (*v16)
          {
            v329 = v713 ? *v327 : 1.0;
            v330 = (float)*v16 * 0.0039216;
            v331 = v330 * v329;
            if (v331 > 0.0)
            {
              v332 = v330 * *(float *)v24;
              if (v714)
              {
                v333 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_435;
              }
              else
              {
                v333 = 1.0;
              }
              v334 = v331 * *v14;
              if ((float)(v332 * v333) < v334)
                v334 = v332 * v333;
              v335 = v334 + (float)(*v14 * (float)(1.0 - v331));
              if (v331 == 1.0)
                v335 = v334;
              v332 = v335 + (float)(v332 * (float)(1.0 - v333));
              if (v333 == 1.0)
                v332 = v335;
              if (v714)
              {
                v331 = (float)(v331 + v333) - (float)(v333 * v331);
LABEL_435:
                *v14 = v332;
                *v7 = v331;
                goto LABEL_437;
              }
              *v14 = v332;
            }
          }
LABEL_437:
          v16 += v321;
          v336 = &v24[4 * v321];
          v337 = &v327[v713];
          if ((unint64_t)v336 >= v12)
            v338 = v326;
          else
            v338 = 0;
          v327 = &v337[v338];
          v24 = &v336[4 * v338];
          v7 += v714;
          v14 = (float *)((char *)v14 + v325);
          --v328;
        }
        while (v328);
        if (v27)
        {
          v339 = &v712[4 * v20];
          if ((unint64_t)v339 >= v27)
            v340 = v324;
          else
            v340 = 0;
          v11 += 4 * v21 + 4 * v340;
          if ((unint64_t)v339 >= v27)
            v341 = v323;
          else
            v341 = 0;
          v24 = &v339[4 * v341];
          v12 += 4 * v341 + 4 * v20;
          v327 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v327 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 17:
      v342 = v26;
      v343 = v23;
      v344 = -(v20 * v23);
      v345 = -(uint64_t)(v21 * v343);
      v346 = 4 * v26;
      v347 = -(uint64_t)v22;
      v348 = (float *)v11;
      while (1)
      {
        v349 = v10;
        do
        {
          if (*v16)
          {
            v350 = v713 ? *v348 : 1.0;
            v351 = (float)*v16 * 0.0039216;
            v352 = v351 * v350;
            if (v352 > 0.0)
            {
              v353 = v351 * *(float *)v24;
              if (v714)
              {
                v354 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_471;
              }
              else
              {
                v354 = 1.0;
              }
              v355 = v352 * *v14;
              if ((float)(v353 * v354) > v355)
                v355 = v353 * v354;
              v356 = v355 + (float)(*v14 * (float)(1.0 - v352));
              if (v352 == 1.0)
                v356 = v355;
              v353 = v356 + (float)(v353 * (float)(1.0 - v354));
              if (v354 == 1.0)
                v353 = v356;
              if (v714)
              {
                v352 = (float)(v352 + v354) - (float)(v354 * v352);
LABEL_471:
                *v14 = v353;
                *v7 = v352;
                goto LABEL_473;
              }
              *v14 = v353;
            }
          }
LABEL_473:
          v16 += v342;
          v357 = &v24[4 * v342];
          v358 = &v348[v713];
          if ((unint64_t)v357 >= v12)
            v359 = v347;
          else
            v359 = 0;
          v348 = &v358[v359];
          v24 = &v357[4 * v359];
          v7 += v714;
          v14 = (float *)((char *)v14 + v346);
          --v349;
        }
        while (v349);
        if (v27)
        {
          v360 = &v712[4 * v20];
          if ((unint64_t)v360 >= v27)
            v361 = v345;
          else
            v361 = 0;
          v11 += 4 * v21 + 4 * v361;
          if ((unint64_t)v360 >= v27)
            v362 = v344;
          else
            v362 = 0;
          v24 = &v360[4 * v362];
          v12 += 4 * v362 + 4 * v20;
          v348 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v348 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 18:
      v363 = v26;
      v677 = -(uint64_t)(v21 * v23);
      v682 = -(v20 * v23);
      v364 = 4 * v26;
      v365 = -(uint64_t)v22;
      v366 = (float *)v11;
      v692 = v365;
      v697 = v26;
      while (1)
      {
        v702 = v11;
        v707 = v9;
        v367 = v10;
        v368 = v713;
        do
        {
          if (*v16)
          {
            v369 = v368 ? *v366 : 1.0;
            v370 = (float)*v16 * 0.0039216;
            v371 = v370 * v369;
            if ((float)(v370 * v369) > 0.0)
            {
              v372 = v370 * *(float *)v24;
              if (v714)
              {
                v373 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_501;
              }
              else
              {
                v373 = 1.0;
              }
              v374 = PDAcolordodgePDA(*v14, v373, v372, v371);
              v372 = v374;
              if (v714)
              {
                v371 = v375;
                v368 = v713;
                v365 = v692;
                v363 = v697;
LABEL_501:
                *v14 = v372;
                *v7 = v371;
                goto LABEL_503;
              }
              *v14 = v374;
              v368 = v713;
              v365 = v692;
              v363 = v697;
            }
          }
LABEL_503:
          v16 += v363;
          v376 = &v24[4 * v363];
          if ((unint64_t)v376 >= v12)
            v377 = v365;
          else
            v377 = 0;
          v366 += v713 + v377;
          v24 = &v376[4 * v377];
          v7 += v714;
          v14 = (float *)((char *)v14 + v364);
          --v367;
        }
        while (v367);
        if (v690)
        {
          v10 = v689;
          v378 = &v712[4 * v688];
          v379 = v707;
          v380 = v677;
          if ((unint64_t)v378 < v690)
            v380 = 0;
          v11 = v702 + 4 * v21 + 4 * v380;
          v381 = v682;
          if ((unint64_t)v378 < v690)
            v381 = 0;
          v24 = &v378[4 * v381];
          v12 += 4 * v381 + 4 * v688;
          v366 = (float *)(v702 + 4 * v21 + 4 * v380);
          v712 = v24;
          v383 = v686;
          v382 = v687;
        }
        else
        {
          v10 = v689;
          v24 += 4 * v688;
          v383 = v686;
          v366 += v21;
          v11 = v702;
          v379 = v707;
          v382 = v687;
        }
        v16 += v382;
        v14 += v383;
        v7 += v711;
        v9 = v379 - 1;
        if (!v9)
          return;
      }
    case 19:
      v384 = v26;
      v678 = -(uint64_t)(v21 * v23);
      v683 = -(v20 * v23);
      v385 = 4 * v26;
      v386 = -(uint64_t)v22;
      v387 = (float *)v11;
      v693 = v386;
      v698 = v26;
      while (1)
      {
        v703 = v11;
        v708 = v9;
        v388 = v10;
        v389 = v713;
        do
        {
          if (*v16)
          {
            v390 = v389 ? *v387 : 1.0;
            v391 = (float)*v16 * 0.0039216;
            v392 = v391 * v390;
            if ((float)(v391 * v390) > 0.0)
            {
              v393 = v391 * *(float *)v24;
              if (v714)
              {
                v394 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_529;
              }
              else
              {
                v394 = 1.0;
              }
              v395 = PDAcolorburnPDA(*v14, v394, v393, v392);
              v393 = v395;
              if (v714)
              {
                v392 = v396;
                v389 = v713;
                v386 = v693;
                v384 = v698;
LABEL_529:
                *v14 = v393;
                *v7 = v392;
                goto LABEL_531;
              }
              *v14 = v395;
              v389 = v713;
              v386 = v693;
              v384 = v698;
            }
          }
LABEL_531:
          v16 += v384;
          v397 = &v24[4 * v384];
          if ((unint64_t)v397 >= v12)
            v398 = v386;
          else
            v398 = 0;
          v387 += v713 + v398;
          v24 = &v397[4 * v398];
          v7 += v714;
          v14 = (float *)((char *)v14 + v385);
          --v388;
        }
        while (v388);
        if (v690)
        {
          v10 = v689;
          v399 = &v712[4 * v688];
          v400 = v708;
          v401 = v678;
          if ((unint64_t)v399 < v690)
            v401 = 0;
          v11 = v703 + 4 * v21 + 4 * v401;
          v402 = v683;
          if ((unint64_t)v399 < v690)
            v402 = 0;
          v24 = &v399[4 * v402];
          v12 += 4 * v402 + 4 * v688;
          v387 = (float *)(v703 + 4 * v21 + 4 * v401);
          v712 = v24;
          v404 = v686;
          v403 = v687;
        }
        else
        {
          v10 = v689;
          v24 += 4 * v688;
          v404 = v686;
          v387 += v21;
          v11 = v703;
          v400 = v708;
          v403 = v687;
        }
        v16 += v403;
        v14 += v404;
        v7 += v711;
        v9 = v400 - 1;
        if (!v9)
          return;
      }
    case 20:
      v405 = v26;
      v679 = -(uint64_t)(v21 * v23);
      v684 = -(v20 * v23);
      v406 = 4 * v26;
      v407 = -(uint64_t)v22;
      v408 = (float *)v11;
      v694 = v407;
      v699 = v26;
      while (1)
      {
        v704 = v11;
        v709 = v9;
        v409 = v10;
        v410 = v713;
        do
        {
          if (*v16)
          {
            v411 = v410 ? *v408 : 1.0;
            v412 = (float)*v16 * 0.0039216;
            v413 = v412 * v411;
            if ((float)(v412 * v411) > 0.0)
            {
              v414 = v412 * *(float *)v24;
              if (v714)
              {
                v415 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_557;
              }
              else
              {
                v415 = 1.0;
              }
              v416 = PDAsoftlightPDA(*v14, v415, v414, v413);
              v414 = v416;
              if (v714)
              {
                v413 = v417;
                v410 = v713;
                v407 = v694;
                v405 = v699;
LABEL_557:
                *v14 = v414;
                *v7 = v413;
                goto LABEL_559;
              }
              *v14 = v416;
              v410 = v713;
              v407 = v694;
              v405 = v699;
            }
          }
LABEL_559:
          v16 += v405;
          v418 = &v24[4 * v405];
          if ((unint64_t)v418 >= v12)
            v419 = v407;
          else
            v419 = 0;
          v408 += v713 + v419;
          v24 = &v418[4 * v419];
          v7 += v714;
          v14 = (float *)((char *)v14 + v406);
          --v409;
        }
        while (v409);
        if (v690)
        {
          v10 = v689;
          v420 = &v712[4 * v688];
          v421 = v709;
          v422 = v679;
          if ((unint64_t)v420 < v690)
            v422 = 0;
          v11 = v704 + 4 * v21 + 4 * v422;
          v423 = v684;
          if ((unint64_t)v420 < v690)
            v423 = 0;
          v24 = &v420[4 * v423];
          v12 += 4 * v423 + 4 * v688;
          v408 = (float *)(v704 + 4 * v21 + 4 * v422);
          v712 = v24;
          v425 = v686;
          v424 = v687;
        }
        else
        {
          v10 = v689;
          v24 += 4 * v688;
          v425 = v686;
          v408 += v21;
          v11 = v704;
          v421 = v709;
          v424 = v687;
        }
        v16 += v424;
        v14 += v425;
        v7 += v711;
        v9 = v421 - 1;
        if (!v9)
          return;
      }
    case 21:
      v426 = v26;
      v680 = -(uint64_t)(v21 * v23);
      v685 = -(v20 * v23);
      v427 = 4 * v26;
      v428 = -(uint64_t)v22;
      v429 = (float *)v11;
      v695 = v428;
      v700 = v26;
      do
      {
        v705 = v11;
        v710 = v9;
        v430 = v10;
        v431 = v713;
        do
        {
          if (*v16)
          {
            v432 = v431 ? *v429 : 1.0;
            v433 = (float)*v16 * 0.0039216;
            v434 = v433 * v432;
            if ((float)(v433 * v432) > 0.0)
            {
              v435 = v433 * *(float *)v24;
              if (v714)
              {
                v436 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_585;
              }
              else
              {
                v436 = 1.0;
              }
              v437 = PDAhardlightPDA(*v14, v436, v435, v434);
              v435 = v437;
              if (v714)
              {
                v434 = v438;
                v431 = v713;
                v428 = v695;
                v426 = v700;
LABEL_585:
                *v14 = v435;
                *v7 = v434;
                goto LABEL_587;
              }
              *v14 = v437;
              v431 = v713;
              v428 = v695;
              v426 = v700;
            }
          }
LABEL_587:
          v16 += v426;
          v439 = &v24[4 * v426];
          if ((unint64_t)v439 >= v12)
            v440 = v428;
          else
            v440 = 0;
          v429 += v713 + v440;
          v24 = &v439[4 * v440];
          v7 += v714;
          v14 = (float *)((char *)v14 + v427);
          --v430;
        }
        while (v430);
        if (v690)
        {
          v10 = v689;
          v441 = &v712[4 * v688];
          v442 = v710;
          v443 = v680;
          if ((unint64_t)v441 < v690)
            v443 = 0;
          v11 = v705 + 4 * v21 + 4 * v443;
          v444 = v685;
          if ((unint64_t)v441 < v690)
            v444 = 0;
          v24 = &v441[4 * v444];
          v12 += 4 * v444 + 4 * v688;
          v429 = (float *)(v705 + 4 * v21 + 4 * v443);
          v712 = v24;
          v446 = v686;
          v445 = v687;
        }
        else
        {
          v10 = v689;
          v24 += 4 * v688;
          v446 = v686;
          v429 += v21;
          v11 = v705;
          v442 = v710;
          v445 = v687;
        }
        v16 += v445;
        v14 += v446;
        v7 += v711;
        v9 = v442 - 1;
      }
      while (v9);
      return;
    case 22:
      v447 = v26;
      v448 = v23;
      v449 = -(v20 * v23);
      v450 = -(uint64_t)(v21 * v448);
      v451 = 4 * v26;
      v452 = -(uint64_t)v22;
      v453 = (float *)v11;
      while (1)
      {
        v454 = v10;
        do
        {
          if (*v16)
          {
            v455 = v713 ? *v453 : 1.0;
            v456 = (float)*v16 * 0.0039216;
            v457 = v456 * v455;
            if (v457 > 0.0)
            {
              v458 = v456 * *(float *)v24;
              if (v714)
              {
                v459 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_615;
              }
              else
              {
                v459 = 1.0;
              }
              v460 = v458 + *v14;
              v461 = v457 * *v14;
              v462 = v458 * v459;
              v463 = v460 - v461;
              v464 = v461 - v462;
              v465 = v463 - v462;
              if (v464 < 0.0)
                v464 = -v464;
              v458 = v465 + v464;
              if (v714)
              {
                v457 = (float)(v457 + v459) - (float)(v459 * v457);
LABEL_615:
                *v14 = v458;
                *v7 = v457;
                goto LABEL_617;
              }
              *v14 = v458;
            }
          }
LABEL_617:
          v16 += v447;
          v466 = &v24[4 * v447];
          v467 = &v453[v713];
          if ((unint64_t)v466 >= v12)
            v468 = v452;
          else
            v468 = 0;
          v453 = &v467[v468];
          v24 = &v466[4 * v468];
          v7 += v714;
          v14 = (float *)((char *)v14 + v451);
          --v454;
        }
        while (v454);
        if (v27)
        {
          v469 = &v712[4 * v20];
          if ((unint64_t)v469 >= v27)
            v470 = v450;
          else
            v470 = 0;
          v11 += 4 * v21 + 4 * v470;
          if ((unint64_t)v469 >= v27)
            v471 = v449;
          else
            v471 = 0;
          v24 = &v469[4 * v471];
          v12 += 4 * v471 + 4 * v20;
          v453 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v453 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 23:
      v472 = v26;
      v473 = v23;
      v474 = -(v20 * v23);
      v475 = -(uint64_t)(v21 * v473);
      v476 = 4 * v26;
      v477 = -(uint64_t)v22;
      v478 = (float *)v11;
      while (1)
      {
        v479 = v10;
        do
        {
          if (*v16)
          {
            v480 = v713 ? *v478 : 1.0;
            v481 = (float)*v16 * 0.0039216;
            v482 = v481 * v480;
            if (v482 > 0.0)
            {
              v483 = v481 * *(float *)v24;
              if (v714)
              {
                v484 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_645;
              }
              else
              {
                v484 = 1.0;
              }
              v483 = (float)(v483 + *v14) + (float)((float)(v483 * *v14) * -2.0);
              if (v714)
              {
                v482 = (float)(v482 + v484) - (float)(v484 * v482);
LABEL_645:
                *v14 = v483;
                *v7 = v482;
                goto LABEL_647;
              }
              *v14 = v483;
            }
          }
LABEL_647:
          v16 += v472;
          v485 = &v24[4 * v472];
          v486 = &v478[v713];
          if ((unint64_t)v485 >= v12)
            v487 = v477;
          else
            v487 = 0;
          v478 = &v486[v487];
          v24 = &v485[4 * v487];
          v7 += v714;
          v14 = (float *)((char *)v14 + v476);
          --v479;
        }
        while (v479);
        if (v27)
        {
          v488 = &v712[4 * v20];
          if ((unint64_t)v488 >= v27)
            v489 = v475;
          else
            v489 = 0;
          v11 += 4 * v21 + 4 * v489;
          if ((unint64_t)v488 >= v27)
            v490 = v474;
          else
            v490 = 0;
          v24 = &v488[4 * v490];
          v12 += 4 * v490 + 4 * v20;
          v478 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v478 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 24:
      v491 = v26;
      v492 = v23;
      v493 = -(v20 * v23);
      v494 = -(uint64_t)(v21 * v492);
      v495 = 4 * v26;
      v496 = -(uint64_t)v22;
      v497 = (float *)v11;
      while (1)
      {
        v498 = v10;
        do
        {
          if (*v16)
          {
            v499 = v713 ? *v497 : 1.0;
            v500 = (float)*v16 * 0.0039216;
            v501 = v500 * v499;
            if (v501 > 0.0)
            {
              v502 = v500 * *(float *)v24;
              if (v714)
              {
                v503 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_680;
              }
              else
              {
                v503 = 1.0;
              }
              v504 = *v14;
              if (v501 == 1.0)
              {
                v505 = 0.0;
              }
              else
              {
                v504 = v501 * *v14;
                v505 = *v14 - v504;
              }
              v506 = (float)(v502 + v505) - (float)(v502 * v503);
              if (v503 == 1.0)
                v506 = v505;
              v502 = v504 + v506;
              if (v714)
              {
                v501 = (float)(v501 + v503) - (float)(v501 * v503);
LABEL_680:
                *v14 = v502;
                *v7 = v501;
                goto LABEL_682;
              }
              *v14 = v502;
            }
          }
LABEL_682:
          v16 += v491;
          v507 = &v24[4 * v491];
          v508 = &v497[v713];
          if ((unint64_t)v507 >= v12)
            v509 = v496;
          else
            v509 = 0;
          v497 = &v508[v509];
          v24 = &v507[4 * v509];
          v7 += v714;
          v14 = (float *)((char *)v14 + v495);
          --v498;
        }
        while (v498);
        if (v27)
        {
          v510 = &v712[4 * v20];
          if ((unint64_t)v510 >= v27)
            v511 = v494;
          else
            v511 = 0;
          v11 += 4 * v21 + 4 * v511;
          if ((unint64_t)v510 >= v27)
            v512 = v493;
          else
            v512 = 0;
          v24 = &v510[4 * v512];
          v12 += 4 * v512 + 4 * v20;
          v497 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v497 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 25:
      v513 = v26;
      v514 = v23;
      v515 = -(v20 * v23);
      v516 = -(uint64_t)(v21 * v514);
      v517 = 4 * v26;
      v518 = -(uint64_t)v22;
      v519 = (float *)v11;
      while (1)
      {
        v520 = v10;
        do
        {
          if (*v16)
          {
            v521 = v713 ? *v519 : 1.0;
            v522 = (float)*v16 * 0.0039216;
            v523 = v522 * v521;
            if (v523 > 0.0)
            {
              v524 = v522 * *(float *)v24;
              if (v714)
              {
                v525 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_715;
              }
              else
              {
                v525 = 1.0;
              }
              v526 = *v14;
              if (v523 == 1.0)
              {
                v527 = 0.0;
              }
              else
              {
                v526 = v523 * *v14;
                v527 = *v14 - v526;
              }
              v528 = (float)(v524 + v527) - (float)(v524 * v525);
              if (v525 == 1.0)
                v528 = v527;
              v524 = v526 + v528;
              if (v714)
              {
                v523 = (float)(v523 + v525) - (float)(v523 * v525);
LABEL_715:
                *v14 = v524;
                *v7 = v523;
                goto LABEL_717;
              }
              *v14 = v524;
            }
          }
LABEL_717:
          v16 += v513;
          v529 = &v24[4 * v513];
          v530 = &v519[v713];
          if ((unint64_t)v529 >= v12)
            v531 = v518;
          else
            v531 = 0;
          v519 = &v530[v531];
          v24 = &v529[4 * v531];
          v7 += v714;
          v14 = (float *)((char *)v14 + v517);
          --v520;
        }
        while (v520);
        if (v27)
        {
          v532 = &v712[4 * v20];
          if ((unint64_t)v532 >= v27)
            v533 = v516;
          else
            v533 = 0;
          v11 += 4 * v21 + 4 * v533;
          if ((unint64_t)v532 >= v27)
            v534 = v515;
          else
            v534 = 0;
          v24 = &v532[4 * v534];
          v12 += 4 * v534 + 4 * v20;
          v519 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v519 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 26:
      v535 = v26;
      v536 = v23;
      v537 = -(v20 * v23);
      v538 = -(uint64_t)(v21 * v536);
      v539 = 4 * v26;
      v540 = -(uint64_t)v22;
      v541 = (float *)v11;
      while (1)
      {
        v542 = v10;
        do
        {
          if (*v16)
          {
            v543 = v713 ? *v541 : 1.0;
            v544 = (float)*v16 * 0.0039216;
            v545 = v544 * v543;
            if (v545 > 0.0)
            {
              v546 = v544 * *(float *)v24;
              if (v714)
              {
                v547 = *v7;
                if (*v7 <= 0.0)
                  goto LABEL_749;
              }
              else
              {
                v547 = 1.0;
              }
              v548 = *v14;
              v549 = v546 - (float)(v546 * v547);
              if (v547 == 1.0)
                v549 = 0.0;
              v550 = (float)(v548 + v549) - (float)(v545 * v548);
              if (v545 != 1.0)
              {
                v548 = v545 * v548;
                v549 = v550;
              }
              v546 = v548 + v549;
              if (v714)
              {
                v545 = (float)(v545 + v547) - (float)(v545 * v547);
LABEL_749:
                *v14 = v546;
                *v7 = v545;
                goto LABEL_751;
              }
              *v14 = v546;
            }
          }
LABEL_751:
          v16 += v535;
          v551 = &v24[4 * v535];
          v552 = &v541[v713];
          if ((unint64_t)v551 >= v12)
            v553 = v540;
          else
            v553 = 0;
          v541 = &v552[v553];
          v24 = &v551[4 * v553];
          v7 += v714;
          v14 = (float *)((char *)v14 + v539);
          --v542;
        }
        while (v542);
        if (v27)
        {
          v554 = &v712[4 * v20];
          if ((unint64_t)v554 >= v27)
            v555 = v538;
          else
            v555 = 0;
          v11 += 4 * v21 + 4 * v555;
          if ((unint64_t)v554 >= v27)
            v556 = v537;
          else
            v556 = 0;
          v24 = &v554[4 * v556];
          v12 += 4 * v556 + 4 * v20;
          v541 = (float *)v11;
          v712 = v24;
        }
        else
        {
          v24 += 4 * v20;
          v541 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v711;
        if (!--v9)
          return;
      }
    case 27:
      v557 = v26;
      v558 = v23;
      v559 = -(v20 * v23);
      v560 = -(uint64_t)(v21 * v558);
      v561 = 4 * v26;
      v562 = -(uint64_t)v22;
      v563 = (float *)v11;
      break;
    default:
      return;
  }
LABEL_767:
  v564 = v10;
  while (1)
  {
    if (!*v16)
      goto LABEL_785;
    v565 = v713 ? *v563 : 1.0;
    v566 = (float)*v16 * 0.0039216;
    v567 = v566 * v565;
    if (v567 <= 0.0)
      goto LABEL_785;
    v568 = v566 * *(float *)v24;
    if (v714)
    {
      v569 = *v7;
      if (*v7 <= 0.0)
        goto LABEL_783;
    }
    else
    {
      v569 = 1.0;
    }
    v570 = *v14 - (float)(v567 * *v14);
    if (v567 == 1.0)
      v570 = 0.0;
    v571 = (float)(v568 + v570) - (float)(v568 * v569);
    if (v569 != 1.0)
    {
      v568 = v568 * v569;
      v570 = v571;
    }
    v568 = v568 + v570;
    if (!v714)
    {
      *v14 = v568;
      goto LABEL_785;
    }
    v567 = (float)(v567 + v569) - (float)(v567 * v569);
LABEL_783:
    *v14 = v568;
    *v7 = v567;
LABEL_785:
    v16 += v557;
    v572 = &v24[4 * v557];
    v573 = &v563[v713];
    if ((unint64_t)v572 >= v12)
      v574 = v562;
    else
      v574 = 0;
    v563 = &v573[v574];
    v24 = &v572[4 * v574];
    v7 += v714;
    v14 = (float *)((char *)v14 + v561);
    if (!--v564)
    {
      if (v27)
      {
        v575 = &v712[4 * v20];
        if ((unint64_t)v575 >= v27)
          v576 = v560;
        else
          v576 = 0;
        v11 += 4 * v21 + 4 * v576;
        if ((unint64_t)v575 >= v27)
          v577 = v559;
        else
          v577 = 0;
        v24 = &v575[4 * v577];
        v12 += 4 * v577 + 4 * v20;
        v563 = (float *)v11;
        v712 = v24;
      }
      else
      {
        v24 += 4 * v20;
        v563 += v21;
      }
      v16 += v32;
      v14 += v33;
      v7 += v711;
      if (!--v9)
        return;
      goto LABEL_767;
    }
  }
}

uint64_t Wf_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  _BOOL4 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int *v23;
  unint64_t v24;
  uint64_t (*v25)(uint64_t, int *, int, int, int, int);
  uint64_t v26;
  int v27;
  int v28;
  uint64_t (*v29)(uint64_t, uint64_t, uint64_t, int);
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  _OWORD v35[64];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = (int *)*a1;
  memset(v35, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*((_QWORD *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v29, (uint64_t)v35) < 1)
    return 0xFFFFFFFFLL;
  v18 = *v6;
  v19 = *(_DWORD *)a3;
  v30 = v19;
  v31 = v18;
  if (v19 != 136319269)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      v23 = WF_image_sample;
      v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&WF_image_sample[2 * v20 + 2];
      if (v29)
      {
LABEL_28:
        v30 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v33 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_W8;
              goto LABEL_50;
            case 3u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_rgb32;
LABEL_50:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 0;
              break;
            case 5u:
              v30 = *(_DWORD *)a3;
              v25 = Wf_image_mark_rgb32;
LABEL_52:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 8;
              break;
            default:
              goto LABEL_36;
          }
          Wf_image_mark_image(v26, (uint64_t)&v29, v27, v28, (void (*)(uint64_t, _DWORD *))v25);
          return 1;
        }
        goto LABEL_36;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v23 = W8_image_sample;
        v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W8_image_sample[2 * v20 + 2];
        if (v29)
        {
LABEL_27:
          v32 = 4;
          goto LABEL_28;
        }
      }
      v23 = W16_image_sample;
      v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W16_image_sample[2 * v20 + 2];
      if (v29)
        goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!v34 && (~v33 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((v33 & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      Wf_mark_inner(*(_QWORD *)(*a1 + 56), v17);
      return 1;
    }
  }
  v29 = Wf_sample_Wf_inner;
LABEL_36:
  Wf_image_mark((uint64_t)a2, (uint64_t)&v29, v8, v17);
  return 1;
}

uint64_t Wf_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float *v6;
  float *v7;
  float v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  float v19;
  float v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t result;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  unsigned int v37;
  unsigned __int8 *v38;
  int v39;
  unsigned __int8 *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  unsigned __int8 *v47;
  unsigned int v48;
  unsigned __int8 *v49;
  unsigned int v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  float v54;
  uint64_t *v55;
  float v56;
  float v57;
  uint64_t *v58;
  uint64_t v59;
  uint64_t v60;
  unsigned __int8 *v61;
  uint64_t *v62;
  uint64_t v63;
  uint64_t v64;
  unsigned __int8 *v65;
  float v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;

  v6 = (float *)*((_QWORD *)a2 + 2);
  v7 = (float *)*((_QWORD *)a2 + 4);
  if (v7)
    v70 = *((_QWORD *)a2 + 5) - a5;
  else
    v70 = 0;
  v8 = *((float *)a2 + 2);
  v9 = *a2;
  v10 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 17);
  v12 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v14 = *((_QWORD *)a2 + 11);
  v15 = *((_QWORD *)a2 + 7) + v14 * a4;
  v16 = *(unsigned __int8 **)(a1 + 32);
  v17 = &v16[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v18 = 4 * (v7 != 0);
  if (*(_QWORD *)(a1 + 176))
  {
    v69 = *((_QWORD *)a2 + 13);
    v68 = *((_QWORD *)a2 + 15);
    v19 = fminf(v8, 1.0);
    v20 = 1.0 - v19;
    v67 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v68 - v15) | (v15 - v69)) < 0)
      {
        v22 = 0;
        v23 = 0;
      }
      else
      {
        v21 = ((v15 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v21 - 7 >= 9)
          v22 = -v11;
        else
          v22 = v11;
        v23 = weights_19497[v21] & 0xF;
      }
      result = v15 >> v13;
      v25 = &v16[(v15 >> v13) * v11];
      if (v9 == 1)
      {
        if (a5 >= 1)
        {
          result = v23;
          v26 = (uint64_t *)v67;
          v27 = a5;
          do
          {
            v28 = *(v26 - 1);
            v29 = *v26;
            v30 = &v25[v28];
            if (v17 >= &v25[v28])
              v31 = &v25[v28];
            else
              v31 = v17;
            if (v16 > v31)
              v31 = v16;
            v32 = *v31;
            if ((v29 & 0xF) != 0)
            {
              v33 = &v30[v29 >> 4];
              if (v17 < v33)
                v33 = v17;
              if (v16 > v33)
                v33 = v16;
              v34 = *v33;
              if (v23)
              {
                v35 = &v30[v22];
                if (v17 >= v35)
                  v36 = v35;
                else
                  v36 = v17;
                if (v16 > v36)
                  v36 = v16;
                v37 = *v36;
                v38 = &v35[v29 >> 4];
                if (v17 < v38)
                  v38 = v17;
                if (v16 > v38)
                  v38 = v16;
                v39 = BLEND8_19499[v23];
                v32 = v32 - ((v39 & v32) >> v23) + ((v39 & v37) >> v23);
                v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
              }
              v32 = v32
                  - ((BLEND8_19499[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_19499[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v23)
            {
              v40 = &v30[v22];
              if (v17 < &v30[v22])
                v40 = v17;
              if (v16 > v40)
                v40 = v16;
              v32 = v32 - ((BLEND8_19499[v23] & v32) >> v23) + ((BLEND8_19499[v23] & *v40) >> v23);
            }
            *v6 = *(float *)&_blt_float[v32] * v19;
            if (v7)
              *v7 = v19;
            v26 += 2;
            ++v6;
            v7 = (float *)((char *)v7 + v18);
            --v27;
          }
          while (v27);
        }
        goto LABEL_87;
      }
      if (a5 >= 1)
        break;
LABEL_87:
      v6 += v10;
      v15 += v14;
      v7 += v70;
      if (!--a6)
        return result;
    }
    v41 = (uint64_t *)v67;
    result = a5;
    while (1)
    {
      v42 = *(v41 - 1);
      v43 = *v41;
      v44 = &v25[v42];
      if (v17 >= &v25[v42])
        v45 = &v25[v42];
      else
        v45 = v17;
      if (v16 > v45)
        v45 = v16;
      v46 = *v45;
      if ((v43 & 0xF) != 0)
      {
        v47 = &v44[v43 >> 4];
        if (v17 < v47)
          v47 = v17;
        if (v16 > v47)
          v47 = v16;
        v48 = *v47;
        if (v23)
        {
          if (v17 >= &v44[v22])
            v49 = &v44[v22];
          else
            v49 = v17;
          if (v16 > v49)
            v49 = v16;
          v50 = *v49;
          v51 = &v44[v22 + (v43 >> 4)];
          if (v17 < v51)
            v51 = v17;
          if (v16 > v51)
            v51 = v16;
          v52 = BLEND8_19499[v23];
          v46 = v46 - ((v52 & v46) >> v23) + ((v52 & v50) >> v23);
          v48 = v48 - ((v52 & v48) >> v23) + ((v52 & *v51) >> v23);
        }
        v46 = v46
            - ((BLEND8_19499[*v41 & 0xF] & v46) >> (*v41 & 0xF))
            + ((BLEND8_19499[*v41 & 0xF] & v48) >> (*v41 & 0xF));
      }
      else if (v23)
      {
        v53 = &v44[v22];
        if (v17 < &v44[v22])
          v53 = v17;
        if (v16 > v53)
          v53 = v16;
        v46 = v46 - ((BLEND8_19499[v23] & v46) >> v23) + ((BLEND8_19499[v23] & *v53) >> v23);
      }
      v54 = *(float *)&_blt_float[v46] * v19;
      if (v7)
      {
        if (v19 < 1.0)
        {
          if (v19 > 0.0)
          {
            *v6 = v54 + (float)(*v6 * v20);
            *v7 = v19 + (float)(*v7 * v20);
          }
        }
        else
        {
          *v6 = v54;
          *v7 = v19;
        }
        goto LABEL_86;
      }
      if (v19 >= 1.0)
        goto LABEL_85;
      if (v19 > 0.0)
        break;
LABEL_86:
      v41 += 2;
      ++v6;
      v7 = (float *)((char *)v7 + v18);
      if (!--result)
        goto LABEL_87;
    }
    v54 = v54 + (float)(*v6 * v20);
LABEL_85:
    *v6 = v54;
    goto LABEL_86;
  }
  v55 = (uint64_t *)(v12 + 16 * a3);
  v56 = fminf(v8, 1.0);
  v57 = 1.0 - v56;
  do
  {
    result = (uint64_t)&v16[(v15 >> v13) * v11];
    if (v9 != 1)
    {
      v62 = v55;
      v63 = a5;
      if (a5 < 1)
        goto LABEL_116;
      while (1)
      {
        v64 = *v62;
        v62 += 2;
        v65 = (unsigned __int8 *)(result + v64);
        if ((unint64_t)v17 < result + v64)
          v65 = v17;
        if (v16 > v65)
          v65 = v16;
        v66 = *(float *)&_blt_float[*v65] * v56;
        if (v7)
        {
          if (v56 < 1.0)
          {
            if (v56 > 0.0)
            {
              *v6 = v66 + (float)(*v6 * v57);
              *v7 = v56 + (float)(*v7 * v57);
            }
          }
          else
          {
            *v6 = v66;
            *v7 = v56;
          }
          goto LABEL_115;
        }
        if (v56 >= 1.0)
          goto LABEL_114;
        if (v56 > 0.0)
          break;
LABEL_115:
        ++v6;
        v7 = (float *)((char *)v7 + v18);
        if (!--v63)
          goto LABEL_116;
      }
      v66 = v66 + (float)(*v6 * v57);
LABEL_114:
      *v6 = v66;
      goto LABEL_115;
    }
    if (a5 >= 1)
    {
      v58 = v55;
      v59 = a5;
      do
      {
        v60 = *v58;
        v58 += 2;
        v61 = (unsigned __int8 *)(result + v60);
        if ((unint64_t)v17 < result + v60)
          v61 = v17;
        if (v16 > v61)
          v61 = v16;
        *v6 = *(float *)&_blt_float[*v61] * v56;
        if (v7)
          *v7 = v56;
        ++v6;
        v7 = (float *)((char *)v7 + v18);
        --v59;
      }
      while (v59);
    }
LABEL_116:
    v6 += v10;
    v15 += v14;
    v7 += v70;
    --a6;
  }
  while (a6);
  return result;
}

void Wf_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  char v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  void *v40;
  int v41;
  int v42;
  int *v43;
  int v44;
  void *v45;
  void *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD v56[4];
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _QWORD *v73;
  int v74;
  int v75;
  int v76[4];

  v56[0] = a3;
  v56[1] = a4;
  v56[2] = *(_DWORD *)(a2 + 184);
  v8 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v58 = v8;
  if (*(_QWORD *)(a1 + 48))
    v9 = (unint64_t)*(int *)(a1 + 32) >> 2;
  else
    v9 = 0;
  v60 = v9;
  v10 = *(_QWORD *)(a2 + 120);
  v11 = *(_DWORD *)(a2 + 20);
  if (v10)
  {
    v12 = HIBYTE(v11);
    v13 = *(int *)(a2 + 24);
    v14 = (uint64_t *)(a2 + 104);
    v15 = (uint64_t *)(a2 + 72);
    v16 = (uint64_t *)(a2 + 88);
  }
  else
  {
    v12 = BYTE2(v11);
    v13 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v14 = (uint64_t *)(a2 + 96);
    v15 = (uint64_t *)(a2 + 64);
    v16 = (uint64_t *)(a2 + 80);
    v10 = *(_QWORD *)(a2 + 112);
  }
  v17 = *v16;
  v18 = *v15;
  v19 = *v14;
  v20 = v12;
  v63 = v12;
  v61 = v19;
  v71 = v13;
  v69 = v17;
  v67 = v18;
  v65 = v10;
  v21 = *(_QWORD *)(a2 + 128);
  v54 = v18;
  v55 = v17;
  if (v21)
  {
    v22 = BYTE2(v11);
    v23 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v24 = (uint64_t *)(a2 + 96);
    v25 = (uint64_t *)(a2 + 64);
    v26 = (uint64_t *)(a2 + 80);
  }
  else
  {
    v22 = HIBYTE(v11);
    v23 = *(int *)(a2 + 24);
    v24 = (uint64_t *)(a2 + 104);
    v25 = (uint64_t *)(a2 + 72);
    v26 = (uint64_t *)(a2 + 88);
    v21 = *(_QWORD *)(a2 + 136);
  }
  v27 = *v26;
  v28 = *v25;
  v29 = *v24;
  v64 = v22;
  v62 = v29;
  v72 = v23;
  v70 = v27;
  v68 = v28;
  v66 = v21;
  v30 = *(unsigned int *)(a1 + 4);
  if ((v30 & 0x80000000) == 0)
  {
    v31 = malloc_type_malloc(16 * v30, 0xABB5E7F1uLL);
    v73 = v31;
    if (v31)
    {
      if (*(_QWORD *)(a2 + 176))
      {
        if ((_DWORD)v30)
        {
          v33 = v31 + 1;
          v34 = v55 - v19;
          do
          {
            if (((v19 - v54) | v34) < 0)
            {
              v37 = 0;
              v38 = 0;
            }
            else
            {
              v35 = ((v19 & (unint64_t)~(-1 << v20)) >> (v20 - 4)) & 0xF;
              v36 = weights_19497[v35];
              if (v35 - 7 >= 9)
                v37 = -(uint64_t)v13;
              else
                v37 = v13;
              v38 = v36 & 0xF;
            }
            *(v33 - 1) = v13 * (v19 >> v20);
            *v33 = v38 | (16 * v37);
            v33 += 2;
            v19 += v10;
            v34 -= v10;
            --v30;
          }
          while (v30);
        }
      }
      else if ((_DWORD)v30)
      {
        v39 = v31 + 1;
        do
        {
          *(v39 - 1) = v13 * (v19 >> v20);
          *v39 = 0;
          v39 += 2;
          v19 += v10;
          --v30;
        }
        while (v30);
      }
      v40 = v31;
      v41 = *(_DWORD *)(a1 + 4);
      v42 = *(_DWORD *)(a1 + 8);
      v74 = v42;
      v75 = v41;
      v43 = *(int **)(a1 + 136);
      if (v43)
      {
        v44 = *(_DWORD *)(a1 + 104);
        v76[0] = *(_DWORD *)(a1 + 108);
        v76[1] = v44;
        shape_enum_clip_alloc((uint64_t)v31, v32, v43, 1, 1, 1, v44, v76[0], v41, v42);
        v46 = v45;
        if (v45)
          goto LABEL_32;
      }
      v47 = 0;
      v48 = 0;
      v46 = 0;
      *(_QWORD *)v76 = 0;
      while (1)
      {
        v49 = *(int *)(a1 + 16) + (uint64_t)v48;
        v50 = *(_QWORD *)(a1 + 48);
        v51 = v47 + *(_DWORD *)(a1 + 12);
        v52 = *(_QWORD *)(a1 + 40) + 4 * v8 * v49 + 4 * v51;
        v53 = v50 + 4 * v9 * v49 + 4 * v51;
        if (!v50)
          v53 = 0;
        v57 = v52;
        v59 = v53;
        a5(a2, v56);
        if (!v46)
          break;
LABEL_32:
        if (!shape_enum_clip_next((uint64_t)v46, &v76[1], v76, &v75, &v74))
        {
          free(v46);
          break;
        }
        v48 = v76[0];
        v47 = v76[1];
        v8 = v58;
        v9 = v60;
      }
      free(v40);
    }
  }
}

uint64_t Wf_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  float *v6;
  float *v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t result;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  unsigned __int8 *v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  unsigned int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  int v55;
  unsigned __int8 *v56;
  unsigned int v57;
  unsigned __int8 *v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  uint64_t *v64;
  float v65;
  float v66;
  float v67;
  unsigned __int8 *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 *v72;
  float v73;
  float v74;
  float v75;
  float v76;
  float v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;

  v6 = (float *)*((_QWORD *)a2 + 2);
  v7 = (float *)*((_QWORD *)a2 + 4);
  if (v7)
    v91 = *((_QWORD *)a2 + 5) - a5;
  else
    v91 = 0;
  v8 = *((float *)a2 + 2);
  v90 = *a2;
  v9 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 17);
  v10 = *((_QWORD *)a2 + 18);
  v12 = *((_QWORD *)a2 + 9);
  v13 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v13 * a4;
  v15 = *(unsigned __int8 **)(a1 + 32);
  v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v7 != 0);
  if (v17)
  {
    v88 = *((_QWORD *)a2 + 15);
    v89 = *((_QWORD *)a2 + 13);
    v19 = v8 * 0.3;
    v20 = v8 * 0.59;
    v21 = v8 * 0.11;
    v87 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v88 - v14) | (v14 - v89)) < 0)
      {
        v24 = 0;
        v23 = 0;
      }
      else
      {
        v22 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v22 - 7 >= 9)
          v23 = -v11;
        else
          v23 = v11;
        v24 = weights_19497[v22] & 0xF;
      }
      v25 = &v15[(v14 >> v12) * v11];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          v26 = (uint64_t *)v87;
          v27 = a5;
          do
          {
            v28 = *(v26 - 1);
            v29 = *v26;
            v30 = &v25[v28];
            if (v16 >= &v25[v28])
              v31 = &v25[v28];
            else
              v31 = v16;
            if (v15 > v31)
              v31 = v15;
            v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if ((v29 & 0xF) != 0)
            {
              v33 = &v30[v29 >> 4];
              if (v16 < v33)
                v33 = v16;
              if (v15 > v33)
                v33 = v15;
              v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
              if (v24)
              {
                if (v16 >= &v30[v23])
                  v35 = &v30[v23];
                else
                  v35 = v16;
                if (v15 > v35)
                  v35 = v15;
                v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                v37 = &v30[v23 + (v29 >> 4)];
                if (v16 < v37)
                  v37 = v16;
                if (v15 > v37)
                  v37 = v15;
                v38 = BLEND8_19499[v24];
                v32 = v32 - ((v38 & v32) >> v24) + ((v38 & v36) >> v24);
                v34 = v34 - ((v38 & v34) >> v24) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v24);
              }
              v32 = v32
                  - ((BLEND8_19499[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_19499[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v24)
            {
              v39 = &v30[v23];
              if (v16 < &v30[v23])
                v39 = v16;
              if (v15 > v39)
                v39 = v15;
              v32 = v32
                  - ((BLEND8_19499[v24] & v32) >> v24)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_19499[v24]) >> v24);
            }
            v40 = *(float *)&_blt_float[HIBYTE(v32)];
            v41 = *(float *)&_blt_float[BYTE2(v32)];
            v42 = *(float *)&_blt_float[BYTE1(v32)];
            if (v8 >= 1.0)
            {
              v43 = (float)((float)(v40 * 0.3) + (float)(v41 * 0.59)) + (float)(v42 * 0.11);
              v44 = 1.0;
            }
            else
            {
              v43 = (float)((float)(v19 * v40) + (float)(v20 * v41)) + (float)(v21 * v42);
              v44 = v8;
            }
            *v6 = v43;
            if (v7)
              *v7 = v44;
            v26 += 2;
            ++v6;
            v7 = (float *)((char *)v7 + result);
            --v27;
          }
          while (v27);
        }
        goto LABEL_93;
      }
      if (a5 >= 1)
        break;
LABEL_93:
      v6 += v9;
      v14 += v13;
      v7 += v91;
      if (!--a6)
        return result;
    }
    v46 = (uint64_t *)v87;
    v45 = a5;
    while (1)
    {
      v47 = *(v46 - 1);
      v48 = *v46;
      v49 = &v25[v47];
      if (v16 >= &v25[v47])
        v50 = &v25[v47];
      else
        v50 = v16;
      if (v15 > v50)
        v50 = v15;
      v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      if ((v48 & 0xF) != 0)
      {
        v52 = &v49[v48 >> 4];
        if (v16 < v52)
          v52 = v16;
        if (v15 > v52)
          v52 = v15;
        v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
        if (v24)
        {
          if (v16 >= &v49[v23])
            v54 = &v49[v23];
          else
            v54 = v16;
          if (v15 > v54)
            v54 = v15;
          v55 = (*v54 << 24) | (v54[1] << 16) | (v54[2] << 8);
          v56 = &v49[v23 + (v48 >> 4)];
          if (v16 < v56)
            v56 = v16;
          if (v15 > v56)
            v56 = v15;
          v57 = BLEND8_19499[v24];
          v51 = v51 - ((v57 & v51) >> v24) + ((v57 & v55) >> v24);
          v53 = v53 - ((v57 & v53) >> v24) + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & v57) >> v24);
        }
        v51 = v51
            - ((BLEND8_19499[*v46 & 0xF] & v51) >> (*v46 & 0xF))
            + ((BLEND8_19499[*v46 & 0xF] & v53) >> (*v46 & 0xF));
      }
      else if (v24)
      {
        v58 = &v49[v23];
        if (v16 < &v49[v23])
          v58 = v16;
        if (v15 > v58)
          v58 = v15;
        v51 = v51
            - ((BLEND8_19499[v24] & v51) >> v24)
            + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & BLEND8_19499[v24]) >> v24);
      }
      v59 = *(float *)&_blt_float[HIBYTE(v51)];
      v60 = *(float *)&_blt_float[BYTE2(v51)];
      v61 = *(float *)&_blt_float[BYTE1(v51)];
      if (v8 >= 1.0)
      {
        v62 = (float)((float)(v59 * 0.3) + (float)(v60 * 0.59)) + (float)(v61 * 0.11);
        v63 = 1.0;
      }
      else
      {
        v62 = (float)((float)(v19 * v59) + (float)(v20 * v60)) + (float)(v21 * v61);
        v63 = v8;
      }
      if (v7)
      {
        if (v63 < 1.0)
        {
          if (v63 > 0.0)
          {
            *v6 = v62 + (float)(*v6 * (float)(1.0 - v63));
            *v7 = v63 + (float)(*v7 * (float)(1.0 - v63));
          }
        }
        else
        {
          *v6 = v62;
          *v7 = v63;
        }
        goto LABEL_92;
      }
      if (v63 >= 1.0)
        goto LABEL_91;
      if (v63 > 0.0)
        break;
LABEL_92:
      v46 += 2;
      ++v6;
      v7 = (float *)((char *)v7 + result);
      if (!--v45)
        goto LABEL_93;
    }
    v62 = v62 + (float)(*v6 * (float)(1.0 - v63));
LABEL_91:
    *v6 = v62;
    goto LABEL_92;
  }
  v64 = (uint64_t *)(v10 + 16 * a3);
  v65 = v8 * 0.3;
  v66 = v8 * 0.59;
  v67 = v8 * 0.11;
  do
  {
    v68 = &v15[(v14 >> v12) * v11];
    if (v90 != 1)
    {
      v78 = v64;
      v79 = a5;
      if (a5 < 1)
        goto LABEL_128;
      while (1)
      {
        v80 = *v78;
        v78 += 2;
        v81 = &v68[v80];
        if (v16 < &v68[v80])
          v81 = v16;
        if (v15 > v81)
          v81 = v15;
        v82 = *(float *)&_blt_float[*v81];
        v83 = *(float *)&_blt_float[v81[1]];
        v84 = *(float *)&_blt_float[v81[2]];
        if (v8 >= 1.0)
        {
          v85 = (float)((float)(v82 * 0.3) + (float)(v83 * 0.59)) + (float)(v84 * 0.11);
          v86 = 1.0;
        }
        else
        {
          v85 = (float)((float)(v65 * v82) + (float)(v66 * v83)) + (float)(v67 * v84);
          v86 = v8;
        }
        if (v7)
        {
          if (v86 < 1.0)
          {
            if (v86 > 0.0)
            {
              *v6 = v85 + (float)(*v6 * (float)(1.0 - v86));
              *v7 = v86 + (float)(*v7 * (float)(1.0 - v86));
            }
          }
          else
          {
            *v6 = v85;
            *v7 = v86;
          }
          goto LABEL_127;
        }
        if (v86 >= 1.0)
          goto LABEL_126;
        if (v86 > 0.0)
          break;
LABEL_127:
        ++v6;
        v7 = (float *)((char *)v7 + result);
        if (!--v79)
          goto LABEL_128;
      }
      v85 = v85 + (float)(*v6 * (float)(1.0 - v86));
LABEL_126:
      *v6 = v85;
      goto LABEL_127;
    }
    if (a5 >= 1)
    {
      v69 = v64;
      v70 = a5;
      do
      {
        v71 = *v69;
        v69 += 2;
        v72 = &v68[v71];
        if (v16 < &v68[v71])
          v72 = v16;
        if (v15 > v72)
          v72 = v15;
        v73 = *(float *)&_blt_float[*v72];
        v74 = *(float *)&_blt_float[v72[1]];
        v75 = *(float *)&_blt_float[v72[2]];
        if (v8 >= 1.0)
        {
          v76 = (float)((float)(v73 * 0.3) + (float)(v74 * 0.59)) + (float)(v75 * 0.11);
          v77 = 1.0;
        }
        else
        {
          v76 = (float)((float)(v65 * v73) + (float)(v66 * v74)) + (float)(v67 * v75);
          v77 = v8;
        }
        *v6 = v76;
        if (v7)
          *v7 = v77;
        ++v6;
        v7 = (float *)((char *)v7 + result);
        --v70;
      }
      while (v70);
    }
LABEL_128:
    v6 += v9;
    v14 += v13;
    v7 += v91;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  float *v7;
  float *v8;
  float v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t result;
  char v19;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int *v32;
  unsigned int v33;
  char v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  int v46;
  unsigned int v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  unsigned int *v60;
  unsigned int v61;
  char v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int *v67;
  int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int *v72;
  int v73;
  unsigned int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  float v83;
  float v84;
  float v85;
  char *v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int *v90;
  unsigned int v91;
  float v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  uint64_t *v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int *v102;
  unsigned int v103;
  float v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  uint64_t v118;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (float *)*((_QWORD *)a2 + 2);
  v8 = (float *)*((_QWORD *)a2 + 4);
  if (v8)
    v118 = *((_QWORD *)a2 + 5) - a5;
  else
    v118 = 0;
  v9 = *((float *)a2 + 2);
  v10 = a2[1];
  v117 = *a2;
  v116 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 17);
  v12 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v115 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v115 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v8 != 0);
  if (v17)
  {
    v114 = *((_QWORD *)a2 + 13);
    v113 = *((_QWORD *)a2 + 15);
    v19 = 32 - v10;
    v20 = v9 * 0.3;
    v21 = v9 * 0.59;
    v22 = v9 * 0.11;
    v112 = v12 + 16 * a3 + 8;
    while (1)
    {
      if (((v113 - v14) | (v14 - v114)) < 0)
      {
        v25 = 0;
        v24 = 0;
      }
      else
      {
        v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        v24 = v23 - 7 >= 9 ? -v11 : v11;
        v25 = weights_19497[v23] & 0xF;
      }
      v26 = (char *)v15 + (v14 >> v13) * v11;
      if (v117 != 1)
        break;
      if (a5 >= 1)
      {
        v27 = (uint64_t *)v112;
        v28 = a5;
        while (1)
        {
          v29 = *(v27 - 1);
          v30 = *v27;
          v31 = &v26[v29];
          if (v16 >= (unsigned int *)&v26[v29])
            v32 = (unsigned int *)&v26[v29];
          else
            v32 = v16;
          if (v15 > v32)
            v32 = v15;
          v33 = bswap32(*v32);
          v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0)
            break;
          if (v25)
          {
            v45 = (unsigned int *)&v31[v24];
            if (v16 < (unsigned int *)&v31[v24])
              v45 = v16;
            if (v15 > v45)
              v45 = v15;
            v46 = BLEND8_19499[v25];
            v43 = v33 - ((v46 & v33) >> v25);
            v44 = (bswap32(*v45) & v46) >> v25;
            goto LABEL_46;
          }
LABEL_47:
          v47 = __ROL4__(v33, v10);
          v48 = *(float *)&_blt_float[HIBYTE(v47)];
          v49 = *(float *)&_blt_float[BYTE2(v47)];
          v50 = *(float *)&_blt_float[BYTE1(v47)];
          v51 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
          if (v9 >= 1.0)
          {
            v52 = v48 * 0.3;
            v53 = v49 * 0.59;
            v54 = v50 * 0.11;
          }
          else
          {
            v52 = v20 * v48;
            v53 = v21 * v49;
            v54 = v22 * v50;
            v51 = v9 * v51;
          }
          *v7 = (float)(v52 + v53) + v54;
          if (v8)
            *v8 = v51;
          v27 += 2;
          ++v7;
          v8 = (float *)((char *)v8 + result);
          if (!--v28)
            goto LABEL_99;
        }
        v35 = (unsigned int *)&v31[v30 >> 4];
        if (v16 < v35)
          v35 = v16;
        if (v15 > v35)
          v35 = v15;
        v36 = bswap32(*v35);
        if (v25)
        {
          v37 = (unsigned int *)&v31[v24];
          if (v16 >= v37)
            v38 = v37;
          else
            v38 = v16;
          if (v15 > v38)
            v38 = v15;
          v39 = bswap32(*v38);
          v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v16 < v40)
            v40 = v16;
          if (v15 > v40)
            v40 = v15;
          v41 = BLEND8_19499[v25];
          v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          v36 = v36 - ((v41 & v36) >> v25) + ((bswap32(*v40) & v41) >> v25);
        }
        v42 = BLEND8_19499[*v27 & 0xF];
        v43 = v33 - ((v42 & v33) >> v34);
        v44 = (v42 & v36) >> v34;
LABEL_46:
        v33 = v43 + v44;
        goto LABEL_47;
      }
LABEL_99:
      v7 += v116;
      v14 += v115;
      v8 += v118;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_99;
    v56 = (uint64_t *)v112;
    v55 = a5;
    while (1)
    {
      v57 = *(v56 - 1);
      v58 = *v56;
      v59 = &v26[v57];
      if (v16 >= (unsigned int *)&v26[v57])
        v60 = (unsigned int *)&v26[v57];
      else
        v60 = v16;
      if (v15 > v60)
        v60 = v15;
      v61 = bswap32(*v60);
      v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        v63 = (unsigned int *)&v59[v58 >> 4];
        if (v16 < v63)
          v63 = v16;
        if (v15 > v63)
          v63 = v15;
        v64 = bswap32(*v63);
        if (v25)
        {
          if (v16 >= (unsigned int *)&v59[v24])
            v65 = (unsigned int *)&v59[v24];
          else
            v65 = v16;
          if (v15 > v65)
            v65 = v15;
          v66 = bswap32(*v65);
          v67 = (unsigned int *)&v59[v24 + (v58 >> 4)];
          if (v16 < v67)
            v67 = v16;
          if (v15 > v67)
            v67 = v15;
          v68 = BLEND8_19499[v25];
          v61 = v61 - ((v68 & v61) >> v25) + ((v68 & v66) >> v25);
          v64 = v64 - ((v68 & v64) >> v25) + ((bswap32(*v67) & v68) >> v25);
        }
        v69 = BLEND8_19499[*v56 & 0xF];
        v70 = v61 - ((v69 & v61) >> v62);
        v71 = (v69 & v64) >> v62;
      }
      else
      {
        if (!v25)
          goto LABEL_85;
        v72 = (unsigned int *)&v59[v24];
        if (v16 < (unsigned int *)&v59[v24])
          v72 = v16;
        if (v15 > v72)
          v72 = v15;
        v73 = BLEND8_19499[v25];
        v70 = v61 - ((v73 & v61) >> v25);
        v71 = (bswap32(*v72) & v73) >> v25;
      }
      v61 = v70 + v71;
LABEL_85:
      v74 = __ROL4__(v61, v10);
      v75 = *(float *)&_blt_float[HIBYTE(v74)];
      v76 = *(float *)&_blt_float[BYTE2(v74)];
      v77 = *(float *)&_blt_float[BYTE1(v74)];
      v78 = *(float *)&_blt_float[(((_BYTE)v61 << v10) | (v61 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        v79 = v75 * 0.3;
        v80 = v76 * 0.59;
        v81 = v77 * 0.11;
      }
      else
      {
        v79 = v20 * v75;
        v80 = v21 * v76;
        v81 = v22 * v77;
        v78 = v9 * v78;
      }
      v82 = (float)(v79 + v80) + v81;
      if (!v8)
      {
        if (v78 < 1.0)
        {
          if (v78 > 0.0)
            *v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        }
        else
        {
          *v7 = v82;
        }
        goto LABEL_98;
      }
      if (v78 >= 1.0)
      {
        *v7 = v82;
LABEL_97:
        *v8 = v78;
        goto LABEL_98;
      }
      if (v78 > 0.0)
      {
        *v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        v78 = v78 + (float)(*v8 * (float)(1.0 - v78));
        goto LABEL_97;
      }
LABEL_98:
      v56 += 2;
      ++v7;
      v8 = (float *)((char *)v8 + result);
      if (!--v55)
        goto LABEL_99;
    }
  }
  v83 = v9 * 0.3;
  v84 = v9 * 0.59;
  v85 = v9 * 0.11;
  do
  {
    v86 = (char *)v15 + (v14 >> v13) * v11;
    if (v117 != 1)
    {
      v99 = (uint64_t *)(v12 + 16 * a3);
      v100 = a5;
      if (a5 < 1)
        goto LABEL_135;
      while (1)
      {
        v101 = *v99;
        v99 += 2;
        v102 = (unsigned int *)&v86[v101];
        if (v16 < (unsigned int *)&v86[v101])
          v102 = v16;
        if (v15 > v102)
          v102 = v15;
        v103 = __ROL4__(bswap32(*v102), v10);
        v104 = *(float *)&_blt_float[HIBYTE(v103)];
        v105 = *(float *)&_blt_float[BYTE2(v103)];
        v106 = *(float *)&_blt_float[BYTE1(v103)];
        v107 = *(float *)&_blt_float[v103 | v6];
        if (v9 >= 1.0)
        {
          v108 = v104 * 0.3;
          v109 = v105 * 0.59;
          v110 = v106 * 0.11;
        }
        else
        {
          v108 = v83 * v104;
          v109 = v84 * v105;
          v110 = v85 * v106;
          v107 = v9 * v107;
        }
        v111 = (float)(v108 + v109) + v110;
        if (!v8)
        {
          if (v107 < 1.0)
          {
            if (v107 > 0.0)
              *v7 = v111 + (float)(*v7 * (float)(1.0 - v107));
          }
          else
          {
            *v7 = v111;
          }
          goto LABEL_134;
        }
        if (v107 >= 1.0)
          break;
        if (v107 > 0.0)
        {
          *v7 = v111 + (float)(*v7 * (float)(1.0 - v107));
          v107 = v107 + (float)(*v8 * (float)(1.0 - v107));
          goto LABEL_133;
        }
LABEL_134:
        ++v7;
        v8 = (float *)((char *)v8 + result);
        if (!--v100)
          goto LABEL_135;
      }
      *v7 = v111;
LABEL_133:
      *v8 = v107;
      goto LABEL_134;
    }
    if (a5 >= 1)
    {
      v87 = (uint64_t *)(v12 + 16 * a3);
      v88 = a5;
      do
      {
        v89 = *v87;
        v87 += 2;
        v90 = (unsigned int *)&v86[v89];
        if (v16 < (unsigned int *)&v86[v89])
          v90 = v16;
        if (v15 > v90)
          v90 = v15;
        v91 = __ROL4__(bswap32(*v90), v10);
        v92 = *(float *)&_blt_float[HIBYTE(v91)];
        v93 = *(float *)&_blt_float[BYTE2(v91)];
        v94 = *(float *)&_blt_float[BYTE1(v91)];
        v95 = *(float *)&_blt_float[v91 | v6];
        if (v9 >= 1.0)
        {
          v96 = v92 * 0.3;
          v97 = v93 * 0.59;
          v98 = v94 * 0.11;
        }
        else
        {
          v96 = v83 * v92;
          v97 = v84 * v93;
          v98 = v85 * v94;
          v95 = v9 * v95;
        }
        *v7 = (float)(v96 + v97) + v98;
        if (v8)
          *v8 = v95;
        ++v7;
        v8 = (float *)((char *)v8 + result);
        --v88;
      }
      while (v88);
    }
LABEL_135:
    v7 += v116;
    v14 += v115;
    v8 += v118;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t Wf_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  float *v7;
  float *v8;
  float v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t result;
  char v19;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int *v32;
  unsigned int v33;
  char v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int *v45;
  unsigned int v46;
  unsigned int v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  uint64_t v55;
  uint64_t *v56;
  uint64_t v57;
  uint64_t v58;
  char *v59;
  unsigned int *v60;
  unsigned int v61;
  char v62;
  unsigned int *v63;
  unsigned int v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int *v67;
  unsigned int v68;
  int v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int *v72;
  unsigned int v73;
  unsigned int v74;
  float v75;
  float v76;
  float v77;
  float v78;
  float v79;
  float v80;
  float v81;
  float v82;
  uint64_t *v83;
  float v84;
  float v85;
  float v86;
  char *v87;
  uint64_t *v88;
  uint64_t v89;
  uint64_t v90;
  unsigned int *v91;
  unsigned int v92;
  float v93;
  float v94;
  float v95;
  float v96;
  float v97;
  float v98;
  float v99;
  uint64_t *v100;
  uint64_t v101;
  uint64_t v102;
  unsigned int *v103;
  unsigned int v104;
  float v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  int v118;
  uint64_t v119;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (float *)*((_QWORD *)a2 + 2);
  v8 = (float *)*((_QWORD *)a2 + 4);
  if (v8)
    v119 = *((_QWORD *)a2 + 5) - a5;
  else
    v119 = 0;
  v9 = *((float *)a2 + 2);
  v10 = a2[1];
  v118 = *a2;
  v117 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v116 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v116 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v8 != 0);
  if (v17)
  {
    v115 = *((_QWORD *)a2 + 13);
    v114 = *((_QWORD *)a2 + 15);
    v19 = 32 - v10;
    v20 = v9 * 0.3;
    v21 = v9 * 0.59;
    v22 = v9 * 0.11;
    v113 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v114 - v14) | (v14 - v115)) < 0)
      {
        v25 = 0;
        v24 = 0;
      }
      else
      {
        v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        v24 = v23 - 7 >= 9 ? -v12 : v12;
        v25 = weights_19497[v23] & 0xF;
      }
      v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v118 != 1)
        break;
      if (a5 >= 1)
      {
        v27 = (uint64_t *)v113;
        v28 = a5;
        while (1)
        {
          v29 = *(v27 - 1);
          v30 = *v27;
          v31 = &v26[v29];
          if (v16 >= (unsigned int *)&v26[v29])
            v32 = (unsigned int *)&v26[v29];
          else
            v32 = v16;
          if (v15 > v32)
            v32 = v15;
          v33 = *v32;
          v34 = v30 & 0xF;
          if ((v30 & 0xF) != 0)
            break;
          if (v25)
          {
            v45 = (unsigned int *)&v31[v24];
            if (v16 < (unsigned int *)&v31[v24])
              v45 = v16;
            if (v15 > v45)
              v45 = v15;
            v46 = BLEND8_19499[v25];
            v43 = v33 - ((v46 & v33) >> v25);
            v44 = (v46 & *v45) >> v25;
            goto LABEL_46;
          }
LABEL_47:
          v47 = __ROL4__(v33, v10);
          v48 = *(float *)&_blt_float[HIBYTE(v47)];
          v49 = *(float *)&_blt_float[BYTE2(v47)];
          v50 = *(float *)&_blt_float[BYTE1(v47)];
          v51 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
          if (v9 >= 1.0)
          {
            v52 = v48 * 0.3;
            v53 = v49 * 0.59;
            v54 = v50 * 0.11;
          }
          else
          {
            v52 = v20 * v48;
            v53 = v21 * v49;
            v54 = v22 * v50;
            v51 = v9 * v51;
          }
          *v7 = (float)(v52 + v53) + v54;
          if (v8)
            *v8 = v51;
          v27 += 2;
          ++v7;
          v8 = (float *)((char *)v8 + result);
          if (!--v28)
            goto LABEL_99;
        }
        v35 = (unsigned int *)&v31[v30 >> 4];
        if (v16 < v35)
          v35 = v16;
        if (v15 > v35)
          v35 = v15;
        v36 = *v35;
        if (v25)
        {
          v37 = (unsigned int *)&v31[v24];
          if (v16 >= v37)
            v38 = v37;
          else
            v38 = v16;
          if (v15 > v38)
            v38 = v15;
          v39 = *v38;
          v40 = (unsigned int *)((char *)v37 + (v30 >> 4));
          if (v16 < v40)
            v40 = v16;
          if (v15 > v40)
            v40 = v15;
          v41 = BLEND8_19499[v25];
          v33 = v33 - ((v41 & v33) >> v25) + ((v41 & v39) >> v25);
          v36 = v36 - ((v41 & v36) >> v25) + ((v41 & *v40) >> v25);
        }
        v42 = BLEND8_19499[*v27 & 0xF];
        v43 = v33 - ((v42 & v33) >> v34);
        v44 = (v42 & v36) >> v34;
LABEL_46:
        v33 = v43 + v44;
        goto LABEL_47;
      }
LABEL_99:
      v7 += v117;
      v14 += v116;
      v8 += v119;
      if (!--a6)
        return result;
    }
    if (a5 < 1)
      goto LABEL_99;
    v56 = (uint64_t *)v113;
    v55 = a5;
    while (1)
    {
      v57 = *(v56 - 1);
      v58 = *v56;
      v59 = &v26[v57];
      if (v16 >= (unsigned int *)&v26[v57])
        v60 = (unsigned int *)&v26[v57];
      else
        v60 = v16;
      if (v15 > v60)
        v60 = v15;
      v61 = *v60;
      v62 = v58 & 0xF;
      if ((v58 & 0xF) != 0)
      {
        v63 = (unsigned int *)&v59[v58 >> 4];
        if (v16 < v63)
          v63 = v16;
        if (v15 > v63)
          v63 = v15;
        v64 = *v63;
        if (v25)
        {
          if (v16 >= (unsigned int *)&v59[v24])
            v65 = (unsigned int *)&v59[v24];
          else
            v65 = v16;
          if (v15 > v65)
            v65 = v15;
          v66 = *v65;
          v67 = (unsigned int *)&v59[v24 + (v58 >> 4)];
          if (v16 < v67)
            v67 = v16;
          if (v15 > v67)
            v67 = v15;
          v68 = BLEND8_19499[v25];
          v61 = v61 - ((v68 & v61) >> v25) + ((v68 & v66) >> v25);
          v64 = v64 - ((v68 & v64) >> v25) + ((v68 & *v67) >> v25);
        }
        v69 = BLEND8_19499[*v56 & 0xF];
        v70 = v61 - ((v69 & v61) >> v62);
        v71 = (v69 & v64) >> v62;
      }
      else
      {
        if (!v25)
          goto LABEL_85;
        v72 = (unsigned int *)&v59[v24];
        if (v16 < (unsigned int *)&v59[v24])
          v72 = v16;
        if (v15 > v72)
          v72 = v15;
        v73 = BLEND8_19499[v25];
        v70 = v61 - ((v73 & v61) >> v25);
        v71 = (v73 & *v72) >> v25;
      }
      v61 = v70 + v71;
LABEL_85:
      v74 = __ROL4__(v61, v10);
      v75 = *(float *)&_blt_float[HIBYTE(v74)];
      v76 = *(float *)&_blt_float[BYTE2(v74)];
      v77 = *(float *)&_blt_float[BYTE1(v74)];
      v78 = *(float *)&_blt_float[(((_BYTE)v61 << v10) | (v61 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        v79 = v75 * 0.3;
        v80 = v76 * 0.59;
        v81 = v77 * 0.11;
      }
      else
      {
        v79 = v20 * v75;
        v80 = v21 * v76;
        v81 = v22 * v77;
        v78 = v9 * v78;
      }
      v82 = (float)(v79 + v80) + v81;
      if (!v8)
      {
        if (v78 < 1.0)
        {
          if (v78 > 0.0)
            *v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        }
        else
        {
          *v7 = v82;
        }
        goto LABEL_98;
      }
      if (v78 >= 1.0)
      {
        *v7 = v82;
LABEL_97:
        *v8 = v78;
        goto LABEL_98;
      }
      if (v78 > 0.0)
      {
        *v7 = v82 + (float)(*v7 * (float)(1.0 - v78));
        v78 = v78 + (float)(*v8 * (float)(1.0 - v78));
        goto LABEL_97;
      }
LABEL_98:
      v56 += 2;
      ++v7;
      v8 = (float *)((char *)v8 + result);
      if (!--v55)
        goto LABEL_99;
    }
  }
  v83 = (uint64_t *)(v11 + 16 * a3);
  v84 = v9 * 0.3;
  v85 = v9 * 0.59;
  v86 = v9 * 0.11;
  do
  {
    v87 = (char *)v15 + (v14 >> v13) * v12;
    if (v118 != 1)
    {
      v100 = v83;
      v101 = a5;
      if (a5 < 1)
        goto LABEL_135;
      while (1)
      {
        v102 = *v100;
        v100 += 2;
        v103 = (unsigned int *)&v87[v102];
        if (v16 < (unsigned int *)&v87[v102])
          v103 = v16;
        if (v15 > v103)
          v103 = v15;
        v104 = __ROL4__(*v103, v10);
        v105 = *(float *)&_blt_float[HIBYTE(v104)];
        v106 = *(float *)&_blt_float[BYTE2(v104)];
        v107 = *(float *)&_blt_float[BYTE1(v104)];
        v108 = *(float *)&_blt_float[v104 | v6];
        if (v9 >= 1.0)
        {
          v109 = v105 * 0.3;
          v110 = v106 * 0.59;
          v111 = v107 * 0.11;
        }
        else
        {
          v109 = v84 * v105;
          v110 = v85 * v106;
          v111 = v86 * v107;
          v108 = v9 * v108;
        }
        v112 = (float)(v109 + v110) + v111;
        if (!v8)
        {
          if (v108 < 1.0)
          {
            if (v108 > 0.0)
              *v7 = v112 + (float)(*v7 * (float)(1.0 - v108));
          }
          else
          {
            *v7 = v112;
          }
          goto LABEL_134;
        }
        if (v108 >= 1.0)
          break;
        if (v108 > 0.0)
        {
          *v7 = v112 + (float)(*v7 * (float)(1.0 - v108));
          v108 = v108 + (float)(*v8 * (float)(1.0 - v108));
          goto LABEL_133;
        }
LABEL_134:
        ++v7;
        v8 = (float *)((char *)v8 + result);
        if (!--v101)
          goto LABEL_135;
      }
      *v7 = v112;
LABEL_133:
      *v8 = v108;
      goto LABEL_134;
    }
    if (a5 >= 1)
    {
      v88 = v83;
      v89 = a5;
      do
      {
        v90 = *v88;
        v88 += 2;
        v91 = (unsigned int *)&v87[v90];
        if (v16 < (unsigned int *)&v87[v90])
          v91 = v16;
        if (v15 > v91)
          v91 = v15;
        v92 = __ROL4__(*v91, v10);
        v93 = *(float *)&_blt_float[HIBYTE(v92)];
        v94 = *(float *)&_blt_float[BYTE2(v92)];
        v95 = *(float *)&_blt_float[BYTE1(v92)];
        v96 = *(float *)&_blt_float[v92 | v6];
        if (v9 >= 1.0)
        {
          v97 = v93 * 0.3;
          v98 = v94 * 0.59;
          v99 = v95 * 0.11;
        }
        else
        {
          v97 = v84 * v93;
          v98 = v85 * v94;
          v99 = v86 * v95;
          v96 = v9 * v96;
        }
        *v7 = (float)(v97 + v98) + v99;
        if (v8)
          *v8 = v96;
        ++v7;
        v8 = (float *)((char *)v8 + result);
        --v89;
      }
      while (v89);
    }
LABEL_135:
    v7 += v117;
    v14 += v116;
    v8 += v119;
    --a6;
  }
  while (a6);
  return result;
}

void Wf_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int *v31;
  float *v32;
  uint64_t v33;
  int v34;
  int v35;
  int v36;
  _QWORD *v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  unsigned __int8 *v41;
  int v42;
  void *v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  float32x2_t *v49;
  unsigned __int8 *v50;
  unsigned int v51;
  float v52;
  int v53;
  _BYTE *v54;
  int v55;
  uint64_t v56;
  int v57;
  float v58;
  BOOL v59;
  uint64_t v60;
  uint64_t v61;
  float *v62;
  unint64_t v63;
  unint64_t v64;
  float *v65;
  unint64_t v66;
  unint64_t v67;
  __int128 *v68;
  uint64_t v69;
  int v70;
  unsigned __int8 *v71;
  unsigned int v72;
  float v73;
  unsigned int v74;
  float v75;
  unsigned __int8 v76;
  float *v77;
  float *v78;
  unsigned __int8 *v79;
  float *v80;
  int v81;
  int v82;
  unsigned int v83;
  float v84;
  float v85;
  unsigned __int8 v86;
  unsigned __int8 v87;
  float *v88;
  unsigned __int8 *v89;
  float *v90;
  int v91;
  unsigned int v92;
  float v93;
  float v94;
  float v95;
  unsigned __int8 v96;
  float *v97;
  int v98;
  unsigned int v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float *v105;
  int v106;
  unsigned int v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float *v113;
  int v114;
  unsigned int v115;
  unsigned int v116;
  float v117;
  float v118;
  float v119;
  float v120;
  float *v121;
  int v122;
  unsigned int v123;
  unsigned int v124;
  float v125;
  float v126;
  float v127;
  float v128;
  float v129;
  uint64_t v130;
  float *v131;
  int v132;
  unsigned int v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  float v139;
  unsigned int v140;
  float v141;
  uint64_t v142;
  float *v143;
  int v144;
  unsigned int v145;
  float v146;
  float v147;
  float v148;
  float v149;
  float v150;
  float v151;
  unsigned int v152;
  float v153;
  float *v154;
  int v155;
  unsigned int v156;
  unsigned int v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  float v163;
  float *v164;
  int v165;
  unsigned int v166;
  unsigned int v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  uint64_t v173;
  float *v174;
  int v175;
  unsigned int v176;
  unsigned int v177;
  float v178;
  float v179;
  float v180;
  float v181;
  float v182;
  float v183;
  unsigned int v184;
  unsigned int v185;
  uint64_t v186;
  float *v187;
  int v188;
  unsigned int v189;
  unsigned int v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float *v195;
  int v196;
  unsigned int v197;
  unsigned int v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  float *v204;
  int v205;
  unsigned int v206;
  unsigned int v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float *v212;
  int v213;
  unsigned __int8 *v214;
  unsigned int v215;
  unsigned int v216;
  float v217;
  float v218;
  float v219;
  float v220;
  __int128 *v221;
  float v222;
  float v223;
  float *v224;
  int v225;
  unsigned int v226;
  unsigned int v227;
  float v228;
  float v229;
  float v230;
  float v231;
  float v232;
  float v233;
  float *v234;
  int v235;
  unsigned int v236;
  unsigned int v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float *v244;
  int v245;
  unsigned int v246;
  unsigned int v247;
  float v248;
  float v249;
  float v250;
  float v251;
  __int128 *v252;
  float v253;
  float v254;
  float *v255;
  int v256;
  unsigned int v257;
  unsigned int v258;
  float v259;
  float v260;
  float v261;
  float v262;
  __int128 *v263;
  float v264;
  float v265;
  float *v266;
  int v267;
  unsigned int v268;
  unsigned int v269;
  float v270;
  float v271;
  float v272;
  float v273;
  __int128 *v274;
  float v275;
  float v276;
  float *v277;
  int v278;
  unsigned int v279;
  unsigned int v280;
  float v281;
  float v282;
  float v283;
  float v284;
  __int128 *v285;
  float v286;
  float v287;
  float *v288;
  int v289;
  unsigned int v290;
  unsigned int v291;
  float v292;
  float v293;
  float v294;
  float v295;
  float v296;
  float v297;
  float v298;
  float v299;
  float v300;
  float v301;
  float *v302;
  int v303;
  unsigned int v304;
  unsigned int v305;
  float v306;
  float v307;
  float v308;
  float v309;
  float *v310;
  int v311;
  unsigned int v312;
  unsigned int v313;
  float v314;
  float v315;
  float v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float *v321;
  int v322;
  unsigned int v323;
  unsigned int v324;
  float v325;
  float v326;
  float v327;
  float v328;
  float v329;
  float v330;
  float v331;
  float *v332;
  int v333;
  unsigned int v334;
  unsigned int v335;
  float v336;
  float v337;
  float v338;
  float v339;
  float v340;
  float v341;
  float v342;
  float *v343;
  int v344;
  unsigned int v345;
  unsigned int v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  float v353;
  unsigned __int8 *v354;
  float *v355;
  int v356;
  unsigned int v357;
  float v358;
  unsigned __int8 v359;
  unsigned __int8 *v360;
  float *v361;
  int v362;
  unsigned int v363;
  float v364;
  float v365;
  float v366;
  float v367;
  unsigned __int8 v368;
  int v369;
  unsigned __int8 *v370;
  unsigned int v371;
  unsigned int v372;
  float v373;
  float v374;
  unsigned __int8 v375;
  float v376;
  float v377;
  float v378;
  unsigned __int8 v379;
  float v380;
  unsigned __int8 v381;
  float *v382;
  float v383;
  float v384;
  float v385;
  float v386;
  unsigned __int8 v387;
  uint64_t v388;
  int v389;
  int v390;
  int v391;
  uint64_t v392;
  unint64_t v393;
  void *v394;
  uint64_t v395;
  uint64_t v396;
  uint64_t v397;
  _QWORD *v398;
  int v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  __n128 v405;
  uint64_t v406;
  uint64_t v407;
  int v408;
  void *v409;
  int *v410;
  uint64_t v411;

  v399 = a3;
  v411 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 4);
  v397 = (int)v4;
  v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 > 0x1FFFFFF)
    return;
  v7 = *(int *)(a1 + 28);
  v8 = *(_QWORD *)(a1 + 40);
  v9 = *(_QWORD *)(a1 + 48);
  a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
  v405 = a4;
  v410 = *(int **)(a1 + 136);
  v10 = *(_QWORD *)(a2 + 104);
  v400 = *(_QWORD *)(a2 + 96);
  v401 = v10;
  v12 = *(int *)(a1 + 12);
  v11 = *(int *)(a1 + 16);
  v408 = *(_DWORD *)(a1 + 8);
  v398 = (_QWORD *)a2;
  v13 = *(int *)(a2 + 16);
  v14 = (v13 + 10) * v5;
  if (v14 > 65439)
  {
    v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x114F985BuLL);
    v16 = v17;
    v19 = v17;
    v20 = v398;
    if (!v17)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v16 = (char *)&v393 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    v19 = 0;
    v20 = v398;
  }
  v394 = v19;
  v21 = v7 >> 2;
  v22 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  v23 = v22 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((_DWORD)v13)
    v24 = 8 * v5;
  else
    v24 = 0;
  v25 = v23 + v24;
  v20[18] = v22;
  v20[19] = v23 + v24;
  v20[20] = v23;
  if (v9)
  {
    v26 = (unint64_t)*(int *)(a1 + 32) >> 2;
    v27 = (float *)(v9 + 4 * (v12 + v26 * v11));
    v28 = v397;
    v406 = v26 - v397;
    v29 = 1;
  }
  else
  {
    v27 = 0;
    v406 = 0;
    v29 = 0;
    v28 = v397;
  }
  v30 = v400;
  v31 = v410;
  v32 = (float *)(v8 + 4 * (v12 + v21 * v11));
  v404 = v21 - v28;
  v33 = *(int *)(a1 + 104);
  v34 = *(_DWORD *)(a1 + 108);
  v35 = *(unsigned __int8 *)(a1 + 2);
  if (v35 == 6 || v35 == 1)
  {
    v36 = v399;
    v37 = v398;
    v38 = v401;
    if (!v410)
      goto LABEL_598;
    v393 = v21;
    v39 = 0;
    LODWORD(v410) = 0;
    v40 = *(int *)(a1 + 124);
    v41 = (unsigned __int8 *)v31 + v33 + (int)v40 * (uint64_t)v34;
    v28 = v397;
    v403 = v40 - v397;
LABEL_21:
    v42 = v408;
    goto LABEL_22;
  }
  v393 = v21;
  if (!v410)
  {
    v403 = 0;
    v39 = 0;
    v41 = 0;
    LODWORD(v410) = 0;
    v36 = v399;
    v37 = v398;
    v38 = v401;
    goto LABEL_21;
  }
  v407 = v29;
  v42 = v408;
  shape_enum_clip_alloc((uint64_t)v17, v18, v410, 1, 1, 1, v33, v34, v4, v408);
  if (!v43)
    goto LABEL_598;
  v409 = v43;
  v44 = 0;
  v45 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
  if (!(_DWORD)v13)
    v45 = 8 * v5;
  v46 = v397;
  v37 = v398;
  v403 = -v397;
  v41 = (unsigned __int8 *)(v25 + v45 + 16);
  v36 = v399;
LABEL_586:
  v388 = v406 + v46;
  while (1)
  {
    LODWORD(v410) = v44;
    while (1)
    {
      v389 = *((_DWORD *)v41 - 4);
      v390 = v389 - v44;
      if (v389 > v44)
        break;
      v39 = v409;
      if (v44 < *((_DWORD *)v41 - 3) + v389)
      {
        v28 = v397;
        v38 = v401;
        v29 = v407;
LABEL_22:
        v395 = -v28;
        v396 = (v4 - 1) + 1;
        v47 = 4 * v29;
        v48 = v39;
        v402 = v4;
        v407 = v29;
        while (2)
        {
          v408 = v42;
          v409 = v48;
          ((void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))*v37)(v37, v30, v38, v4);
          v49 = (float32x2_t *)v37[20];
          v50 = (unsigned __int8 *)v37[18];
          v51 = *((_DWORD *)v37 + 2);
          if (v51 == *((_DWORD *)v37 + 3))
          {
            v52 = v405.n128_f32[0];
            if (v405.n128_f32[0] >= 1.0)
            {
              v55 = v407;
            }
            else
            {
              v53 = v4;
              v54 = (_BYTE *)v37[18];
              v55 = v407;
              do
              {
                if (*v54)
                  *v49 = vmul_n_f32(*v49, v52);
                ++v54;
                ++v49;
                --v53;
              }
              while (v53);
              v49 += v395;
              v50 += v396 + v395;
            }
          }
          else
          {
            v56 = v37[19];
            v57 = HIWORD(v51) & 0x3F;
            v58 = v405.n128_f32[0];
            if (v57 == 16)
            {
              v55 = v407;
              v61 = 0;
              v62 = (float *)v49 + 1;
              if (v405.n128_f32[0] >= 1.0)
              {
                do
                {
                  if (v50[v61])
                  {
                    v64 = *(unsigned int *)(v56 + 4 * v61);
                    *(v62 - 1) = *(float *)&_blt_float[v64 + 256]
                               + *(float *)&_blt_float[BYTE1(v64) + 512];
                    *v62 = *(float *)&_blt_float[BYTE2(v64) + 256]
                         + *(float *)((char *)&_blt_float[512] + ((v64 >> 22) & 0x3FC));
                  }
                  ++v61;
                  v62 += 2;
                }
                while ((_DWORD)v4 != (_DWORD)v61);
              }
              else
              {
                do
                {
                  if (v50[v61])
                  {
                    v63 = *(unsigned int *)(v56 + 4 * v61);
                    *(v62 - 1) = v58
                               * (float)(*(float *)&_blt_float[v63 + 256]
                                       + *(float *)&_blt_float[BYTE1(v63) + 512]);
                    *v62 = v58
                         * (float)(*(float *)&_blt_float[BYTE2(v63) + 256]
                                 + *(float *)((char *)&_blt_float[512] + ((v63 >> 22) & 0x3FC)));
                  }
                  ++v61;
                  v62 += 2;
                }
                while ((_DWORD)v4 != (_DWORD)v61);
              }
            }
            else
            {
              v59 = v57 == 32;
              v55 = v407;
              v60 = 0;
              if (v59)
              {
                if (v405.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v50[v60])
                      v49[v60] = *(float32x2_t *)(v56 + 8 * v60);
                    ++v60;
                  }
                  while ((_DWORD)v4 != (_DWORD)v60);
                }
                else
                {
                  do
                  {
                    if (v50[v60])
                      v49[v60] = vmul_n_f32(*(float32x2_t *)(v56 + 8 * v60), v58);
                    ++v60;
                  }
                  while ((_DWORD)v4 != (_DWORD)v60);
                }
              }
              else
              {
                v65 = (float *)v49 + 1;
                if (v405.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v50[v60])
                    {
                      v67 = *(unsigned int *)(v56 + 4 * v60);
                      *(v65 - 1) = *(float *)&_blt_float[*(_DWORD *)(v56 + 4 * v60)];
                      *v65 = *(float *)((char *)_blt_float + ((v67 >> 22) & 0x3FC));
                    }
                    ++v60;
                    v65 += 2;
                  }
                  while ((_DWORD)v4 != (_DWORD)v60);
                }
                else
                {
                  do
                  {
                    if (v50[v60])
                    {
                      v66 = *(unsigned int *)(v56 + 4 * v60);
                      *(v65 - 1) = v58 * *(float *)&_blt_float[*(_DWORD *)(v56 + 4 * v60)];
                      *v65 = v58 * *(float *)((char *)_blt_float + ((v66 >> 22) & 0x3FC));
                    }
                    ++v60;
                    v65 += 2;
                  }
                  while ((_DWORD)v4 != (_DWORD)v60);
                }
              }
            }
          }
          v68 = &xmmword_185005000;
          switch(v36)
          {
            case 0:
              v69 = v41 != 0;
              v70 = v4;
              v71 = v41;
              if (v55)
              {
                do
                {
                  v72 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v72 = (*v71 * v72 + ((*v71 * v72) >> 8) + 1) >> 8;
                    if ((_BYTE)v72)
                    {
                      if (v72 == 255)
                      {
                        *v27 = 0.0;
                        *v32 = 0.0;
                      }
                      else
                      {
                        v73 = (float)((float)v72 * -0.0039216) + 1.0;
                        *v32 = v73 * *v32;
                        *v27 = v73 * *v27;
                      }
                    }
                  }
                  ++v50;
                  v71 += v69;
                  ++v32;
                  ++v27;
                  --v70;
                }
                while (v70);
              }
              else
              {
                do
                {
                  v74 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v74 = (*v71 * v74 + ((*v71 * v74) >> 8) + 1) >> 8;
                    if ((_BYTE)v74)
                    {
                      v75 = 0.0;
                      if (v74 != 255)
                        v75 = (float)((float)((float)v74 * -0.0039216) + 1.0) * *v32;
                      *v32 = v75;
                    }
                  }
                  ++v50;
                  v71 += v69;
                  ++v32;
                  --v70;
                }
                while (v70);
              }
              goto LABEL_500;
            case 1:
              v76 = *v50;
              if (v55)
              {
                v77 = v32 - 1;
                v78 = (float *)v49 + 1;
                v79 = v50 + 1;
                v80 = v27 - 1;
                v81 = v4;
                if (v41)
                {
                  v82 = v408;
                  do
                  {
                    if (v76)
                    {
                      v83 = ((unsigned __int16)(*v41 * v76 + ((*v41 * v76) >> 8) + 1) >> 8);
                      if (v83)
                      {
                        if (v83 == 255)
                        {
                          v77[1] = *(v78 - 1);
                          v84 = *v78;
                        }
                        else
                        {
                          v85 = (float)v83 * 0.0039216;
                          v77[1] = (float)((float)(1.0 - v85) * v77[1]) + (float)(*(v78 - 1) * v85);
                          v84 = (float)((float)(1.0 - v85) * v80[1]) + (float)(*v78 * v85);
                        }
                        v80[1] = v84;
                      }
                    }
                    v86 = *v79++;
                    v76 = v86;
                    ++v41;
                    ++v77;
                    v78 += 2;
                    ++v80;
                    --v81;
                  }
                  while (v81);
                  v41 += v403;
                }
                else
                {
                  v82 = v408;
                  do
                  {
                    if (v76)
                    {
                      if (v76 == 255)
                      {
                        v77[1] = *(v78 - 1);
                        v373 = *v78;
                      }
                      else
                      {
                        v374 = (float)v76 * 0.0039216;
                        v77[1] = (float)((float)(1.0 - v374) * v77[1]) + (float)(*(v78 - 1) * v374);
                        v373 = (float)((float)(1.0 - v374) * v80[1]) + (float)(*v78 * v374);
                      }
                      v80[1] = v373;
                    }
                    v375 = *v79++;
                    v76 = v375;
                    ++v77;
                    v78 += 2;
                    ++v80;
                    --v81;
                  }
                  while (v81);
                  v41 = 0;
                }
                v32 = &v77[v404 + 1];
                v27 = &v80[v406 + 1];
                goto LABEL_503;
              }
              v354 = v50 + 1;
              v355 = v32 - 1;
              v356 = v4;
              if (v41)
              {
                v82 = v408;
                do
                {
                  if (v76)
                  {
                    v357 = ((unsigned __int16)(*v41 * v76 + ((*v41 * v76) >> 8) + 1) >> 8);
                    if (v357)
                    {
                      if (v357 == 255)
                        v358 = v49->f32[0];
                      else
                        v358 = (float)((float)(1.0 - (float)((float)v357 * 0.0039216)) * v355[1])
                             + (float)(v49->f32[0] * (float)((float)v357 * 0.0039216));
                      v355[1] = v358;
                    }
                  }
                  v359 = *v354++;
                  v76 = v359;
                  ++v49;
                  ++v41;
                  ++v355;
                  --v356;
                }
                while (v356);
                v41 += v403;
              }
              else
              {
                v82 = v408;
                do
                {
                  if (v76)
                  {
                    if (v76 == 255)
                      v380 = v49->f32[0];
                    else
                      v380 = (float)((float)(1.0 - (float)((float)v76 * 0.0039216)) * v355[1])
                           + (float)(v49->f32[0] * (float)((float)v76 * 0.0039216));
                    v355[1] = v380;
                  }
                  v381 = *v354++;
                  v76 = v381;
                  ++v49;
                  ++v355;
                  --v356;
                }
                while (v356);
                v41 = 0;
              }
              v382 = &v355[v404];
              goto LABEL_585;
            case 2:
              v87 = *v50;
              if (v55)
              {
                v88 = v32 - 1;
                v89 = v50 + 1;
                v90 = v27 - 1;
                v91 = v4;
                if (v41)
                {
                  v82 = v408;
                  while (1)
                  {
                    if (!v87)
                      goto LABEL_105;
                    v92 = ((unsigned __int16)(*v41 * v87 + ((*v41 * v87) >> 8) + 1) >> 8);
                    if (!v92)
                      goto LABEL_105;
                    if (v92 == 255)
                    {
                      v93 = v49->f32[1];
                      if (v93 >= 1.0)
                      {
                        v88[1] = v49->f32[0];
                        goto LABEL_104;
                      }
                      if (v93 > 0.0)
                      {
                        v94 = v49->f32[0];
                        goto LABEL_102;
                      }
                    }
                    else
                    {
                      v95 = (float)v92 * 0.0039216;
                      v93 = v95 * v49->f32[1];
                      if (v93 > 0.0)
                      {
                        v94 = v95 * v49->f32[0];
LABEL_102:
                        v88[1] = v94 + (float)(v88[1] * (float)(1.0 - v93));
                        v93 = v93 + (float)(v90[1] * (float)(1.0 - v93));
LABEL_104:
                        v90[1] = v93;
                      }
                    }
LABEL_105:
                    v96 = *v89++;
                    v87 = v96;
                    ++v49;
                    ++v41;
                    ++v88;
                    ++v90;
                    if (!--v91)
                    {
                      v41 += v403;
LABEL_561:
                      v32 = &v88[v404 + 1];
                      v27 = &v90[v406 + 1];
                      goto LABEL_503;
                    }
                  }
                }
                v82 = v408;
                while (1)
                {
                  if (v87)
                  {
                    if (v87 == 255)
                    {
                      v376 = v49->f32[1];
                      if (v376 >= 1.0)
                      {
                        v88[1] = v49->f32[0];
                        goto LABEL_558;
                      }
                      if (v376 > 0.0)
                      {
                        v377 = v49->f32[0];
                        goto LABEL_556;
                      }
                    }
                    else
                    {
                      v378 = (float)v87 * 0.0039216;
                      v376 = v378 * v49->f32[1];
                      if (v376 > 0.0)
                      {
                        v377 = v378 * v49->f32[0];
LABEL_556:
                        v88[1] = v377 + (float)(v88[1] * (float)(1.0 - v376));
                        v376 = v376 + (float)(v90[1] * (float)(1.0 - v376));
LABEL_558:
                        v90[1] = v376;
                      }
                    }
                  }
                  v379 = *v89++;
                  v87 = v379;
                  ++v49;
                  ++v88;
                  ++v90;
                  if (!--v91)
                  {
                    v41 = 0;
                    goto LABEL_561;
                  }
                }
              }
              v360 = v50 + 1;
              v361 = v32 - 1;
              v362 = v4;
              if (!v41)
              {
                v82 = v408;
                while (1)
                {
                  if (v87)
                  {
                    if (v87 == 255)
                    {
                      v383 = v49->f32[1];
                      if (v383 >= 1.0)
                      {
                        v386 = v49->f32[0];
                        goto LABEL_581;
                      }
                      if (v383 > 0.0)
                      {
                        v384 = v49->f32[0];
                        goto LABEL_579;
                      }
                    }
                    else
                    {
                      v385 = (float)v87 * 0.0039216;
                      v383 = v385 * v49->f32[1];
                      if (v383 > 0.0)
                      {
                        v384 = v385 * v49->f32[0];
LABEL_579:
                        v386 = v384 + (float)(v361[1] * (float)(1.0 - v383));
LABEL_581:
                        v361[1] = v386;
                      }
                    }
                  }
                  v387 = *v360++;
                  v87 = v387;
                  ++v49;
                  ++v361;
                  if (!--v362)
                  {
                    v41 = 0;
                    goto LABEL_584;
                  }
                }
              }
              v82 = v408;
              do
              {
                if (v87)
                {
                  v363 = ((unsigned __int16)(*v41 * v87 + ((*v41 * v87) >> 8) + 1) >> 8);
                  if (v363)
                  {
                    if (v363 == 255)
                    {
                      v364 = v49->f32[1];
                      if (v364 >= 1.0)
                      {
                        v367 = v49->f32[0];
                        goto LABEL_528;
                      }
                      if (v364 <= 0.0)
                        goto LABEL_529;
                      v365 = v49->f32[0];
                    }
                    else
                    {
                      v366 = (float)v363 * 0.0039216;
                      v364 = v366 * v49->f32[1];
                      if (v364 <= 0.0)
                        goto LABEL_529;
                      v365 = v366 * v49->f32[0];
                    }
                    v367 = v365 + (float)(v361[1] * (float)(1.0 - v364));
LABEL_528:
                    v361[1] = v367;
                  }
                }
LABEL_529:
                v368 = *v360++;
                v87 = v368;
                ++v49;
                ++v41;
                ++v361;
                --v362;
              }
              while (v362);
              v41 += v403;
LABEL_584:
              v382 = &v361[v404];
LABEL_585:
              v32 = v382 + 1;
              v27 += v406;
LABEL_503:
              v42 = v82 - 1;
              if (!v42)
                goto LABEL_596;
              v48 = 0;
              LODWORD(v410) = (_DWORD)v410 + 1;
              v30 += v37[16];
              v38 += v37[17];
              if (v409)
              {
                v401 = v38;
                v46 = v397;
                v44 = (int)v410;
                goto LABEL_586;
              }
              continue;
            case 3:
              v97 = (float *)v49 + 1;
              v98 = v4;
              v71 = v41;
              do
              {
                v99 = *v50;
                if (*v50)
                {
                  if (v41)
                    v99 = (*v71 * v99 + ((*v71 * v99) >> 8) + 1) >> 8;
                  if ((_BYTE)v99)
                  {
                    if (v99 == 255)
                    {
                      *v32 = *(v97 - 1) * *v27;
                      v100 = *v97 * *v27;
                    }
                    else
                    {
                      v101 = (float)v99 * 0.0039216;
                      v102 = *v27;
                      v103 = v101 * *v27;
                      v104 = 1.0 - v101;
                      *v32 = (float)(v104 * *v32) + (float)(*(v97 - 1) * v103);
                      v100 = (float)(v104 * v102) + (float)(*v97 * v103);
                    }
                    *v27 = v100;
                  }
                }
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v97 += 2;
                v27 = (float *)((char *)v27 + v47);
                --v98;
              }
              while (v98);
              goto LABEL_500;
            case 4:
              v105 = (float *)v49 + 1;
              v106 = v4;
              v71 = v41;
              do
              {
                v107 = *v50;
                if (*v50)
                {
                  if (v41)
                    v107 = (*v71 * v107 + ((*v71 * v107) >> 8) + 1) >> 8;
                  if ((_BYTE)v107)
                  {
                    if (v107 == 255)
                    {
                      *v32 = *(v105 - 1) * (float)(1.0 - *v27);
                      v108 = *v105 * (float)(1.0 - *v27);
                    }
                    else
                    {
                      v109 = (float)v107 * 0.0039216;
                      v110 = *v27;
                      v111 = v109 * (float)(1.0 - *v27);
                      v112 = 1.0 - v109;
                      *v32 = (float)(v112 * *v32) + (float)(*(v105 - 1) * v111);
                      v108 = (float)(v112 * v110) + (float)(*v105 * v111);
                    }
                    *v27 = v108;
                  }
                }
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v105 += 2;
                v27 = (float *)((char *)v27 + v47);
                --v106;
              }
              while (v106);
              goto LABEL_500;
            case 5:
              v113 = (float *)v49 + 1;
              v114 = v4;
              v71 = v41;
              while (1)
              {
                v115 = *v50;
                if (*v50)
                {
                  if (!v41)
                    goto LABEL_134;
                  v116 = *v71 * v115 + ((*v71 * v115) >> 8) + 1;
                  if (BYTE1(v116))
                    break;
                }
LABEL_135:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v113 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v114)
                  goto LABEL_500;
              }
              v115 = v116 >> 8;
LABEL_134:
              v117 = *v27;
              v118 = (float)v115 * 0.0039216;
              v119 = *(v113 - 1) * v118;
              v120 = v118 * *v113;
              *v32 = (float)(*v32 * (float)(1.0 - v120)) + (float)(v119 * *v27);
              *v27 = (float)(v117 * (float)(1.0 - v120)) + (float)(v120 * v117);
              goto LABEL_135;
            case 6:
              v121 = (float *)v49 + 1;
              v122 = v4;
              v71 = v41;
              while (1)
              {
                v123 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v124 = *v71 * v123 + ((*v71 * v123) >> 8) + 1;
                    if (!BYTE1(v124))
                      goto LABEL_147;
                    v123 = v124 >> 8;
                  }
                  v125 = *v27;
                  v126 = 1.0 - *v27;
                  if (v126 >= 1.0)
                  {
                    v129 = (float)v123 * 0.0039216;
                    *v32 = v129 * *(v121 - 1);
                    v128 = v129 * *v121;
                    goto LABEL_146;
                  }
                  if (v126 > 0.0)
                  {
                    v127 = v126 * (float)((float)v123 * 0.0039216);
                    *v32 = *v32 + (float)(*(v121 - 1) * v127);
                    v128 = v125 + (float)(*v121 * v127);
LABEL_146:
                    *v27 = v128;
                  }
                }
LABEL_147:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v121 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v122)
                  goto LABEL_500;
              }
            case 7:
              v130 = v41 != 0;
              v131 = (float *)v49 + 1;
              v132 = v4;
              v71 = v41;
              if (v55)
              {
                do
                {
                  v133 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v133 = (*v71 * v133 + ((*v71 * v133) >> 8) + 1) >> 8;
                    if ((_BYTE)v133)
                    {
                      if (v133 == 255)
                      {
                        v134 = *v131;
                        *v32 = *v32 * *v131;
                        v135 = v134 * *v27;
                      }
                      else
                      {
                        v136 = (float)v133 * 0.0039216;
                        v137 = *v27;
                        v138 = v136 * *v131;
                        v139 = 1.0 - v136;
                        *v32 = (float)(v139 * *v32) + (float)(*v32 * v138);
                        v135 = (float)(v139 * v137) + (float)(v137 * v138);
                      }
                      *v27 = v135;
                    }
                  }
                  ++v50;
                  v71 += v130;
                  ++v32;
                  ++v27;
                  v131 += 2;
                  --v132;
                }
                while (v132);
              }
              else
              {
                do
                {
                  v140 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v140 = (*v71 * v140 + ((*v71 * v140) >> 8) + 1) >> 8;
                    if ((_BYTE)v140)
                    {
                      if (v140 == 255)
                        v141 = *v32 * *v131;
                      else
                        v141 = (float)((float)(1.0 - (float)((float)v140 * 0.0039216)) * *v32)
                             + (float)(*v32 * (float)((float)((float)v140 * 0.0039216) * *v131));
                      *v32 = v141;
                    }
                  }
                  ++v50;
                  v71 += v130;
                  ++v32;
                  v131 += 2;
                  --v132;
                }
                while (v132);
              }
              goto LABEL_500;
            case 8:
              v142 = v41 != 0;
              v143 = (float *)v49 + 1;
              v144 = v4;
              v71 = v41;
              if (v55)
              {
                do
                {
                  v145 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v145 = (*v71 * v145 + ((*v71 * v145) >> 8) + 1) >> 8;
                    if ((_BYTE)v145)
                    {
                      if (v145 == 255)
                      {
                        v146 = 1.0 - *v143;
                        *v32 = *v32 * v146;
                        v147 = v146 * *v27;
                      }
                      else
                      {
                        v148 = (float)v145 * 0.0039216;
                        v149 = *v27;
                        v150 = v148 * (float)(1.0 - *v143);
                        v151 = 1.0 - v148;
                        *v32 = (float)(v151 * *v32) + (float)(*v32 * v150);
                        v147 = (float)(v151 * v149) + (float)(v149 * v150);
                      }
                      *v27 = v147;
                    }
                  }
                  ++v50;
                  v71 += v142;
                  ++v32;
                  ++v27;
                  v143 += 2;
                  --v144;
                }
                while (v144);
              }
              else
              {
                do
                {
                  v152 = *v50;
                  if (*v50)
                  {
                    if (v41)
                      v152 = (*v71 * v152 + ((*v71 * v152) >> 8) + 1) >> 8;
                    if ((_BYTE)v152)
                    {
                      if (v152 == 255)
                        v153 = *v32 * (float)(1.0 - *v143);
                      else
                        v153 = (float)((float)(1.0 - (float)((float)v152 * 0.0039216)) * *v32)
                             + (float)(*v32
                                     * (float)((float)((float)v152 * 0.0039216) * (float)(1.0 - *v143)));
                      *v32 = v153;
                    }
                  }
                  ++v50;
                  v71 += v142;
                  ++v32;
                  v143 += 2;
                  --v144;
                }
                while (v144);
              }
              goto LABEL_500;
            case 9:
              v154 = (float *)v49 + 1;
              v155 = v4;
              v71 = v41;
              while (1)
              {
                v156 = *v50;
                if (*v50)
                {
                  if (!v41)
                    goto LABEL_196;
                  v157 = *v71 * v156 + ((*v71 * v156) >> 8) + 1;
                  if (BYTE1(v157))
                    break;
                }
LABEL_197:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v154 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v155)
                  goto LABEL_500;
              }
              v156 = v157 >> 8;
LABEL_196:
              v158 = *v27;
              v159 = (float)v156 * 0.0039216;
              v160 = *(v154 - 1) * v159;
              v161 = v159 * *v154;
              v162 = 1.0 - *v27;
              v163 = (float)(1.0 - v159) + v161;
              *v32 = (float)(*v32 * v163) + (float)(v160 * v162);
              *v27 = (float)(v158 * v163) + (float)(v161 * v162);
              goto LABEL_197;
            case 10:
              v164 = (float *)v49 + 1;
              v165 = v4;
              v71 = v41;
              while (1)
              {
                v166 = *v50;
                if (*v50)
                {
                  if (!v41)
                    goto LABEL_204;
                  v167 = *v71 * v166 + ((*v71 * v166) >> 8) + 1;
                  if (BYTE1(v167))
                    break;
                }
LABEL_205:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v164 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v165)
                  goto LABEL_500;
              }
              v166 = v167 >> 8;
LABEL_204:
              v168 = *v27;
              v169 = (float)v166 * 0.0039216;
              v170 = *(v164 - 1) * v169;
              v171 = v169 * *v164;
              v172 = 1.0 - *v27;
              *v32 = (float)(*v32 * (float)(1.0 - v171)) + (float)(v170 * v172);
              *v27 = (float)(v168 * (float)(1.0 - v171)) + (float)(v171 * v172);
              goto LABEL_205;
            case 11:
              v173 = v41 != 0;
              v174 = (float *)v49 + 1;
              v175 = v4;
              v71 = v41;
              if (v55)
              {
                while (1)
                {
                  v176 = *v50;
                  if (*v50)
                  {
                    if (!v41)
                      goto LABEL_212;
                    v177 = *v71 * v176 + ((*v71 * v176) >> 8) + 1;
                    if (BYTE1(v177))
                      break;
                  }
LABEL_215:
                  ++v50;
                  v71 += v173;
                  ++v32;
                  ++v27;
                  v174 += 2;
                  if (!--v175)
                    goto LABEL_500;
                }
                v176 = v177 >> 8;
LABEL_212:
                v178 = (float)v176 * 0.0039216;
                v179 = *(v174 - 1) * v178;
                v180 = *v174 * v178;
                v181 = *v27 + v180;
                v182 = (float)(v180 - v179) + (float)(*v27 - *v32);
                v183 = 1.0;
                if (v181 <= 1.0)
                  v183 = v181;
                *v27 = v183;
                *v32 = v183 - v182;
                goto LABEL_215;
              }
              while (1)
              {
                v184 = *v50;
                if (*v50)
                {
                  if (!v41)
                    goto LABEL_221;
                  v185 = *v71 * v184 + ((*v71 * v184) >> 8) + 1;
                  if (BYTE1(v185))
                    break;
                }
LABEL_222:
                ++v50;
                v71 += v173;
                ++v32;
                v174 += 2;
                if (!--v175)
                  goto LABEL_500;
              }
              v184 = v185 >> 8;
LABEL_221:
              *v32 = 1.0
                   - (float)((float)(1.0 - *v32)
                           + (float)((float)(*v174 * (float)((float)v184 * 0.0039216))
                                   - (float)(*(v174 - 1) * (float)((float)v184 * 0.0039216))));
              goto LABEL_222;
            case 12:
              v186 = v41 != 0;
              if (v55)
              {
                v187 = (float *)v49 + 1;
                v188 = v4;
                v71 = v41;
                while (1)
                {
                  v189 = *v50;
                  if (*v50)
                  {
                    if (!v41)
                      goto LABEL_230;
                    v190 = *v71 * v189 + ((*v71 * v189) >> 8) + 1;
                    if (BYTE1(v190))
                      break;
                  }
LABEL_233:
                  ++v50;
                  v71 += v186;
                  ++v32;
                  ++v27;
                  v187 += 2;
                  if (!--v188)
                    goto LABEL_500;
                }
                v189 = v190 >> 8;
LABEL_230:
                v191 = (float)v189 * 0.0039216;
                v192 = *(v187 - 1) * v191;
                v193 = *v27 + (float)(*v187 * v191);
                v194 = v192 + *v32;
                if (v193 > 1.0)
                  v193 = 1.0;
                *v32 = v194;
                *v27 = v193;
                goto LABEL_233;
              }
              v369 = v4;
              v370 = v41;
              while (1)
              {
                v371 = *v50;
                if (*v50)
                {
                  if (!v41)
                    goto LABEL_536;
                  v372 = *v370 * v371 + ((*v370 * v371) >> 8) + 1;
                  if (BYTE1(v372))
                    break;
                }
LABEL_537:
                ++v50;
                ++v49;
                v370 += v186;
                ++v32;
                if (!--v369)
                {
                  v41 = &v370[v403];
LABEL_501:
                  v32 += v404;
                  v27 += v406;
LABEL_502:
                  v82 = v408;
                  goto LABEL_503;
                }
              }
              v371 = v372 >> 8;
LABEL_536:
              *v32 = *v32 + (float)(v49->f32[0] * (float)((float)v371 * 0.0039216));
              goto LABEL_537;
            case 13:
              v195 = (float *)v49 + 1;
              v196 = v4;
              v71 = v41;
              while (1)
              {
                v197 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v198 = *v71 * v197 + ((*v71 * v197) >> 8) + 1;
                    if (!BYTE1(v198))
                      goto LABEL_251;
                    v197 = v198 >> 8;
                  }
                  v199 = (float)v197 * 0.0039216;
                  v200 = *v195 * v199;
                  if (v200 > 0.0)
                  {
                    v201 = *(v195 - 1) * v199;
                    v202 = 1.0;
                    if (!v55 || (v202 = *v27, *v27 > 0.0))
                    {
                      v203 = (float)(v201 * *v32) + (float)(*v32 * (float)(1.0 - v200));
                      if (v200 == 1.0)
                        v203 = v201 * *v32;
                      v201 = v203 + (float)(v201 * (float)(1.0 - v202));
                      if (v202 == 1.0)
                        v201 = v203;
                      if (!v55)
                      {
                        *v32 = v201;
                        goto LABEL_251;
                      }
                      v200 = (float)(v200 + v202) - (float)(v202 * v200);
                    }
                    *v32 = v201;
                    *v27 = v200;
                  }
                }
LABEL_251:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v195 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v196)
                  goto LABEL_500;
              }
            case 14:
              v204 = (float *)v49 + 1;
              v205 = v4;
              v71 = v41;
              while (1)
              {
                v206 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v207 = *v71 * v206 + ((*v71 * v206) >> 8) + 1;
                    if (!BYTE1(v207))
                      goto LABEL_265;
                    v206 = v207 >> 8;
                  }
                  v208 = (float)v206 * 0.0039216;
                  v209 = *v204 * v208;
                  if (v209 > 0.0)
                  {
                    v210 = *(v204 - 1) * v208;
                    v211 = 1.0;
                    if (!v55 || (v211 = *v27, *v27 > 0.0))
                    {
                      v210 = *v32 + (float)(v210 * (float)(1.0 - *v32));
                      if (!v55)
                      {
                        *v32 = v210;
                        goto LABEL_265;
                      }
                      v209 = (float)(v209 + v211) - (float)(v211 * v209);
                    }
                    *v32 = v210;
                    *v27 = v209;
                  }
                }
LABEL_265:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v204 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v205)
                  goto LABEL_500;
              }
            case 15:
              v400 = v30;
              v401 = v38;
              v212 = (float *)v49 + 1;
              v213 = v4;
              v214 = v41;
              while (1)
              {
                v215 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v216 = *v214 * v215 + ((*v214 * v215) >> 8) + 1;
                    if (!BYTE1(v216))
                      goto LABEL_281;
                    v215 = v216 >> 8;
                  }
                  v217 = (float)v215 * *((float *)v68 + 159);
                  v218 = *v212 * v217;
                  if (v218 > 0.0)
                  {
                    v219 = *(v212 - 1) * v217;
                    if (v55)
                    {
                      v220 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_279:
                        *v32 = v219;
                        *v27 = v218;
                        goto LABEL_281;
                      }
                    }
                    else
                    {
                      v220 = 1.0;
                    }
                    v221 = v68;
                    v222 = PDAoverlayPDA(*v32, v220, v219, v218);
                    v55 = v407;
                    v219 = v222;
                    if (!(_DWORD)v407)
                    {
                      *v32 = v222;
                      v68 = v221;
                      v4 = v402;
                      goto LABEL_281;
                    }
                    v218 = v223;
                    v68 = v221;
                    v4 = v402;
                    goto LABEL_279;
                  }
                }
LABEL_281:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v212 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v213)
                  goto LABEL_386;
              }
            case 16:
              v224 = (float *)v49 + 1;
              v225 = v4;
              v71 = v41;
              while (1)
              {
                v226 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v227 = *v71 * v226 + ((*v71 * v226) >> 8) + 1;
                    if (!BYTE1(v227))
                      goto LABEL_301;
                    v226 = v227 >> 8;
                  }
                  v228 = (float)v226 * 0.0039216;
                  v229 = *v224 * v228;
                  if (v229 > 0.0)
                  {
                    v230 = *(v224 - 1) * v228;
                    v231 = 1.0;
                    if (!v55 || (v231 = *v27, *v27 > 0.0))
                    {
                      v232 = v229 * *v32;
                      if ((float)(v230 * v231) < v232)
                        v232 = v230 * v231;
                      v233 = v232 + (float)(*v32 * (float)(1.0 - v229));
                      if (v229 == 1.0)
                        v233 = v232;
                      v230 = v233 + (float)(v230 * (float)(1.0 - v231));
                      if (v231 == 1.0)
                        v230 = v233;
                      if (!v55)
                      {
                        *v32 = v230;
                        goto LABEL_301;
                      }
                      v229 = (float)(v229 + v231) - (float)(v231 * v229);
                    }
                    *v32 = v230;
                    *v27 = v229;
                  }
                }
LABEL_301:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v224 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v225)
                  goto LABEL_500;
              }
            case 17:
              v234 = (float *)v49 + 1;
              v235 = v4;
              v71 = v41;
              while (1)
              {
                v236 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v237 = *v71 * v236 + ((*v71 * v236) >> 8) + 1;
                    if (!BYTE1(v237))
                      goto LABEL_321;
                    v236 = v237 >> 8;
                  }
                  v238 = (float)v236 * 0.0039216;
                  v239 = *v234 * v238;
                  if (v239 > 0.0)
                  {
                    v240 = *(v234 - 1) * v238;
                    v241 = 1.0;
                    if (!v55 || (v241 = *v27, *v27 > 0.0))
                    {
                      v242 = v239 * *v32;
                      if ((float)(v240 * v241) > v242)
                        v242 = v240 * v241;
                      v243 = v242 + (float)(*v32 * (float)(1.0 - v239));
                      if (v239 == 1.0)
                        v243 = v242;
                      v240 = v243 + (float)(v240 * (float)(1.0 - v241));
                      if (v241 == 1.0)
                        v240 = v243;
                      if (!v55)
                      {
                        *v32 = v240;
                        goto LABEL_321;
                      }
                      v239 = (float)(v239 + v241) - (float)(v241 * v239);
                    }
                    *v32 = v240;
                    *v27 = v239;
                  }
                }
LABEL_321:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v234 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v235)
                  goto LABEL_500;
              }
            case 18:
              v400 = v30;
              v401 = v38;
              v244 = (float *)v49 + 1;
              v245 = v4;
              v214 = v41;
              while (1)
              {
                v246 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v247 = *v214 * v246 + ((*v214 * v246) >> 8) + 1;
                    if (!BYTE1(v247))
                      goto LABEL_337;
                    v246 = v247 >> 8;
                  }
                  v248 = (float)v246 * *((float *)v68 + 159);
                  v249 = *v244 * v248;
                  if (v249 > 0.0)
                  {
                    v250 = *(v244 - 1) * v248;
                    if (v55)
                    {
                      v251 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_335:
                        *v32 = v250;
                        *v27 = v249;
                        goto LABEL_337;
                      }
                    }
                    else
                    {
                      v251 = 1.0;
                    }
                    v252 = v68;
                    v253 = PDAcolordodgePDA(*v32, v251, v250, v249);
                    v55 = v407;
                    v250 = v253;
                    if (!(_DWORD)v407)
                    {
                      *v32 = v253;
                      v68 = v252;
                      v4 = v402;
                      goto LABEL_337;
                    }
                    v249 = v254;
                    v68 = v252;
                    v4 = v402;
                    goto LABEL_335;
                  }
                }
LABEL_337:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v244 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v245)
                  goto LABEL_386;
              }
            case 19:
              v400 = v30;
              v401 = v38;
              v255 = (float *)v49 + 1;
              v256 = v4;
              v214 = v41;
              while (1)
              {
                v257 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v258 = *v214 * v257 + ((*v214 * v257) >> 8) + 1;
                    if (!BYTE1(v258))
                      goto LABEL_353;
                    v257 = v258 >> 8;
                  }
                  v259 = (float)v257 * *((float *)v68 + 159);
                  v260 = *v255 * v259;
                  if (v260 > 0.0)
                  {
                    v261 = *(v255 - 1) * v259;
                    if (v55)
                    {
                      v262 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_351:
                        *v32 = v261;
                        *v27 = v260;
                        goto LABEL_353;
                      }
                    }
                    else
                    {
                      v262 = 1.0;
                    }
                    v263 = v68;
                    v264 = PDAcolorburnPDA(*v32, v262, v261, v260);
                    v55 = v407;
                    v261 = v264;
                    if (!(_DWORD)v407)
                    {
                      *v32 = v264;
                      v68 = v263;
                      v4 = v402;
                      goto LABEL_353;
                    }
                    v260 = v265;
                    v68 = v263;
                    v4 = v402;
                    goto LABEL_351;
                  }
                }
LABEL_353:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v255 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v256)
                  goto LABEL_386;
              }
            case 20:
              v400 = v30;
              v401 = v38;
              v266 = (float *)v49 + 1;
              v267 = v4;
              v214 = v41;
              while (1)
              {
                v268 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v269 = *v214 * v268 + ((*v214 * v268) >> 8) + 1;
                    if (!BYTE1(v269))
                      goto LABEL_369;
                    v268 = v269 >> 8;
                  }
                  v270 = (float)v268 * *((float *)v68 + 159);
                  v271 = *v266 * v270;
                  if (v271 > 0.0)
                  {
                    v272 = *(v266 - 1) * v270;
                    if (v55)
                    {
                      v273 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_367:
                        *v32 = v272;
                        *v27 = v271;
                        goto LABEL_369;
                      }
                    }
                    else
                    {
                      v273 = 1.0;
                    }
                    v274 = v68;
                    v275 = PDAsoftlightPDA(*v32, v273, v272, v271);
                    v55 = v407;
                    v272 = v275;
                    if (!(_DWORD)v407)
                    {
                      *v32 = v275;
                      v68 = v274;
                      v4 = v402;
                      goto LABEL_369;
                    }
                    v271 = v276;
                    v68 = v274;
                    v4 = v402;
                    goto LABEL_367;
                  }
                }
LABEL_369:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v266 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v267)
                  goto LABEL_386;
              }
            case 21:
              v400 = v30;
              v401 = v38;
              v277 = (float *)v49 + 1;
              v278 = v4;
              v214 = v41;
              while (1)
              {
                v279 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v280 = *v214 * v279 + ((*v214 * v279) >> 8) + 1;
                    if (!BYTE1(v280))
                      goto LABEL_385;
                    v279 = v280 >> 8;
                  }
                  v281 = (float)v279 * *((float *)v68 + 159);
                  v282 = *v277 * v281;
                  if (v282 > 0.0)
                  {
                    v283 = *(v277 - 1) * v281;
                    if (v55)
                    {
                      v284 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_383:
                        *v32 = v283;
                        *v27 = v282;
                        goto LABEL_385;
                      }
                    }
                    else
                    {
                      v284 = 1.0;
                    }
                    v285 = v68;
                    v286 = PDAhardlightPDA(*v32, v284, v283, v282);
                    v55 = v407;
                    v283 = v286;
                    if (!(_DWORD)v407)
                    {
                      *v32 = v286;
                      v68 = v285;
                      v4 = v402;
                      goto LABEL_385;
                    }
                    v282 = v287;
                    v68 = v285;
                    v4 = v402;
                    goto LABEL_383;
                  }
                }
LABEL_385:
                ++v50;
                v214 += v41 != 0;
                ++v32;
                v277 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v278)
                {
LABEL_386:
                  v41 = &v214[v403];
                  v32 += v404;
                  v27 += v406;
                  v36 = v399;
                  v37 = v398;
                  v30 = v400;
                  v38 = v401;
                  goto LABEL_502;
                }
              }
            case 22:
              v288 = (float *)v49 + 1;
              v289 = v4;
              v71 = v41;
              while (1)
              {
                v290 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v291 = *v71 * v290 + ((*v71 * v290) >> 8) + 1;
                    if (!BYTE1(v291))
                      goto LABEL_403;
                    v290 = v291 >> 8;
                  }
                  v292 = (float)v290 * 0.0039216;
                  v293 = *v288 * v292;
                  if (v293 > 0.0)
                  {
                    v294 = *(v288 - 1) * v292;
                    if (v55)
                    {
                      v295 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_401:
                        *v32 = v294;
                        *v27 = v293;
                        goto LABEL_403;
                      }
                    }
                    else
                    {
                      v295 = 1.0;
                    }
                    v296 = v294 + *v32;
                    v297 = v293 * *v32;
                    v298 = v294 * v295;
                    v299 = v296 - v297;
                    v300 = v297 - v298;
                    v301 = v299 - v298;
                    if (v300 < 0.0)
                      v300 = -v300;
                    v294 = v301 + v300;
                    if (!v55)
                    {
                      *v32 = v294;
                      goto LABEL_403;
                    }
                    v293 = (float)(v293 + v295) - (float)(v295 * v293);
                    goto LABEL_401;
                  }
                }
LABEL_403:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v288 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v289)
                  goto LABEL_500;
              }
            case 23:
              v302 = (float *)v49 + 1;
              v303 = v4;
              v71 = v41;
              while (1)
              {
                v304 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v305 = *v71 * v304 + ((*v71 * v304) >> 8) + 1;
                    if (!BYTE1(v305))
                      goto LABEL_419;
                    v304 = v305 >> 8;
                  }
                  v306 = (float)v304 * 0.0039216;
                  v307 = *v302 * v306;
                  if (v307 > 0.0)
                  {
                    v308 = *(v302 - 1) * v306;
                    if (v55)
                    {
                      v309 = *v27;
                      if (*v27 <= 0.0)
                      {
LABEL_417:
                        *v32 = v308;
                        *v27 = v307;
                        goto LABEL_419;
                      }
                    }
                    else
                    {
                      v309 = 1.0;
                    }
                    v308 = (float)(v308 + *v32) + (float)((float)(v308 * *v32) * -2.0);
                    if (!v55)
                    {
                      *v32 = v308;
                      goto LABEL_419;
                    }
                    v307 = (float)(v307 + v309) - (float)(v309 * v307);
                    goto LABEL_417;
                  }
                }
LABEL_419:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v302 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v303)
                  goto LABEL_500;
              }
            case 24:
              v310 = (float *)v49 + 1;
              v311 = v4;
              v71 = v41;
              while (1)
              {
                v312 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v313 = *v71 * v312 + ((*v71 * v312) >> 8) + 1;
                    if (!BYTE1(v313))
                      goto LABEL_439;
                    v312 = v313 >> 8;
                  }
                  v314 = (float)v312 * 0.0039216;
                  v315 = *v310 * v314;
                  if (v315 > 0.0)
                  {
                    v316 = *(v310 - 1) * v314;
                    v317 = 1.0;
                    if (!v55 || (v317 = *v27, *v27 > 0.0))
                    {
                      v318 = *v32;
                      if (v315 != 1.0)
                        v318 = v315 * *v32;
                      v319 = 0.0;
                      if (v315 != 1.0)
                        v319 = *v32 - (float)(v315 * *v32);
                      v320 = (float)(v316 + v319) - (float)(v316 * v317);
                      if (v317 == 1.0)
                        v320 = v319;
                      v316 = v318 + v320;
                      if (!v55)
                      {
                        *v32 = v316;
                        goto LABEL_439;
                      }
                      v315 = (float)(v315 + v317) - (float)(v315 * v317);
                    }
                    *v32 = v316;
                    *v27 = v315;
                  }
                }
LABEL_439:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v310 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v311)
                  goto LABEL_500;
              }
            case 25:
              v321 = (float *)v49 + 1;
              v71 = v41;
              v322 = v4;
              while (1)
              {
                v323 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v324 = *v71 * v323 + ((*v71 * v323) >> 8) + 1;
                    if (!BYTE1(v324))
                      goto LABEL_459;
                    v323 = v324 >> 8;
                  }
                  v325 = (float)v323 * 0.0039216;
                  v326 = *v321 * v325;
                  if (v326 > 0.0)
                  {
                    v327 = *(v321 - 1) * v325;
                    v328 = 1.0;
                    if (!v55 || (v328 = *v27, *v27 > 0.0))
                    {
                      v329 = *v32;
                      if (v326 != 1.0)
                        v329 = v326 * *v32;
                      v330 = 0.0;
                      if (v326 != 1.0)
                        v330 = *v32 - (float)(v326 * *v32);
                      v331 = (float)(v327 + v330) - (float)(v327 * v328);
                      if (v328 == 1.0)
                        v331 = v330;
                      v327 = v329 + v331;
                      if (!v55)
                      {
                        *v32 = v327;
                        goto LABEL_459;
                      }
                      v326 = (float)(v326 + v328) - (float)(v326 * v328);
                    }
                    *v32 = v327;
                    *v27 = v326;
                  }
                }
LABEL_459:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v321 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v322)
                  goto LABEL_500;
              }
            case 26:
              v332 = (float *)v49 + 1;
              v71 = v41;
              v333 = v4;
              while (1)
              {
                v334 = *v50;
                if (*v50)
                {
                  if (v41)
                  {
                    v335 = *v71 * v334 + ((*v71 * v334) >> 8) + 1;
                    if (!BYTE1(v335))
                      goto LABEL_480;
                    v334 = v335 >> 8;
                  }
                  v336 = (float)v334 * 0.0039216;
                  v337 = *v332 * v336;
                  if (v337 > 0.0)
                  {
                    v338 = *(v332 - 1) * v336;
                    v339 = 1.0;
                    if (!v55 || (v339 = *v27, *v27 > 0.0))
                    {
                      v340 = *v32;
                      v341 = v338 - (float)(v338 * v339);
                      if (v339 == 1.0)
                        v341 = 0.0;
                      if (v337 == 1.0)
                        v342 = *v32;
                      else
                        v342 = v337 * v340;
                      if (v337 != 1.0)
                        v341 = (float)(v340 + v341) - (float)(v337 * v340);
                      v338 = v342 + v341;
                      if (!v55)
                      {
                        *v32 = v338;
                        goto LABEL_480;
                      }
                      v337 = (float)(v337 + v339) - (float)(v337 * v339);
                    }
                    *v32 = v338;
                    *v27 = v337;
                  }
                }
LABEL_480:
                ++v50;
                v71 += v41 != 0;
                ++v32;
                v332 += 2;
                v27 = (float *)((char *)v27 + v47);
                if (!--v333)
                  goto LABEL_500;
              }
            case 27:
              v343 = (float *)v49 + 1;
              v71 = v41;
              v344 = v4;
              break;
            default:
              goto LABEL_502;
          }
          break;
        }
        while (2)
        {
          v345 = *v50;
          if (*v50)
          {
            if (!v41)
              goto LABEL_487;
            v346 = *v71 * v345 + ((*v71 * v345) >> 8) + 1;
            if (BYTE1(v346))
            {
              v345 = v346 >> 8;
LABEL_487:
              v347 = (float)v345 * 0.0039216;
              v348 = *v343 * v347;
              if (v348 > 0.0)
              {
                v349 = *(v343 - 1) * v347;
                v350 = 1.0;
                if (v55 && (v350 = *v27, *v27 <= 0.0))
                {
LABEL_497:
                  *v32 = v349;
                  *v27 = v348;
                }
                else
                {
                  v351 = *v32 - (float)(v348 * *v32);
                  if (v348 == 1.0)
                    v351 = 0.0;
                  v352 = (float)(v349 + v351) - (float)(v349 * v350);
                  if (v350 == 1.0)
                  {
                    v353 = v351;
                  }
                  else
                  {
                    v349 = v349 * v350;
                    v353 = v352;
                  }
                  v349 = v349 + v353;
                  if (v55)
                  {
                    v348 = (float)(v348 + v350) - (float)(v348 * v350);
                    goto LABEL_497;
                  }
                  *v32 = v349;
                }
              }
            }
          }
          ++v50;
          v71 += v41 != 0;
          ++v32;
          v343 += 2;
          v27 = (float *)((char *)v27 + v47);
          if (!--v344)
          {
LABEL_500:
            v41 = &v71[v403];
            goto LABEL_501;
          }
          continue;
        }
      }
      v391 = shape_enum_clip_scan((uint64_t)v409, (_DWORD *)v41 - 4);
      v44 = (int)v410;
      if (!v391)
        goto LABEL_596;
    }
    v42 -= v390;
    if (v42 < 1)
      break;
    v30 += v37[16] * v390;
    v401 += v37[17] * v390;
    v32 += v393 * v390;
    v392 = v388 * v390;
    if (!(_DWORD)v407)
      v392 = 0;
    v27 += v392;
    v44 = v389;
  }
LABEL_596:
  if (v409)
    free(v409);
LABEL_598:
  if (v394)
    free(v394);
}

uint64_t Wf_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  _BOOL8 v8;
  int v9;
  __n128 v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  _BYTE v18[36];
  char v19;
  _QWORD v20[483];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E0C80C00];
  v7 = *(int **)v2;
  v8 = !*((_QWORD *)v3 + 12) && !*(_QWORD *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v9 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13)
      goto LABEL_22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 16))
  {
    v12 = Wf_shade_radial_W;
  }
  else if (*(_QWORD *)(v5 + 24))
  {
    v12 = Wf_shade_conic_W;
  }
  else if (v16 < 2)
  {
    v12 = Wf_shade_axial_W;
  }
  else
  {
    v12 = Wf_shade_custom_W;
  }
  v13 = v12;
LABEL_22:
  v14 = *v7;
  v15 = v14;
  Wf_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17))
    free(v17);
  return 1;
}

void Wf_shade_radial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float *v5;
  float v6;
  float v7;
  float *v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  uint64_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  char *v23;
  float *v24;
  uint64_t v25;
  float *v26;
  float *v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float v31;
  int v32;
  unsigned int v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float *i;
  float v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  BOOL v46;
  float v47;
  BOOL v48;
  unsigned int v49;
  float v50;
  uint64_t v51;
  float v52;
  float v53;
  float v54;
  char v55;
  float v56;
  float v57;
  float v58;
  uint64_t v59;
  int v60;
  float v61;
  float v62;
  float v63;
  float v65;
  float v66;
  float v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v71;
  float v72;
  float v73;
  float v74;
  uint64_t v75;
  float v76;
  float v77;
  uint64_t v78;
  float v79;
  float v80;
  float v81;
  char v82;
  char v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  float v88;
  uint64_t v89;
  float v90;
  float v91;
  float v92;
  int v93;

  v5 = *(float **)(a1 + 400);
  v6 = *(float *)(a1 + 280);
  v7 = *(float *)(a1 + 284);
  v8 = *(float **)(a1 + 272);
  v9 = v8[1];
  v10 = v9 * (float)a2;
  v11 = v9 * (float)a3;
  v12 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v11) + (float)(v6 * v10));
  v13 = *(float *)(a1 + 300) + (float)((float)(v11 * *(float *)(a1 + 292)) + (float)(v7 * v10));
  v14 = *(float *)(a1 + 336);
  v15 = *(float *)(a1 + 344);
  v16 = *(float *)(a1 + 304);
  v17 = *(float *)(a1 + 308);
  v18 = *(unsigned int *)(a1 + 324);
  v19 = v5[2];
  v20 = v5[4];
  v21 = v5[5];
  v22 = v5[7];
  v25 = a1 + 144;
  v23 = *(char **)(a1 + 144);
  v24 = *(float **)(v25 + 8);
  v26 = *(float **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v27 = *(float **)(a1 + 392);
  else
    v27 = v8;
  v28 = *(_QWORD *)(a1 + 32);
  v29 = *(_QWORD *)(a1 + 40);
  if (v29)
    v8 = *(float **)(a1 + 40);
  if (v19 != 0.0 || v22 != 0.0 || v7 != 0.0)
  {
    v33 = *(_DWORD *)(a1 + 320);
    v34 = v5[3];
    v35 = v5[8];
    v36 = -v5[6];
    v37 = v17 - v16;
    for (i = v24 + 1; ; i += 2)
    {
      v39 = v36 + (float)((float)(v12 + v12) * v19);
      v40 = (float)((float)(v13 * v13) + (float)(v12 * v12)) - v22;
      if (v21 == 0.0)
      {
        v47 = v40 / v39;
      }
      else
      {
        v41 = (float)((float)(v21 * -4.0) * v40) + (float)(v39 * v39);
        if (v41 < 0.0)
          goto LABEL_49;
        v42 = sqrtf(v41);
        v43 = v35 * (float)(v39 - v42);
        v44 = v39 + v42;
        v45 = v35 * v44;
        v46 = (float)(v35 * v44) <= v43;
        if ((float)(v35 * v44) <= v43)
          v47 = v35 * v44;
        else
          v47 = v43;
        if (v46)
          v45 = v43;
        if (v45 < 0.0)
        {
          v48 = v45 < v34;
LABEL_30:
          v49 = v33;
          if (v48)
            goto LABEL_49;
LABEL_31:
          if ((v49 & 0x80000000) == 0)
            goto LABEL_43;
          goto LABEL_49;
        }
        if (v45 <= 1.0)
        {
          v50 = v16 + (float)(v45 * v37);
          goto LABEL_42;
        }
        if ((v18 & 0x80000000) == 0)
        {
          v49 = v18;
          if (v45 <= v20)
          {
LABEL_43:
            v51 = v49;
            if (!v29)
              v51 = 0;
            v52 = v8[v51];
            if (v29)
              v53 = v8[v51];
            else
              v53 = 1.0;
            v54 = *(float *)(v28 + 4 * v49) * v53;
            goto LABEL_51;
          }
        }
      }
      if (v47 < 0.0)
      {
        v48 = v47 < v34;
        goto LABEL_30;
      }
      if (v47 > 1.0)
      {
        v49 = v18;
        if (v47 > v20)
          goto LABEL_49;
        goto LABEL_31;
      }
      v50 = v16 + (float)(v47 * v37);
LABEL_42:
      v49 = (int)(float)(v15 * (float)(v50 - v14));
      if ((v49 & 0x80000000) == 0)
        goto LABEL_43;
LABEL_49:
      if (!v26)
      {
        v55 = 0;
        goto LABEL_53;
      }
      v52 = *v27;
      v54 = *v27 * *v26;
LABEL_51:
      *(i - 1) = v54;
      *i = v52;
      v55 = -1;
LABEL_53:
      v12 = v6 + v12;
      v13 = v7 + v13;
      *v23++ = v55;
      if (!--a4)
        return;
    }
  }
  v30 = v13 * v13;
  v31 = -v21;
  if (v30 <= (float)-v21)
  {
    v56 = fabsf(v5[8]);
    v57 = v21 * -4.0;
    v58 = v17 - v16;
    if (v29)
      v59 = v18;
    else
      v59 = 0;
    v60 = a4 + 2;
    while (1)
    {
      v61 = v30 + (float)(v12 * v12);
      v62 = v6 + v12;
      v63 = v30 + (float)(v62 * v62);
      if (v61 > v31 && v63 > v31)
      {
        if ((v18 & 0x80000000) != 0)
        {
          if (!v26)
          {
            v82 = 0;
LABEL_121:
            v83 = 0;
            goto LABEL_93;
          }
          v72 = *v27;
          v74 = *v27 * *v26;
        }
        else
        {
          v72 = v8[v59];
          if (v29)
            v73 = v8[v59];
          else
            v73 = 1.0;
          v74 = *(float *)(v28 + 4 * v18) * v73;
        }
        *v24 = v74;
        v24[1] = v72;
        goto LABEL_91;
      }
      v65 = sqrtf(v57 * v63);
      v66 = v56 * sqrtf(v57 * v61);
      v67 = v56 * v65;
      v68 = (int)(float)(v15 * (float)((float)(v16 + (float)(v66 * v58)) - v14));
      v69 = (int)(float)(v15 * (float)((float)(v16 + (float)((float)(v56 * v65) * v58)) - v14));
      if (v66 <= 1.0 && v67 <= 1.0)
      {
        v75 = (int)v68;
        if (!v29)
          v75 = 0;
        v76 = v8[v75];
        v77 = *(float *)(v28 + 4 * (int)v68);
        v78 = (int)v69;
        if (v29)
          v79 = v8[v75];
        else
          v79 = 1.0;
        if (!v29)
          v78 = 0;
        v72 = v8[v78];
        v80 = v77 * v79;
        if (v29)
          v81 = v8[v78];
        else
          v81 = 1.0;
        v74 = *(float *)(v28 + 4 * (int)v69) * v81;
        *v24 = v80;
        v24[1] = v76;
LABEL_91:
        v82 = -1;
        goto LABEL_92;
      }
      if (v66 <= 1.0)
      {
        if ((v68 & 0x80000000) == 0)
        {
          if (v29)
            v71 = (int)(float)(v15 * (float)((float)(v16 + (float)(v66 * v58)) - v14));
          else
            v71 = 0;
LABEL_99:
          v84 = v8[v71];
          if (v29)
            v85 = v8[v71];
          else
            v85 = 1.0;
          v86 = *(float *)(v28 + 4 * v68) * v85;
          goto LABEL_105;
        }
      }
      else if (v66 <= v20)
      {
        v71 = v59;
        v68 = v18;
        if ((v18 & 0x80000000) == 0)
          goto LABEL_99;
      }
      if (!v26)
      {
        v82 = 0;
        goto LABEL_106;
      }
      v84 = *v27;
      v86 = *v27 * *v26;
LABEL_105:
      *v24 = v86;
      v24[1] = v84;
      v82 = -1;
LABEL_106:
      if (v67 <= 1.0)
      {
        if ((v69 & 0x80000000) == 0)
        {
          if (v29)
            v87 = v69;
          else
            v87 = 0;
LABEL_114:
          v72 = v8[v87];
          if (v29)
            v88 = v8[v87];
          else
            v88 = 1.0;
          v74 = *(float *)(v28 + 4 * v69) * v88;
          goto LABEL_92;
        }
      }
      else if (v67 <= v20)
      {
        v87 = v59;
        v69 = v18;
        if ((v18 & 0x80000000) == 0)
          goto LABEL_114;
      }
      if (!v26)
        goto LABEL_121;
      v72 = *v27;
      v74 = *v27 * *v26;
LABEL_92:
      v24[2] = v74;
      v24[3] = v72;
      v83 = -1;
LABEL_93:
      v12 = v6 + v62;
      v24 += 4;
      *v23 = v82;
      v23[1] = v83;
      v23 += 2;
      v60 -= 2;
      if (v60 <= 2)
        return;
    }
  }
  if (v26 || (v18 & 0x80000000) == 0)
  {
    if ((v18 & 0x80000000) != 0)
    {
      v90 = *v27;
      v92 = *v27 * *v26;
    }
    else
    {
      if (v29)
        v89 = v18;
      else
        v89 = 0;
      v90 = v8[v89];
      v91 = 1.0;
      if (v29)
        v91 = v8[v89];
      v92 = *(float *)(v28 + 4 * v18) * v91;
    }
    v93 = a4 + 4;
    do
    {
      *v24 = v92;
      v24[1] = v90;
      v24[2] = v92;
      v24[3] = v90;
      v24[4] = v92;
      v24[5] = v90;
      v93 -= 4;
      v24[6] = v92;
      v24[7] = v90;
      v24 += 8;
      *(_DWORD *)v23 = -1;
      v23 += 4;
    }
    while (v93 > 4);
  }
  else
  {
    if (a4 >= 4)
      v32 = 4;
    else
      v32 = a4;
    bzero(v23, ((a4 - v32 + 3) & 0xFFFFFFFC) + 4);
  }
}

void Wf_shade_conic_W(float32x2_t *a1, uint64_t a2, uint64_t a3, int a4, double a5, __n128 a6)
{
  float32x2_t v7;
  float v8;
  float v9;
  float v10;
  float *v11;
  _BYTE *v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  float v18;
  signed int v19;
  float v20;
  unsigned int v21;
  float v22;
  int v23;
  float v24;
  uint64_t v25;
  float v26;
  uint64_t v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  __n128 v33;

  v7 = a1[35];
  a6.n128_u64[0] = (unint64_t)vadd_f32(a1[37], vmla_n_f32(vmul_n_f32(a1[36], *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a3), v7, *(float *)(*(_QWORD *)&a1[34] + 4) * (float)a2));
  v8 = a1[42].f32[0];
  v9 = a1[43].f32[0];
  v10 = a1[38].f32[0];
  v12 = (_BYTE *)a1[18];
  v11 = (float *)a1[19];
  v13 = a1[4];
  v14 = a1[5];
  if (v14)
    v15 = a1[5];
  else
    v15 = a1[34];
  v16 = a1[38].f32[1] - v10;
  do
  {
    v33 = a6;
    v17 = v9
        * (float)((float)(v10 + (float)((float)((float)(atan2f(a6.n128_f32[1], a6.n128_f32[0]) * 0.15915) + 0.5) * v16))
                - v8);
    v18 = floorf(v17);
    v19 = vcvtms_s32_f32(v17);
    v20 = ceilf(v17);
    v21 = vcvtms_s32_f32(v9 + v17);
    if (v17 < 0.0)
      v19 = v21;
    v22 = ceilf(v17 - v9);
    if (v17 > v9)
      v20 = v22;
    v23 = (int)v20;
    v24 = (float)(int)v18;
    v25 = v19;
    if (!*(_QWORD *)&v14)
      v25 = 0;
    v26 = *(float *)(*(_QWORD *)&v15 + 4 * v25);
    v27 = v23;
    if (!*(_QWORD *)&v14)
      v27 = 0;
    v28 = v17 - v24;
    if (v14)
      v29 = v26;
    else
      v29 = 1.0;
    if (v14)
      v30 = *(float *)(*(_QWORD *)&v15 + 4 * v27);
    else
      v30 = 1.0;
    v31 = *(float *)(*(_QWORD *)&v13 + 4 * v19) * v29;
    v32 = v26 + (float)(v28 * (float)(*(float *)(*(_QWORD *)&v15 + 4 * v27) - v26));
    a6.n128_u64[1] = v33.n128_u64[1];
    *v11 = v31 + (float)(v28 * (float)((float)(*(float *)(*(_QWORD *)&v13 + 4 * v23) * v30) - v31));
    v11[1] = v32;
    v11 += 2;
    a6.n128_u64[0] = (unint64_t)vadd_f32(v7, (float32x2_t)v33.n128_u64[0]);
    *v12++ = -1;
    --a4;
  }
  while (a4);
}

uint64_t Wf_shade_custom_W(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, int32x4_t a6)
{
  uint64_t v6;
  float32x2_t v7;
  float32x4_t v8;
  float v9;
  float v10;
  float v11;
  float v12;
  char *v13;
  float *v14;
  float *v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  float *v20;
  float32x4_t v21;
  float v22;
  float v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  float v28;
  char v29;

  v6 = *(_QWORD *)(result + 272);
  v7 = *(float32x2_t *)(result + 280);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)(result + 296), vmla_n_f32(vmul_n_f32(*(float32x2_t *)(result + 288), *(float *)(v6 + 4) * (float)a3), v7, *(float *)(v6 + 4) * (float)a2));
  v8 = *(float32x4_t *)(result + 304);
  v9 = *(float *)(result + 336);
  v10 = *(float *)(result + 348);
  v11 = *(float *)(result + 344);
  v12 = *(float *)(result + 356);
  v13 = *(char **)(result + 144);
  v14 = *(float **)(result + 384);
  v15 = *(float **)(result + 392);
  if (!v15)
    v15 = *(float **)(result + 272);
  v16 = *(_QWORD *)(result + 32);
  v17 = *(_QWORD *)(result + 40);
  v18 = *(_DWORD *)(result + 48);
  if (v17)
    v19 = *(_DWORD *)(result + 48);
  else
    v19 = 0;
  if (v17)
    v6 = *(_QWORD *)(result + 40);
  v20 = (float *)(*(_QWORD *)(result + 152) + 4);
  do
  {
    v21 = (float32x4_t)vzip1q_s32(a6, a6);
    if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vtrn2_s16(vrev32_s16(vmovn_s32(vcgtq_f32(v8, v21))), vmovn_s32(vcgtq_f32(v21, v8))), 0xFuLL))) & 1) == 0)
    {
      v24 = (int)(float)(v12 * (float)(*(float *)&a6.i32[1] - v10));
      result = (int)(float)(v11 * (float)(*(float *)a6.i32 - v9));
      v25 = v16 + 4 * v18 * v24;
      v26 = (int)result;
      v27 = v6 + 4 * v19 * v24;
      if (!v17)
        v26 = 0;
      v22 = *(float *)(v27 + 4 * v26);
      if (v17)
        v28 = *(float *)(v27 + 4 * v26);
      else
        v28 = 1.0;
      v23 = *(float *)(v25 + 4 * (int)result) * v28;
      goto LABEL_18;
    }
    if (v14)
    {
      v22 = *v15;
      v23 = *v15 * *v14;
LABEL_18:
      *(v20 - 1) = v23;
      *v20 = v22;
      v29 = -1;
      goto LABEL_20;
    }
    v29 = 0;
LABEL_20:
    *(float32x2_t *)a6.i8 = vadd_f32(v7, *(float32x2_t *)a6.i8);
    *v13++ = v29;
    v20 += 2;
    --a4;
  }
  while (a4);
  return result;
}

void Wf_shade_axial_W(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v5;
  float *v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  unsigned int v12;
  unsigned int v13;
  _DWORD *v14;
  float *v15;
  uint64_t v16;
  float *v17;
  float *v18;
  uint64_t v19;
  uint64_t v20;
  float *v21;
  int v22;
  float *i;
  unsigned int v24;
  uint64_t v25;
  float v26;
  float v27;
  float v28;
  char v29;
  uint64_t v30;
  float v31;
  float v32;
  float v33;
  int v34;

  v5 = *(float *)(a1 + 280);
  v6 = *(float **)(a1 + 272);
  v7 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(v6[1] * (float)a3)) + (float)(v5 * (float)(v6[1] * (float)a2)));
  v8 = *(float *)(a1 + 336);
  v9 = *(float *)(a1 + 344);
  v10 = *(float *)(a1 + 304);
  v11 = *(float *)(a1 + 308);
  v12 = *(_DWORD *)(a1 + 320);
  v13 = *(_DWORD *)(a1 + 324);
  v16 = a1 + 144;
  v14 = *(_DWORD **)(a1 + 144);
  v15 = *(float **)(v16 + 8);
  v17 = *(float **)(a1 + 384);
  if (*(_QWORD *)(a1 + 392))
    v18 = *(float **)(a1 + 392);
  else
    v18 = v6;
  v19 = *(_QWORD *)(a1 + 32);
  v20 = *(_QWORD *)(a1 + 40);
  if (v20)
    v21 = *(float **)(a1 + 40);
  else
    v21 = v6;
  if (v5 != 0.0)
  {
    for (i = v15 + 1; ; i += 2)
    {
      v24 = v12;
      if (v7 >= v10)
      {
        v24 = v13;
        if (v7 <= v11)
          v24 = (int)(float)(v9 * (float)(v7 - v8));
      }
      if ((v24 & 0x80000000) != 0)
      {
        if (!v17)
        {
          v29 = 0;
          goto LABEL_31;
        }
        v26 = *v18;
        v28 = *v18 * *v17;
      }
      else
      {
        v25 = v24;
        if (!v20)
          v25 = 0;
        v26 = v21[v25];
        if (v20)
          v27 = v21[v25];
        else
          v27 = 1.0;
        v28 = *(float *)(v19 + 4 * v24) * v27;
      }
      *(i - 1) = v28;
      *i = v26;
      v29 = -1;
LABEL_31:
      v7 = v5 + v7;
      *(_BYTE *)v14 = v29;
      v14 = (_DWORD *)((char *)v14 + 1);
      if (!--a4)
        return;
    }
  }
  if (v7 >= v10)
  {
    v12 = v13;
    if (v7 <= v11)
      v12 = (int)(float)(v9 * (float)(v7 - v8));
  }
  if ((v12 & 0x80000000) == 0 || v17)
  {
    if ((v12 & 0x80000000) != 0)
    {
      v31 = *v18;
      v33 = *v18 * *v17;
    }
    else
    {
      v30 = v12;
      if (!v20)
        v30 = 0;
      v31 = v21[v30];
      v32 = 1.0;
      if (v20)
        v32 = v21[v30];
      v33 = *(float *)(v19 + 4 * v12) * v32;
    }
    v34 = a4 + 4;
    do
    {
      *v15 = v33;
      v15[1] = v31;
      v15[2] = v33;
      v15[3] = v31;
      v15[4] = v33;
      v15[5] = v31;
      v34 -= 4;
      v15[6] = v33;
      v15[7] = v31;
      v15 += 8;
      *v14++ = -1;
    }
    while (v34 > 4);
  }
  else
  {
    if (a4 >= 4)
      v22 = 4;
    else
      v22 = a4;
    bzero(v14, ((a4 - v22 + 3) & 0xFFFFFFFC) + 4);
  }
}

int8x8_t *WF_pattern(uint64_t a1, int8x8_t *a2, unsigned int a3, int a4, float *a5, float a6)
{
  uint64_t v9;
  int8x8_t v10;
  float v11;
  int8x8_t *v12;
  float v13;
  int v14;
  float v15;
  char *v16;
  __int32 v18;

  v9 = *(_QWORD *)(*(_QWORD *)a1 + 64);
  v10.i32[0] = *(_DWORD *)v9;
  v11 = *(float *)(v9 + 4);
  if (!a2 || a3 <= 7)
  {
    v18 = *(_DWORD *)v9;
    v12 = (int8x8_t *)malloc_type_malloc(0x38uLL, 0x705560E0uLL);
    v10.i32[0] = v18;
    a2 = v12;
    if (!v12)
      return a2;
  }
  if (*(float *)v10.i32 <= a6)
    v13 = a6;
  else
    v13 = *(float *)v10.i32;
  if (v11 < a6)
    v13 = v11;
  if (a5)
    v14 = a4;
  else
    v14 = 0;
  switch(v14)
  {
    case 1:
      v15 = *a5;
      goto LABEL_18;
    case 4:
      v15 = (float)(v11
                  - (float)((float)((float)(*a5 * *(float *)(v9 + 8)) + (float)(a5[1] * *(float *)(v9 + 12)))
                          + (float)(a5[2] * *(float *)(v9 + 16))))
          - a5[3];
      goto LABEL_18;
    case 3:
      v15 = (float)((float)(*a5 * *(float *)(v9 + 8)) + (float)(a5[1] * *(float *)(v9 + 12)))
          + (float)(a5[2] * *(float *)(v9 + 16));
LABEL_18:
      *(float *)v10.i32 = v13 * v15;
      break;
  }
  *(_OWORD *)a2->i8 = xmmword_185004C60;
  a2[3].i32[0] = 0;
  *(float *)&v10.i32[1] = v13;
  a2[6] = vrev32_s8(v10);
  a2[2] = (int8x8_t)1;
  v16 = (char *)&a2[6] + 4;
  if (v13 >= v11)
    v16 = 0;
  a2[4] = (int8x8_t)&a2[6];
  a2[5] = (int8x8_t)v16;
  return a2;
}

uint64_t WF_mark(uint64_t a1, __n128 a2)
{
  return WF_mark_inner(*(_QWORD *)(*(_QWORD *)a1 + 56), a2);
}

uint64_t WF_mark_inner(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  int32x2_t v5;
  int32x2_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  unint64_t v12;
  unsigned int v13;
  int v14;
  uint64_t v15;
  uint16x4_t *v16;
  int v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  float v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  unsigned int v33;
  size_t v34;
  _BYTE *v35;
  _BYTE *v36;
  unint64_t v37;
  _BYTE *v38;
  uint64_t v39;
  unint64_t v40;
  unsigned int *v41;
  int v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int8x16_t *v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  unsigned int *v55;
  int v56;
  unsigned int *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  char *v61;
  char *v62;
  unint64_t v63;
  unint64_t v64;
  unint64_t v65;
  unint64_t v66;
  uint64_t v67;
  unsigned int *v68;
  int v69;
  unsigned int *v70;
  uint64_t v71;
  unsigned int *v72;
  char *v73;
  uint64_t v74;
  _BYTE *v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  char *v79;
  int v80;
  int v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  int *v86;
  int v87;
  int v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;
  int v92;
  unsigned int v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  int v101;
  float v102;
  unsigned int v103;
  int v104;
  float v105;
  int v106;
  float v107;
  unsigned int v108;
  int v109;
  float v110;
  float v111;
  unsigned int v112;
  unsigned int v113;
  uint64_t v114;
  int v115;
  unsigned int v116;
  int v117;
  uint64_t v118;
  int v119;
  unsigned int v120;
  int v121;
  int v122;
  float v123;
  int v124;
  float v125;
  float v126;
  uint64_t v127;
  int v128;
  float v129;
  float v130;
  float v131;
  int v132;
  uint64_t v133;
  int v134;
  float v135;
  float v136;
  int v137;
  unsigned int v138;
  int v139;
  float v140;
  float v141;
  float v142;
  unsigned int v143;
  int v144;
  float v145;
  float v146;
  unsigned int v147;
  int v148;
  float v149;
  unsigned int v150;
  unsigned int v151;
  int v152;
  float v153;
  float v154;
  float v155;
  float v156;
  unsigned int v157;
  int v158;
  float v159;
  float v160;
  float v161;
  float v162;
  unsigned int v163;
  int v164;
  float v165;
  unsigned int v166;
  unsigned int v167;
  int v168;
  float v169;
  unsigned int v170;
  unsigned int v171;
  int v172;
  float v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  float v177;
  unsigned int v178;
  void *v179;
  unsigned int v180;
  int v181;
  float v182;
  float v183;
  float v184;
  unsigned int v185;
  int v186;
  float v187;
  float v188;
  unsigned int v189;
  int v190;
  float v191;
  float v192;
  float v193;
  float v194;
  unsigned int v195;
  int v196;
  float v197;
  float v198;
  float v199;
  float v200;
  unsigned int v201;
  int v202;
  float v203;
  float v204;
  float v205;
  float v206;
  unsigned int v207;
  int v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float32x4_t v213;
  float32x4_t v214;
  int v215;
  unsigned int v216;
  unsigned int v217;
  int v218;
  int v219;
  unsigned int *v220;
  unint64_t v221;
  int v222;
  int v223;
  unint64_t v224;
  uint64_t v225;
  unint64_t v226;
  unint64_t v227;
  unint64_t v228;
  uint64_t v229;
  uint64_t v230;
  int v231;
  unsigned int *v232;
  unsigned int v233;
  uint64_t v234;
  char *v235;
  uint64_t v236;
  int v237;
  int v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  float v243;
  unsigned int v244;
  unsigned int *v245;
  uint64_t v246;
  unsigned int *v247;
  uint64_t v248;
  uint64_t v249;
  int v250;
  float v251;
  unsigned int v252;
  unsigned int *v253;
  uint64_t v254;
  unsigned int *v255;
  uint64_t v256;
  uint64_t v257;
  int v258;
  float v259;
  float v260;
  unsigned int v261;
  unsigned int *v262;
  uint64_t v263;
  unsigned int *v264;
  uint64_t v265;
  uint64_t v266;
  int v267;
  float v268;
  float v269;
  unsigned int *v270;
  uint64_t v271;
  unsigned int *v272;
  uint64_t v273;
  uint64_t v274;
  int v275;
  float v276;
  float v277;
  float v278;
  unsigned int v279;
  float v280;
  unsigned int *v281;
  uint64_t v282;
  unsigned int *v283;
  uint64_t v284;
  uint64_t v285;
  int v286;
  float v287;
  unsigned int v288;
  unsigned int *v289;
  uint64_t v290;
  unsigned int *v291;
  uint64_t v292;
  uint64_t v293;
  int v294;
  float v295;
  unsigned int v296;
  unsigned int *v297;
  uint64_t v298;
  unsigned int *v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  float v303;
  float v304;
  unsigned int *v305;
  uint64_t v306;
  unsigned int *v307;
  uint64_t v308;
  uint64_t v309;
  int v310;
  float v311;
  float v312;
  unsigned int *v313;
  uint64_t v314;
  unsigned int *v315;
  uint64_t v316;
  uint64_t v317;
  int v318;
  float v319;
  float v320;
  float v321;
  float v322;
  float v323;
  unsigned int *v324;
  uint64_t v325;
  unsigned int *v326;
  uint64_t v327;
  uint64_t v328;
  int v329;
  float v330;
  float v331;
  float v332;
  unsigned int *v333;
  uint64_t v334;
  unsigned int *v335;
  uint64_t v336;
  uint64_t v337;
  int v338;
  float v339;
  float v340;
  float v341;
  float v342;
  float v343;
  float v344;
  unsigned int v345;
  unsigned int *v346;
  uint64_t v347;
  unsigned int *v348;
  uint64_t v349;
  uint64_t v350;
  int v351;
  float v352;
  float v353;
  float v354;
  float v355;
  unsigned int v356;
  unsigned int *v357;
  uint64_t v358;
  unsigned int *v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  int v365;
  float v366;
  float v367;
  uint64_t v368;
  unint64_t v369;
  float v370;
  unsigned int v371;
  unsigned int *v372;
  uint64_t v373;
  unsigned int *v374;
  uint64_t v375;
  uint64_t v376;
  int v377;
  float v378;
  float v379;
  float v380;
  float v381;
  float v382;
  float v383;
  unsigned int v384;
  unsigned int *v385;
  uint64_t v386;
  unsigned int *v387;
  uint64_t v388;
  uint64_t v389;
  int v390;
  float v391;
  float v392;
  float v393;
  float v394;
  float v395;
  float v396;
  unsigned int v397;
  unsigned int *v398;
  uint64_t v399;
  unsigned int *v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  int v406;
  float v407;
  float v408;
  uint64_t v409;
  unint64_t v410;
  float v411;
  unsigned int v412;
  unsigned int *v413;
  uint64_t v414;
  unsigned int *v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  int v421;
  float v422;
  float v423;
  uint64_t v424;
  unint64_t v425;
  float v426;
  unsigned int v427;
  unsigned int *v428;
  uint64_t v429;
  unsigned int *v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  int v436;
  float v437;
  float v438;
  uint64_t v439;
  unint64_t v440;
  float v441;
  unsigned int v442;
  unsigned int *v443;
  uint64_t v444;
  unsigned int *v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  int v451;
  float v452;
  float v453;
  uint64_t v454;
  unint64_t v455;
  float v456;
  unsigned int v457;
  unsigned int *v458;
  uint64_t v459;
  unsigned int *v460;
  uint64_t v461;
  uint64_t v462;
  int v463;
  float v464;
  float v465;
  float v466;
  float v467;
  float v468;
  float v469;
  float v470;
  float v471;
  float v472;
  unsigned int v473;
  unsigned int *v474;
  uint64_t v475;
  unsigned int *v476;
  uint64_t v477;
  uint64_t v478;
  int v479;
  float v480;
  float v481;
  float v482;
  float v483;
  float v484;
  unsigned int v485;
  unsigned int *v486;
  uint64_t v487;
  unsigned int *v488;
  uint64_t v489;
  uint64_t v490;
  int v491;
  float v492;
  float v493;
  float v494;
  float v495;
  float v496;
  float v497;
  float v498;
  float v499;
  unsigned int v500;
  unsigned int *v501;
  uint64_t v502;
  unsigned int *v503;
  uint64_t v504;
  uint64_t v505;
  int v506;
  float v507;
  float v508;
  float v509;
  float v510;
  float v511;
  float v512;
  float v513;
  float v514;
  unsigned int v515;
  unsigned int *v516;
  uint64_t v517;
  unsigned int *v518;
  uint64_t v519;
  uint64_t v520;
  int v521;
  float v522;
  float v523;
  float v524;
  float v525;
  float v526;
  float v527;
  float v528;
  unsigned int v529;
  unsigned int *v530;
  uint64_t v531;
  unsigned int *v532;
  uint64_t v533;
  uint64_t v534;
  int v535;
  float v536;
  float v537;
  float v538;
  float v539;
  float v540;
  float v541;
  float v542;
  unsigned int v543;
  unsigned int *v544;
  uint64_t v545;
  unsigned int *v546;
  uint64_t v547;
  uint64_t v548;
  int v549;
  float v550;
  unsigned int *v551;
  uint64_t v552;
  unsigned int *v553;
  uint64_t v554;
  uint64_t v555;
  int v556;
  float v557;
  unsigned int *v558;
  uint64_t v559;
  unsigned int *v560;
  uint64_t v561;
  uint64_t v562;
  int v563;
  float v564;
  unsigned int *v565;
  uint64_t v566;
  unsigned int *v567;
  uint64_t v568;
  uint64_t v569;
  int v570;
  float v571;
  unsigned int *v572;
  uint64_t v573;
  unsigned int *v574;
  uint64_t v575;
  uint64_t v576;
  int v577;
  float v578;
  unsigned int *v579;
  uint64_t v580;
  unsigned int *v581;
  uint64_t v582;
  uint64_t v583;
  int v584;
  unsigned int *v585;
  uint64_t v586;
  unsigned int *v587;
  uint64_t v588;
  uint64_t v589;
  uint8x8_t v590;
  unsigned int v591;
  int v592;
  unsigned int v593;
  uint64_t v594;
  uint64_t v595;
  int v596;
  int v597;
  unsigned int *v598;
  uint64_t v599;
  unsigned int *v600;
  uint64_t v601;
  uint64_t v602;
  int v603;
  int v604;
  unsigned int *v605;
  uint64_t v606;
  unsigned int *v607;
  uint64_t v608;
  uint64_t v609;
  int v610;
  unsigned int *v611;
  uint64_t v612;
  unsigned int *v613;
  uint64_t v614;
  uint64_t v615;
  uint64_t v616;
  char *v617;
  unint64_t v618;
  char *v619;
  uint64_t v620;
  int v621;
  uint64_t v622;
  char *v623;
  uint64_t v624;
  char *v625;
  unint64_t v626;
  uint64_t v627;
  uint64_t v628;
  char *v629;
  uint64_t v630;
  unint64_t v631;
  unsigned int *v632;
  unsigned int *v633;
  uint64_t v634;
  unint64_t v635;
  unint64_t v636;
  unint64_t v637;
  uint64_t v638;
  int v639;
  int v640;
  unsigned int *v641;
  unint64_t v642;
  char *v643;
  int v644;
  int v645;
  uint64_t v646;
  uint64_t v647;
  unint64_t v648;
  uint64_t v649;
  unsigned int *v650;
  uint64_t v651;
  unint64_t v652;
  int v653;
  int v654[2];
  int v655[2];
  int v656[2];
  int v657[2];
  int v658[2];
  int v659;
  int v660;
  unsigned int v661;
  unsigned int *v662;
  unint64_t v663;
  unint64_t v664;
  int32x2_t v665;
  unint64_t v666;
  uint64_t v667;
  unint64_t v668;
  unint64_t v669;
  uint64_t v670;
  int32x2_t v671;
  uint64_t v672;
  uint64_t v673;
  int v674[4];
  __int128 v675;
  __int128 v676;
  __int128 v677;
  __int128 v678;
  __int128 v679;
  __int128 v680;
  __int128 v681;
  __int128 v682;
  __int128 v683;
  _DWORD v684[1024];
  uint64_t v685;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v685 = *MEMORY[0x1E0C80C00];
  v7 = *(unsigned int **)(v3 + 96);
  v8 = *(_QWORD *)(v3 + 48);
  v9 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
  if ((int)v9 > 27)
    return 0xFFFFFFFFLL;
  v11 = v3;
  v12 = *(unsigned int *)(v3 + 4);
  v13 = v12 - 1;
  if ((int)v12 < 1)
    return 0;
  v14 = *(_DWORD *)(v3 + 8);
  v15 = (v14 - 1);
  if (v14 < 1)
    return 0;
  v16 = *(uint16x4_t **)(v3 + 136);
  if ((*(_DWORD *)v3 & 0xFF0000) == 0x50000 || !v16)
  {
    v18 = *(_DWORD *)v3 & 0xFF00;
    v634 = *(unsigned int *)(v2 + 16 * *(_DWORD *)v3 + 8 * (v7 == 0) + 4 * (v8 == 0));
    v638 = v3;
    if (v18 == 1024)
    {
      v684[0] = *(_DWORD *)(v3 + 4);
      v674[0] = v14;
      v19 = **(_DWORD **)(v3 + 88);
      v20 = bswap32(v19);
      v21 = 1.0;
      if (v7)
        v21 = COERCE_FLOAT(bswap32(*v7));
      v6.i32[0] = v20;
      v22 = *(_QWORD *)(v3 + 40);
      v23 = (unint64_t)*(int *)(v3 + 28) >> 2;
      v25 = *(int *)(v3 + 12);
      v24 = *(int *)(v3 + 16);
      if (v8)
      {
        v669 = (unint64_t)*(int *)(v3 + 32) >> 2;
        v667 = v8 + 4 * (v25 + v669 * v24);
        v661 = 1;
      }
      else
      {
        v667 = 0;
        v669 = 0;
        v661 = 0;
      }
      *(float *)v5.i32 = 1.0 - v21;
      v37 = v22 + 4 * (v25 + v24 * v23);
      v671 = v6;
      v665 = v5;
      v652 = (unint64_t)*(int *)(v3 + 28) >> 2;
      v663 = v37;
      if (v16)
      {
        shape_enum_clip_alloc(v2, v3, (int *)v16, 1, 1, 1, *(_DWORD *)(v3 + 104), *(_DWORD *)(v3 + 108), v12, v14);
        v36 = v38;
        v39 = v667;
        v40 = v669;
        if (v38)
          goto LABEL_308;
        return 1;
      }
      v36 = 0;
      if (v8)
        v46 = v12;
      else
        v46 = 0;
      v39 = v667;
      v40 = v669 - v46;
      v47 = (int8x16_t *)(v22 + 4 * (v25 + v24 * v23));
      v48 = v12;
LABEL_65:
      v37 = v23 - v48;
      switch((int)v9)
      {
        case 0:
          v74 = v9;
          v75 = v36;
          v76 = v37 + (int)v12;
          v77 = v674[0];
          v78 = v674[0] - 1;
          v79 = &v47->i8[4 * ((v76 * v78) & (v76 >> 63))];
          if (v76 < 0)
            v76 = -v76;
          v80 = 4 * v12;
          v81 = v12;
          CGBlt_fillBytes(4 * v12, v674[0], 0, v79, 4 * v76);
          if (v8)
          {
            v82 = v40 + v81;
            v39 += 4 * ((v82 * v78) & (v82 >> 63));
            if (v82 >= 0)
              v40 += v81;
            else
              v40 = -v82;
            CGBlt_fillBytes(v80, v77, 0, (char *)v39, 4 * v40);
          }
          v11 = v638;
          v37 = v663;
          v36 = v75;
          v9 = v74;
          v23 = v652;
          goto LABEL_306;
        case 1:
          v83 = (int)v12;
          v84 = v37 + (int)v12;
          if (v84 < 0)
          {
            v47 = (int8x16_t *)((char *)v47 + 4 * v84 * (v674[0] - 1));
            v84 = -v84;
          }
          v85 = 0;
          v86 = *(int **)(v11 + 88);
          if (v86)
            v85 = *v86;
          v87 = 4 * v12;
          v88 = v674[0];
          CGBlt_fillBytes(4 * v12, v674[0], v85, v47->i8, 4 * v84);
          if (v8)
          {
            v89 = v88;
            v11 = v638;
            v90 = *(int **)(v638 + 96);
            if (!v90)
              v90 = (int *)&unk_1850012EC;
            v39 += 4 * (((v40 + v83) * (v89 - 1)) & ((uint64_t)(v40 + v83) >> 63));
            if ((uint64_t)(v40 + v83) >= 0)
              v40 += v83;
            else
              v40 = -(uint64_t)(v40 + v83);
            CGBlt_fillBytes(v87, v89, *v90, (char *)v39, 4 * v40);
            v9 = v634;
          }
          else
          {
            v9 = v634;
            v11 = v638;
          }
          goto LABEL_305;
        case 2:
          v91 = 4 * v661;
          if (v8)
          {
            do
            {
              v92 = v684[0];
              if (v684[0] >= 4)
              {
                v93 = (v684[0] >> 2) + 1;
                do
                {
                  v94 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v39))
                                                                * *(float *)v5.i32)));
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)v39 = v94;
                  v95 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 4)))
                                                                * *(float *)v5.i32)));
                  v47->i32[1] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[1]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 4) = v95;
                  v96 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 8)))
                                                                * *(float *)v5.i32)));
                  v47->i32[2] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[2]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 8) = v96;
                  v97 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)(v39 + 12)))
                                                                * *(float *)v5.i32)));
                  v47->i32[3] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->u32[3]))
                                                                                     * *(float *)v5.i32)));
                  *(_DWORD *)(v39 + 12) = v97;
                  ++v47;
                  --v93;
                  v39 += 16 * v661;
                }
                while (v93 > 1);
                v92 = v684[0] & 3;
              }
              if (v92 >= 1)
              {
                v98 = v92 + 1;
                do
                {
                  v99 = bswap32(COERCE_UNSIGNED_INT(v21 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v39))
                                                                * *(float *)v5.i32)));
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  v47 = (int8x16_t *)((char *)v47 + 4);
                  *(_DWORD *)v39 = v99;
                  v39 += v91;
                  --v98;
                }
                while (v98 > 1);
              }
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            v213 = (float32x4_t)vdupq_lane_s32(v5, 0);
            v214 = (float32x4_t)vdupq_lane_s32(v6, 0);
            do
            {
              v215 = v684[0];
              if (v684[0] >= 4)
              {
                v216 = (v684[0] >> 2) + 1;
                do
                {
                  *v47 = vrev32q_s8((int8x16_t)vmlaq_f32(v214, v213, (float32x4_t)vrev32q_s8(*v47)));
                  ++v47;
                  --v216;
                  v39 += 16 * v661;
                }
                while (v216 > 1);
                v215 &= 3u;
              }
              if (v215 >= 1)
              {
                v217 = v215 + 1;
                do
                {
                  v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + (float)(COERCE_FLOAT(bswap32(v47->i32[0]))
                                                                                     * *(float *)v5.i32)));
                  v47 = (int8x16_t *)((char *)v47 + 4);
                  v39 += v91;
                  --v217;
                }
                while (v217 > 1);
              }
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 3:
          v100 = bswap32(LODWORD(v21));
          do
          {
            v101 = v684[0];
            do
            {
              v102 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              if (v102 <= 0.0)
              {
                *(_DWORD *)v39 = 0;
                v47->i32[0] = 0;
              }
              else if (v102 >= 1.0)
              {
                v47->i32[0] = v19;
                *(_DWORD *)v39 = v100;
              }
              else
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 * v102));
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT(v21 * v102));
              }
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v101;
            }
            while (v101);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 4:
          v103 = bswap32(LODWORD(v21));
          do
          {
            v104 = v684[0];
            do
            {
              v105 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              if (v105 <= 0.0)
              {
                *(_DWORD *)v39 = 0;
                v47->i32[0] = 0;
              }
              else if (v105 >= 1.0)
              {
                v47->i32[0] = v19;
                *(_DWORD *)v39 = v103;
              }
              else
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v105 * *(float *)v6.i32));
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT(v21 * v105));
              }
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v104;
            }
            while (v104);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 5:
          do
          {
            v106 = v684[0];
            do
            {
              v107 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * v107)));
              v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * v107) + (float)(v21 * v107)));
              v39 += 4 * v661;
              --v106;
            }
            while (v106);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 6:
          v108 = bswap32(LODWORD(v21));
          while (1)
          {
            v109 = v684[0];
            do
            {
              v110 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v111 = 1.0 - v110;
              v112 = v19;
              v113 = v108;
              if ((float)(1.0 - v110) < 1.0)
              {
                if (v111 <= 0.0)
                  goto LABEL_125;
                v112 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(v47->i32[0])) + (float)(*(float *)v6.i32 * v111)));
                v113 = bswap32(COERCE_UNSIGNED_INT(v110 + (float)(v21 * v111)));
              }
              v47->i32[0] = v112;
              *(_DWORD *)v39 = v113;
LABEL_125:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v109;
            }
            while (v109);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 7:
          v114 = 4 * v661;
          if (v8)
          {
            do
            {
              v115 = v684[0];
              do
              {
                v116 = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(*(_DWORD *)v39))));
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)v39 = v116;
                v39 += v114;
                --v115;
              }
              while (v115);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              v117 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v21 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v114;
                --v117;
              }
              while (v117);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 8:
          v118 = 4 * v661;
          if (v8)
          {
            do
            {
              v119 = v684[0];
              do
              {
                v120 = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(*(_DWORD *)v39))));
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)v39 = v120;
                v39 += v118;
                --v119;
              }
              while (v119);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              v121 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v118;
                --v121;
              }
              while (v121);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 9:
          do
          {
            v122 = v684[0];
            do
            {
              v123 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(v21 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * (float)(1.0 - v123))));
              v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 * v123) + (float)(v21 * (float)(1.0 - v123))));
              v39 += 4 * v661;
              --v122;
            }
            while (v122);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 10:
          do
          {
            v124 = v684[0];
            do
            {
              v125 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * COERCE_FLOAT(bswap32(v47->i32[0])))+ (float)(*(float *)v6.i32 * (float)(1.0 - v125))));
              v47 = (int8x16_t *)((char *)v47 + 4);
              *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v5.i32 * v125) + (float)(v21 * (float)(1.0 - v125))));
              v39 += 4 * v661;
              --v124;
            }
            while (v124);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            --v674[0];
          }
          while (v674[0]);
          goto LABEL_305;
        case 11:
          v126 = v21 - *(float *)v6.i32;
          v127 = 4 * v661;
          if (v8)
          {
            do
            {
              v128 = v684[0];
              do
              {
                v129 = COERCE_FLOAT(bswap32(v47->i32[0]));
                v130 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                v131 = v21 + v130;
                if ((float)(v21 + v130) > 1.0)
                  v131 = 1.0;
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v126 + (float)(v131 - (float)(v130 - v129))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)v39 = bswap32(LODWORD(v131));
                v39 += v127;
                --v128;
              }
              while (v128);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              v132 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v126 + COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v127;
                --v132;
              }
              while (v132);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 12:
          v133 = 4 * v661;
          if (v8)
          {
            do
            {
              v134 = v684[0];
              do
              {
                v135 = v21 + COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                v136 = *(float *)v6.i32 + COERCE_FLOAT(bswap32(v47->i32[0]));
                if (v135 > 1.0)
                  v135 = 1.0;
                v47->i32[0] = bswap32(LODWORD(v136));
                v47 = (int8x16_t *)((char *)v47 + 4);
                *(_DWORD *)v39 = bswap32(LODWORD(v135));
                v39 += v133;
                --v134;
              }
              while (v134);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          else
          {
            do
            {
              v137 = v684[0];
              do
              {
                v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v6.i32 + COERCE_FLOAT(bswap32(v47->i32[0]))));
                v47 = (int8x16_t *)((char *)v47 + 4);
                v39 += v133;
                --v137;
              }
              while (v137);
              v47 = (int8x16_t *)((char *)v47 + 4 * v37);
              v39 += 4 * v40;
              --v674[0];
            }
            while (v674[0]);
          }
          goto LABEL_305;
        case 13:
          if (v21 <= 0.0)
            goto LABEL_305;
          v138 = bswap32(LODWORD(v21));
          while (1)
          {
            v139 = v684[0];
            do
            {
              if (v8)
              {
                v140 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v140 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v138;
                  goto LABEL_189;
                }
              }
              else
              {
                v140 = 1.0;
              }
              v141 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v142 = (float)(*(float *)v6.i32 * v141) + (float)(v141 * *(float *)v5.i32);
              if (v21 == 1.0)
                v142 = *(float *)v6.i32 * v141;
              if (v140 != 1.0)
                v142 = v142 + (float)(*(float *)v6.i32 * (float)(1.0 - v140));
              v47->i32[0] = bswap32(LODWORD(v142));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v140) - (float)(v140 * v21)));
LABEL_189:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v139;
            }
            while (v139);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 14:
          if (v21 <= 0.0)
            goto LABEL_305;
          v143 = bswap32(LODWORD(v21));
          while (1)
          {
            v144 = v684[0];
            do
            {
              if (v8)
              {
                v145 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v145 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v143;
                  goto LABEL_201;
                }
              }
              else
              {
                v145 = 1.0;
              }
              v146 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v146 + (float)(*(float *)v6.i32 * (float)(1.0 - v146))));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v145) - (float)(v145 * v21)));
LABEL_201:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v144;
            }
            while (v144);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 15:
          if (v21 <= 0.0)
            goto LABEL_305;
          v147 = bswap32(LODWORD(v21));
          while (1)
          {
            v148 = v684[0];
            do
            {
              if (v8)
              {
                v149 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v149 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v147;
                  goto LABEL_214;
                }
              }
              else
              {
                v149 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAoverlayPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v149, *(float *)v6.i32, v21)));
              if (v8)
                *(_DWORD *)v39 = bswap32(v150);
              v6.i32[0] = v671.i32[0];
LABEL_214:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v148;
            }
            while (v148);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_304;
          }
        case 16:
          if (v21 <= 0.0)
            goto LABEL_305;
          v151 = bswap32(LODWORD(v21));
          while (1)
          {
            v152 = v684[0];
            do
            {
              if (v8)
              {
                v153 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v153 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v151;
                  goto LABEL_232;
                }
              }
              else
              {
                v153 = 1.0;
              }
              v154 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v155 = v21 * v154;
              if ((float)(v153 * *(float *)v6.i32) < (float)(v21 * v154))
                v155 = v153 * *(float *)v6.i32;
              v156 = v155 + (float)(v154 * *(float *)v5.i32);
              if (v21 == 1.0)
                v156 = v155;
              if (v153 != 1.0)
                v156 = v156 + (float)(*(float *)v6.i32 * (float)(1.0 - v153));
              v47->i32[0] = bswap32(LODWORD(v156));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v153) - (float)(v153 * v21)));
LABEL_232:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v152;
            }
            while (v152);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 17:
          if (v21 <= 0.0)
            goto LABEL_305;
          v157 = bswap32(LODWORD(v21));
          while (1)
          {
            v158 = v684[0];
            do
            {
              if (v8)
              {
                v159 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v159 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v157;
                  goto LABEL_250;
                }
              }
              else
              {
                v159 = 1.0;
              }
              v160 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v161 = v21 * v160;
              if ((float)(v159 * *(float *)v6.i32) > (float)(v21 * v160))
                v161 = v159 * *(float *)v6.i32;
              v162 = v161 + (float)(v160 * *(float *)v5.i32);
              if (v21 == 1.0)
                v162 = v161;
              if (v159 != 1.0)
                v162 = v162 + (float)(*(float *)v6.i32 * (float)(1.0 - v159));
              v47->i32[0] = bswap32(LODWORD(v162));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v159) - (float)(v159 * v21)));
LABEL_250:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v158;
            }
            while (v158);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 18:
          if (v21 <= 0.0)
            goto LABEL_305;
          v163 = bswap32(LODWORD(v21));
          while (1)
          {
            v164 = v684[0];
            do
            {
              if (v8)
              {
                v165 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v165 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v163;
                  goto LABEL_263;
                }
              }
              else
              {
                v165 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAcolordodgePDA(COERCE_FLOAT(bswap32(v47->i32[0])), v165, *(float *)v6.i32, v21)));
              if (v8)
                *(_DWORD *)v39 = bswap32(v166);
              v6.i32[0] = v671.i32[0];
LABEL_263:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v164;
            }
            while (v164);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_304;
          }
        case 19:
          if (v21 <= 0.0)
            goto LABEL_305;
          v167 = bswap32(LODWORD(v21));
          while (1)
          {
            v168 = v684[0];
            do
            {
              if (v8)
              {
                v169 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v169 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v167;
                  goto LABEL_276;
                }
              }
              else
              {
                v169 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAcolorburnPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v169, *(float *)v6.i32, v21)));
              if (v8)
                *(_DWORD *)v39 = bswap32(v170);
              v6.i32[0] = v671.i32[0];
LABEL_276:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v168;
            }
            while (v168);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_304;
          }
        case 20:
          if (v21 <= 0.0)
            goto LABEL_305;
          v171 = bswap32(LODWORD(v21));
          while (1)
          {
            v172 = v684[0];
            do
            {
              if (v8)
              {
                v173 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v173 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v171;
                  goto LABEL_289;
                }
              }
              else
              {
                v173 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAsoftlightPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v173, *(float *)v6.i32, v21)));
              if (v8)
                *(_DWORD *)v39 = bswap32(v174);
              v6.i32[0] = v671.i32[0];
LABEL_289:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v172;
            }
            while (v172);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_304;
          }
        case 21:
          if (v21 <= 0.0)
            goto LABEL_305;
          v175 = bswap32(LODWORD(v21));
          while (1)
          {
            v176 = v684[0];
            do
            {
              if (v8)
              {
                v177 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v177 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v175;
                  goto LABEL_302;
                }
              }
              else
              {
                v177 = 1.0;
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(PDAhardlightPDA(COERCE_FLOAT(bswap32(v47->i32[0])), v177, *(float *)v6.i32, v21)));
              if (v8)
                *(_DWORD *)v39 = bswap32(v178);
              v6.i32[0] = v671.i32[0];
LABEL_302:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v176;
            }
            while (v176);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
            {
LABEL_304:
              v9 = v634;
              v11 = v638;
              v23 = v652;
LABEL_305:
              v37 = v663;
LABEL_306:
              if (!v36)
                return 1;
              v673 = 0;
LABEL_308:
              if (!shape_enum_clip_next((uint64_t)v36, (int *)&v673 + 1, &v673, v684, v674))
                goto LABEL_312;
              v47 = (int8x16_t *)(v37 + 4 * v23 * (int)v673 + 4 * SHIDWORD(v673));
              v48 = v684[0];
              if (v8)
              {
                v39 = v667 + 4 * v669 * (int)v673 + 4 * SHIDWORD(v673);
                v40 = v669 - v684[0];
              }
              LODWORD(v12) = v684[0];
              v6 = v671;
              v5 = v665;
              goto LABEL_65;
            }
          }
        case 22:
          if (v21 <= 0.0)
            goto LABEL_305;
          v180 = bswap32(LODWORD(v21));
          while (1)
          {
            v181 = v684[0];
            do
            {
              if (v8)
              {
                v182 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v182 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v180;
                  goto LABEL_324;
                }
              }
              else
              {
                v182 = 1.0;
              }
              v183 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v184 = (float)(v21 * v183) - (float)(v182 * *(float *)v6.i32);
              if (v184 < 0.0)
                v184 = -v184;
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)(*(float *)v6.i32 + v183) - (float)(v21 * v183))- (float)(v182 * *(float *)v6.i32))+ v184));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v182) - (float)(v182 * v21)));
LABEL_324:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v181;
            }
            while (v181);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 23:
          if (v21 <= 0.0)
            goto LABEL_305;
          v185 = bswap32(LODWORD(v21));
          while (1)
          {
            v186 = v684[0];
            do
            {
              if (v8)
              {
                v187 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v187 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v185;
                  goto LABEL_336;
                }
              }
              else
              {
                v187 = 1.0;
              }
              v188 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)(*(float *)v6.i32 + v188) + (float)((float)(*(float *)v6.i32 * v188)
                                                                                                 * -2.0)));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v187) - (float)(v187 * v21)));
LABEL_336:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v186;
            }
            while (v186);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 24:
          if (v21 <= 0.0)
            goto LABEL_305;
          v189 = bswap32(LODWORD(v21));
          while (1)
          {
            v190 = v684[0];
            do
            {
              if (v8)
              {
                v191 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v191 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v189;
                  goto LABEL_353;
                }
              }
              else
              {
                v191 = 1.0;
              }
              v192 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v193 = v192;
              if (v21 == 1.0)
              {
                v194 = 0.0;
              }
              else
              {
                v193 = v21 * v192;
                v194 = v192 - (float)(v21 * v192);
              }
              if (v191 != 1.0)
                v194 = (float)(v194 + *(float *)v6.i32) - (float)(v191 * *(float *)v6.i32);
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v193 + v194));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v191) - (float)(v21 * v191)));
LABEL_353:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v190;
            }
            while (v190);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 25:
          if (v21 <= 0.0)
            goto LABEL_305;
          v195 = bswap32(LODWORD(v21));
          while (1)
          {
            v196 = v684[0];
            do
            {
              if (v8)
              {
                v197 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v197 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v195;
                  goto LABEL_370;
                }
              }
              else
              {
                v197 = 1.0;
              }
              v198 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v199 = v198;
              if (v21 == 1.0)
              {
                v200 = 0.0;
              }
              else
              {
                v199 = v21 * v198;
                v200 = v198 - (float)(v21 * v198);
              }
              if (v197 != 1.0)
                v200 = (float)(v200 + *(float *)v6.i32) - (float)(v197 * *(float *)v6.i32);
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v199 + v200));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v197) - (float)(v21 * v197)));
LABEL_370:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v196;
            }
            while (v196);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 26:
          if (v21 <= 0.0)
            goto LABEL_305;
          v201 = bswap32(LODWORD(v21));
          while (1)
          {
            v202 = v684[0];
            do
            {
              if (v8)
              {
                v203 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
                if (v203 <= 0.0)
                {
                  v47->i32[0] = v19;
                  *(_DWORD *)v39 = v201;
                  goto LABEL_386;
                }
              }
              else
              {
                v203 = 1.0;
              }
              v204 = COERCE_FLOAT(bswap32(v47->i32[0]));
              v205 = v204;
              v206 = *(float *)v6.i32 - (float)(v203 * *(float *)v6.i32);
              if (v203 == 1.0)
                v206 = 0.0;
              if (v21 != 1.0)
              {
                v205 = v21 * v204;
                v206 = (float)(v206 + v204) - (float)(v21 * v204);
              }
              v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v205 + v206));
              if (v8)
                *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v203) - (float)(v21 * v203)));
LABEL_386:
              v47 = (int8x16_t *)((char *)v47 + 4);
              v39 += 4 * v661;
              --v202;
            }
            while (v202);
            v47 = (int8x16_t *)((char *)v47 + 4 * v37);
            v39 += 4 * v40;
            if (!--v674[0])
              goto LABEL_305;
          }
        case 27:
          if (v21 <= 0.0)
            goto LABEL_305;
          v207 = bswap32(LODWORD(v21));
          break;
        default:
          goto LABEL_306;
      }
LABEL_391:
      v208 = v684[0];
      while (v8)
      {
        v209 = COERCE_FLOAT(bswap32(*(_DWORD *)v39));
        if (v209 > 0.0)
          goto LABEL_396;
        v47->i32[0] = v19;
        *(_DWORD *)v39 = v207;
LABEL_403:
        v47 = (int8x16_t *)((char *)v47 + 4);
        v39 += 4 * v661;
        if (!--v208)
        {
          v47 = (int8x16_t *)((char *)v47 + 4 * v37);
          v39 += 4 * v40;
          if (!--v674[0])
            goto LABEL_305;
          goto LABEL_391;
        }
      }
      v209 = 1.0;
LABEL_396:
      v210 = COERCE_FLOAT(bswap32(v47->i32[0]));
      v211 = v210 - (float)(v21 * v210);
      if (v21 == 1.0)
        v211 = 0.0;
      v212 = v209 * *(float *)v6.i32;
      if (v209 == 1.0)
        v212 = *(float *)v6.i32;
      else
        v211 = (float)(v211 + *(float *)v6.i32) - (float)(v209 * *(float *)v6.i32);
      v47->i32[0] = bswap32(COERCE_UNSIGNED_INT(v212 + v211));
      if (v8)
        *(_DWORD *)v39 = bswap32(COERCE_UNSIGNED_INT((float)(v21 + v209) - (float)(v21 * v209)));
      goto LABEL_403;
    }
    v684[0] = *(_DWORD *)(v3 + 4);
    v674[0] = v14;
    v26 = *(_QWORD *)(v3 + 40);
    v28 = *(int *)(v3 + 12);
    v27 = *(int *)(v3 + 16);
    v29 = (unint64_t)*(int *)(v3 + 28) >> 2;
    if (v8)
    {
      v642 = (unint64_t)*(int *)(v3 + 32) >> 2;
      v643 = (char *)(v8 + 4 * (v28 + v642 * v27));
      v30 = 0xFFFFFFFFLL;
    }
    else
    {
      v642 = 0;
      v643 = 0;
      v30 = 0;
    }
    v41 = *(unsigned int **)(v11 + 88);
    v641 = (unsigned int *)(v26 + 4 * (v28 + v27 * v29));
    v42 = *(_DWORD *)(v11 + 56);
    v43 = *(_DWORD *)(v11 + 60);
    v666 = (unint64_t)*(int *)(v11 + 76) >> 2;
    if (v18 == 256)
    {
      if (v7)
      {
        v664 = (unint64_t)*(int *)(v11 + 80) >> 2;
        v7 += v42 + v664 * v43;
        v44 = 0xFFFFFFFFLL;
      }
      else
      {
        v664 = 0;
        v44 = 0;
      }
      v41 += v42 + v43 * v666;
      if (v666 == v29 && (char *)v641 - (char *)v41 >= 1)
      {
        if (v12 >= (unint64_t)((char *)v641 - (char *)v41) >> 2)
        {
          v641 += v13;
          v41 += v13;
          v643 += 4 * (v30 & v13);
          v56 = -1;
          v666 = v29;
          v7 += v44 & v13;
          goto LABEL_48;
        }
        v55 = &v41[v29 * v15];
        if (v641 <= &v55[v13])
        {
          v641 += v29 * v15;
          v29 = -(uint64_t)v29;
          v73 = &v643[4 * v642 * v15];
          v642 = -(uint64_t)v642;
          v643 = v73;
          v7 += v664 * v15;
          v30 &= 1u;
          v664 = -(uint64_t)v664;
          v666 = v29;
          v44 &= 1u;
          v56 = 1;
          v41 = v55;
          goto LABEL_48;
        }
      }
      v30 &= 1u;
      v44 &= 1u;
      v56 = 1;
LABEL_48:
      v639 = *(_DWORD *)(v11 + 56);
      v640 = *(_DWORD *)(v11 + 60);
      if (v16)
      {
        v57 = v7;
        v670 = v44;
        v672 = v30;
        v650 = 0;
        v662 = 0;
        v58 = -1;
        v45 = v666;
        v645 = v664;
        goto LABEL_53;
      }
      v63 = v56 * (int)v12;
      v668 = v642 - (int)v30 * (int)v12;
      v64 = -1;
      v65 = v664;
      v644 = v56;
      v645 = v664;
      v66 = v666;
      v45 = v666;
LABEL_61:
      v646 = 0;
      v647 = (uint64_t)v41;
      v70 = 0;
      v666 = v66 - v63;
      v662 = 0;
      v664 = v65 - (int)v44 * (int)v12;
      v71 = (uint64_t)v7;
      v61 = (char *)v7;
      v62 = v643;
      v72 = v641;
      goto LABEL_438;
    }
    v45 = *(unsigned int *)(v11 + 64);
    v645 = *(_DWORD *)(v11 + 68);
    if (v7)
    {
      v664 = (unint64_t)*(int *)(v11 + 80) >> 2;
      v44 = 1;
    }
    else
    {
      v664 = 0;
      v44 = 0;
    }
    v662 = &v41[v666 * v645];
    v30 &= 1u;
    if (v16)
    {
      v57 = v7;
      v639 = *(_DWORD *)(v11 + 56);
      v640 = *(_DWORD *)(v11 + 60);
      v670 = v44;
      v672 = v30;
      v56 = 1;
      v650 = *(unsigned int **)(v11 + 88);
      v58 = (uint64_t)v650;
LABEL_53:
      v644 = v56;
      shape_enum_clip_alloc(v2, v30, (int *)v16, v56, v29, 1, *(_DWORD *)(v11 + 104), *(_DWORD *)(v11 + 108), v12, v14);
      v60 = v59;
      v7 = v57;
      v651 = (uint64_t)v57;
      v61 = (char *)v57;
      v62 = v643;
      v668 = v642;
      if (v59)
        goto LABEL_417;
      return 1;
    }
    v668 = v642 - (v30 * v12);
    if (!v41)
    {
      v639 = *(_DWORD *)(v11 + 56);
      v640 = *(_DWORD *)(v11 + 60);
      v64 = 0;
      v644 = 1;
      v63 = v12;
      v65 = v664;
      v66 = (unint64_t)*(int *)(v11 + 76) >> 2;
      goto LABEL_61;
    }
    v67 = v43 % v645;
    v640 = v43 % v645;
    v647 = *(_QWORD *)(v11 + 88);
    v68 = &v41[v666 * v67];
    v69 = v42 % (int)v45;
    v70 = &v68[v69];
    v64 = (unint64_t)&v68[(int)v45];
    v639 = v69;
    v646 = 0;
    if (v7)
    {
      v71 = (uint64_t)&v7[v664 * v67 + v69];
      v644 = 1;
      v44 = 1;
      v61 = (char *)v71;
    }
    else
    {
      v71 = 0;
      v61 = 0;
      v644 = 1;
    }
    v41 = &v68[v69];
    v62 = v643;
    v72 = v641;
    v63 = v12;
LABEL_438:
    v670 = v44;
    v672 = v30;
    v228 = v29 - v63;
    v648 = v29 - v63;
    switch((int)v9)
    {
      case 0:
        v632 = v7;
        v650 = v70;
        v651 = v71;
        v58 = v64;
        v635 = v29;
        v229 = (int)v12;
        v230 = v228 - (int)v12;
        v231 = v12 - 1;
        v232 = &v72[-(int)v12 + 1];
        if (v644 >= 0)
        {
          v232 = v72;
          v230 = v228 + (int)v12;
        }
        v233 = v674[0];
        v234 = v674[0] - 1;
        v235 = (char *)&v232[(v230 * v234) & (v230 >> 63)];
        if (v230 < 0)
          v230 = -v230;
        v653 = 4 * v12;
        CGBlt_fillBytes(4 * v12, v674[0], 0, v235, 4 * v230);
        if ((_DWORD)v672)
        {
          if (v644 < 0)
          {
            v236 = v668 - v229;
            v62 -= 4 * v231;
          }
          else
          {
            v236 = v668 + v229;
          }
          v62 += 4 * ((v236 * v234) & (v236 >> 63));
          if (v236 < 0)
            v236 = -v236;
          v668 = v236;
          CGBlt_fillBytes(v653, v233, 0, v62, 4 * v236);
        }
        v29 = v635;
        v41 = (unsigned int *)v647;
        goto LABEL_1229;
      case 1:
        v636 = v29;
        v237 = *(unsigned __int8 *)(v11 + 1);
        v238 = v12;
        if (v237 == 2)
        {
          if ((int)v12 >= 8 && (4 * v45) <= 0x40)
          {
            LODWORD(v4) = 4 * v45;
            v590 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4);
            v590.i16[0] = vaddlv_u8(v590);
            if (v590.i32[0] <= 1u)
            {
              v650 = v70;
              v651 = v71;
              v58 = v64;
              v591 = 4 * v12;
              v659 = v674[0];
              v592 = v12;
              CGSFillDRAM64(v72, 4 * (v12 + v228), 4 * v12, v674[0], v647, 4 * v666, 4 * v45, v645, 4 * v639, v640);
              if ((_DWORD)v672)
              {
                v593 = v591;
                v60 = v646;
                v29 = v636;
                if ((_DWORD)v670)
                  CGSFillDRAM64(v62, 4 * (v592 + v668), v593, v659, (uint64_t)v7, 4 * v664, 4 * v45, v645, 4 * v639, v640);
                else
                  CGBlt_fillBytes(v593, v659, 32831, v62, 4 * (v592 + v668));
                v41 = (unsigned int *)v647;
                if (v646)
                  goto LABEL_1268;
                return 1;
              }
              v60 = v646;
              v41 = (unsigned int *)v647;
LABEL_1248:
              v29 = v636;
              if (v60)
                goto LABEL_1268;
              return 1;
            }
          }
        }
        else if (v237 == 1)
        {
          v650 = v70;
          v651 = v71;
          v239 = (int)v12;
          v632 = v7;
          v58 = v64;
          if (v644 < 0)
          {
            v240 = v666 - (int)v12;
            v41 += -(int)v12 + 1;
            v241 = v648 - (int)v12;
            v72 += -(int)v12 + 1;
          }
          else
          {
            v240 = v666 + (int)v12;
            v241 = v648 + (int)v12;
          }
          v616 = v674[0] - 1;
          v617 = (char *)&v41[(v240 * v616) & (v240 >> 63)];
          if (v240 >= 0)
            v618 = v240;
          else
            v618 = -v240;
          v649 = v674[0] - 1;
          v619 = (char *)&v72[(v241 * v616) & (v241 >> 63)];
          if (v241 >= 0)
            LODWORD(v620) = v241;
          else
            v620 = -v241;
          v621 = 4 * v12;
          v666 = v618;
          v660 = v674[0];
          CGBlt_copyBytes(4 * v12, v674[0], v617, v619, 4 * v618, 4 * v620);
          if ((_DWORD)v672)
          {
            v41 = (unsigned int *)v647;
            if ((_DWORD)v670)
            {
              v622 = v664 - v239;
              v623 = &v61[-4 * v238 + 4];
              v624 = v668 - v239;
              v625 = &v62[-4 * v238 + 4];
              if (v644 >= 0)
              {
                v623 = v61;
                v625 = v62;
                v622 = v664 + v239;
                v624 = v668 + v239;
              }
              v61 = &v623[4 * ((v622 * v649) & (v622 >> 63))];
              if (v622 >= 0)
                v626 = v622;
              else
                v626 = -v622;
              v62 = &v625[4 * ((v624 * v649) & (v624 >> 63))];
              if (v624 >= 0)
                v627 = v624;
              else
                v627 = -v624;
              v664 = v626;
              v668 = v627;
              CGBlt_copyBytes(v621, v660, v61, &v625[4 * ((v624 * v649) & (v624 >> 63))], 4 * v626, 4 * v627);
            }
            else
            {
              v628 = v668 - v239;
              v629 = &v62[-4 * v238 + 4];
              if (v644 >= 0)
              {
                v629 = v62;
                v628 = v668 + v239;
              }
              v630 = (v628 * v649) & (v628 >> 63);
              v62 = &v629[4 * v630];
              if (v628 < 0)
                v628 = -v628;
              v668 = v628;
              CGBlt_fillBytes(v621, v660, 32831, &v629[4 * v630], 4 * v628);
            }
            v29 = v636;
          }
          else
          {
            v29 = v636;
            v41 = (unsigned int *)v647;
          }
LABEL_1229:
          v60 = v646;
          v7 = v632;
          if (v646)
            goto LABEL_1268;
          return 1;
        }
        if ((_DWORD)v30)
        {
          v594 = 4 * (int)v30;
          v595 = 4 * v644;
          if (!(_DWORD)v44)
          {
            v29 = v636;
            do
            {
              v610 = v684[0];
              do
              {
                *v72 = *v41;
                *(_DWORD *)v62 = 32831;
                v611 = &v41[v644];
                if ((unint64_t)v611 >= v64)
                  v612 = -(uint64_t)(int)v45;
                else
                  v612 = 0;
                v61 += 4 * v612;
                v41 = &v611[v612];
                v62 += v594;
                v72 = (unsigned int *)((char *)v72 + v595);
                --v610;
              }
              while (v610);
              if (v662)
              {
                v613 = &v70[v666];
                if (v613 >= v662)
                  v614 = -(uint64_t)(v664 * v645);
                else
                  v614 = 0;
                v71 += 4 * v664 + 4 * v614;
                if (v613 >= v662)
                  v615 = -(uint64_t)(v666 * v645);
                else
                  v615 = 0;
                v70 = &v613[v615];
                v64 += 4 * v615 + 4 * v666;
                v61 = (char *)v71;
                v41 = v70;
              }
              else
              {
                v41 += v666;
                v61 += 4 * v664;
              }
              v72 += v228;
              v62 += 4 * v668;
              --v674[0];
            }
            while (v674[0]);
            goto LABEL_1266;
          }
          v596 = v674[0];
          do
          {
            v597 = v12;
            do
            {
              *v72 = *v41;
              *(_DWORD *)v62 = *(_DWORD *)v61;
              v598 = &v41[v644];
              if ((unint64_t)v598 >= v64)
                v599 = -(uint64_t)(int)v45;
              else
                v599 = 0;
              v61 += 4 * (int)v44 + 4 * v599;
              v41 = &v598[v599];
              v62 += v594;
              v72 = (unsigned int *)((char *)v72 + v595);
              --v597;
            }
            while (v597);
            if (v662)
            {
              v600 = &v70[v666];
              if (v600 >= v662)
                v601 = -(uint64_t)(v664 * v645);
              else
                v601 = 0;
              v71 += 4 * v664 + 4 * v601;
              if (v600 >= v662)
                v602 = -(uint64_t)(v666 * v645);
              else
                v602 = 0;
              v70 = &v600[v602];
              v64 += 4 * v602 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v596;
            LODWORD(v12) = v238;
          }
          while (v596);
        }
        else
        {
          v603 = v674[0];
          do
          {
            v604 = v12;
            do
            {
              *v72 = *v41;
              v605 = &v41[v644];
              if ((unint64_t)v605 >= v64)
                v606 = -(uint64_t)(int)v45;
              else
                v606 = 0;
              v61 += 4 * (int)v44 + 4 * v606;
              v41 = &v605[v606];
              v72 += v644;
              --v604;
            }
            while (v604);
            if (v662)
            {
              v607 = &v70[v666];
              if (v607 >= v662)
                v608 = -(uint64_t)(v664 * v645);
              else
                v608 = 0;
              v71 += 4 * v664 + 4 * v608;
              if (v607 >= v662)
                v609 = -(uint64_t)(v666 * v645);
              else
                v609 = 0;
              v70 = &v607[v609];
              v64 += 4 * v609 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v603;
            LODWORD(v12) = v238;
          }
          while (v603);
        }
        v650 = v70;
        v651 = v71;
        v58 = v64;
        v674[0] = 0;
        v60 = v646;
        v41 = (unsigned int *)v647;
        goto LABEL_1248;
      case 2:
        if ((_DWORD)v30)
        {
          do
          {
            v242 = v684[0];
            do
            {
              v243 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v243 >= 1.0)
              {
                *v72 = *v41;
                *(_DWORD *)v62 = *(_DWORD *)v61;
              }
              else if (v243 > 0.0)
              {
                v244 = bswap32(COERCE_UNSIGNED_INT(v243 + (float)(COERCE_FLOAT(bswap32(*(_DWORD *)v62))
                                                                * (float)(1.0 - v243))));
                *v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v41)) + (float)(COERCE_FLOAT(bswap32(*v72))
                                                                                       * (float)(1.0 - v243))));
                *(_DWORD *)v62 = v244;
              }
              v245 = &v41[v644];
              if ((unint64_t)v245 >= v64)
                v246 = -(uint64_t)(int)v45;
              else
                v246 = 0;
              v61 += 4 * (int)v44 + 4 * v246;
              v41 = &v245[v246];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v242;
            }
            while (v242);
            if (v662)
            {
              v247 = &v70[v666];
              if (v247 >= v662)
                v248 = -(uint64_t)(v664 * v645);
              else
                v248 = 0;
              v71 += 4 * v664 + 4 * v248;
              if (v247 >= v662)
                v249 = -(uint64_t)(v666 * v645);
              else
                v249 = 0;
              v70 = &v247[v249];
              v64 += 4 * v249 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v549 = v684[0];
            do
            {
              v550 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v550 >= 1.0)
              {
                *v72 = *v41;
              }
              else if (v550 > 0.0)
              {
                *v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v41)) + (float)(COERCE_FLOAT(bswap32(*v72))
                                                                                       * (float)(1.0 - v550))));
              }
              v551 = &v41[v644];
              if ((unint64_t)v551 >= v64)
                v552 = -(uint64_t)(int)v45;
              else
                v552 = 0;
              v61 += 4 * (int)v44 + 4 * v552;
              v41 = &v551[v552];
              v72 += v644;
              --v549;
            }
            while (v549);
            if (v662)
            {
              v553 = &v70[v666];
              if (v553 >= v662)
                v554 = -(uint64_t)(v664 * v645);
              else
                v554 = 0;
              v71 += 4 * v664 + 4 * v554;
              if (v553 >= v662)
                v555 = -(uint64_t)(v666 * v645);
              else
                v555 = 0;
              v70 = &v553[v555];
              v64 += 4 * v555 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 3:
        if ((_DWORD)v44)
        {
          do
          {
            v250 = v684[0];
            do
            {
              v251 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v251 <= 0.0)
              {
                *(_DWORD *)v62 = 0;
                *v72 = 0;
              }
              else if (v251 >= 1.0)
              {
                *v72 = *v41;
                *(_DWORD *)v62 = *(_DWORD *)v61;
              }
              else
              {
                v252 = bswap32(COERCE_UNSIGNED_INT(v251 * COERCE_FLOAT(bswap32(*(_DWORD *)v61))));
                *v72 = bswap32(COERCE_UNSIGNED_INT(v251 * COERCE_FLOAT(bswap32(*v41))));
                *(_DWORD *)v62 = v252;
              }
              v253 = &v41[v644];
              if ((unint64_t)v253 >= v64)
                v254 = -(uint64_t)(int)v45;
              else
                v254 = 0;
              v61 += 4 * (int)v44 + 4 * v254;
              v41 = &v253[v254];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v250;
            }
            while (v250);
            if (v662)
            {
              v255 = &v70[v666];
              if (v255 >= v662)
                v256 = -(uint64_t)(v664 * v645);
              else
                v256 = 0;
              v71 += 4 * v664 + 4 * v256;
              if (v255 >= v662)
                v257 = -(uint64_t)(v666 * v645);
              else
                v257 = 0;
              v70 = &v255[v257];
              v64 += 4 * v257 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v556 = v684[0];
            do
            {
              v557 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v557 <= 0.0)
              {
                *v72 = 0;
              }
              else if (v557 >= 1.0)
              {
                *v72 = *v41;
              }
              else
              {
                *v72 = bswap32(COERCE_UNSIGNED_INT(v557 * COERCE_FLOAT(bswap32(*v41))));
              }
              v558 = &v41[v644];
              if ((unint64_t)v558 >= v64)
                v559 = -(uint64_t)(int)v45;
              else
                v559 = 0;
              v61 += 4 * v559;
              v41 = &v558[v559];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v556;
            }
            while (v556);
            if (v662)
            {
              v560 = &v70[v666];
              if (v560 >= v662)
                v561 = -(uint64_t)(v664 * v645);
              else
                v561 = 0;
              v71 += 4 * v664 + 4 * v561;
              if (v560 >= v662)
                v562 = -(uint64_t)(v666 * v645);
              else
                v562 = 0;
              v70 = &v560[v562];
              v64 += 4 * v562 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 4:
        do
        {
          v258 = v684[0];
          do
          {
            v259 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            if (v259 <= 0.0)
            {
              *(_DWORD *)v62 = 0;
              *v72 = 0;
            }
            else if (v259 >= 1.0)
            {
              if ((_DWORD)v44)
                v261 = bswap32(*(_DWORD *)v61);
              else
                v261 = 1065353216;
              *(_DWORD *)v62 = bswap32(v261);
            }
            else
            {
              if ((_DWORD)v44)
                v260 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v260 = 1.0;
              *v72 = bswap32(COERCE_UNSIGNED_INT(v259 * COERCE_FLOAT(bswap32(*v41))));
              *(_DWORD *)v62 = bswap32(COERCE_UNSIGNED_INT(v259 * v260));
            }
            v262 = &v41[v644];
            if ((unint64_t)v262 >= v64)
              v263 = -(uint64_t)(int)v45;
            else
              v263 = 0;
            v61 += 4 * (int)v44 + 4 * v263;
            v41 = &v262[v263];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v258;
          }
          while (v258);
          if (v662)
          {
            v264 = &v70[v666];
            if (v264 >= v662)
              v265 = -(uint64_t)(v664 * v645);
            else
              v265 = 0;
            v71 += 4 * v664 + 4 * v265;
            if (v264 >= v662)
              v266 = -(uint64_t)(v666 * v645);
            else
              v266 = 0;
            v70 = &v264[v266];
            v64 += 4 * v266 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 5:
        do
        {
          v267 = v684[0];
          do
          {
            v268 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            v269 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *v72 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v269) * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * v268)));
            *(_DWORD *)v62 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v269) * v268) + (float)(v269 * v268)));
            v270 = &v41[v644];
            if ((unint64_t)v270 >= v64)
              v271 = -(uint64_t)(int)v45;
            else
              v271 = 0;
            v61 += 4 * (int)v44 + 4 * v271;
            v41 = &v270[v271];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v267;
          }
          while (v267);
          if (v662)
          {
            v272 = &v70[v666];
            if (v272 >= v662)
              v273 = -(uint64_t)(v664 * v645);
            else
              v273 = 0;
            v71 += 4 * v664 + 4 * v273;
            if (v272 >= v662)
              v274 = -(uint64_t)(v666 * v645);
            else
              v274 = 0;
            v70 = &v272[v274];
            v64 += 4 * v274 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 6:
        while (1)
        {
          v275 = v684[0];
          do
          {
            v276 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            v277 = 1.0 - v276;
            if ((float)(1.0 - v276) >= 1.0)
            {
              v279 = *v41;
              if ((_DWORD)v44)
                v280 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v280 = 1.0;
            }
            else
            {
              if (v277 <= 0.0)
                goto LABEL_547;
              if ((_DWORD)v44)
                v278 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v278 = 1.0;
              v279 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v72)) + (float)(COERCE_FLOAT(bswap32(*v41)) * v277)));
              v280 = v276 + (float)(v278 * v277);
            }
            *v72 = v279;
            *(_DWORD *)v62 = bswap32(LODWORD(v280));
LABEL_547:
            v281 = &v41[v644];
            if ((unint64_t)v281 >= v64)
              v282 = -(uint64_t)(int)v45;
            else
              v282 = 0;
            v61 += 4 * (int)v44 + 4 * v282;
            v41 = &v281[v282];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v275;
          }
          while (v275);
          if (v662)
          {
            v283 = &v70[v666];
            if (v283 >= v662)
              v284 = -(uint64_t)(v664 * v645);
            else
              v284 = 0;
            v71 += 4 * v664 + 4 * v284;
            if (v283 >= v662)
              v285 = -(uint64_t)(v666 * v645);
            else
              v285 = 0;
            v70 = &v283[v285];
            v64 += 4 * v285 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
          {
LABEL_1266:
            v650 = v70;
            v651 = v71;
            v58 = v64;
            v41 = (unsigned int *)v647;
LABEL_1267:
            v60 = v646;
            if (!v646)
              return 1;
LABEL_1268:
            v673 = 0;
LABEL_417:
            if (!shape_enum_clip_next(v60, (int *)&v673 + 1, &v673, v684, v674))
            {
              v179 = (void *)v60;
LABEL_1082:
              free(v179);
              return 1;
            }
            v646 = v60;
            v647 = (uint64_t)v41;
            if (v662)
            {
              v72 = &v641[v29 * (int)v673 + SHIDWORD(v673)];
              v218 = ((int)v673 + *(_DWORD *)(v11 + 60)) % v645;
              v63 = v684[0];
              v219 = (HIDWORD(v673) + *(_DWORD *)(v11 + 56)) % (int)v45;
              v220 = &v41[v666 * v218];
              v70 = &v220[v219];
              v64 = (unint64_t)&v220[(int)v45];
              v30 = v672;
              if ((_DWORD)v672)
                v62 = &v643[4 * v642 * (int)v673 + 4 * SHIDWORD(v673)];
              v221 = v668;
              if ((_DWORD)v672)
                v221 = v642 - v684[0];
              v668 = v221;
              if ((_DWORD)v670)
                v44 = v670;
              else
                v44 = 0;
              v71 = v651;
              if ((_DWORD)v670)
              {
                v71 = (uint64_t)&v7[v664 * v218 + v219];
                v61 = (char *)v71;
              }
              LODWORD(v12) = v684[0];
              v41 = &v220[v219];
              v639 = (HIDWORD(v673) + *(_DWORD *)(v11 + 56)) % (int)v45;
              v640 = ((int)v673 + *(_DWORD *)(v11 + 60)) % v645;
            }
            else
            {
              v662 = 0;
              v222 = HIDWORD(v673) * v644;
              LODWORD(v12) = v684[0];
              v223 = v684[0] * v644;
              v72 = &v641[v29 * (int)v673 + HIDWORD(v673) * v644];
              v63 = v684[0] * v644;
              v41 += (int)v673 * (int)v45 + HIDWORD(v673) * v644;
              v666 = (int)v45 - v684[0] * v644;
              v44 = v670;
              v30 = v672;
              if ((_DWORD)v672)
                v62 = &v643[4 * v642 * (int)v673 + 4 * v222];
              v224 = v668;
              if ((_DWORD)v672)
                v224 = v642 - v223;
              v668 = v224;
              v225 = (uint64_t)&v7[(int)v673 * v645 + v222];
              v226 = v645 - v223;
              if ((_DWORD)v670)
                v61 = (char *)v225;
              v227 = v664;
              if ((_DWORD)v670)
                v227 = v226;
              v664 = v227;
              v64 = v58;
              v70 = v650;
              v71 = v651;
            }
            goto LABEL_438;
          }
        }
      case 7:
        if ((_DWORD)v30)
        {
          do
          {
            v286 = v684[0];
            do
            {
              v287 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v287 <= 0.0)
              {
                *(_DWORD *)v62 = 0;
                *v72 = 0;
              }
              else if (v287 < 1.0)
              {
                v288 = bswap32(COERCE_UNSIGNED_INT(v287 * COERCE_FLOAT(bswap32(*(_DWORD *)v62))));
                *v72 = bswap32(COERCE_UNSIGNED_INT(v287 * COERCE_FLOAT(bswap32(*v72))));
                *(_DWORD *)v62 = v288;
              }
              v289 = &v41[v644];
              if ((unint64_t)v289 >= v64)
                v290 = -(uint64_t)(int)v45;
              else
                v290 = 0;
              v61 += 4 * (int)v44 + 4 * v290;
              v41 = &v289[v290];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v286;
            }
            while (v286);
            if (v662)
            {
              v291 = &v70[v666];
              if (v291 >= v662)
                v292 = -(uint64_t)(v664 * v645);
              else
                v292 = 0;
              v71 += 4 * v664 + 4 * v292;
              if (v291 >= v662)
                v293 = -(uint64_t)(v666 * v645);
              else
                v293 = 0;
              v70 = &v291[v293];
              v64 += 4 * v293 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v563 = v684[0];
            do
            {
              v564 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v564 <= 0.0)
              {
                *v72 = 0;
              }
              else if (v564 < 1.0)
              {
                *v72 = bswap32(COERCE_UNSIGNED_INT(v564 * COERCE_FLOAT(bswap32(*v72))));
              }
              v565 = &v41[v644];
              if ((unint64_t)v565 >= v64)
                v566 = -(uint64_t)(int)v45;
              else
                v566 = 0;
              v61 += 4 * (int)v44 + 4 * v566;
              v41 = &v565[v566];
              v72 += v644;
              --v563;
            }
            while (v563);
            if (v662)
            {
              v567 = &v70[v666];
              if (v567 >= v662)
                v568 = -(uint64_t)(v664 * v645);
              else
                v568 = 0;
              v71 += 4 * v664 + 4 * v568;
              if (v567 >= v662)
                v569 = -(uint64_t)(v666 * v645);
              else
                v569 = 0;
              v70 = &v567[v569];
              v64 += 4 * v569 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 8:
        if ((_DWORD)v30)
        {
          do
          {
            v294 = v684[0];
            do
            {
              v295 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v295 <= 0.0)
              {
                *(_DWORD *)v62 = 0;
                *v72 = 0;
              }
              else if (v295 < 1.0)
              {
                v296 = bswap32(COERCE_UNSIGNED_INT(v295 * COERCE_FLOAT(bswap32(*(_DWORD *)v62))));
                *v72 = bswap32(COERCE_UNSIGNED_INT(v295 * COERCE_FLOAT(bswap32(*v72))));
                *(_DWORD *)v62 = v296;
              }
              v297 = &v41[v644];
              if ((unint64_t)v297 >= v64)
                v298 = -(uint64_t)(int)v45;
              else
                v298 = 0;
              v61 += 4 * (int)v44 + 4 * v298;
              v41 = &v297[v298];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v294;
            }
            while (v294);
            if (v662)
            {
              v299 = &v70[v666];
              if (v299 >= v662)
                v300 = -(uint64_t)(v664 * v645);
              else
                v300 = 0;
              v71 += 4 * v664 + 4 * v300;
              if (v299 >= v662)
                v301 = -(uint64_t)(v666 * v645);
              else
                v301 = 0;
              v70 = &v299[v301];
              v64 += 4 * v301 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v570 = v684[0];
            do
            {
              v571 = 1.0 - COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v571 <= 0.0)
              {
                *v72 = 0;
              }
              else if (v571 < 1.0)
              {
                *v72 = bswap32(COERCE_UNSIGNED_INT(v571 * COERCE_FLOAT(bswap32(*v72))));
              }
              v572 = &v41[v644];
              if ((unint64_t)v572 >= v64)
                v573 = -(uint64_t)(int)v45;
              else
                v573 = 0;
              v61 += 4 * (int)v44 + 4 * v573;
              v41 = &v572[v573];
              v72 += v644;
              --v570;
            }
            while (v570);
            if (v662)
            {
              v574 = &v70[v666];
              if (v574 >= v662)
                v575 = -(uint64_t)(v664 * v645);
              else
                v575 = 0;
              v71 += 4 * v664 + 4 * v575;
              if (v574 >= v662)
                v576 = -(uint64_t)(v666 * v645);
              else
                v576 = 0;
              v70 = &v574[v576];
              v64 += 4 * v576 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 9:
        do
        {
          v302 = v684[0];
          do
          {
            v303 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            v304 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *v72 = bswap32(COERCE_UNSIGNED_INT((float)(v304 * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v303))));
            *(_DWORD *)v62 = bswap32(COERCE_UNSIGNED_INT((float)(v303 * v304) + (float)(v304 * (float)(1.0 - v303))));
            v305 = &v41[v644];
            if ((unint64_t)v305 >= v64)
              v306 = -(uint64_t)(int)v45;
            else
              v306 = 0;
            v61 += 4 * (int)v44 + 4 * v306;
            v41 = &v305[v306];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v302;
          }
          while (v302);
          if (v662)
          {
            v307 = &v70[v666];
            if (v307 >= v662)
              v308 = -(uint64_t)(v664 * v645);
            else
              v308 = 0;
            v71 += 4 * v664 + 4 * v308;
            if (v307 >= v662)
              v309 = -(uint64_t)(v666 * v645);
            else
              v309 = 0;
            v70 = &v307[v309];
            v64 += 4 * v309 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 10:
        do
        {
          v310 = v684[0];
          do
          {
            v311 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
            v312 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
            *v72 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v312) * COERCE_FLOAT(bswap32(*v72)))+ (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v311))));
            *(_DWORD *)v62 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v312) * v311) + (float)(v312 * (float)(1.0 - v311))));
            v313 = &v41[v644];
            if ((unint64_t)v313 >= v64)
              v314 = -(uint64_t)(int)v45;
            else
              v314 = 0;
            v61 += 4 * (int)v44 + 4 * v314;
            v41 = &v313[v314];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v310;
          }
          while (v310);
          if (v662)
          {
            v315 = &v70[v666];
            if (v315 >= v662)
              v316 = -(uint64_t)(v664 * v645);
            else
              v316 = 0;
            v71 += 4 * v664 + 4 * v316;
            if (v315 >= v662)
              v317 = -(uint64_t)(v666 * v645);
            else
              v317 = 0;
            v70 = &v315[v317];
            v64 += 4 * v317 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_1266;
      case 11:
        if ((_DWORD)v30)
        {
          do
          {
            v318 = v684[0];
            do
            {
              if ((_DWORD)v44)
                v319 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v319 = 1.0;
              v320 = COERCE_FLOAT(bswap32(*v72));
              v321 = COERCE_FLOAT(bswap32(*v41));
              v322 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              v323 = v319 + v322;
              if ((float)(v319 + v322) > 1.0)
                v323 = 1.0;
              *v72 = bswap32(COERCE_UNSIGNED_INT((float)(v319 - v321) + (float)(v323 - (float)(v322 - v320))));
              *(_DWORD *)v62 = bswap32(LODWORD(v323));
              v324 = &v41[v644];
              if ((unint64_t)v324 >= v64)
                v325 = -(uint64_t)(int)v45;
              else
                v325 = 0;
              v61 += 4 * (int)v44 + 4 * v325;
              v41 = &v324[v325];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v318;
            }
            while (v318);
            if (v662)
            {
              v326 = &v70[v666];
              if (v326 >= v662)
                v327 = -(uint64_t)(v664 * v645);
              else
                v327 = 0;
              v71 += 4 * v664 + 4 * v327;
              if (v326 >= v662)
                v328 = -(uint64_t)(v666 * v645);
              else
                v328 = 0;
              v70 = &v326[v328];
              v64 += 4 * v328 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v577 = v684[0];
            do
            {
              if ((_DWORD)v44)
                v578 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v578 = 1.0;
              *v72 = bswap32(COERCE_UNSIGNED_INT((float)(v578 - COERCE_FLOAT(bswap32(*v41))) + COERCE_FLOAT(bswap32(*v72))));
              v579 = &v41[v644];
              if ((unint64_t)v579 >= v64)
                v580 = -(uint64_t)(int)v45;
              else
                v580 = 0;
              v61 += 4 * (int)v44 + 4 * v580;
              v41 = &v579[v580];
              v72 += v644;
              --v577;
            }
            while (v577);
            if (v662)
            {
              v581 = &v70[v666];
              if (v581 >= v662)
                v582 = -(uint64_t)(v664 * v645);
              else
                v582 = 0;
              v71 += 4 * v664 + 4 * v582;
              if (v581 >= v662)
                v583 = -(uint64_t)(v666 * v645);
              else
                v583 = 0;
              v70 = &v581[v583];
              v64 += 4 * v583 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 12:
        if ((_DWORD)v30)
        {
          do
          {
            v329 = v684[0];
            do
            {
              if ((_DWORD)v44)
                v330 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              else
                v330 = 1.0;
              v331 = v330 + COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              v332 = COERCE_FLOAT(bswap32(*v72)) + COERCE_FLOAT(bswap32(*v41));
              if (v331 > 1.0)
                v331 = 1.0;
              *v72 = bswap32(LODWORD(v332));
              *(_DWORD *)v62 = bswap32(LODWORD(v331));
              v333 = &v41[v644];
              if ((unint64_t)v333 >= v64)
                v334 = -(uint64_t)(int)v45;
              else
                v334 = 0;
              v61 += 4 * (int)v44 + 4 * v334;
              v41 = &v333[v334];
              v62 += 4 * (int)v30;
              v72 += v644;
              --v329;
            }
            while (v329);
            if (v662)
            {
              v335 = &v70[v666];
              if (v335 >= v662)
                v336 = -(uint64_t)(v664 * v645);
              else
                v336 = 0;
              v71 += 4 * v664 + 4 * v336;
              if (v335 >= v662)
                v337 = -(uint64_t)(v666 * v645);
              else
                v337 = 0;
              v70 = &v335[v337];
              v64 += 4 * v337 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        else
        {
          do
          {
            v584 = v684[0];
            do
            {
              *v72 = bswap32(COERCE_UNSIGNED_INT(COERCE_FLOAT(bswap32(*v72)) + COERCE_FLOAT(bswap32(*v41))));
              v585 = &v41[v644];
              if ((unint64_t)v585 >= v64)
                v586 = -(uint64_t)(int)v45;
              else
                v586 = 0;
              v61 += 4 * (int)v44 + 4 * v586;
              v41 = &v585[v586];
              v72 += v644;
              --v584;
            }
            while (v584);
            if (v662)
            {
              v587 = &v70[v666];
              if (v587 >= v662)
                v588 = -(uint64_t)(v664 * v645);
              else
                v588 = 0;
              v71 += 4 * v664 + 4 * v588;
              if (v587 >= v662)
                v589 = -(uint64_t)(v666 * v645);
              else
                v589 = 0;
              v70 = &v587[v589];
              v64 += 4 * v589 + 4 * v666;
              v61 = (char *)v71;
              v41 = v70;
            }
            else
            {
              v41 += v666;
              v61 += 4 * v664;
            }
            v72 += v228;
            v62 += 4 * v668;
            --v674[0];
          }
          while (v674[0]);
        }
        goto LABEL_1266;
      case 13:
        while (1)
        {
          v338 = v684[0];
          do
          {
            v339 = 1.0;
            v340 = 1.0;
            if ((_DWORD)v44)
            {
              v340 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v340 <= 0.0)
                goto LABEL_694;
            }
            if ((_DWORD)v30)
            {
              v339 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v339 <= 0.0)
              {
                v345 = *v41;
                goto LABEL_692;
              }
            }
            v341 = COERCE_FLOAT(bswap32(*v72));
            v342 = COERCE_FLOAT(bswap32(*v41));
            v343 = v341 * v342;
            v344 = (float)(v341 * v342) + (float)(v341 * (float)(1.0 - v340));
            if (v340 == 1.0)
              v344 = v343;
            if (v339 != 1.0)
              v344 = v344 + (float)(v342 * (float)(1.0 - v339));
            if ((_DWORD)v30)
            {
              v340 = (float)(v340 + v339) - (float)(v339 * v340);
              v345 = bswap32(LODWORD(v344));
LABEL_692:
              *v72 = v345;
              *(_DWORD *)v62 = bswap32(LODWORD(v340));
              goto LABEL_694;
            }
            *v72 = bswap32(LODWORD(v344));
LABEL_694:
            v346 = &v41[v644];
            if ((unint64_t)v346 >= v64)
              v347 = -(uint64_t)(int)v45;
            else
              v347 = 0;
            v61 += 4 * (int)v44 + 4 * v347;
            v41 = &v346[v347];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v338;
          }
          while (v338);
          if (v662)
          {
            v348 = &v70[v666];
            if (v348 >= v662)
              v349 = -(uint64_t)(v664 * v645);
            else
              v349 = 0;
            v71 += 4 * v664 + 4 * v349;
            if (v348 >= v662)
              v350 = -(uint64_t)(v666 * v645);
            else
              v350 = 0;
            v70 = &v348[v350];
            v64 += 4 * v350 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 14:
        while (1)
        {
          v351 = v684[0];
          do
          {
            v352 = 1.0;
            v353 = 1.0;
            if ((_DWORD)v44)
            {
              v353 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v353 <= 0.0)
                goto LABEL_719;
            }
            if ((_DWORD)v30)
            {
              v352 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v352 <= 0.0)
              {
                v356 = *v41;
                goto LABEL_717;
              }
            }
            v354 = COERCE_FLOAT(bswap32(*v72));
            v355 = v354 + (float)(COERCE_FLOAT(bswap32(*v41)) * (float)(1.0 - v354));
            if ((_DWORD)v30)
            {
              v353 = (float)(v353 + v352) - (float)(v352 * v353);
              v356 = bswap32(LODWORD(v355));
LABEL_717:
              *v72 = v356;
              *(_DWORD *)v62 = bswap32(LODWORD(v353));
              goto LABEL_719;
            }
            *v72 = bswap32(LODWORD(v355));
LABEL_719:
            v357 = &v41[v644];
            if ((unint64_t)v357 >= v64)
              v358 = -(uint64_t)(int)v45;
            else
              v358 = 0;
            v61 += 4 * (int)v44 + 4 * v358;
            v41 = &v357[v358];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v351;
          }
          while (v351);
          if (v662)
          {
            v359 = &v70[v666];
            if (v359 >= v662)
              v360 = -(uint64_t)(v664 * v645);
            else
              v360 = 0;
            v71 += 4 * v664 + 4 * v360;
            if (v359 >= v662)
              v361 = -(uint64_t)(v666 * v645);
            else
              v361 = 0;
            v70 = &v359[v361];
            v64 += 4 * v361 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 15:
        v650 = v70;
        v651 = v71;
        v637 = v29;
        v631 = v45;
        v633 = v7;
        v362 = (int)v44;
        v363 = 4 * (int)v30;
        v364 = -(uint64_t)(int)v45;
        *(_QWORD *)v654 = v364;
        do
        {
          v365 = v684[0];
          do
          {
            v366 = 1.0;
            v367 = 1.0;
            if (!(_DWORD)v44 || (v367 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v367 > 0.0))
            {
              if ((_DWORD)v30 && (v366 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v366 <= 0.0))
              {
                *v72 = *v41;
                *(_DWORD *)v62 = bswap32(LODWORD(v367));
              }
              else
              {
                v368 = v363;
                v369 = v64;
                v370 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v72)), v366, COERCE_FLOAT(bswap32(*v41)), v367);
                LODWORD(v30) = v672;
                *v72 = bswap32(LODWORD(v370));
                if ((_DWORD)v672)
                  *(_DWORD *)v62 = bswap32(v371);
                LODWORD(v44) = v670;
                v64 = v369;
                v363 = v368;
                v364 = *(_QWORD *)v654;
              }
            }
            v372 = &v41[v644];
            if ((unint64_t)v372 >= v64)
              v373 = v364;
            else
              v373 = 0;
            v61 += 4 * v362 + 4 * v373;
            v41 = &v372[v373];
            v62 += v363;
            v72 += v644;
            --v365;
          }
          while (v365);
          if (v662)
          {
            v374 = &v650[v666];
            v375 = -(uint64_t)(v664 * v645);
            if (v374 < v662)
              v375 = 0;
            v61 = (char *)(v651 + 4 * v664 + 4 * v375);
            v376 = -(uint64_t)(v666 * v645);
            if (v374 < v662)
              v376 = 0;
            v41 = &v374[v376];
            v64 += 4 * v376 + 4 * v666;
            v650 = v41;
            v651 += 4 * v664 + 4 * v375;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 16:
        while (1)
        {
          v377 = v684[0];
          do
          {
            v378 = 1.0;
            v379 = 1.0;
            if ((_DWORD)v44)
            {
              v379 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v379 <= 0.0)
                goto LABEL_773;
            }
            if ((_DWORD)v30)
            {
              v378 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v378 <= 0.0)
              {
                v384 = *v41;
                goto LABEL_771;
              }
            }
            v380 = COERCE_FLOAT(bswap32(*v72));
            v381 = COERCE_FLOAT(bswap32(*v41));
            v382 = v379 * v380;
            if ((float)(v378 * v381) < (float)(v379 * v380))
              v382 = v378 * v381;
            v383 = v382 + (float)(v380 * (float)(1.0 - v379));
            if (v379 == 1.0)
              v383 = v382;
            if (v378 != 1.0)
              v383 = v383 + (float)(v381 * (float)(1.0 - v378));
            if ((_DWORD)v30)
            {
              v379 = (float)(v379 + v378) - (float)(v378 * v379);
              v384 = bswap32(LODWORD(v383));
LABEL_771:
              *v72 = v384;
              *(_DWORD *)v62 = bswap32(LODWORD(v379));
              goto LABEL_773;
            }
            *v72 = bswap32(LODWORD(v383));
LABEL_773:
            v385 = &v41[v644];
            if ((unint64_t)v385 >= v64)
              v386 = -(uint64_t)(int)v45;
            else
              v386 = 0;
            v61 += 4 * (int)v44 + 4 * v386;
            v41 = &v385[v386];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v377;
          }
          while (v377);
          if (v662)
          {
            v387 = &v70[v666];
            if (v387 >= v662)
              v388 = -(uint64_t)(v664 * v645);
            else
              v388 = 0;
            v71 += 4 * v664 + 4 * v388;
            if (v387 >= v662)
              v389 = -(uint64_t)(v666 * v645);
            else
              v389 = 0;
            v70 = &v387[v389];
            v64 += 4 * v389 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 17:
        while (1)
        {
          v390 = v684[0];
          do
          {
            v391 = 1.0;
            v392 = 1.0;
            if ((_DWORD)v44)
            {
              v392 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v392 <= 0.0)
                goto LABEL_804;
            }
            if ((_DWORD)v30)
            {
              v391 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v391 <= 0.0)
              {
                v397 = *v41;
                goto LABEL_802;
              }
            }
            v393 = COERCE_FLOAT(bswap32(*v72));
            v394 = COERCE_FLOAT(bswap32(*v41));
            v395 = v392 * v393;
            if ((float)(v391 * v394) > (float)(v392 * v393))
              v395 = v391 * v394;
            v396 = v395 + (float)(v393 * (float)(1.0 - v392));
            if (v392 == 1.0)
              v396 = v395;
            if (v391 != 1.0)
              v396 = v396 + (float)(v394 * (float)(1.0 - v391));
            if ((_DWORD)v30)
            {
              v392 = (float)(v392 + v391) - (float)(v391 * v392);
              v397 = bswap32(LODWORD(v396));
LABEL_802:
              *v72 = v397;
              *(_DWORD *)v62 = bswap32(LODWORD(v392));
              goto LABEL_804;
            }
            *v72 = bswap32(LODWORD(v396));
LABEL_804:
            v398 = &v41[v644];
            if ((unint64_t)v398 >= v64)
              v399 = -(uint64_t)(int)v45;
            else
              v399 = 0;
            v61 += 4 * (int)v44 + 4 * v399;
            v41 = &v398[v399];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v390;
          }
          while (v390);
          if (v662)
          {
            v400 = &v70[v666];
            if (v400 >= v662)
              v401 = -(uint64_t)(v664 * v645);
            else
              v401 = 0;
            v71 += 4 * v664 + 4 * v401;
            if (v400 >= v662)
              v402 = -(uint64_t)(v666 * v645);
            else
              v402 = 0;
            v70 = &v400[v402];
            v64 += 4 * v402 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 18:
        v650 = v70;
        v651 = v71;
        v637 = v29;
        v631 = v45;
        v633 = v7;
        v403 = (int)v44;
        v404 = 4 * (int)v30;
        v405 = -(uint64_t)(int)v45;
        *(_QWORD *)v655 = v405;
        do
        {
          v406 = v684[0];
          do
          {
            v407 = 1.0;
            v408 = 1.0;
            if (!(_DWORD)v44 || (v408 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v408 > 0.0))
            {
              if ((_DWORD)v30 && (v407 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v407 <= 0.0))
              {
                *v72 = *v41;
                *(_DWORD *)v62 = bswap32(LODWORD(v408));
              }
              else
              {
                v409 = v404;
                v410 = v64;
                v411 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v72)), v407, COERCE_FLOAT(bswap32(*v41)), v408);
                LODWORD(v30) = v672;
                *v72 = bswap32(LODWORD(v411));
                if ((_DWORD)v672)
                  *(_DWORD *)v62 = bswap32(v412);
                LODWORD(v44) = v670;
                v64 = v410;
                v404 = v409;
                v405 = *(_QWORD *)v655;
              }
            }
            v413 = &v41[v644];
            if ((unint64_t)v413 >= v64)
              v414 = v405;
            else
              v414 = 0;
            v61 += 4 * v403 + 4 * v414;
            v41 = &v413[v414];
            v62 += v404;
            v72 += v644;
            --v406;
          }
          while (v406);
          if (v662)
          {
            v415 = &v650[v666];
            v416 = -(uint64_t)(v664 * v645);
            if (v415 < v662)
              v416 = 0;
            v61 = (char *)(v651 + 4 * v664 + 4 * v416);
            v417 = -(uint64_t)(v666 * v645);
            if (v415 < v662)
              v417 = 0;
            v41 = &v415[v417];
            v64 += 4 * v417 + 4 * v666;
            v650 = v41;
            v651 += 4 * v664 + 4 * v416;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 19:
        v650 = v70;
        v651 = v71;
        v637 = v29;
        v631 = v45;
        v633 = v7;
        v418 = (int)v44;
        v419 = 4 * (int)v30;
        v420 = -(uint64_t)(int)v45;
        *(_QWORD *)v656 = v420;
        do
        {
          v421 = v684[0];
          do
          {
            v422 = 1.0;
            v423 = 1.0;
            if (!(_DWORD)v44 || (v423 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v423 > 0.0))
            {
              if ((_DWORD)v30 && (v422 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v422 <= 0.0))
              {
                *v72 = *v41;
                *(_DWORD *)v62 = bswap32(LODWORD(v423));
              }
              else
              {
                v424 = v419;
                v425 = v64;
                v426 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v72)), v422, COERCE_FLOAT(bswap32(*v41)), v423);
                LODWORD(v30) = v672;
                *v72 = bswap32(LODWORD(v426));
                if ((_DWORD)v672)
                  *(_DWORD *)v62 = bswap32(v427);
                LODWORD(v44) = v670;
                v64 = v425;
                v419 = v424;
                v420 = *(_QWORD *)v656;
              }
            }
            v428 = &v41[v644];
            if ((unint64_t)v428 >= v64)
              v429 = v420;
            else
              v429 = 0;
            v61 += 4 * v418 + 4 * v429;
            v41 = &v428[v429];
            v62 += v419;
            v72 += v644;
            --v421;
          }
          while (v421);
          if (v662)
          {
            v430 = &v650[v666];
            v431 = -(uint64_t)(v664 * v645);
            if (v430 < v662)
              v431 = 0;
            v61 = (char *)(v651 + 4 * v664 + 4 * v431);
            v432 = -(uint64_t)(v666 * v645);
            if (v430 < v662)
              v432 = 0;
            v41 = &v430[v432];
            v64 += 4 * v432 + 4 * v666;
            v650 = v41;
            v651 += 4 * v664 + 4 * v431;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 20:
        v650 = v70;
        v651 = v71;
        v637 = v29;
        v631 = v45;
        v633 = v7;
        v433 = (int)v44;
        v434 = 4 * (int)v30;
        v435 = -(uint64_t)(int)v45;
        *(_QWORD *)v657 = v435;
        do
        {
          v436 = v684[0];
          do
          {
            v437 = 1.0;
            v438 = 1.0;
            if (!(_DWORD)v44 || (v438 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v438 > 0.0))
            {
              if ((_DWORD)v30 && (v437 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v437 <= 0.0))
              {
                *v72 = *v41;
                *(_DWORD *)v62 = bswap32(LODWORD(v438));
              }
              else
              {
                v439 = v434;
                v440 = v64;
                v441 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v72)), v437, COERCE_FLOAT(bswap32(*v41)), v438);
                LODWORD(v30) = v672;
                *v72 = bswap32(LODWORD(v441));
                if ((_DWORD)v672)
                  *(_DWORD *)v62 = bswap32(v442);
                LODWORD(v44) = v670;
                v64 = v440;
                v434 = v439;
                v435 = *(_QWORD *)v657;
              }
            }
            v443 = &v41[v644];
            if ((unint64_t)v443 >= v64)
              v444 = v435;
            else
              v444 = 0;
            v61 += 4 * v433 + 4 * v444;
            v41 = &v443[v444];
            v62 += v434;
            v72 += v644;
            --v436;
          }
          while (v436);
          if (v662)
          {
            v445 = &v650[v666];
            v446 = -(uint64_t)(v664 * v645);
            if (v445 < v662)
              v446 = 0;
            v61 = (char *)(v651 + 4 * v664 + 4 * v446);
            v447 = -(uint64_t)(v666 * v645);
            if (v445 < v662)
              v447 = 0;
            v41 = &v445[v447];
            v64 += 4 * v447 + 4 * v666;
            v650 = v41;
            v651 += 4 * v664 + 4 * v446;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
        goto LABEL_910;
      case 21:
        v650 = v70;
        v651 = v71;
        v637 = v29;
        v631 = v45;
        v633 = v7;
        v448 = (int)v44;
        v449 = 4 * (int)v30;
        v450 = -(uint64_t)(int)v45;
        *(_QWORD *)v658 = v450;
        do
        {
          v451 = v684[0];
          do
          {
            v452 = 1.0;
            v453 = 1.0;
            if (!(_DWORD)v44 || (v453 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v453 > 0.0))
            {
              if ((_DWORD)v30 && (v452 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v452 <= 0.0))
              {
                *v72 = *v41;
                *(_DWORD *)v62 = bswap32(LODWORD(v453));
              }
              else
              {
                v454 = v449;
                v455 = v64;
                v456 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v72)), v452, COERCE_FLOAT(bswap32(*v41)), v453);
                LODWORD(v30) = v672;
                *v72 = bswap32(LODWORD(v456));
                if ((_DWORD)v672)
                  *(_DWORD *)v62 = bswap32(v457);
                LODWORD(v44) = v670;
                v64 = v455;
                v449 = v454;
                v450 = *(_QWORD *)v658;
              }
            }
            v458 = &v41[v644];
            if ((unint64_t)v458 >= v64)
              v459 = v450;
            else
              v459 = 0;
            v61 += 4 * v448 + 4 * v459;
            v41 = &v458[v459];
            v62 += v449;
            v72 += v644;
            --v451;
          }
          while (v451);
          if (v662)
          {
            v460 = &v650[v666];
            v461 = -(uint64_t)(v664 * v645);
            if (v460 < v662)
              v461 = 0;
            v61 = (char *)(v651 + 4 * v664 + 4 * v461);
            v462 = -(uint64_t)(v666 * v645);
            if (v460 < v662)
              v462 = 0;
            v41 = &v460[v462];
            v64 += 4 * v462 + 4 * v666;
            v650 = v41;
            v651 += 4 * v664 + 4 * v461;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v648;
          v62 += 4 * v668;
          --v674[0];
        }
        while (v674[0]);
LABEL_910:
        v58 = v64;
        v7 = v633;
        LODWORD(v9) = v634;
        v29 = v637;
        v11 = v638;
        v41 = (unsigned int *)v647;
        v45 = v631;
        goto LABEL_1267;
      case 22:
        while (1)
        {
          v463 = v684[0];
          do
          {
            v464 = 1.0;
            v465 = 1.0;
            if ((_DWORD)v44)
            {
              v465 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v465 <= 0.0)
                goto LABEL_923;
            }
            if ((_DWORD)v30)
            {
              v464 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v464 <= 0.0)
              {
                v473 = *v41;
                goto LABEL_921;
              }
            }
            v466 = COERCE_FLOAT(bswap32(*v72));
            v467 = COERCE_FLOAT(bswap32(*v41));
            v468 = v466 + v467;
            v469 = v465 * v466;
            v470 = v468 - v469;
            v471 = v469 - (float)(v464 * v467);
            if (v471 < 0.0)
              v471 = -v471;
            v472 = (float)(v470 - (float)(v464 * v467)) + v471;
            if ((_DWORD)v30)
            {
              v465 = (float)(v465 + v464) - (float)(v464 * v465);
              v473 = bswap32(LODWORD(v472));
LABEL_921:
              *v72 = v473;
              *(_DWORD *)v62 = bswap32(LODWORD(v465));
              goto LABEL_923;
            }
            *v72 = bswap32(LODWORD(v472));
LABEL_923:
            v474 = &v41[v644];
            if ((unint64_t)v474 >= v64)
              v475 = -(uint64_t)(int)v45;
            else
              v475 = 0;
            v61 += 4 * (int)v44 + 4 * v475;
            v41 = &v474[v475];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v463;
          }
          while (v463);
          if (v662)
          {
            v476 = &v70[v666];
            if (v476 >= v662)
              v477 = -(uint64_t)(v664 * v645);
            else
              v477 = 0;
            v71 += 4 * v664 + 4 * v477;
            if (v476 >= v662)
              v478 = -(uint64_t)(v666 * v645);
            else
              v478 = 0;
            v70 = &v476[v478];
            v64 += 4 * v478 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 23:
        while (1)
        {
          v479 = v684[0];
          do
          {
            v480 = 1.0;
            v481 = 1.0;
            if ((_DWORD)v44)
            {
              v481 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v481 <= 0.0)
                goto LABEL_948;
            }
            if ((_DWORD)v30)
            {
              v480 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v480 <= 0.0)
              {
                v485 = *v41;
                goto LABEL_946;
              }
            }
            v482 = COERCE_FLOAT(bswap32(*v72));
            v483 = COERCE_FLOAT(bswap32(*v41));
            v484 = (float)(v482 + v483) + (float)((float)(v482 * v483) * -2.0);
            if ((_DWORD)v30)
            {
              v481 = (float)(v481 + v480) - (float)(v480 * v481);
              v485 = bswap32(LODWORD(v484));
LABEL_946:
              *v72 = v485;
              *(_DWORD *)v62 = bswap32(LODWORD(v481));
              goto LABEL_948;
            }
            *v72 = bswap32(LODWORD(v484));
LABEL_948:
            v486 = &v41[v644];
            if ((unint64_t)v486 >= v64)
              v487 = -(uint64_t)(int)v45;
            else
              v487 = 0;
            v61 += 4 * (int)v44 + 4 * v487;
            v41 = &v486[v487];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v479;
          }
          while (v479);
          if (v662)
          {
            v488 = &v70[v666];
            if (v488 >= v662)
              v489 = -(uint64_t)(v664 * v645);
            else
              v489 = 0;
            v71 += 4 * v664 + 4 * v489;
            if (v488 >= v662)
              v490 = -(uint64_t)(v666 * v645);
            else
              v490 = 0;
            v70 = &v488[v490];
            v64 += 4 * v490 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 24:
        while (1)
        {
          v491 = v684[0];
          do
          {
            v492 = 1.0;
            v493 = 1.0;
            if ((_DWORD)v44)
            {
              v493 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v493 <= 0.0)
                goto LABEL_978;
            }
            if ((_DWORD)v30)
            {
              v492 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v492 <= 0.0)
              {
                v500 = *v41;
                goto LABEL_976;
              }
            }
            v494 = COERCE_FLOAT(bswap32(*v72));
            v495 = COERCE_FLOAT(bswap32(*v41));
            v496 = v494 - (float)(v493 * v494);
            if (v493 == 1.0)
            {
              v497 = 0.0;
            }
            else
            {
              v494 = v493 * v494;
              v497 = v496;
            }
            v498 = (float)(v497 + v495) - (float)(v492 * v495);
            if (v492 == 1.0)
              v498 = v497;
            v499 = v494 + v498;
            if ((_DWORD)v30)
            {
              v493 = (float)(v493 + v492) - (float)(v493 * v492);
              v500 = bswap32(LODWORD(v499));
LABEL_976:
              *v72 = v500;
              *(_DWORD *)v62 = bswap32(LODWORD(v493));
              goto LABEL_978;
            }
            *v72 = bswap32(LODWORD(v499));
LABEL_978:
            v501 = &v41[v644];
            if ((unint64_t)v501 >= v64)
              v502 = -(uint64_t)(int)v45;
            else
              v502 = 0;
            v61 += 4 * (int)v44 + 4 * v502;
            v41 = &v501[v502];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v491;
          }
          while (v491);
          if (v662)
          {
            v503 = &v70[v666];
            if (v503 >= v662)
              v504 = -(uint64_t)(v664 * v645);
            else
              v504 = 0;
            v71 += 4 * v664 + 4 * v504;
            if (v503 >= v662)
              v505 = -(uint64_t)(v666 * v645);
            else
              v505 = 0;
            v70 = &v503[v505];
            v64 += 4 * v505 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 25:
        while (1)
        {
          v506 = v684[0];
          do
          {
            v507 = 1.0;
            v508 = 1.0;
            if ((_DWORD)v44)
            {
              v508 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v508 <= 0.0)
                goto LABEL_1008;
            }
            if ((_DWORD)v30)
            {
              v507 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v507 <= 0.0)
              {
                v515 = *v41;
                goto LABEL_1006;
              }
            }
            v509 = COERCE_FLOAT(bswap32(*v72));
            v510 = COERCE_FLOAT(bswap32(*v41));
            v511 = v509 - (float)(v508 * v509);
            if (v508 == 1.0)
            {
              v512 = 0.0;
            }
            else
            {
              v509 = v508 * v509;
              v512 = v511;
            }
            v513 = (float)(v512 + v510) - (float)(v507 * v510);
            if (v507 == 1.0)
              v513 = v512;
            v514 = v509 + v513;
            if ((_DWORD)v30)
            {
              v508 = (float)(v508 + v507) - (float)(v508 * v507);
              v515 = bswap32(LODWORD(v514));
LABEL_1006:
              *v72 = v515;
              *(_DWORD *)v62 = bswap32(LODWORD(v508));
              goto LABEL_1008;
            }
            *v72 = bswap32(LODWORD(v514));
LABEL_1008:
            v516 = &v41[v644];
            if ((unint64_t)v516 >= v64)
              v517 = -(uint64_t)(int)v45;
            else
              v517 = 0;
            v61 += 4 * (int)v44 + 4 * v517;
            v41 = &v516[v517];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v506;
          }
          while (v506);
          if (v662)
          {
            v518 = &v70[v666];
            if (v518 >= v662)
              v519 = -(uint64_t)(v664 * v645);
            else
              v519 = 0;
            v71 += 4 * v664 + 4 * v519;
            if (v518 >= v662)
              v520 = -(uint64_t)(v666 * v645);
            else
              v520 = 0;
            v70 = &v518[v520];
            v64 += 4 * v520 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 26:
        while (1)
        {
          v521 = v684[0];
          do
          {
            v522 = 1.0;
            v523 = 1.0;
            if ((_DWORD)v44)
            {
              v523 = COERCE_FLOAT(bswap32(*(_DWORD *)v61));
              if (v523 <= 0.0)
                goto LABEL_1037;
            }
            if ((_DWORD)v30)
            {
              v522 = COERCE_FLOAT(bswap32(*(_DWORD *)v62));
              if (v522 <= 0.0)
              {
                v529 = *v41;
                goto LABEL_1035;
              }
            }
            v524 = COERCE_FLOAT(bswap32(*v41));
            v525 = COERCE_FLOAT(bswap32(*v72));
            v526 = v525;
            v527 = v524 - (float)(v522 * v524);
            if (v522 == 1.0)
              v527 = 0.0;
            if (v523 != 1.0)
            {
              v526 = v523 * v525;
              v527 = (float)(v527 + v525) - (float)(v523 * v525);
            }
            v528 = v526 + v527;
            if ((_DWORD)v30)
            {
              v523 = (float)(v523 + v522) - (float)(v523 * v522);
              v529 = bswap32(LODWORD(v528));
LABEL_1035:
              *v72 = v529;
              *(_DWORD *)v62 = bswap32(LODWORD(v523));
              goto LABEL_1037;
            }
            *v72 = bswap32(LODWORD(v528));
LABEL_1037:
            v530 = &v41[v644];
            if ((unint64_t)v530 >= v64)
              v531 = -(uint64_t)(int)v45;
            else
              v531 = 0;
            v61 += 4 * (int)v44 + 4 * v531;
            v41 = &v530[v531];
            v62 += 4 * (int)v30;
            v72 += v644;
            --v521;
          }
          while (v521);
          if (v662)
          {
            v532 = &v70[v666];
            if (v532 >= v662)
              v533 = -(uint64_t)(v664 * v645);
            else
              v533 = 0;
            v71 += 4 * v664 + 4 * v533;
            if (v532 >= v662)
              v534 = -(uint64_t)(v666 * v645);
            else
              v534 = 0;
            v70 = &v532[v534];
            v64 += 4 * v534 + 4 * v666;
            v61 = (char *)v71;
            v41 = v70;
          }
          else
          {
            v41 += v666;
            v61 += 4 * v664;
          }
          v72 += v228;
          v62 += 4 * v668;
          if (!--v674[0])
            goto LABEL_1266;
        }
      case 27:
        break;
      default:
        goto LABEL_1266;
    }
LABEL_1052:
    v535 = v684[0];
    while (1)
    {
      v536 = 1.0;
      v537 = 1.0;
      if (!(_DWORD)v44 || (v537 = COERCE_FLOAT(bswap32(*(_DWORD *)v61)), v537 > 0.0))
      {
        if ((_DWORD)v30 && (v536 = COERCE_FLOAT(bswap32(*(_DWORD *)v62)), v536 <= 0.0))
        {
          v543 = *v41;
        }
        else
        {
          v538 = COERCE_FLOAT(bswap32(*v72));
          v539 = COERCE_FLOAT(bswap32(*v41));
          v540 = v539;
          v541 = v538 - (float)(v537 * v538);
          if (v537 == 1.0)
            v541 = 0.0;
          if (v536 != 1.0)
          {
            v540 = v536 * v539;
            v541 = (float)(v541 + v539) - (float)(v536 * v539);
          }
          v542 = v540 + v541;
          if (!(_DWORD)v30)
          {
            *v72 = bswap32(LODWORD(v542));
            goto LABEL_1066;
          }
          v537 = (float)(v537 + v536) - (float)(v537 * v536);
          v543 = bswap32(LODWORD(v542));
        }
        *v72 = v543;
        *(_DWORD *)v62 = bswap32(LODWORD(v537));
      }
LABEL_1066:
      v544 = &v41[v644];
      if ((unint64_t)v544 >= v64)
        v545 = -(uint64_t)(int)v45;
      else
        v545 = 0;
      v61 += 4 * (int)v44 + 4 * v545;
      v41 = &v544[v545];
      v62 += 4 * (int)v30;
      v72 += v644;
      if (!--v535)
      {
        if (v662)
        {
          v546 = &v70[v666];
          if (v546 >= v662)
            v547 = -(uint64_t)(v664 * v645);
          else
            v547 = 0;
          v71 += 4 * v664 + 4 * v547;
          if (v546 >= v662)
            v548 = -(uint64_t)(v666 * v645);
          else
            v548 = 0;
          v70 = &v546[v548];
          v64 += 4 * v548 + 4 * v666;
          v61 = (char *)v71;
          v41 = v70;
        }
        else
        {
          v41 += v666;
          v61 += 4 * v664;
        }
        v72 += v228;
        v62 += 4 * v668;
        if (!--v674[0])
          goto LABEL_1266;
        goto LABEL_1052;
      }
    }
  }
  v17 = *(_DWORD *)(v3 + 128);
  if ((v17 | 8) == 8)
  {
    if ((*(_DWORD *)v3 & 0xFF00) == 0x400)
      WF_mark_constmask(v3, v9, v4);
    else
      WF_mark_pixelmask(v3, v9);
  }
  else
  {
    v31 = *(_DWORD *)(v3 + 112);
    v32 = *(_DWORD *)(v3 + 116);
    v33 = (v31 + 15) & 0xFFFFFFF0;
    v34 = v33 * v32;
    if ((int)v34 <= 4096)
    {
      v36 = v684;
    }
    else
    {
      v35 = malloc_type_malloc(v34, 0xB98CD2D6uLL);
      if (!v35)
        return 1;
      v36 = v35;
      v16 = *(uint16x4_t **)(v11 + 136);
      v17 = *(_DWORD *)(v11 + 128);
    }
    CGSConvertBitsToMask(v16, *(_DWORD *)(v11 + 124), v36, v33, v31, v32, v17);
    v49 = *(_OWORD *)(v11 + 112);
    v680 = *(_OWORD *)(v11 + 96);
    v681 = v49;
    v50 = *(_OWORD *)(v11 + 144);
    v682 = *(_OWORD *)(v11 + 128);
    v683 = v50;
    v51 = *(_OWORD *)(v11 + 48);
    v676 = *(_OWORD *)(v11 + 32);
    v677 = v51;
    v52 = *(_OWORD *)(v11 + 80);
    v678 = *(_OWORD *)(v11 + 64);
    v679 = v52;
    v53 = *(_OWORD *)v11;
    v54 = *(_OWORD *)(v11 + 16);
    *(_OWORD *)v674 = *(_OWORD *)v11;
    v675 = v54;
    HIDWORD(v681) = (v31 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v682 + 1) = v36;
    if (BYTE1(v674[0]) << 8 == 1024)
      WF_mark_constmask((uint64_t)v674, v9, *(double *)&v53);
    else
      WF_mark_pixelmask((uint64_t)v674, v9);
    if (v36 != (_BYTE *)v684)
    {
LABEL_312:
      v179 = v36;
      goto LABEL_1082;
    }
  }
  return 1;
}

void WF_mark_constmask(uint64_t a1, int a2, double a3)
{
  int32x2_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int *v6;
  float v7;
  unsigned int v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  float v18;
  unint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  float v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  unsigned int *v35;
  uint64_t v36;
  unsigned int *v37;
  unsigned int *v38;
  char v39;
  int v40;
  int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  unsigned int *v46;
  uint64_t v47;
  unsigned int *v48;
  unsigned int *v49;
  char v50;
  int v51;
  int v52;
  unsigned int v53;
  unsigned int v54;
  uint64_t v55;
  int v56;
  unsigned int v57;
  float v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  float v64;
  uint64_t v65;
  int v66;
  unsigned int v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  uint64_t v75;
  int v76;
  float v77;
  float v78;
  float v79;
  float v80;
  uint64_t v81;
  int v82;
  unsigned int v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  uint64_t v91;
  int v92;
  unsigned int v93;
  float v94;
  float v95;
  float v96;
  float v97;
  uint64_t v98;
  int v99;
  unsigned int v100;
  float v101;
  float v102;
  float v103;
  uint64_t v104;
  int v105;
  float v106;
  float v107;
  float v108;
  float v109;
  float v110;
  uint64_t v111;
  int v112;
  float v113;
  float v114;
  float v115;
  float v116;
  uint64_t v117;
  int v118;
  float v119;
  float v120;
  float v121;
  float v122;
  float v123;
  float v124;
  uint64_t v125;
  int v126;
  float v127;
  float v128;
  float v129;
  float v130;
  uint64_t v131;
  int v132;
  float v133;
  float v134;
  float v135;
  float v136;
  float v137;
  float v138;
  uint64_t v139;
  int v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  uint64_t v146;
  int v147;
  float v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  uint64_t v154;
  int v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  float v161;
  float v162;
  uint64_t v163;
  int v164;
  float v165;
  float v166;
  float v167;
  float v168;
  float v169;
  float v170;
  float v171;
  uint64_t v172;
  int v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  uint64_t v180;
  int v181;
  float v182;
  float v183;
  float v184;
  float v185;
  float v186;
  float v187;
  uint64_t v188;
  int v189;
  float v190;
  float v191;
  float v192;
  float v193;
  float v194;
  float v195;
  uint64_t v196;
  int v197;
  float v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float v203;
  uint64_t v204;
  int v205;
  float v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float v213;
  float v214;
  uint64_t v215;
  int v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  uint64_t v222;
  int v223;
  float v224;
  float v225;
  float v226;
  float v227;
  float v228;
  float v229;
  float v230;
  float v231;
  uint64_t v232;
  int v233;
  float v234;
  float v235;
  float v236;
  float v237;
  float v238;
  float v239;
  float v240;
  float v241;
  uint64_t v242;
  int v243;
  float v244;
  float v245;
  float v246;
  float v247;
  float v248;
  float v249;
  float v250;
  uint64_t v251;
  int v252;
  float v253;
  float v254;
  float v255;
  float v256;
  float v257;
  float v258;
  float v259;
  int v260;
  int v261;
  int v262;
  char v263;
  unsigned int *v264;
  unsigned int *v265;
  int v266;
  int v267;
  unsigned int v268;
  unsigned int v269;
  int v270;
  int v271;
  char v272;
  unsigned int *v273;
  int8x8_t *v274;
  int v275;
  unsigned int v276;
  unsigned int v277;
  int v278;
  unsigned int v279;
  float v280;
  int v281;
  unsigned int v282;
  float v283;
  int v284;
  int v285;
  uint64_t v286;
  int v287;
  unint64_t v288;
  unsigned int v289;
  unint64_t v290;
  unsigned int v291;
  int v292;
  unsigned int v293;
  unsigned int v294;
  unsigned int v295;
  float v296;
  float v297;
  float v298;
  float v299;
  unsigned int v300;
  unsigned int v301;
  float v302;
  float v303;
  float v304;
  float v305;
  unsigned int v306;
  unsigned int v307;
  float v308;
  float v309;
  float v310;
  float v311;
  unsigned int v312;
  float v313;
  float v314;
  float v315;
  float v316;
  unsigned int v317;
  int v318;
  uint64_t v319;
  unint64_t v320;
  int v321;
  unint64_t v322;
  unsigned int v323;
  int v324;
  unsigned int v325;
  unsigned int v326;
  unsigned int v327;
  unsigned int v328;
  float v329;
  float v330;
  float v331;
  float v332;
  float v333;
  unsigned int v334;
  float v335;
  float v336;
  float v337;
  unsigned int v338;
  float v339;
  float v340;
  float v341;
  unsigned int v342;
  unsigned int v343;
  float v344;
  float v345;
  int v346;
  uint64_t v347;
  int v348;
  int32x4_t v349;
  unint64_t v350;
  unsigned int v351;
  int v352;
  unsigned int v353;
  unsigned int v354;
  unsigned int v355;
  unsigned int v356;
  unsigned int v357;
  int v358;
  int v359;
  uint64_t v360;
  float32x2_t v361;
  float32x2_t v362;
  unint64_t v363;
  unsigned int v364;
  int v365;
  unsigned int v366;
  unsigned int v367;
  float v368;
  unsigned int v369;
  int v370;
  unint64_t v371;
  float v372;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(_QWORD *)(a1 + 136);
  v6 = *(unsigned int **)(a1 + 96);
  if (v6)
    v7 = COERCE_FLOAT(bswap32(*v6));
  else
    v7 = 1.0;
  v8 = **(_DWORD **)(a1 + 88);
  v9 = *(_DWORD *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v12 = *(int *)(a1 + 12);
  v11 = *(int *)(a1 + 16);
  if (v4)
  {
    v13 = (unint64_t)*(int *)(a1 + 32) >> 2;
    v14 = (unsigned int *)(v4 + 4 * (v12 + v13 * v11));
    v15 = 1;
    if (!v5)
      return;
  }
  else
  {
    v14 = 0;
    v13 = 0;
    v15 = 0;
    if (!v5)
      return;
  }
  v16 = v13 - v9;
  if (v4)
    v17 = v13 - v9;
  else
    v17 = v13;
  v18 = COERCE_FLOAT(bswap32(v8));
  v19 = (unint64_t)*(int *)(a1 + 28) >> 2;
  *(float *)v3.i32 = v18;
  v20 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * (v12 + v19 * v11));
  v21 = *(int *)(a1 + 124);
  v22 = v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v21;
  v23 = v21 - v9;
  v24 = v19 - v9;
  v372 = v18;
  v371 = v24;
  v25 = v23;
  v26 = *(_DWORD *)(a1 + 4);
  v27 = v17;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        v28 = 4 * v15;
        do
        {
          v29 = v9;
          do
          {
            v30 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v30 == 255)
              {
                *v14 = 0;
                *v20 = 0;
              }
              else
              {
                v31 = (float)(v30 ^ 0xFFu) * 0.0039216;
                v32 = bswap32(COERCE_UNSIGNED_INT(v31 * COERCE_FLOAT(bswap32(*v14))));
                *v20 = bswap32(COERCE_UNSIGNED_INT(v31 * COERCE_FLOAT(bswap32(*v20))));
                *v14 = v32;
              }
            }
            ++v22;
            ++v20;
            v14 = (unsigned int *)((char *)v14 + v28);
            --v29;
          }
          while (v29);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v260 = v9;
          do
          {
            v261 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v261 == 255)
                *v20 = 0;
              else
                *v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(v261 ^ 0xFFu) * 0.0039216) * COERCE_FLOAT(bswap32(*v20))));
            }
            ++v22;
            ++v20;
            --v260;
          }
          while (v260);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 1:
      v33 = v22 & 3;
      if (!v4)
      {
        v262 = -1 << (8 * v33);
        if ((v22 & 3) != 0)
          v263 = v22 & 0xFC;
        else
          v263 = v22;
        if ((v22 & 3) != 0)
        {
          v264 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v262 = -1;
          v264 = (unsigned int *)v22;
        }
        if ((v22 & 3) != 0)
          v265 = &v20[-(v22 & 3)];
        else
          v265 = v20;
        if ((v22 & 3) != 0)
          v266 = v33 + v9;
        else
          v266 = v9;
        if ((((_BYTE)v266 + v263) & 3) != 0)
        {
          v267 = 4 - (((_BYTE)v266 + v263) & 3);
          v33 += v267;
          v268 = 0xFFFFFFFF >> (8 * v267);
          if (v266 >= 4)
            v269 = v268;
          else
            v269 = 0;
          if (v266 >= 4)
            v268 = -1;
          v262 &= v268;
        }
        else
        {
          v269 = 0;
        }
        v347 = v23 - v33;
        v348 = v266 >> 2;
        v349 = vdupq_n_s32(v8);
        v350 = v24 - v33;
        while (1)
        {
          v351 = *v264 & v262;
          v352 = v348;
          v353 = v269;
          if (!v351)
            goto LABEL_550;
LABEL_532:
          if (v351 == -1)
          {
            *(int32x4_t *)v265 = v349;
            goto LABEL_550;
          }
          while (1)
          {
            if ((_BYTE)v351)
            {
              v354 = v8;
              if (v351 != 255)
                v354 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v351 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(*v265))* (float)(1.0 - (float)((float)v351 * 0.0039216)))));
              *v265 = v354;
            }
            if (BYTE1(v351))
            {
              v355 = v8;
              if (BYTE1(v351) != 255)
                v355 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE1(v351) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[1]))* (float)(1.0 - (float)((float)BYTE1(v351) * 0.0039216)))));
              v265[1] = v355;
            }
            if (BYTE2(v351))
            {
              v356 = v8;
              if (BYTE2(v351) != 255)
                v356 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE2(v351) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[2]))* (float)(1.0 - (float)((float)BYTE2(v351) * 0.0039216)))));
              v265[2] = v356;
            }
            v357 = HIBYTE(v351);
            if (v357 == 255)
            {
              v265[3] = v8;
            }
            else if (v357)
            {
              v265[3] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v357 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v265[3])) * (float)(1.0 - (float)((float)v357 * 0.0039216)))));
            }
LABEL_550:
            while (1)
            {
              v358 = v352;
              v265 += 4;
              --v352;
              ++v264;
              if (v358 < 2)
                break;
              v351 = *v264;
              if (*v264)
                goto LABEL_532;
            }
            if (!v353)
              break;
            v353 = 0;
            v351 = *v264 & v269;
          }
          v264 = (unsigned int *)((char *)v264 + v347);
          v265 += v350;
          if (!--v10)
            return;
        }
      }
      v34 = -1 << (8 * v33);
      v35 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
      v36 = 4 * (v22 & 3);
      v37 = &v20[v36 / 0xFFFFFFFFFFFFFFFCLL];
      v38 = &v14[v36 / 0xFFFFFFFFFFFFFFFCLL];
      if ((v22 & 3) != 0)
        v39 = v22 & 0xFC;
      else
        v39 = v22;
      if ((v22 & 3) != 0)
      {
        v40 = v33 + v9;
      }
      else
      {
        v34 = -1;
        v35 = (unsigned int *)v22;
        v38 = v14;
        v37 = v20;
        v40 = v9;
      }
      if ((((_BYTE)v40 + v39) & 3) != 0)
      {
        v41 = 4 - (((_BYTE)v40 + v39) & 3);
        v33 += v41;
        v42 = 0xFFFFFFFF >> (8 * v41);
        if (v40 >= 4)
          v43 = v42;
        else
          v43 = 0;
        if (v40 >= 4)
          v42 = -1;
        v34 &= v42;
      }
      else
      {
        v43 = 0;
      }
      v286 = v23 - v33;
      v287 = v40 >> 2;
      v288 = v24 - v33;
      v289 = bswap32(LODWORD(v7));
      v290 = v16 - v33;
      do
      {
        v291 = *v35 & v34;
        v292 = v287;
        v293 = v43;
        if (!v291)
          goto LABEL_501;
LABEL_483:
        if (v291 == -1)
        {
          *v37 = v8;
          *v38 = v289;
          v37[1] = v8;
          v38[1] = v289;
          v37[2] = v8;
          v38[2] = v289;
LABEL_498:
          v37[3] = v8;
          v38[3] = v289;
          goto LABEL_501;
        }
        while (1)
        {
          if ((_BYTE)v291)
          {
            v294 = v8;
            v295 = v289;
            if (v291 != 255)
            {
              v296 = (float)v291 * 0.0039216;
              v297 = v296 * *(float *)v3.i32;
              v298 = v7 * v296;
              v299 = 1.0 - v296;
              v294 = bswap32(COERCE_UNSIGNED_INT(v297 + (float)(COERCE_FLOAT(bswap32(*v37)) * v299)));
              v295 = bswap32(COERCE_UNSIGNED_INT(v298 + (float)(COERCE_FLOAT(bswap32(*v38)) * v299)));
            }
            *v37 = v294;
            *v38 = v295;
          }
          if (BYTE1(v291))
          {
            v300 = v8;
            v301 = v289;
            if (BYTE1(v291) != 255)
            {
              v302 = (float)BYTE1(v291) * 0.0039216;
              v303 = v302 * *(float *)v3.i32;
              v304 = v7 * v302;
              v305 = 1.0 - v302;
              v300 = bswap32(COERCE_UNSIGNED_INT(v303 + (float)(COERCE_FLOAT(bswap32(v37[1])) * v305)));
              v301 = bswap32(COERCE_UNSIGNED_INT(v304 + (float)(COERCE_FLOAT(bswap32(v38[1])) * v305)));
            }
            v37[1] = v300;
            v38[1] = v301;
          }
          if (BYTE2(v291))
          {
            v306 = v8;
            v307 = v289;
            if (BYTE2(v291) != 255)
            {
              v308 = (float)BYTE2(v291) * 0.0039216;
              v309 = v308 * *(float *)v3.i32;
              v310 = v7 * v308;
              v311 = 1.0 - v308;
              v306 = bswap32(COERCE_UNSIGNED_INT(v309 + (float)(COERCE_FLOAT(bswap32(v37[2])) * v311)));
              v307 = bswap32(COERCE_UNSIGNED_INT(v310 + (float)(COERCE_FLOAT(bswap32(v38[2])) * v311)));
            }
            v37[2] = v306;
            v38[2] = v307;
          }
          v312 = HIBYTE(v291);
          if (v312 == 255)
            goto LABEL_498;
          if (v312)
          {
            v313 = (float)v312 * 0.0039216;
            v314 = v313 * *(float *)v3.i32;
            v315 = v7 * v313;
            v316 = 1.0 - v313;
            v317 = bswap32(COERCE_UNSIGNED_INT(v315 + (float)(COERCE_FLOAT(bswap32(v38[3])) * v316)));
            v37[3] = bswap32(COERCE_UNSIGNED_INT(v314 + (float)(COERCE_FLOAT(bswap32(v37[3])) * v316)));
            v38[3] = v317;
          }
LABEL_501:
          while (1)
          {
            v318 = v292;
            v37 += 4;
            v38 += 4;
            --v292;
            ++v35;
            if (v318 < 2)
              break;
            v291 = *v35;
            if (*v35)
              goto LABEL_483;
          }
          if (!v293)
            break;
          v293 = 0;
          v291 = *v35 & v43;
        }
        v35 = (unsigned int *)((char *)v35 + v286);
        v37 += v288;
        v38 += v290;
        --v10;
      }
      while (v10);
      return;
    case 2:
      *(float *)&a3 = 1.0 - v7;
      v44 = v22 & 3;
      if (v4)
      {
        v45 = -1 << (8 * v44);
        v46 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
        v47 = 4 * (v22 & 3);
        v48 = &v20[v47 / 0xFFFFFFFFFFFFFFFCLL];
        v49 = &v14[v47 / 0xFFFFFFFFFFFFFFFCLL];
        if ((v22 & 3) != 0)
          v50 = v22 & 0xFC;
        else
          v50 = v22;
        if ((v22 & 3) != 0)
        {
          v51 = v44 + v9;
        }
        else
        {
          v45 = -1;
          v46 = (unsigned int *)v22;
          v49 = v14;
          v48 = v20;
          v51 = *(_DWORD *)(a1 + 4);
        }
        if ((((_BYTE)v51 + v50) & 3) != 0)
        {
          v52 = 4 - (((_BYTE)v51 + v50) & 3);
          v44 += v52;
          v53 = 0xFFFFFFFF >> (8 * v52);
          if (v51 >= 4)
            v54 = v53;
          else
            v54 = 0;
          if (v51 >= 4)
            v53 = -1;
          v45 &= v53;
        }
        else
        {
          v54 = 0;
        }
        v319 = v23 - v44;
        v320 = v24 - v44;
        v321 = v51 >> 2;
        v322 = v16 - v44;
        while (1)
        {
          v323 = *v46 & v45;
          v324 = v321;
          v325 = v54;
          if (!v323)
            goto LABEL_522;
LABEL_511:
          if (v323 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v323)
            {
              v331 = (float)v323 * 0.0039216;
              v332 = v331 * *(float *)v3.i32;
              v333 = v7 * v331;
              v334 = bswap32(COERCE_UNSIGNED_INT(v333 + (float)(COERCE_FLOAT(bswap32(*v49)) * (float)(1.0 - v333))));
              *v48 = bswap32(COERCE_UNSIGNED_INT(v332 + (float)(COERCE_FLOAT(bswap32(*v48)) * (float)(1.0 - v333))));
              *v49 = v334;
            }
            if ((v323 & 0xFF00) != 0)
            {
              v335 = (float)BYTE1(v323) * 0.0039216;
              v336 = v335 * *(float *)v3.i32;
              v337 = v7 * v335;
              v338 = bswap32(COERCE_UNSIGNED_INT(v337 + (float)(COERCE_FLOAT(bswap32(v49[1])) * (float)(1.0 - v337))));
              v48[1] = bswap32(COERCE_UNSIGNED_INT(v336 + (float)(COERCE_FLOAT(bswap32(v48[1])) * (float)(1.0 - v337))));
              v49[1] = v338;
            }
            if ((v323 & 0xFF0000) != 0)
            {
              v339 = (float)BYTE2(v323) * 0.0039216;
              v340 = v339 * *(float *)v3.i32;
              v341 = v7 * v339;
              v342 = bswap32(COERCE_UNSIGNED_INT(v341 + (float)(COERCE_FLOAT(bswap32(v49[2])) * (float)(1.0 - v341))));
              v48[2] = bswap32(COERCE_UNSIGNED_INT(v340 + (float)(COERCE_FLOAT(bswap32(v48[2])) * (float)(1.0 - v341))));
              v49[2] = v342;
            }
            v343 = HIBYTE(v323);
            if (v343)
            {
              v344 = (float)v343 * 0.0039216;
              v345 = v7 * v344;
              v329 = (float)(v344 * *(float *)v3.i32)
                   + (float)(COERCE_FLOAT(bswap32(v48[3])) * (float)(1.0 - (float)(v7 * v344)));
              v330 = v345 + (float)(COERCE_FLOAT(bswap32(v49[3])) * (float)(1.0 - v345));
              goto LABEL_521;
            }
LABEL_522:
            while (1)
            {
              v346 = v324;
              v48 += 4;
              v49 += 4;
              --v324;
              ++v46;
              if (v346 < 2)
                break;
              v323 = *v46;
              if (*v46)
                goto LABEL_511;
            }
            if (!v325)
              break;
            v325 = 0;
            v323 = *v46 & v54;
          }
          v46 = (unsigned int *)((char *)v46 + v319);
          v48 += v320;
          v49 += v322;
          if (!--v10)
            return;
        }
        v326 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(*v49)) * *(float *)&a3)));
        *v48 = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(*v48)) * *(float *)&a3)));
        *v49 = v326;
        v327 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(v49[1])) * *(float *)&a3)));
        v48[1] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[1])) * *(float *)&a3)));
        v49[1] = v327;
        v328 = bswap32(COERCE_UNSIGNED_INT(v7 + (float)(COERCE_FLOAT(bswap32(v49[2])) * *(float *)&a3)));
        v48[2] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[2])) * *(float *)&a3)));
        v49[2] = v328;
        v329 = *(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v48[3])) * *(float *)&a3);
        v330 = v7 + (float)(COERCE_FLOAT(bswap32(v49[3])) * *(float *)&a3);
LABEL_521:
        v48[3] = bswap32(LODWORD(v329));
        v49[3] = bswap32(LODWORD(v330));
        goto LABEL_522;
      }
      v270 = v44 + v9;
      v271 = -1 << (8 * v44);
      if ((v22 & 3) != 0)
        v272 = v22 & 0xFC;
      else
        v272 = v5 + *(_DWORD *)(a1 + 104) + *(_DWORD *)(a1 + 108) * v21;
      if ((v22 & 3) != 0)
      {
        v273 = (unsigned int *)(v22 & 0xFFFFFFFFFFFFFFFCLL);
      }
      else
      {
        v271 = -1;
        v273 = (unsigned int *)(v5 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v21);
      }
      if ((v22 & 3) != 0)
        v274 = (int8x8_t *)&v20[-(v22 & 3)];
      else
        v274 = (int8x8_t *)v20;
      if ((v22 & 3) == 0)
        v270 = *(_DWORD *)(a1 + 4);
      if ((((_BYTE)v270 + v272) & 3) != 0)
      {
        v275 = 4 - (((_BYTE)v270 + v272) & 3);
        v44 += v275;
        v276 = 0xFFFFFFFF >> (8 * v275);
        if (v270 >= 4)
          v277 = v276;
        else
          v277 = 0;
        if (v270 >= 4)
          v276 = -1;
        v271 &= v276;
      }
      else
      {
        v277 = 0;
      }
      v359 = v270 >> 2;
      v360 = v23 - v44;
      v361 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
      v362 = (float32x2_t)vdup_lane_s32(v3, 0);
      v363 = v24 - v44;
      while (1)
      {
        v364 = *v273 & v271;
        v365 = v359;
        v366 = v277;
        if (!v364)
          goto LABEL_571;
LABEL_560:
        if (v364 == -1)
          break;
        while (1)
        {
          if ((_BYTE)v364)
            v274->i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v364 * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274->i32[0]))* (float)(1.0 - (float)(v7 * (float)((float)v364 * 0.0039216))))));
          if ((v364 & 0xFF00) != 0)
            v274->i32[1] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE1(v364) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274->u32[1]))* (float)(1.0 - (float)(v7 * (float)((float)BYTE1(v364) * 0.0039216))))));
          if ((v364 & 0xFF0000) != 0)
            v274[1].i32[0] = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)BYTE2(v364) * 0.0039216) * *(float *)v3.i32)+ (float)(COERCE_FLOAT(bswap32(v274[1].u32[0]))* (float)(1.0 - (float)(v7 * (float)((float)BYTE2(v364) * 0.0039216))))));
          v369 = HIBYTE(v364);
          if (v369)
          {
            v368 = (float)((float)((float)v369 * 0.0039216) * *(float *)v3.i32)
                 + (float)(COERCE_FLOAT(bswap32(v274[1].u32[1]))
                         * (float)(1.0 - (float)(v7 * (float)((float)v369 * 0.0039216))));
            goto LABEL_570;
          }
LABEL_571:
          while (1)
          {
            v370 = v365;
            v274 += 2;
            --v365;
            ++v273;
            if (v370 < 2)
              break;
            v364 = *v273;
            if (*v273)
              goto LABEL_560;
          }
          if (!v366)
            break;
          v366 = 0;
          v364 = *v273 & v277;
        }
        v273 = (unsigned int *)((char *)v273 + v360);
        v274 = (int8x8_t *)((char *)v274 + 4 * v363);
        if (!--v10)
          return;
      }
      v367 = v274[1].u32[1];
      v274[1].i32[0] = bswap32(COERCE_UNSIGNED_INT(*(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v274[1].u32[0]))
                                                                            * *(float *)&a3)));
      *v274 = vrev32_s8((int8x8_t)vmla_f32(v362, v361, (float32x2_t)vrev32_s8(*v274)));
      v368 = *(float *)v3.i32 + (float)(COERCE_FLOAT(bswap32(v367)) * *(float *)&a3);
LABEL_570:
      v274[1].i32[1] = bswap32(LODWORD(v368));
      goto LABEL_571;
    case 3:
      v55 = 4 * v15;
      do
      {
        v56 = v9;
        do
        {
          v57 = *(unsigned __int8 *)v22;
          if (*(_BYTE *)v22)
          {
            if (v57 == 255)
            {
              v58 = COERCE_FLOAT(bswap32(*v14));
              v59 = v18 * v58;
              v60 = v7 * v58;
            }
            else
            {
              v61 = (float)v57 * 0.0039216;
              v62 = COERCE_FLOAT(bswap32(*v14));
              v63 = v7 * (float)(v61 * v62);
              v64 = 1.0 - v61;
              v59 = (float)((float)(v61 * v62) * v18) + (float)(COERCE_FLOAT(bswap32(*v20)) * (float)(1.0 - v61));
              v60 = v63 + (float)(v62 * v64);
            }
            *v20 = bswap32(LODWORD(v59));
            *v14 = bswap32(LODWORD(v60));
          }
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v55);
          --v56;
        }
        while (v56);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 4:
      v65 = 4 * v15;
      do
      {
        v66 = v9;
        do
        {
          v67 = *(unsigned __int8 *)v22;
          if (*(_BYTE *)v22)
          {
            if (v67 == 255)
            {
              v68 = COERCE_FLOAT(bswap32(*v14));
              v69 = (float)(1.0 - v68) * v18;
              v70 = v7 * (float)(1.0 - v68);
            }
            else
            {
              v71 = (float)v67 * 0.0039216;
              v72 = COERCE_FLOAT(bswap32(*v14));
              v73 = v71 * (float)(1.0 - v72);
              v74 = 1.0 - v71;
              v69 = (float)(v73 * v18) + (float)(COERCE_FLOAT(bswap32(*v20)) * (float)(1.0 - v71));
              v70 = (float)(v7 * v73) + (float)(v72 * v74);
            }
            *v20 = bswap32(LODWORD(v69));
            *v14 = bswap32(LODWORD(v70));
          }
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v65);
          --v66;
        }
        while (v66);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 5:
      v75 = 4 * v15;
      do
      {
        v76 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v77 = COERCE_FLOAT(bswap32(*v14));
            v78 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v79 = v78 * v18;
            v80 = v7 * v78;
            *v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v80) * COERCE_FLOAT(bswap32(*v20))) + (float)(v79 * v77)));
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v80) * v77) + (float)(v80 * v77)));
          }
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v75);
          --v76;
        }
        while (v76);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 6:
      v81 = 4 * v15;
      while (1)
      {
        v82 = v9;
        do
        {
          v83 = *(unsigned __int8 *)v22;
          if (!*(_BYTE *)v22)
            goto LABEL_85;
          v84 = COERCE_FLOAT(bswap32(*v14));
          v85 = 1.0 - v84;
          if ((float)(1.0 - v84) >= 1.0)
          {
            v90 = (float)v83 * 0.0039216;
            v88 = v90 * v18;
            v89 = v7 * v90;
          }
          else
          {
            if (v85 <= 0.0)
              goto LABEL_85;
            v86 = (float)v83 * 0.0039216;
            v87 = v7 * v86;
            v88 = COERCE_FLOAT(bswap32(*v20)) + (float)((float)(v86 * v18) * v85);
            v89 = v84 + (float)(v87 * v85);
          }
          *v20 = bswap32(LODWORD(v88));
          *v14 = bswap32(LODWORD(v89));
LABEL_85:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v81);
          --v82;
        }
        while (v82);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 7:
      if (v4)
      {
        v91 = 4 * v15;
        do
        {
          v92 = v9;
          do
          {
            v93 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v93 == 255)
              {
                v94 = v7 * COERCE_FLOAT(bswap32(*v20));
                v95 = v7 * COERCE_FLOAT(bswap32(*v14));
              }
              else
              {
                v96 = (float)(v7 * (float)((float)v93 * 0.0039216)) + (float)(1.0 - (float)((float)v93 * 0.0039216));
                v94 = v96 * COERCE_FLOAT(bswap32(*v20));
                v95 = v96 * COERCE_FLOAT(bswap32(*v14));
              }
              *v20 = bswap32(LODWORD(v94));
              *v14 = bswap32(LODWORD(v95));
            }
            ++v22;
            ++v20;
            v14 = (unsigned int *)((char *)v14 + v91);
            --v92;
          }
          while (v92);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v278 = v9;
          do
          {
            v279 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v279 == 255)
                v280 = v7 * COERCE_FLOAT(bswap32(*v20));
              else
                v280 = (float)((float)(v7 * (float)((float)v279 * 0.0039216))
                             + (float)(1.0 - (float)((float)v279 * 0.0039216)))
                     * COERCE_FLOAT(bswap32(*v20));
              *v20 = bswap32(LODWORD(v280));
            }
            ++v22;
            ++v20;
            --v278;
          }
          while (v278);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 8:
      v97 = 1.0 - v7;
      if (v4)
      {
        v98 = 4 * v15;
        do
        {
          v99 = v9;
          do
          {
            v100 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v100 == 255)
              {
                v101 = v97 * COERCE_FLOAT(bswap32(*v20));
                v102 = v97 * COERCE_FLOAT(bswap32(*v14));
              }
              else
              {
                v103 = (float)(v7 * (float)((float)v100 * -0.0039216)) + 1.0;
                v101 = v103 * COERCE_FLOAT(bswap32(*v20));
                v102 = v103 * COERCE_FLOAT(bswap32(*v14));
              }
              *v20 = bswap32(LODWORD(v101));
              *v14 = bswap32(LODWORD(v102));
            }
            ++v22;
            ++v20;
            v14 = (unsigned int *)((char *)v14 + v98);
            --v99;
          }
          while (v99);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v281 = v9;
          do
          {
            v282 = *(unsigned __int8 *)v22;
            if (*(_BYTE *)v22)
            {
              if (v282 == 255)
                v283 = v97 * COERCE_FLOAT(bswap32(*v20));
              else
                v283 = (float)((float)(v7 * (float)((float)v282 * -0.0039216)) + 1.0) * COERCE_FLOAT(bswap32(*v20));
              *v20 = bswap32(LODWORD(v283));
            }
            ++v22;
            ++v20;
            --v281;
          }
          while (v281);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 9:
      v104 = 4 * v15;
      do
      {
        v105 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v106 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v107 = COERCE_FLOAT(bswap32(*v14));
            v108 = v106 * v18;
            v109 = v7 * v106;
            v110 = (float)(1.0 - v106) + (float)(v7 * v106);
            *v20 = bswap32(COERCE_UNSIGNED_INT((float)(v110 * COERCE_FLOAT(bswap32(*v20))) + (float)(v108 * (float)(1.0 - v107))));
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)(v110 * v107) + (float)(v109 * (float)(1.0 - v107))));
          }
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v104);
          --v105;
        }
        while (v105);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 10:
      v111 = 4 * v15;
      do
      {
        v112 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v113 = COERCE_FLOAT(bswap32(*v14));
            v114 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v115 = v114 * v18;
            v116 = v7 * v114;
            *v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v116) * COERCE_FLOAT(bswap32(*v20))) + (float)(v115 * (float)(1.0 - v113))));
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v116) * v113) + (float)(v116 * (float)(1.0 - v113))));
          }
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v111);
          --v112;
        }
        while (v112);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        --v10;
      }
      while (v10);
      return;
    case 11:
      if (v4)
      {
        v117 = 4 * v15;
        do
        {
          v118 = v9;
          do
          {
            if (*(_BYTE *)v22)
            {
              v119 = (float)*(unsigned __int8 *)v22 * 0.0039216;
              v120 = v119 * v18;
              v121 = v7 * v119;
              v122 = COERCE_FLOAT(bswap32(*v20));
              v123 = COERCE_FLOAT(bswap32(*v14));
              v124 = v121 + v123;
              if ((float)(v121 + v123) > 1.0)
                v124 = 1.0;
              *v20 = bswap32(COERCE_UNSIGNED_INT((float)(v121 - v120) + (float)(v124 - (float)(v123 - v122))));
              *v14 = bswap32(LODWORD(v124));
            }
            ++v22;
            ++v20;
            v14 = (unsigned int *)((char *)v14 + v117);
            --v118;
          }
          while (v118);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v284 = v9;
          do
          {
            if (*(_BYTE *)v22)
              *v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)(v7 * (float)((float)*(unsigned __int8 *)v22 * 0.0039216))- (float)((float)((float)*(unsigned __int8 *)v22 * 0.0039216) * v18))+ COERCE_FLOAT(bswap32(*v20))));
            ++v22;
            ++v20;
            --v284;
          }
          while (v284);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 12:
      if (v4)
      {
        v125 = 4 * v15;
        do
        {
          v126 = v9;
          do
          {
            if (*(_BYTE *)v22)
            {
              v127 = (float)*(unsigned __int8 *)v22 * 0.0039216;
              v128 = v127 * v18;
              v129 = (float)(v7 * v127) + COERCE_FLOAT(bswap32(*v14));
              v130 = v128 + COERCE_FLOAT(bswap32(*v20));
              if (v129 > 1.0)
                v129 = 1.0;
              *v20 = bswap32(LODWORD(v130));
              *v14 = bswap32(LODWORD(v129));
            }
            ++v22;
            ++v20;
            v14 = (unsigned int *)((char *)v14 + v125);
            --v126;
          }
          while (v126);
          v22 += v23;
          v20 += v24;
          v14 += v17;
          --v10;
        }
        while (v10);
      }
      else
      {
        do
        {
          v285 = v9;
          do
          {
            if (*(_BYTE *)v22)
              *v20 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)*(unsigned __int8 *)v22 * 0.0039216) * v18)+ COERCE_FLOAT(bswap32(*v20))));
            ++v22;
            ++v20;
            --v285;
          }
          while (v285);
          v22 += v23;
          v20 += v24;
          --v10;
        }
        while (v10);
      }
      return;
    case 13:
      v131 = 4 * v15;
      while (1)
      {
        v132 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v133 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v134 = v7 * v133;
            if ((float)(v7 * v133) > 0.0)
            {
              v135 = v133 * v18;
              if (v4)
              {
                v136 = COERCE_FLOAT(bswap32(*v14));
                if (v136 <= 0.0)
                  goto LABEL_158;
              }
              else
              {
                v136 = 1.0;
              }
              v137 = COERCE_FLOAT(bswap32(*v20));
              v138 = (float)(v135 * v137) + (float)(v137 * (float)(1.0 - v134));
              if (v134 == 1.0)
                v138 = v135 * v137;
              v135 = v138 + (float)(v135 * (float)(1.0 - v136));
              if (v136 == 1.0)
                v135 = v138;
              if (v4)
              {
                v134 = (float)(v134 + v136) - (float)(v136 * v134);
LABEL_158:
                *v20 = bswap32(LODWORD(v135));
                *v14 = bswap32(LODWORD(v134));
                goto LABEL_160;
              }
              *v20 = bswap32(LODWORD(v135));
            }
          }
LABEL_160:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v131);
          --v132;
        }
        while (v132);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 14:
      v139 = 4 * v15;
      while (1)
      {
        v140 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v141 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v142 = v7 * v141;
            if ((float)(v7 * v141) > 0.0)
            {
              v143 = v141 * v18;
              if (v4)
              {
                v144 = COERCE_FLOAT(bswap32(*v14));
                if (v144 <= 0.0)
                  goto LABEL_173;
              }
              else
              {
                v144 = 1.0;
              }
              v145 = COERCE_FLOAT(bswap32(*v20));
              v143 = v145 + (float)(v143 * (float)(1.0 - v145));
              if (v4)
              {
                v142 = (float)(v142 + v144) - (float)(v144 * v142);
LABEL_173:
                *v20 = bswap32(LODWORD(v143));
                *v14 = bswap32(LODWORD(v142));
                goto LABEL_175;
              }
              *v20 = bswap32(LODWORD(v143));
            }
          }
LABEL_175:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v139);
          --v140;
        }
        while (v140);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 15:
      v146 = 4 * v15;
      while (1)
      {
        v147 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v148 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v149 = v7 * v148;
            if ((float)(v7 * v148) > 0.0)
            {
              v150 = v148 * *(float *)v3.i32;
              if (v4)
              {
                v151 = COERCE_FLOAT(bswap32(*v14));
                if (v151 <= 0.0)
                  goto LABEL_188;
              }
              else
              {
                v151 = 1.0;
              }
              v152 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v20)), v151, v150, v149);
              v150 = v152;
              if (v4)
              {
                v149 = v153;
                *(float *)v3.i32 = v372;
LABEL_188:
                *v20 = bswap32(LODWORD(v150));
                *v14 = bswap32(LODWORD(v149));
                goto LABEL_190;
              }
              *v20 = bswap32(LODWORD(v152));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_190:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v146);
          --v147;
        }
        while (v147);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        v9 = v26;
        if (!v10)
          return;
      }
    case 16:
      v154 = 4 * v15;
      while (1)
      {
        v155 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v156 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v157 = v7 * v156;
            if ((float)(v7 * v156) > 0.0)
            {
              v158 = v156 * v18;
              if (v4)
              {
                v159 = COERCE_FLOAT(bswap32(*v14));
                if (v159 <= 0.0)
                  goto LABEL_209;
              }
              else
              {
                v159 = 1.0;
              }
              v160 = COERCE_FLOAT(bswap32(*v20));
              v161 = v157 * v160;
              if ((float)(v158 * v159) < (float)(v157 * v160))
                v161 = v158 * v159;
              v162 = v161 + (float)(v160 * (float)(1.0 - v157));
              if (v157 == 1.0)
                v162 = v161;
              v158 = v162 + (float)(v158 * (float)(1.0 - v159));
              if (v159 == 1.0)
                v158 = v162;
              if (v4)
              {
                v157 = (float)(v157 + v159) - (float)(v159 * v157);
LABEL_209:
                *v20 = bswap32(LODWORD(v158));
                *v14 = bswap32(LODWORD(v157));
                goto LABEL_211;
              }
              *v20 = bswap32(LODWORD(v158));
            }
          }
LABEL_211:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v154);
          --v155;
        }
        while (v155);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 17:
      v163 = 4 * v15;
      while (1)
      {
        v164 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v165 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v166 = v7 * v165;
            if ((float)(v7 * v165) > 0.0)
            {
              v167 = v165 * v18;
              if (v4)
              {
                v168 = COERCE_FLOAT(bswap32(*v14));
                if (v168 <= 0.0)
                  goto LABEL_230;
              }
              else
              {
                v168 = 1.0;
              }
              v169 = COERCE_FLOAT(bswap32(*v20));
              v170 = v166 * v169;
              if ((float)(v167 * v168) > (float)(v166 * v169))
                v170 = v167 * v168;
              v171 = v170 + (float)(v169 * (float)(1.0 - v166));
              if (v166 == 1.0)
                v171 = v170;
              v167 = v171 + (float)(v167 * (float)(1.0 - v168));
              if (v168 == 1.0)
                v167 = v171;
              if (v4)
              {
                v166 = (float)(v166 + v168) - (float)(v168 * v166);
LABEL_230:
                *v20 = bswap32(LODWORD(v167));
                *v14 = bswap32(LODWORD(v166));
                goto LABEL_232;
              }
              *v20 = bswap32(LODWORD(v167));
            }
          }
LABEL_232:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v163);
          --v164;
        }
        while (v164);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 18:
      v172 = 4 * v15;
      while (1)
      {
        v173 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v174 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v175 = v7 * v174;
            if ((float)(v7 * v174) > 0.0)
            {
              v176 = v174 * *(float *)v3.i32;
              if (v4)
              {
                v177 = COERCE_FLOAT(bswap32(*v14));
                if (v177 <= 0.0)
                  goto LABEL_245;
              }
              else
              {
                v177 = 1.0;
              }
              v178 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v20)), v177, v176, v175);
              v176 = v178;
              if (v4)
              {
                v175 = v179;
                *(float *)v3.i32 = v372;
LABEL_245:
                *v20 = bswap32(LODWORD(v176));
                *v14 = bswap32(LODWORD(v175));
                goto LABEL_247;
              }
              *v20 = bswap32(LODWORD(v178));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_247:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v172);
          --v173;
        }
        while (v173);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        v9 = v26;
        if (!v10)
          return;
      }
    case 19:
      v180 = 4 * v15;
      while (1)
      {
        v181 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v182 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v183 = v7 * v182;
            if ((float)(v7 * v182) > 0.0)
            {
              v184 = v182 * *(float *)v3.i32;
              if (v4)
              {
                v185 = COERCE_FLOAT(bswap32(*v14));
                if (v185 <= 0.0)
                  goto LABEL_260;
              }
              else
              {
                v185 = 1.0;
              }
              v186 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v20)), v185, v184, v183);
              v184 = v186;
              if (v4)
              {
                v183 = v187;
                *(float *)v3.i32 = v372;
LABEL_260:
                *v20 = bswap32(LODWORD(v184));
                *v14 = bswap32(LODWORD(v183));
                goto LABEL_262;
              }
              *v20 = bswap32(LODWORD(v186));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_262:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v180);
          --v181;
        }
        while (v181);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        v9 = v26;
        if (!v10)
          return;
      }
    case 20:
      v188 = 4 * v15;
      while (1)
      {
        v189 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v190 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v191 = v7 * v190;
            if ((float)(v7 * v190) > 0.0)
            {
              v192 = v190 * *(float *)v3.i32;
              if (v4)
              {
                v193 = COERCE_FLOAT(bswap32(*v14));
                if (v193 <= 0.0)
                  goto LABEL_275;
              }
              else
              {
                v193 = 1.0;
              }
              v194 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v20)), v193, v192, v191);
              v192 = v194;
              if (v4)
              {
                v191 = v195;
                *(float *)v3.i32 = v372;
LABEL_275:
                *v20 = bswap32(LODWORD(v192));
                *v14 = bswap32(LODWORD(v191));
                goto LABEL_277;
              }
              *v20 = bswap32(LODWORD(v194));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_277:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v188);
          --v189;
        }
        while (v189);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        v9 = v26;
        if (!v10)
          return;
      }
    case 21:
      v196 = 4 * v15;
      while (1)
      {
        v197 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v198 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v199 = v7 * v198;
            if ((float)(v7 * v198) > 0.0)
            {
              v200 = v198 * *(float *)v3.i32;
              if (v4)
              {
                v201 = COERCE_FLOAT(bswap32(*v14));
                if (v201 <= 0.0)
                  goto LABEL_290;
              }
              else
              {
                v201 = 1.0;
              }
              v202 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v20)), v201, v200, v199);
              v200 = v202;
              if (v4)
              {
                v199 = v203;
                *(float *)v3.i32 = v372;
LABEL_290:
                *v20 = bswap32(LODWORD(v200));
                *v14 = bswap32(LODWORD(v199));
                goto LABEL_292;
              }
              *v20 = bswap32(LODWORD(v202));
              *(float *)v3.i32 = v372;
            }
          }
LABEL_292:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v196);
          --v197;
        }
        while (v197);
        v22 += v25;
        v20 += v371;
        v14 += v27;
        --v10;
        v9 = v26;
        if (!v10)
          return;
      }
    case 22:
      v204 = 4 * v15;
      while (1)
      {
        v205 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v206 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v207 = v7 * v206;
            if ((float)(v7 * v206) > 0.0)
            {
              v208 = v206 * v18;
              if (v4)
              {
                v209 = COERCE_FLOAT(bswap32(*v14));
                if (v209 <= 0.0)
                  goto LABEL_307;
              }
              else
              {
                v209 = 1.0;
              }
              v210 = COERCE_FLOAT(bswap32(*v20));
              v211 = v208 + v210;
              v212 = v208 * v209;
              v213 = (float)(v207 * v210) - v212;
              v214 = (float)(v211 - (float)(v207 * v210)) - v212;
              if (v213 < 0.0)
                v213 = -v213;
              v208 = v214 + v213;
              if (v4)
              {
                v207 = (float)(v207 + v209) - (float)(v209 * v207);
LABEL_307:
                *v20 = bswap32(LODWORD(v208));
                *v14 = bswap32(LODWORD(v207));
                goto LABEL_309;
              }
              *v20 = bswap32(LODWORD(v208));
            }
          }
LABEL_309:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v204);
          --v205;
        }
        while (v205);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 23:
      v215 = 4 * v15;
      while (1)
      {
        v216 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v217 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v218 = v7 * v217;
            if ((float)(v7 * v217) > 0.0)
            {
              v219 = v217 * v18;
              if (v4)
              {
                v220 = COERCE_FLOAT(bswap32(*v14));
                if (v220 <= 0.0)
                  goto LABEL_322;
              }
              else
              {
                v220 = 1.0;
              }
              v221 = COERCE_FLOAT(bswap32(*v20));
              v219 = (float)(v219 + v221) + (float)((float)(v219 * v221) * -2.0);
              if (v4)
              {
                v218 = (float)(v218 + v220) - (float)(v220 * v218);
LABEL_322:
                *v20 = bswap32(LODWORD(v219));
                *v14 = bswap32(LODWORD(v218));
                goto LABEL_324;
              }
              *v20 = bswap32(LODWORD(v219));
            }
          }
LABEL_324:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v215);
          --v216;
        }
        while (v216);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 24:
      v222 = 4 * v15;
      while (1)
      {
        v223 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v224 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v225 = v7 * v224;
            if ((float)(v7 * v224) > 0.0)
            {
              v226 = v224 * v18;
              if (v4)
              {
                v227 = COERCE_FLOAT(bswap32(*v14));
                if (v227 <= 0.0)
                  goto LABEL_342;
              }
              else
              {
                v227 = 1.0;
              }
              v228 = COERCE_FLOAT(bswap32(*v20));
              v229 = v228;
              if (v225 == 1.0)
              {
                v230 = 0.0;
              }
              else
              {
                v229 = v225 * v228;
                v230 = v228 - (float)(v225 * v228);
              }
              v231 = (float)(v226 + v230) - (float)(v226 * v227);
              if (v227 == 1.0)
                v231 = v230;
              v226 = v229 + v231;
              if (v4)
              {
                v225 = (float)(v225 + v227) - (float)(v225 * v227);
LABEL_342:
                *v20 = bswap32(LODWORD(v226));
                *v14 = bswap32(LODWORD(v225));
                goto LABEL_344;
              }
              *v20 = bswap32(LODWORD(v226));
            }
          }
LABEL_344:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v222);
          --v223;
        }
        while (v223);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 25:
      v232 = 4 * v15;
      while (1)
      {
        v233 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v234 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v235 = v7 * v234;
            if ((float)(v7 * v234) > 0.0)
            {
              v236 = v234 * v18;
              if (v4)
              {
                v237 = COERCE_FLOAT(bswap32(*v14));
                if (v237 <= 0.0)
                  goto LABEL_362;
              }
              else
              {
                v237 = 1.0;
              }
              v238 = COERCE_FLOAT(bswap32(*v20));
              v239 = v238;
              if (v235 == 1.0)
              {
                v240 = 0.0;
              }
              else
              {
                v239 = v235 * v238;
                v240 = v238 - (float)(v235 * v238);
              }
              v241 = (float)(v236 + v240) - (float)(v236 * v237);
              if (v237 == 1.0)
                v241 = v240;
              v236 = v239 + v241;
              if (v4)
              {
                v235 = (float)(v235 + v237) - (float)(v235 * v237);
LABEL_362:
                *v20 = bswap32(LODWORD(v236));
                *v14 = bswap32(LODWORD(v235));
                goto LABEL_364;
              }
              *v20 = bswap32(LODWORD(v236));
            }
          }
LABEL_364:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v232);
          --v233;
        }
        while (v233);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 26:
      v242 = 4 * v15;
      while (1)
      {
        v243 = v9;
        do
        {
          if (*(_BYTE *)v22)
          {
            v244 = (float)*(unsigned __int8 *)v22 * 0.0039216;
            v245 = v7 * v244;
            if ((float)(v7 * v244) > 0.0)
            {
              v246 = v244 * v18;
              if (v4)
              {
                v247 = COERCE_FLOAT(bswap32(*v14));
                if (v247 <= 0.0)
                  goto LABEL_381;
              }
              else
              {
                v247 = 1.0;
              }
              v248 = COERCE_FLOAT(bswap32(*v20));
              v249 = v248;
              v250 = v246 - (float)(v246 * v247);
              if (v247 == 1.0)
                v250 = 0.0;
              if (v245 != 1.0)
              {
                v249 = v245 * v248;
                v250 = (float)(v250 + v248) - (float)(v245 * v248);
              }
              v246 = v249 + v250;
              if (v4)
              {
                v245 = (float)(v245 + v247) - (float)(v245 * v247);
LABEL_381:
                *v20 = bswap32(LODWORD(v246));
                *v14 = bswap32(LODWORD(v245));
                goto LABEL_383;
              }
              *v20 = bswap32(LODWORD(v246));
            }
          }
LABEL_383:
          ++v22;
          ++v20;
          v14 = (unsigned int *)((char *)v14 + v242);
          --v243;
        }
        while (v243);
        v22 += v23;
        v20 += v24;
        v14 += v17;
        if (!--v10)
          return;
      }
    case 27:
      v251 = 4 * v15;
      break;
    default:
      return;
  }
  do
  {
    v252 = v9;
    do
    {
      if (*(_BYTE *)v22)
      {
        v253 = (float)*(unsigned __int8 *)v22 * 0.0039216;
        v254 = v7 * v253;
        if ((float)(v7 * v253) > 0.0)
        {
          v255 = v253 * v18;
          if (v4)
          {
            v256 = COERCE_FLOAT(bswap32(*v14));
            if (v256 <= 0.0)
              goto LABEL_400;
          }
          else
          {
            v256 = 1.0;
          }
          v257 = COERCE_FLOAT(bswap32(*v20));
          v258 = v257 - (float)(v254 * v257);
          if (v254 == 1.0)
            v258 = 0.0;
          v259 = (float)(v255 + v258) - (float)(v255 * v256);
          if (v256 != 1.0)
          {
            v255 = v255 * v256;
            v258 = v259;
          }
          v255 = v255 + v258;
          if (v4)
          {
            v254 = (float)(v254 + v256) - (float)(v254 * v256);
LABEL_400:
            *v20 = bswap32(LODWORD(v255));
            *v14 = bswap32(LODWORD(v254));
            goto LABEL_402;
          }
          *v20 = bswap32(LODWORD(v255));
        }
      }
LABEL_402:
      ++v22;
      ++v20;
      v14 = (unsigned int *)((char *)v14 + v251);
      --v252;
    }
    while (v252);
    v22 += v23;
    v20 += v24;
    v14 += v17;
    --v10;
  }
  while (v10);
}

void WF_mark_pixelmask(uint64_t a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unsigned int *v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  int v22;
  int v23;
  unsigned int *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  unsigned int *v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  unsigned int v35;
  float v36;
  unsigned int v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unsigned int *v42;
  uint64_t v43;
  int v44;
  unsigned int v45;
  float v46;
  unsigned int v47;
  unsigned int *v48;
  unsigned int *v49;
  uint64_t v50;
  unsigned int *v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unsigned int *v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  float v63;
  float v64;
  float v65;
  float v66;
  unsigned int v67;
  unsigned int *v68;
  unsigned int *v69;
  uint64_t v70;
  unsigned int *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unsigned int *v80;
  int v81;
  unsigned int v82;
  float v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  unsigned int *v92;
  unsigned int *v93;
  uint64_t v94;
  unsigned int *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int *v104;
  int v105;
  unsigned int v106;
  float v107;
  float v108;
  float v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  unsigned int *v116;
  unsigned int *v117;
  uint64_t v118;
  unsigned int *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  unsigned int *v128;
  int v129;
  float v130;
  float v131;
  float v132;
  float v133;
  unsigned int *v134;
  unsigned int *v135;
  uint64_t v136;
  unsigned int *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  unsigned int *v146;
  int v147;
  unsigned int v148;
  float v149;
  float v150;
  float v151;
  float v152;
  float v153;
  float v154;
  float v155;
  float v156;
  unsigned int *v157;
  unsigned int *v158;
  uint64_t v159;
  unsigned int *v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unsigned int *v168;
  int v169;
  unsigned int v170;
  float v171;
  float v172;
  float v173;
  float v174;
  float v175;
  float v176;
  float v177;
  float v178;
  float v179;
  unsigned int *v180;
  unsigned int *v181;
  uint64_t v182;
  unsigned int *v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  unsigned int *v191;
  int v192;
  unsigned int v193;
  float v194;
  float v195;
  float v196;
  unsigned int *v197;
  unsigned int *v198;
  uint64_t v199;
  unsigned int *v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  unsigned int *v209;
  int v210;
  float v211;
  float v212;
  float v213;
  float v214;
  float v215;
  unsigned int *v216;
  unsigned int *v217;
  uint64_t v218;
  unsigned int *v219;
  uint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  unsigned int *v228;
  int v229;
  float v230;
  float v231;
  float v232;
  float v233;
  unsigned int *v234;
  unsigned int *v235;
  uint64_t v236;
  unsigned int *v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  unsigned int *v245;
  int v246;
  float v247;
  float v248;
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  unsigned int *v254;
  unsigned int *v255;
  uint64_t v256;
  unsigned int *v257;
  uint64_t v258;
  uint64_t v259;
  uint64_t v260;
  uint64_t v261;
  uint64_t v262;
  uint64_t v263;
  uint64_t v264;
  unsigned int *v265;
  int v266;
  float v267;
  float v268;
  float v269;
  float v270;
  unsigned int *v271;
  unsigned int *v272;
  uint64_t v273;
  unsigned int *v274;
  uint64_t v275;
  uint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  uint64_t v281;
  uint64_t v282;
  unsigned int *v283;
  int v284;
  float v285;
  float v286;
  float v287;
  float v288;
  float v289;
  float v290;
  float v291;
  unsigned int *v292;
  unsigned int *v293;
  uint64_t v294;
  unsigned int *v295;
  uint64_t v296;
  uint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  uint64_t v302;
  uint64_t v303;
  unsigned int *v304;
  int v305;
  float v306;
  float v307;
  float v308;
  float v309;
  float v310;
  float v311;
  unsigned int *v312;
  unsigned int *v313;
  uint64_t v314;
  unsigned int *v315;
  uint64_t v316;
  uint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  unsigned int *v321;
  int v322;
  int v323;
  float v324;
  float v325;
  float v326;
  float v327;
  float v328;
  float v329;
  float v330;
  unsigned int *v331;
  uint64_t v332;
  unsigned int *v333;
  int v334;
  uint64_t v335;
  uint64_t v336;
  uint64_t v337;
  unint64_t v338;
  uint64_t v339;
  uint64_t v340;
  uint64_t v341;
  uint64_t v342;
  uint64_t v343;
  uint64_t v344;
  unsigned int *v345;
  int v346;
  float v347;
  float v348;
  float v349;
  float v350;
  float v351;
  float v352;
  float v353;
  float v354;
  unsigned int *v355;
  unsigned int *v356;
  uint64_t v357;
  unsigned int *v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  unsigned int *v367;
  int v368;
  float v369;
  float v370;
  float v371;
  float v372;
  float v373;
  float v374;
  float v375;
  float v376;
  unsigned int *v377;
  unsigned int *v378;
  uint64_t v379;
  unsigned int *v380;
  uint64_t v381;
  uint64_t v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  unsigned int *v386;
  int v387;
  int v388;
  float v389;
  float v390;
  float v391;
  float v392;
  float v393;
  float v394;
  float v395;
  unsigned int *v396;
  uint64_t v397;
  unsigned int *v398;
  int v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  unint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  unsigned int *v407;
  int v408;
  int v409;
  float v410;
  float v411;
  float v412;
  float v413;
  float v414;
  float v415;
  float v416;
  unsigned int *v417;
  uint64_t v418;
  unsigned int *v419;
  int v420;
  uint64_t v421;
  uint64_t v422;
  uint64_t v423;
  unint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  unsigned int *v428;
  int v429;
  int v430;
  float v431;
  float v432;
  float v433;
  float v434;
  float v435;
  float v436;
  float v437;
  unsigned int *v438;
  uint64_t v439;
  unsigned int *v440;
  int v441;
  uint64_t v442;
  uint64_t v443;
  uint64_t v444;
  unint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  unsigned int *v449;
  int v450;
  int v451;
  float v452;
  float v453;
  float v454;
  float v455;
  float v456;
  float v457;
  float v458;
  unsigned int *v459;
  uint64_t v460;
  unsigned int *v461;
  int v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  unint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  unsigned int *v473;
  int v474;
  float v475;
  float v476;
  float v477;
  float v478;
  float v479;
  float v480;
  float v481;
  float v482;
  float v483;
  float v484;
  unsigned int *v485;
  unsigned int *v486;
  uint64_t v487;
  unsigned int *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  unsigned int *v497;
  int v498;
  float v499;
  float v500;
  float v501;
  float v502;
  float v503;
  float v504;
  unsigned int *v505;
  unsigned int *v506;
  uint64_t v507;
  unsigned int *v508;
  uint64_t v509;
  uint64_t v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  unsigned int *v517;
  int v518;
  float v519;
  float v520;
  float v521;
  float v522;
  float v523;
  float v524;
  float v525;
  float v526;
  float v527;
  unsigned int *v528;
  unsigned int *v529;
  uint64_t v530;
  unsigned int *v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  unsigned int *v540;
  int v541;
  float v542;
  float v543;
  float v544;
  float v545;
  float v546;
  float v547;
  float v548;
  float v549;
  float v550;
  unsigned int *v551;
  unsigned int *v552;
  uint64_t v553;
  unsigned int *v554;
  uint64_t v555;
  uint64_t v556;
  uint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  unsigned int *v563;
  int v564;
  float v565;
  float v566;
  float v567;
  float v568;
  float v569;
  float v570;
  float v571;
  float v572;
  unsigned int *v573;
  unsigned int *v574;
  uint64_t v575;
  unsigned int *v576;
  uint64_t v577;
  uint64_t v578;
  uint64_t v579;
  uint64_t v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  unsigned int *v585;
  int v586;
  float v587;
  float v588;
  float v589;
  float v590;
  float v591;
  float v592;
  float v593;
  float v594;
  unsigned int *v595;
  unsigned int *v596;
  uint64_t v597;
  unsigned int *v598;
  uint64_t v599;
  uint64_t v600;
  int v601;
  unsigned int v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  int v607;
  unsigned int v608;
  unsigned int *v609;
  uint64_t v610;
  unsigned int *v611;
  unsigned int *v612;
  uint64_t v613;
  unsigned int *v614;
  uint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  unsigned int *v620;
  int v621;
  unsigned int v622;
  float v623;
  float v624;
  float v625;
  float v626;
  unsigned int *v627;
  unsigned int *v628;
  uint64_t v629;
  unsigned int *v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  unsigned int *v637;
  int v638;
  unsigned int v639;
  float v640;
  float v641;
  unsigned int *v642;
  unsigned int *v643;
  uint64_t v644;
  unsigned int *v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  unsigned int *v652;
  int v653;
  unsigned int v654;
  float v655;
  float v656;
  unsigned int *v657;
  unsigned int *v658;
  uint64_t v659;
  unsigned int *v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  unsigned int *v667;
  int v668;
  float v669;
  unsigned int *v670;
  unsigned int *v671;
  uint64_t v672;
  unsigned int *v673;
  uint64_t v674;
  uint64_t v675;
  uint64_t v676;
  uint64_t v677;
  int v678;
  unsigned int *v679;
  uint64_t v680;
  unsigned int *v681;
  unsigned int *v682;
  uint64_t v683;
  unsigned int *v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  int v688;
  unsigned int v689;
  unsigned int v690;
  unsigned int v691;
  float v692;
  unsigned int *v693;
  uint64_t v694;
  unsigned int *v695;
  unsigned int *v696;
  uint64_t v697;
  unsigned int *v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  unint64_t v710;
  uint64_t v711;
  uint64_t v712;
  int v713;
  unint64_t v714;
  uint64_t v715;
  uint64_t v716;
  uint64_t v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  uint64_t v724;
  uint64_t v725;
  uint64_t v726;
  uint64_t v727;
  uint64_t v728;
  uint64_t v729;
  int v730;
  int v731;
  int v732;
  int v733;
  int v734;
  unint64_t v735;
  unsigned int *v736;
  int v737;
  int v738;

  v2 = *(_QWORD *)(a1 + 48);
  v3 = *(_QWORD *)(a1 + 136);
  v5 = *(int *)(a1 + 12);
  v4 = *(int *)(a1 + 16);
  if (v2)
  {
    v6 = (unint64_t)*(int *)(a1 + 32) >> 2;
    v7 = (unsigned int *)(v2 + 4 * (v5 + v6 * v4));
    v8 = -1;
    if (!v3)
      return;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return;
  }
  v10 = *(_DWORD *)(a1 + 4);
  v9 = *(_DWORD *)(a1 + 8);
  v12 = *(_QWORD *)(a1 + 88);
  v11 = *(_QWORD *)(a1 + 96);
  v13 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v14 = (unsigned int *)(*(_QWORD *)(a1 + 40) + 4 * (v5 + v13 * v4));
  v15 = *(int *)(a1 + 124);
  v16 = (_BYTE *)(v3 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(a1 + 56);
  v18 = *(int *)(a1 + 60);
  v19 = *(int *)(a1 + 76);
  if ((*(_DWORD *)a1 & 0xFF00) == 0x100)
  {
    v20 = v19 >> 2;
    if (v11)
    {
      v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
      v11 += 4 * (v17 + v21 * v18);
      v738 = -1;
    }
    else
    {
      v21 = 0;
      v738 = 0;
    }
    v24 = (unsigned int *)(v12 + 4 * (v17 + v20 * v18));
    if (v20 == v13 && (char *)v14 - (char *)v24 >= 1)
    {
      if (v10 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v24) >> 2))
      {
        v14 += v10 - 1;
        v24 += v10 - 1;
        v16 += v10 - 1;
        v7 += v8 & (v10 - 1);
        v26 = -1;
        v20 = (unint64_t)*(int *)(a1 + 28) >> 2;
        v11 += 4 * (v738 & (v10 - 1));
        goto LABEL_16;
      }
      v25 = v9 - 1;
      if (v14 <= &v24[v13 * v25 - 1 + v10])
      {
        v14 += v13 * v25;
        v20 = -(uint64_t)v13;
        v16 += v15 * v25;
        v15 = -v15;
        v7 += v6 * v25;
        v6 = -(uint64_t)v6;
        v8 &= 1u;
        v11 += 4 * v21 * v25;
        v21 = -(uint64_t)v21;
        v738 &= 1u;
        v26 = 1;
        v24 += v13 * v25;
        v13 = -(uint64_t)v13;
        goto LABEL_16;
      }
    }
    v8 &= 1u;
    v738 &= 1u;
    v26 = 1;
LABEL_16:
    v27 = 0;
    v736 = 0;
    v12 = -1;
    v23 = v21;
    v22 = v20;
    goto LABEL_19;
  }
  v22 = *(_DWORD *)(a1 + 64);
  v23 = *(_DWORD *)(a1 + 68);
  v20 = v19 >> 2;
  if (v11)
  {
    v21 = (unint64_t)*(int *)(a1 + 80) >> 2;
    v738 = 1;
  }
  else
  {
    v21 = 0;
    v738 = 0;
  }
  v27 = v12 + 4 * v20 * v23;
  v8 &= 1u;
  v26 = 1;
  v736 = *(unsigned int **)(a1 + 88);
  v24 = v736;
LABEL_19:
  v737 = v8;
  v28 = v26 * v10;
  if (v27)
  {
    v29 = (int)v18 % v23;
    v30 = &v24[v20 * v29];
    v31 = (int)v17 % v22;
    v24 = &v30[v31];
    v12 = (unint64_t)&v30[v22];
    if ((v738 & 1) != 0)
      v11 += 4 * v21 * v29 + 4 * v31;
    v736 = &v30[v31];
  }
  else
  {
    v20 -= v28;
    v21 -= v738 * v10;
  }
  v32 = v15 - v28;
  v33 = v13 - v28;
  v735 = v6 - v737 * v10;
  v712 = v20;
  v713 = v10;
  v710 = v33;
  v711 = v32;
  v714 = v27;
  switch(a2)
  {
    case 0:
      if (v737)
      {
        do
        {
          v34 = v10;
          do
          {
            v35 = *v16;
            if (*v16)
            {
              if (v35 == 255)
              {
                *v7 = 0;
                *v14 = 0;
              }
              else
              {
                v36 = (float)((float)v35 * -0.0039216) + 1.0;
                v37 = bswap32(COERCE_UNSIGNED_INT(v36 * COERCE_FLOAT(bswap32(*v7))));
                *v14 = bswap32(COERCE_UNSIGNED_INT(v36 * COERCE_FLOAT(bswap32(*v14))));
                *v7 = v37;
              }
            }
            v16 += v26;
            v7 += v737;
            v14 += v26;
            --v34;
          }
          while (v34);
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        do
        {
          v601 = v10;
          do
          {
            v602 = *v16;
            if (*v16)
            {
              if (v602 == 255)
                *v14 = 0;
              else
                *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v602 * -0.0039216) + 1.0) * COERCE_FLOAT(bswap32(*v14))));
            }
            v16 += v26;
            v14 += v26;
            --v601;
          }
          while (v601);
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 1:
      if (v737)
      {
        v38 = v26;
        if (v738)
        {
          v39 = v23;
          v40 = -(v20 * v23);
          v41 = -(uint64_t)(v21 * v39);
          v42 = (unsigned int *)v11;
          v43 = -(uint64_t)v22;
          do
          {
            v44 = v10;
            do
            {
              v45 = *v16;
              if (*v16)
              {
                if (v45 == 255)
                {
                  *v14 = *v24;
                  *v7 = *v42;
                }
                else
                {
                  v46 = (float)v45 * 0.0039216;
                  v47 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v46) * COERCE_FLOAT(bswap32(*v7)))+ (float)(COERCE_FLOAT(bswap32(*v42)) * v46)));
                  *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v46) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * v46)));
                  *v7 = v47;
                }
              }
              v16 += v38;
              v48 = &v24[v38];
              v49 = &v42[v738];
              if ((unint64_t)v48 >= v12)
                v50 = v43;
              else
                v50 = 0;
              v42 = &v49[v50];
              v24 = &v48[v50];
              v7 += v737;
              v14 += v38;
              --v44;
            }
            while (v44);
            if (v27)
            {
              v51 = &v736[v20];
              if ((unint64_t)v51 >= v27)
                v52 = v41;
              else
                v52 = 0;
              v11 += 4 * v21 + 4 * v52;
              if ((unint64_t)v51 >= v27)
                v53 = v40;
              else
                v53 = 0;
              v24 = &v51[v53];
              v12 += 4 * v53 + 4 * v20;
              v42 = (unsigned int *)v11;
              v736 = v24;
            }
            else
            {
              v24 += v20;
              v42 += v21;
            }
            v16 += v32;
            v14 += v33;
            v7 += v735;
            --v9;
          }
          while (v9);
        }
        else
        {
          v686 = -(uint64_t)v22;
          v687 = -(v20 * v23);
          do
          {
            v688 = v10;
            do
            {
              v689 = *v16;
              if (*v16)
              {
                if (v689 == 255)
                {
                  v690 = *v24;
                  v691 = 32831;
                }
                else
                {
                  v692 = (float)v689 * 0.0039216;
                  v690 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v692) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * v692)));
                  v691 = bswap32(COERCE_UNSIGNED_INT(v692 + (float)((float)(1.0 - v692) * COERCE_FLOAT(bswap32(*v7)))));
                }
                *v14 = v690;
                *v7 = v691;
              }
              v16 += v38;
              v693 = &v24[v38];
              if ((unint64_t)v693 >= v12)
                v694 = v686;
              else
                v694 = 0;
              v24 = &v693[v694];
              v7 += v737;
              v14 += v38;
              --v688;
            }
            while (v688);
            v16 += v32;
            v14 += v33;
            v695 = v736;
            v7 += v735;
            v696 = &v736[v20];
            if ((unint64_t)v696 >= v27)
              v697 = v687;
            else
              v697 = 0;
            v698 = &v696[v697];
            v699 = v12 + 4 * v697 + 4 * v20;
            if (v27)
            {
              v12 = v699;
              v695 = v698;
            }
            v736 = v695;
            if (v27)
              v24 = v698;
            else
              v24 += v20;
            --v9;
          }
          while (v9);
        }
      }
      else
      {
        v603 = v26;
        v604 = -(uint64_t)v22;
        v605 = -(v20 * v23);
        v606 = 4 * v26;
        do
        {
          v607 = v10;
          do
          {
            v608 = *v16;
            if (*v16)
            {
              if (v608 == 255)
                *v14 = *v24;
              else
                *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - (float)((float)v608 * 0.0039216)) * COERCE_FLOAT(bswap32(*v14)))+ (float)(COERCE_FLOAT(bswap32(*v24)) * (float)((float)v608 * 0.0039216))));
            }
            v16 += v603;
            v609 = &v24[v603];
            if ((unint64_t)v609 >= v12)
              v610 = v604;
            else
              v610 = 0;
            v24 = &v609[v610];
            v14 = (unsigned int *)((char *)v14 + v606);
            --v607;
          }
          while (v607);
          v16 += v32;
          v14 += v33;
          v611 = v736;
          v612 = &v736[v20];
          if ((unint64_t)v612 >= v27)
            v613 = v605;
          else
            v613 = 0;
          v614 = &v612[v613];
          v615 = v12 + 4 * v613 + 4 * v20;
          if (v27)
          {
            v12 = v615;
            v611 = v614;
          }
          v736 = v611;
          if (v27)
            v24 = v614;
          else
            v24 += v20;
          --v9;
        }
        while (v9);
      }
      return;
    case 2:
      v54 = v26;
      if (v737)
      {
        v55 = -(uint64_t)v22;
        v56 = v23;
        v57 = -(v20 * v23);
        v58 = -(uint64_t)(v21 * v56);
        v59 = (unsigned int *)v11;
        while (1)
        {
          v60 = v10;
          do
          {
            v61 = *v16;
            if (!*v16)
              goto LABEL_72;
            if (v61 == 255)
            {
              v62 = *v59;
              v63 = COERCE_FLOAT(bswap32(*v59));
              v64 = v63;
              if (v63 >= 1.0)
              {
                v67 = *v24;
                goto LABEL_71;
              }
              if (v63 <= 0.0)
                goto LABEL_72;
              v65 = COERCE_FLOAT(bswap32(*v24));
            }
            else
            {
              v66 = (float)v61 * 0.0039216;
              v64 = v66 * COERCE_FLOAT(bswap32(*v59));
              if (v64 <= 0.0)
                goto LABEL_72;
              v65 = v66 * COERCE_FLOAT(bswap32(*v24));
            }
            v67 = bswap32(COERCE_UNSIGNED_INT(v65 + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v64))));
            v62 = bswap32(COERCE_UNSIGNED_INT(v64 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v64))));
LABEL_71:
            *v14 = v67;
            *v7 = v62;
LABEL_72:
            v16 += v54;
            v68 = &v24[v54];
            v69 = &v59[v738];
            if ((unint64_t)v68 >= v12)
              v70 = v55;
            else
              v70 = 0;
            v59 = &v69[v70];
            v24 = &v68[v70];
            v7 += v737;
            v14 += v54;
            --v60;
          }
          while (v60);
          if (v27)
          {
            v71 = &v736[v20];
            if ((unint64_t)v71 >= v27)
              v72 = v58;
            else
              v72 = 0;
            v11 += 4 * v21 + 4 * v72;
            if ((unint64_t)v71 >= v27)
              v73 = v57;
            else
              v73 = 0;
            v24 = &v71[v73];
            v12 += 4 * v73 + 4 * v20;
            v59 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v59 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          if (!--v9)
            return;
        }
      }
      v616 = -(uint64_t)v22;
      v617 = v23;
      v618 = -(v20 * v23);
      v619 = -(uint64_t)(v21 * v617);
      v620 = (unsigned int *)v11;
LABEL_830:
      v621 = v10;
      while (1)
      {
        v622 = *v16;
        if (*v16)
        {
          if (v622 == 255)
          {
            v623 = COERCE_FLOAT(bswap32(*v620));
            if (v623 >= 1.0)
            {
              *v14 = *v24;
              goto LABEL_840;
            }
            if (v623 > 0.0)
            {
              v624 = COERCE_FLOAT(bswap32(*v24)) + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v623));
LABEL_838:
              *v14 = bswap32(LODWORD(v624));
            }
          }
          else
          {
            v625 = (float)v622 * 0.0039216;
            v626 = v625 * COERCE_FLOAT(bswap32(*v620));
            if (v626 > 0.0)
            {
              v624 = (float)(v625 * COERCE_FLOAT(bswap32(*v24)))
                   + (float)(COERCE_FLOAT(bswap32(*v14)) * (float)(1.0 - v626));
              goto LABEL_838;
            }
          }
        }
LABEL_840:
        v16 += v54;
        v627 = &v24[v54];
        v628 = &v620[v738];
        if ((unint64_t)v627 >= v12)
          v629 = v616;
        else
          v629 = 0;
        v620 = &v628[v629];
        v24 = &v627[v629];
        v14 += v54;
        if (!--v621)
        {
          if (v27)
          {
            v630 = &v736[v20];
            if ((unint64_t)v630 >= v27)
              v631 = v619;
            else
              v631 = 0;
            v11 += 4 * v21 + 4 * v631;
            if ((unint64_t)v630 >= v27)
              v632 = v618;
            else
              v632 = 0;
            v24 = &v630[v632];
            v12 += 4 * v632 + 4 * v20;
            v620 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v620 += v21;
          }
          v16 += v32;
          v14 += v33;
          if (!--v9)
            return;
          goto LABEL_830;
        }
      }
    case 3:
      v74 = v26;
      v75 = v23;
      v76 = -(v20 * v23);
      v77 = -(uint64_t)(v21 * v75);
      v78 = 4 * v26;
      v79 = -(uint64_t)v22;
      v80 = (unsigned int *)v11;
      do
      {
        v81 = v10;
        do
        {
          v82 = *v16;
          if (*v16)
          {
            if (v82 == 255)
            {
              if (v738)
                v83 = COERCE_FLOAT(bswap32(*v80));
              else
                v83 = 1.0;
              v85 = COERCE_FLOAT(bswap32(*v7));
              v86 = COERCE_FLOAT(bswap32(*v24)) * v85;
              v87 = v83 * v85;
            }
            else
            {
              if (v738)
                v84 = COERCE_FLOAT(bswap32(*v80));
              else
                v84 = 1.0;
              v88 = (float)v82 * 0.0039216;
              v89 = COERCE_FLOAT(bswap32(*v7));
              v90 = v88 * v89;
              v91 = 1.0 - v88;
              v86 = (float)((float)(1.0 - v88) * COERCE_FLOAT(bswap32(*v14)))
                  + (float)(COERCE_FLOAT(bswap32(*v24)) * (float)(v88 * v89));
              v87 = (float)(v91 * v89) + (float)(v84 * v90);
            }
            *v14 = bswap32(LODWORD(v86));
            *v7 = bswap32(LODWORD(v87));
          }
          v16 += v74;
          v92 = &v24[v74];
          v93 = &v80[v738];
          if ((unint64_t)v92 >= v12)
            v94 = v79;
          else
            v94 = 0;
          v80 = &v93[v94];
          v24 = &v92[v94];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v78);
          --v81;
        }
        while (v81);
        if (v27)
        {
          v95 = &v736[v20];
          if ((unint64_t)v95 >= v27)
            v96 = v77;
          else
            v96 = 0;
          v11 += 4 * v21 + 4 * v96;
          if ((unint64_t)v95 >= v27)
            v97 = v76;
          else
            v97 = 0;
          v24 = &v95[v97];
          v12 += 4 * v97 + 4 * v20;
          v80 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v80 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 4:
      v98 = v26;
      v99 = v23;
      v100 = -(v20 * v23);
      v101 = -(uint64_t)(v21 * v99);
      v102 = 4 * v26;
      v103 = -(uint64_t)v22;
      v104 = (unsigned int *)v11;
      do
      {
        v105 = v10;
        do
        {
          v106 = *v16;
          if (*v16)
          {
            if (v106 == 255)
            {
              if (v738)
                v107 = COERCE_FLOAT(bswap32(*v104));
              else
                v107 = 1.0;
              v109 = 1.0 - COERCE_FLOAT(bswap32(*v7));
              v110 = v109 * COERCE_FLOAT(bswap32(*v24));
              v111 = v107 * v109;
            }
            else
            {
              if (v738)
                v108 = COERCE_FLOAT(bswap32(*v104));
              else
                v108 = 1.0;
              v112 = (float)v106 * 0.0039216;
              v113 = COERCE_FLOAT(bswap32(*v7));
              v114 = v112 * (float)(1.0 - v113);
              v115 = 1.0 - v112;
              v110 = (float)((float)(1.0 - v112) * COERCE_FLOAT(bswap32(*v14)))
                   + (float)(COERCE_FLOAT(bswap32(*v24)) * v114);
              v111 = (float)(v115 * v113) + (float)(v108 * v114);
            }
            *v14 = bswap32(LODWORD(v110));
            *v7 = bswap32(LODWORD(v111));
          }
          v16 += v98;
          v116 = &v24[v98];
          v117 = &v104[v738];
          if ((unint64_t)v116 >= v12)
            v118 = v103;
          else
            v118 = 0;
          v104 = &v117[v118];
          v24 = &v116[v118];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v102);
          --v105;
        }
        while (v105);
        if (v27)
        {
          v119 = &v736[v20];
          if ((unint64_t)v119 >= v27)
            v120 = v101;
          else
            v120 = 0;
          v11 += 4 * v21 + 4 * v120;
          if ((unint64_t)v119 >= v27)
            v121 = v100;
          else
            v121 = 0;
          v24 = &v119[v121];
          v12 += 4 * v121 + 4 * v20;
          v104 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v104 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 5:
      v122 = v26;
      v123 = v23;
      v124 = -(v20 * v23);
      v125 = -(uint64_t)(v21 * v123);
      v126 = 4 * v26;
      v127 = -(uint64_t)v22;
      v128 = (unsigned int *)v11;
      do
      {
        v129 = v10;
        do
        {
          if (*v16)
          {
            v130 = COERCE_FLOAT(bswap32(*v7));
            v131 = (float)*v16 * 0.0039216;
            v132 = v131 * COERCE_FLOAT(bswap32(*v24));
            v133 = v131 * COERCE_FLOAT(bswap32(*v128));
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v133) * COERCE_FLOAT(bswap32(*v14))) + (float)(v132 * v130)));
            *v7 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v133) * v130) + (float)(v133 * v130)));
          }
          v16 += v122;
          v134 = &v24[v122];
          v135 = &v128[v738];
          if ((unint64_t)v134 >= v12)
            v136 = v127;
          else
            v136 = 0;
          v128 = &v135[v136];
          v24 = &v134[v136];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v126);
          --v129;
        }
        while (v129);
        if (v27)
        {
          v137 = &v736[v20];
          if ((unint64_t)v137 >= v27)
            v138 = v125;
          else
            v138 = 0;
          v11 += 4 * v21 + 4 * v138;
          if ((unint64_t)v137 >= v27)
            v139 = v124;
          else
            v139 = 0;
          v24 = &v137[v139];
          v12 += 4 * v139 + 4 * v20;
          v128 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v128 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 6:
      v140 = v26;
      v141 = v23;
      v142 = -(v20 * v23);
      v143 = -(uint64_t)(v21 * v141);
      v144 = 4 * v26;
      v145 = -(uint64_t)v22;
      v146 = (unsigned int *)v11;
      while (1)
      {
        v147 = v10;
        do
        {
          v148 = *v16;
          if (!*v16)
            goto LABEL_176;
          v149 = COERCE_FLOAT(bswap32(*v7));
          v150 = 1.0 - v149;
          if ((float)(1.0 - v149) >= 1.0)
          {
            if (v738)
              v152 = COERCE_FLOAT(bswap32(*v146));
            else
              v152 = 1.0;
            v153 = (float)v148 * 0.0039216;
            v154 = v153 * COERCE_FLOAT(bswap32(*v24));
            v155 = v153 * v152;
          }
          else
          {
            if (v150 <= 0.0)
              goto LABEL_176;
            if (v738)
              v151 = COERCE_FLOAT(bswap32(*v146));
            else
              v151 = 1.0;
            v156 = (float)((float)v148 * 0.0039216) * v150;
            v154 = COERCE_FLOAT(bswap32(*v14)) + (float)(COERCE_FLOAT(bswap32(*v24)) * v156);
            v155 = v149 + (float)(v151 * v156);
          }
          *v14 = bswap32(LODWORD(v154));
          *v7 = bswap32(LODWORD(v155));
LABEL_176:
          v16 += v140;
          v157 = &v24[v140];
          v158 = &v146[v738];
          if ((unint64_t)v157 >= v12)
            v159 = v145;
          else
            v159 = 0;
          v146 = &v158[v159];
          v24 = &v157[v159];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v144);
          --v147;
        }
        while (v147);
        if (v27)
        {
          v160 = &v736[v20];
          if ((unint64_t)v160 >= v27)
            v161 = v143;
          else
            v161 = 0;
          v11 += 4 * v21 + 4 * v161;
          if ((unint64_t)v160 >= v27)
            v162 = v142;
          else
            v162 = 0;
          v24 = &v160[v162];
          v12 += 4 * v162 + 4 * v20;
          v146 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v146 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 7:
      v163 = v26;
      if (v737)
      {
        v164 = v23;
        v165 = -(v20 * v23);
        v166 = -(uint64_t)(v21 * v164);
        v167 = -(uint64_t)v22;
        v168 = (unsigned int *)v11;
        do
        {
          v169 = v10;
          do
          {
            v170 = *v16;
            if (*v16)
            {
              if (v170 == 255)
              {
                v171 = COERCE_FLOAT(bswap32(*v168));
                v172 = COERCE_FLOAT(bswap32(*v14)) * v171;
                v173 = COERCE_FLOAT(bswap32(*v7)) * v171;
              }
              else
              {
                v174 = (float)v170 * 0.0039216;
                v175 = COERCE_FLOAT(bswap32(*v7));
                v176 = COERCE_FLOAT(bswap32(*v14));
                v177 = COERCE_FLOAT(bswap32(*v168));
                v178 = v174 * v177;
                v179 = 1.0 - v174;
                v172 = (float)((float)(1.0 - v174) * v176) + (float)(v176 * (float)(v174 * v177));
                v173 = (float)(v179 * v175) + (float)(v175 * v178);
              }
              *v14 = bswap32(LODWORD(v172));
              *v7 = bswap32(LODWORD(v173));
            }
            v16 += v163;
            v180 = &v24[v163];
            v181 = &v168[v738];
            if ((unint64_t)v180 >= v12)
              v182 = v167;
            else
              v182 = 0;
            v168 = &v181[v182];
            v24 = &v180[v182];
            v7 += v737;
            v14 += v163;
            --v169;
          }
          while (v169);
          if (v27)
          {
            v183 = &v736[v20];
            if ((unint64_t)v183 >= v27)
              v184 = v166;
            else
              v184 = 0;
            v11 += 4 * v21 + 4 * v184;
            if ((unint64_t)v183 >= v27)
              v185 = v165;
            else
              v185 = 0;
            v24 = &v183[v185];
            v12 += 4 * v185 + 4 * v20;
            v168 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v168 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        v633 = -(uint64_t)v22;
        v634 = v23;
        v635 = -(v20 * v23);
        v636 = -(uint64_t)(v21 * v634);
        v637 = (unsigned int *)v11;
        do
        {
          v638 = v10;
          do
          {
            v639 = *v16;
            if (*v16)
            {
              if (v639 == 255)
              {
                v640 = COERCE_FLOAT(bswap32(*v14)) * COERCE_FLOAT(bswap32(*v637));
              }
              else
              {
                v641 = COERCE_FLOAT(bswap32(*v14));
                v640 = (float)((float)(1.0 - (float)((float)v639 * 0.0039216)) * v641)
                     + (float)(v641 * (float)((float)((float)v639 * 0.0039216) * COERCE_FLOAT(bswap32(*v637))));
              }
              *v14 = bswap32(LODWORD(v640));
            }
            v16 += v163;
            v642 = &v24[v163];
            v643 = &v637[v738];
            if ((unint64_t)v642 >= v12)
              v644 = v633;
            else
              v644 = 0;
            v637 = &v643[v644];
            v24 = &v642[v644];
            v14 += v163;
            --v638;
          }
          while (v638);
          if (v27)
          {
            v645 = &v736[v20];
            if ((unint64_t)v645 >= v27)
              v646 = v636;
            else
              v646 = 0;
            v11 += 4 * v21 + 4 * v646;
            if ((unint64_t)v645 >= v27)
              v647 = v635;
            else
              v647 = 0;
            v24 = &v645[v647];
            v12 += 4 * v647 + 4 * v20;
            v637 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v637 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 8:
      v186 = v26;
      if (v737)
      {
        v187 = -(uint64_t)v22;
        v188 = v23;
        v189 = -(v20 * v23);
        v190 = -(uint64_t)(v21 * v188);
        v191 = (unsigned int *)v11;
        do
        {
          v192 = v10;
          do
          {
            v193 = *v16;
            if (*v16)
            {
              v194 = COERCE_FLOAT(bswap32(*v14));
              v195 = COERCE_FLOAT(bswap32(*v7));
              if (v193 == 255)
                v196 = 1.0 - COERCE_FLOAT(bswap32(*v191));
              else
                v196 = (float)((float)((float)v193 * -0.0039216) * COERCE_FLOAT(bswap32(*v191))) + 1.0;
              *v14 = bswap32(COERCE_UNSIGNED_INT(v196 * v194));
              *v7 = bswap32(COERCE_UNSIGNED_INT(v196 * v195));
            }
            v16 += v186;
            v197 = &v24[v186];
            v198 = &v191[v738];
            if ((unint64_t)v197 >= v12)
              v199 = v187;
            else
              v199 = 0;
            v191 = &v198[v199];
            v24 = &v197[v199];
            v7 += v737;
            v14 += v186;
            --v192;
          }
          while (v192);
          if (v27)
          {
            v200 = &v736[v20];
            if ((unint64_t)v200 >= v27)
              v201 = v190;
            else
              v201 = 0;
            v11 += 4 * v21 + 4 * v201;
            if ((unint64_t)v200 >= v27)
              v202 = v189;
            else
              v202 = 0;
            v24 = &v200[v202];
            v12 += 4 * v202 + 4 * v20;
            v191 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v191 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        v648 = -(uint64_t)v22;
        v649 = v23;
        v650 = -(v20 * v23);
        v651 = -(uint64_t)(v21 * v649);
        v652 = (unsigned int *)v11;
        do
        {
          v653 = v10;
          do
          {
            v654 = *v16;
            if (*v16)
            {
              v655 = COERCE_FLOAT(bswap32(*v14));
              if (v654 == 255)
                v656 = COERCE_FLOAT(bswap32(*v652));
              else
                v656 = (float)((float)v654 * 0.0039216) * COERCE_FLOAT(bswap32(*v652));
              *v14 = bswap32(COERCE_UNSIGNED_INT((float)(1.0 - v656) * v655));
            }
            v16 += v186;
            v657 = &v24[v186];
            v658 = &v652[v738];
            if ((unint64_t)v657 >= v12)
              v659 = v648;
            else
              v659 = 0;
            v652 = &v658[v659];
            v24 = &v657[v659];
            v14 += v186;
            --v653;
          }
          while (v653);
          if (v27)
          {
            v660 = &v736[v20];
            if ((unint64_t)v660 >= v27)
              v661 = v651;
            else
              v661 = 0;
            v11 += 4 * v21 + 4 * v661;
            if ((unint64_t)v660 >= v27)
              v662 = v650;
            else
              v662 = 0;
            v24 = &v660[v662];
            v12 += 4 * v662 + 4 * v20;
            v652 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v652 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 9:
      v203 = v26;
      v204 = v23;
      v205 = -(v20 * v23);
      v206 = -(uint64_t)(v21 * v204);
      v207 = 4 * v26;
      v208 = -(uint64_t)v22;
      v209 = (unsigned int *)v11;
      do
      {
        v210 = v10;
        do
        {
          if (*v16)
          {
            v211 = COERCE_FLOAT(bswap32(*v7));
            v212 = (float)*v16 * 0.0039216;
            v213 = v212 * COERCE_FLOAT(bswap32(*v24));
            v214 = v212 * COERCE_FLOAT(bswap32(*v209));
            v215 = (float)(1.0 - v212) + v214;
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)(v215 * COERCE_FLOAT(bswap32(*v14))) + (float)(v213 * (float)(1.0 - v211))));
            *v7 = bswap32(COERCE_UNSIGNED_INT((float)(v215 * v211) + (float)(v214 * (float)(1.0 - v211))));
          }
          v16 += v203;
          v216 = &v24[v203];
          v217 = &v209[v738];
          if ((unint64_t)v216 >= v12)
            v218 = v208;
          else
            v218 = 0;
          v209 = &v217[v218];
          v24 = &v216[v218];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v207);
          --v210;
        }
        while (v210);
        if (v27)
        {
          v219 = &v736[v20];
          if ((unint64_t)v219 >= v27)
            v220 = v206;
          else
            v220 = 0;
          v11 += 4 * v21 + 4 * v220;
          if ((unint64_t)v219 >= v27)
            v221 = v205;
          else
            v221 = 0;
          v24 = &v219[v221];
          v12 += 4 * v221 + 4 * v20;
          v209 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v209 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 10:
      v222 = v26;
      v223 = v23;
      v224 = -(v20 * v23);
      v225 = -(uint64_t)(v21 * v223);
      v226 = 4 * v26;
      v227 = -(uint64_t)v22;
      v228 = (unsigned int *)v11;
      do
      {
        v229 = v10;
        do
        {
          if (*v16)
          {
            v230 = COERCE_FLOAT(bswap32(*v7));
            v231 = (float)*v16 * 0.0039216;
            v232 = v231 * COERCE_FLOAT(bswap32(*v24));
            v233 = v231 * COERCE_FLOAT(bswap32(*v228));
            *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v233) * COERCE_FLOAT(bswap32(*v14))) + (float)(v232 * (float)(1.0 - v230))));
            *v7 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v233) * v230) + (float)(v233 * (float)(1.0 - v230))));
          }
          v16 += v222;
          v234 = &v24[v222];
          v235 = &v228[v738];
          if ((unint64_t)v234 >= v12)
            v236 = v227;
          else
            v236 = 0;
          v228 = &v235[v236];
          v24 = &v234[v236];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v226);
          --v229;
        }
        while (v229);
        if (v27)
        {
          v237 = &v736[v20];
          if ((unint64_t)v237 >= v27)
            v238 = v225;
          else
            v238 = 0;
          v11 += 4 * v21 + 4 * v238;
          if ((unint64_t)v237 >= v27)
            v239 = v224;
          else
            v239 = 0;
          v24 = &v237[v239];
          v12 += 4 * v239 + 4 * v20;
          v228 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v228 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        --v9;
      }
      while (v9);
      return;
    case 11:
      v240 = v26;
      if (v737)
      {
        v241 = v23;
        v242 = -(v20 * v23);
        v243 = -(uint64_t)(v21 * v241);
        v244 = -(uint64_t)v22;
        v245 = (unsigned int *)v11;
        do
        {
          v246 = v10;
          do
          {
            if (*v16)
            {
              if (v738)
                v247 = COERCE_FLOAT(bswap32(*v245));
              else
                v247 = 1.0;
              v248 = (float)*v16 * 0.0039216;
              v249 = v248 * COERCE_FLOAT(bswap32(*v24));
              v250 = v248 * v247;
              v251 = COERCE_FLOAT(bswap32(*v14));
              v252 = COERCE_FLOAT(bswap32(*v7));
              v253 = v250 + v252;
              if ((float)(v250 + v252) > 1.0)
                v253 = 1.0;
              *v14 = bswap32(COERCE_UNSIGNED_INT((float)(v250 - v249) + (float)(v253 - (float)(v252 - v251))));
              *v7 = bswap32(LODWORD(v253));
            }
            v16 += v240;
            v254 = &v24[v240];
            v255 = &v245[v738];
            if ((unint64_t)v254 >= v12)
              v256 = v244;
            else
              v256 = 0;
            v245 = &v255[v256];
            v24 = &v254[v256];
            v7 += v737;
            v14 += v240;
            --v246;
          }
          while (v246);
          if (v27)
          {
            v257 = &v736[v20];
            if ((unint64_t)v257 >= v27)
              v258 = v243;
            else
              v258 = 0;
            v11 += 4 * v21 + 4 * v258;
            if ((unint64_t)v257 >= v27)
              v259 = v242;
            else
              v259 = 0;
            v24 = &v257[v259];
            v12 += 4 * v259 + 4 * v20;
            v245 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v245 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        v663 = -(uint64_t)v22;
        v664 = v23;
        v665 = -(v20 * v23);
        v666 = -(uint64_t)(v21 * v664);
        v667 = (unsigned int *)v11;
        do
        {
          v668 = v10;
          do
          {
            if (*v16)
            {
              if (v738)
                v669 = COERCE_FLOAT(bswap32(*v667));
              else
                v669 = 1.0;
              *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)((float)*v16 * 0.0039216) * v669)- (float)((float)((float)*v16 * 0.0039216) * COERCE_FLOAT(bswap32(*v24))))+ COERCE_FLOAT(bswap32(*v14))));
            }
            v16 += v240;
            v670 = &v24[v240];
            v671 = &v667[v738];
            if ((unint64_t)v670 >= v12)
              v672 = v663;
            else
              v672 = 0;
            v667 = &v671[v672];
            v24 = &v670[v672];
            v14 += v240;
            --v668;
          }
          while (v668);
          if (v27)
          {
            v673 = &v736[v20];
            if ((unint64_t)v673 >= v27)
              v674 = v666;
            else
              v674 = 0;
            v11 += 4 * v21 + 4 * v674;
            if ((unint64_t)v673 >= v27)
              v675 = v665;
            else
              v675 = 0;
            v24 = &v673[v675];
            v12 += 4 * v675 + 4 * v20;
            v667 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v667 += v21;
          }
          v16 += v32;
          v14 += v33;
          --v9;
        }
        while (v9);
      }
      return;
    case 12:
      v260 = v26;
      if (v737)
      {
        v261 = v23;
        v262 = -(v20 * v23);
        v263 = -(uint64_t)(v21 * v261);
        v264 = -(uint64_t)v22;
        v265 = (unsigned int *)v11;
        do
        {
          v266 = v10;
          do
          {
            if (*v16)
            {
              if (v738)
                v267 = COERCE_FLOAT(bswap32(*v265));
              else
                v267 = 1.0;
              v268 = (float)*v16 * 0.0039216;
              v269 = (float)(v268 * v267) + COERCE_FLOAT(bswap32(*v7));
              v270 = (float)(v268 * COERCE_FLOAT(bswap32(*v24))) + COERCE_FLOAT(bswap32(*v14));
              if (v269 > 1.0)
                v269 = 1.0;
              *v14 = bswap32(LODWORD(v270));
              *v7 = bswap32(LODWORD(v269));
            }
            v16 += v260;
            v271 = &v24[v260];
            v272 = &v265[v738];
            if ((unint64_t)v271 >= v12)
              v273 = v264;
            else
              v273 = 0;
            v265 = &v272[v273];
            v24 = &v271[v273];
            v7 += v737;
            v14 += v260;
            --v266;
          }
          while (v266);
          if (v27)
          {
            v274 = &v736[v20];
            if ((unint64_t)v274 >= v27)
              v275 = v263;
            else
              v275 = 0;
            v11 += 4 * v21 + 4 * v275;
            if ((unint64_t)v274 >= v27)
              v276 = v262;
            else
              v276 = 0;
            v24 = &v274[v276];
            v12 += 4 * v276 + 4 * v20;
            v265 = (unsigned int *)v11;
            v736 = v24;
          }
          else
          {
            v24 += v20;
            v265 += v21;
          }
          v16 += v32;
          v14 += v33;
          v7 += v735;
          --v9;
        }
        while (v9);
      }
      else
      {
        v676 = -(uint64_t)v22;
        v677 = -(v20 * v23);
        do
        {
          v678 = v10;
          do
          {
            if (*v16)
              *v14 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)*v16 * 0.0039216) * COERCE_FLOAT(bswap32(*v24)))+ COERCE_FLOAT(bswap32(*v14))));
            v16 += v260;
            v679 = &v24[v260];
            if ((unint64_t)v679 >= v12)
              v680 = v676;
            else
              v680 = 0;
            v24 = &v679[v680];
            v14 += v260;
            --v678;
          }
          while (v678);
          v16 += v32;
          v14 += v33;
          v681 = v736;
          v682 = &v736[v20];
          if ((unint64_t)v682 >= v27)
            v683 = v677;
          else
            v683 = 0;
          v684 = &v682[v683];
          v685 = v12 + 4 * v683 + 4 * v20;
          if (v27)
          {
            v12 = v685;
            v681 = v684;
          }
          v736 = v681;
          if (v27)
            v24 = v684;
          else
            v24 += v20;
          --v9;
        }
        while (v9);
      }
      return;
    case 13:
      v277 = v26;
      v278 = v23;
      v279 = -(v20 * v23);
      v280 = -(uint64_t)(v21 * v278);
      v281 = 4 * v26;
      v282 = -(uint64_t)v22;
      v283 = (unsigned int *)v11;
      while (1)
      {
        v284 = v10;
        do
        {
          if (*v16)
          {
            v285 = v738 ? COERCE_FLOAT(bswap32(*v283)) : 1.0;
            v286 = (float)*v16 * 0.0039216;
            v287 = v286 * v285;
            if (v287 > 0.0)
            {
              v288 = v286 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v289 = COERCE_FLOAT(bswap32(*v7));
                if (v289 <= 0.0)
                  goto LABEL_342;
              }
              else
              {
                v289 = 1.0;
              }
              v290 = COERCE_FLOAT(bswap32(*v14));
              v291 = (float)(v288 * v290) + (float)(v290 * (float)(1.0 - v287));
              if (v287 == 1.0)
                v291 = v288 * v290;
              v288 = v291 + (float)(v288 * (float)(1.0 - v289));
              if (v289 == 1.0)
                v288 = v291;
              if (v737)
              {
                v287 = (float)(v287 + v289) - (float)(v289 * v287);
LABEL_342:
                *v14 = bswap32(LODWORD(v288));
                *v7 = bswap32(LODWORD(v287));
                goto LABEL_344;
              }
              *v14 = bswap32(LODWORD(v288));
            }
          }
LABEL_344:
          v16 += v277;
          v292 = &v24[v277];
          v293 = &v283[v738];
          if ((unint64_t)v292 >= v12)
            v294 = v282;
          else
            v294 = 0;
          v283 = &v293[v294];
          v24 = &v292[v294];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v281);
          --v284;
        }
        while (v284);
        if (v27)
        {
          v295 = &v736[v20];
          if ((unint64_t)v295 >= v27)
            v296 = v280;
          else
            v296 = 0;
          v11 += 4 * v21 + 4 * v296;
          if ((unint64_t)v295 >= v27)
            v297 = v279;
          else
            v297 = 0;
          v24 = &v295[v297];
          v12 += 4 * v297 + 4 * v20;
          v283 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v283 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 14:
      v298 = v26;
      v299 = v23;
      v300 = -(v20 * v23);
      v301 = -(uint64_t)(v21 * v299);
      v302 = 4 * v26;
      v303 = -(uint64_t)v22;
      v304 = (unsigned int *)v11;
      while (1)
      {
        v305 = v10;
        do
        {
          if (*v16)
          {
            v306 = v738 ? COERCE_FLOAT(bswap32(*v304)) : 1.0;
            v307 = (float)*v16 * 0.0039216;
            v308 = v307 * v306;
            if (v308 > 0.0)
            {
              v309 = v307 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v310 = COERCE_FLOAT(bswap32(*v7));
                if (v310 <= 0.0)
                  goto LABEL_372;
              }
              else
              {
                v310 = 1.0;
              }
              v311 = COERCE_FLOAT(bswap32(*v14));
              v309 = v311 + (float)(v309 * (float)(1.0 - v311));
              if (v737)
              {
                v308 = (float)(v308 + v310) - (float)(v310 * v308);
LABEL_372:
                *v14 = bswap32(LODWORD(v309));
                *v7 = bswap32(LODWORD(v308));
                goto LABEL_374;
              }
              *v14 = bswap32(LODWORD(v309));
            }
          }
LABEL_374:
          v16 += v298;
          v312 = &v24[v298];
          v313 = &v304[v738];
          if ((unint64_t)v312 >= v12)
            v314 = v303;
          else
            v314 = 0;
          v304 = &v313[v314];
          v24 = &v312[v314];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v302);
          --v305;
        }
        while (v305);
        if (v27)
        {
          v315 = &v736[v20];
          if ((unint64_t)v315 >= v27)
            v316 = v301;
          else
            v316 = 0;
          v11 += 4 * v21 + 4 * v316;
          if ((unint64_t)v315 >= v27)
            v317 = v300;
          else
            v317 = 0;
          v24 = &v315[v317];
          v12 += 4 * v317 + 4 * v20;
          v304 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v304 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 15:
      v318 = v26;
      v700 = -(uint64_t)(v21 * v23);
      v705 = -(v20 * v23);
      v319 = 4 * v26;
      v320 = -(uint64_t)v22;
      v321 = (unsigned int *)v11;
      v715 = v320;
      v720 = v26;
      while (1)
      {
        v725 = v11;
        v730 = v9;
        v322 = v10;
        v323 = v738;
        do
        {
          if (*v16)
          {
            v324 = v323 ? COERCE_FLOAT(bswap32(*v321)) : 1.0;
            v325 = (float)*v16 * 0.0039216;
            v326 = v325 * v324;
            if ((float)(v325 * v324) > 0.0)
            {
              v327 = v325 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v328 = COERCE_FLOAT(bswap32(*v7));
                if (v328 <= 0.0)
                  goto LABEL_402;
              }
              else
              {
                v328 = 1.0;
              }
              v329 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v14)), v328, v327, v326);
              v327 = v329;
              if (v737)
              {
                v326 = v330;
                v323 = v738;
                v320 = v715;
                v318 = v720;
LABEL_402:
                *v14 = bswap32(LODWORD(v327));
                *v7 = bswap32(LODWORD(v326));
                goto LABEL_404;
              }
              *v14 = bswap32(LODWORD(v329));
              v323 = v738;
              v320 = v715;
              v318 = v720;
            }
          }
LABEL_404:
          v16 += v318;
          v331 = &v24[v318];
          if ((unint64_t)v331 >= v12)
            v332 = v320;
          else
            v332 = 0;
          v321 += v738 + v332;
          v24 = &v331[v332];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v319);
          --v322;
        }
        while (v322);
        if (v714)
        {
          v10 = v713;
          v333 = &v736[v712];
          v334 = v730;
          v335 = v700;
          if ((unint64_t)v333 < v714)
            v335 = 0;
          v11 = v725 + 4 * v21 + 4 * v335;
          v336 = v705;
          if ((unint64_t)v333 < v714)
            v336 = 0;
          v24 = &v333[v336];
          v12 += 4 * v336 + 4 * v712;
          v321 = (unsigned int *)(v725 + 4 * v21 + 4 * v335);
          v736 = v24;
          v338 = v710;
          v337 = v711;
        }
        else
        {
          v10 = v713;
          v24 += v712;
          v338 = v710;
          v321 += v21;
          v11 = v725;
          v334 = v730;
          v337 = v711;
        }
        v16 += v337;
        v14 += v338;
        v7 += v735;
        v9 = v334 - 1;
        if (!v9)
          return;
      }
    case 16:
      v339 = v26;
      v340 = v23;
      v341 = -(v20 * v23);
      v342 = -(uint64_t)(v21 * v340);
      v343 = 4 * v26;
      v344 = -(uint64_t)v22;
      v345 = (unsigned int *)v11;
      while (1)
      {
        v346 = v10;
        do
        {
          if (*v16)
          {
            v347 = v738 ? COERCE_FLOAT(bswap32(*v345)) : 1.0;
            v348 = (float)*v16 * 0.0039216;
            v349 = v348 * v347;
            if (v349 > 0.0)
            {
              v350 = v348 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v351 = COERCE_FLOAT(bswap32(*v7));
                if (v351 <= 0.0)
                  goto LABEL_436;
              }
              else
              {
                v351 = 1.0;
              }
              v352 = COERCE_FLOAT(bswap32(*v14));
              v353 = v349 * v352;
              if ((float)(v350 * v351) < (float)(v349 * v352))
                v353 = v350 * v351;
              v354 = v353 + (float)(v352 * (float)(1.0 - v349));
              if (v349 == 1.0)
                v354 = v353;
              v350 = v354 + (float)(v350 * (float)(1.0 - v351));
              if (v351 == 1.0)
                v350 = v354;
              if (v737)
              {
                v349 = (float)(v349 + v351) - (float)(v351 * v349);
LABEL_436:
                *v14 = bswap32(LODWORD(v350));
                *v7 = bswap32(LODWORD(v349));
                goto LABEL_438;
              }
              *v14 = bswap32(LODWORD(v350));
            }
          }
LABEL_438:
          v16 += v339;
          v355 = &v24[v339];
          v356 = &v345[v738];
          if ((unint64_t)v355 >= v12)
            v357 = v344;
          else
            v357 = 0;
          v345 = &v356[v357];
          v24 = &v355[v357];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v343);
          --v346;
        }
        while (v346);
        if (v27)
        {
          v358 = &v736[v20];
          if ((unint64_t)v358 >= v27)
            v359 = v342;
          else
            v359 = 0;
          v11 += 4 * v21 + 4 * v359;
          if ((unint64_t)v358 >= v27)
            v360 = v341;
          else
            v360 = 0;
          v24 = &v358[v360];
          v12 += 4 * v360 + 4 * v20;
          v345 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v345 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 17:
      v361 = v26;
      v362 = v23;
      v363 = -(v20 * v23);
      v364 = -(uint64_t)(v21 * v362);
      v365 = 4 * v26;
      v366 = -(uint64_t)v22;
      v367 = (unsigned int *)v11;
      while (1)
      {
        v368 = v10;
        do
        {
          if (*v16)
          {
            v369 = v738 ? COERCE_FLOAT(bswap32(*v367)) : 1.0;
            v370 = (float)*v16 * 0.0039216;
            v371 = v370 * v369;
            if (v371 > 0.0)
            {
              v372 = v370 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v373 = COERCE_FLOAT(bswap32(*v7));
                if (v373 <= 0.0)
                  goto LABEL_472;
              }
              else
              {
                v373 = 1.0;
              }
              v374 = COERCE_FLOAT(bswap32(*v14));
              v375 = v371 * v374;
              if ((float)(v372 * v373) > (float)(v371 * v374))
                v375 = v372 * v373;
              v376 = v375 + (float)(v374 * (float)(1.0 - v371));
              if (v371 == 1.0)
                v376 = v375;
              v372 = v376 + (float)(v372 * (float)(1.0 - v373));
              if (v373 == 1.0)
                v372 = v376;
              if (v737)
              {
                v371 = (float)(v371 + v373) - (float)(v373 * v371);
LABEL_472:
                *v14 = bswap32(LODWORD(v372));
                *v7 = bswap32(LODWORD(v371));
                goto LABEL_474;
              }
              *v14 = bswap32(LODWORD(v372));
            }
          }
LABEL_474:
          v16 += v361;
          v377 = &v24[v361];
          v378 = &v367[v738];
          if ((unint64_t)v377 >= v12)
            v379 = v366;
          else
            v379 = 0;
          v367 = &v378[v379];
          v24 = &v377[v379];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v365);
          --v368;
        }
        while (v368);
        if (v27)
        {
          v380 = &v736[v20];
          if ((unint64_t)v380 >= v27)
            v381 = v364;
          else
            v381 = 0;
          v11 += 4 * v21 + 4 * v381;
          if ((unint64_t)v380 >= v27)
            v382 = v363;
          else
            v382 = 0;
          v24 = &v380[v382];
          v12 += 4 * v382 + 4 * v20;
          v367 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v367 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 18:
      v383 = v26;
      v701 = -(uint64_t)(v21 * v23);
      v706 = -(v20 * v23);
      v384 = 4 * v26;
      v385 = -(uint64_t)v22;
      v386 = (unsigned int *)v11;
      v716 = v385;
      v721 = v26;
      while (1)
      {
        v726 = v11;
        v731 = v9;
        v387 = v10;
        v388 = v738;
        do
        {
          if (*v16)
          {
            v389 = v388 ? COERCE_FLOAT(bswap32(*v386)) : 1.0;
            v390 = (float)*v16 * 0.0039216;
            v391 = v390 * v389;
            if ((float)(v390 * v389) > 0.0)
            {
              v392 = v390 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v393 = COERCE_FLOAT(bswap32(*v7));
                if (v393 <= 0.0)
                  goto LABEL_502;
              }
              else
              {
                v393 = 1.0;
              }
              v394 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v14)), v393, v392, v391);
              v392 = v394;
              if (v737)
              {
                v391 = v395;
                v388 = v738;
                v385 = v716;
                v383 = v721;
LABEL_502:
                *v14 = bswap32(LODWORD(v392));
                *v7 = bswap32(LODWORD(v391));
                goto LABEL_504;
              }
              *v14 = bswap32(LODWORD(v394));
              v388 = v738;
              v385 = v716;
              v383 = v721;
            }
          }
LABEL_504:
          v16 += v383;
          v396 = &v24[v383];
          if ((unint64_t)v396 >= v12)
            v397 = v385;
          else
            v397 = 0;
          v386 += v738 + v397;
          v24 = &v396[v397];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v384);
          --v387;
        }
        while (v387);
        if (v714)
        {
          v10 = v713;
          v398 = &v736[v712];
          v399 = v731;
          v400 = v701;
          if ((unint64_t)v398 < v714)
            v400 = 0;
          v11 = v726 + 4 * v21 + 4 * v400;
          v401 = v706;
          if ((unint64_t)v398 < v714)
            v401 = 0;
          v24 = &v398[v401];
          v12 += 4 * v401 + 4 * v712;
          v386 = (unsigned int *)(v726 + 4 * v21 + 4 * v400);
          v736 = v24;
          v403 = v710;
          v402 = v711;
        }
        else
        {
          v10 = v713;
          v24 += v712;
          v403 = v710;
          v386 += v21;
          v11 = v726;
          v399 = v731;
          v402 = v711;
        }
        v16 += v402;
        v14 += v403;
        v7 += v735;
        v9 = v399 - 1;
        if (!v9)
          return;
      }
    case 19:
      v404 = v26;
      v702 = -(uint64_t)(v21 * v23);
      v707 = -(v20 * v23);
      v405 = 4 * v26;
      v406 = -(uint64_t)v22;
      v407 = (unsigned int *)v11;
      v717 = v406;
      v722 = v26;
      while (1)
      {
        v727 = v11;
        v732 = v9;
        v408 = v10;
        v409 = v738;
        do
        {
          if (*v16)
          {
            v410 = v409 ? COERCE_FLOAT(bswap32(*v407)) : 1.0;
            v411 = (float)*v16 * 0.0039216;
            v412 = v411 * v410;
            if ((float)(v411 * v410) > 0.0)
            {
              v413 = v411 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v414 = COERCE_FLOAT(bswap32(*v7));
                if (v414 <= 0.0)
                  goto LABEL_530;
              }
              else
              {
                v414 = 1.0;
              }
              v415 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v14)), v414, v413, v412);
              v413 = v415;
              if (v737)
              {
                v412 = v416;
                v409 = v738;
                v406 = v717;
                v404 = v722;
LABEL_530:
                *v14 = bswap32(LODWORD(v413));
                *v7 = bswap32(LODWORD(v412));
                goto LABEL_532;
              }
              *v14 = bswap32(LODWORD(v415));
              v409 = v738;
              v406 = v717;
              v404 = v722;
            }
          }
LABEL_532:
          v16 += v404;
          v417 = &v24[v404];
          if ((unint64_t)v417 >= v12)
            v418 = v406;
          else
            v418 = 0;
          v407 += v738 + v418;
          v24 = &v417[v418];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v405);
          --v408;
        }
        while (v408);
        if (v714)
        {
          v10 = v713;
          v419 = &v736[v712];
          v420 = v732;
          v421 = v702;
          if ((unint64_t)v419 < v714)
            v421 = 0;
          v11 = v727 + 4 * v21 + 4 * v421;
          v422 = v707;
          if ((unint64_t)v419 < v714)
            v422 = 0;
          v24 = &v419[v422];
          v12 += 4 * v422 + 4 * v712;
          v407 = (unsigned int *)(v727 + 4 * v21 + 4 * v421);
          v736 = v24;
          v424 = v710;
          v423 = v711;
        }
        else
        {
          v10 = v713;
          v24 += v712;
          v424 = v710;
          v407 += v21;
          v11 = v727;
          v420 = v732;
          v423 = v711;
        }
        v16 += v423;
        v14 += v424;
        v7 += v735;
        v9 = v420 - 1;
        if (!v9)
          return;
      }
    case 20:
      v425 = v26;
      v703 = -(uint64_t)(v21 * v23);
      v708 = -(v20 * v23);
      v426 = 4 * v26;
      v427 = -(uint64_t)v22;
      v428 = (unsigned int *)v11;
      v718 = v427;
      v723 = v26;
      while (1)
      {
        v728 = v11;
        v733 = v9;
        v429 = v10;
        v430 = v738;
        do
        {
          if (*v16)
          {
            v431 = v430 ? COERCE_FLOAT(bswap32(*v428)) : 1.0;
            v432 = (float)*v16 * 0.0039216;
            v433 = v432 * v431;
            if ((float)(v432 * v431) > 0.0)
            {
              v434 = v432 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v435 = COERCE_FLOAT(bswap32(*v7));
                if (v435 <= 0.0)
                  goto LABEL_558;
              }
              else
              {
                v435 = 1.0;
              }
              v436 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v14)), v435, v434, v433);
              v434 = v436;
              if (v737)
              {
                v433 = v437;
                v430 = v738;
                v427 = v718;
                v425 = v723;
LABEL_558:
                *v14 = bswap32(LODWORD(v434));
                *v7 = bswap32(LODWORD(v433));
                goto LABEL_560;
              }
              *v14 = bswap32(LODWORD(v436));
              v430 = v738;
              v427 = v718;
              v425 = v723;
            }
          }
LABEL_560:
          v16 += v425;
          v438 = &v24[v425];
          if ((unint64_t)v438 >= v12)
            v439 = v427;
          else
            v439 = 0;
          v428 += v738 + v439;
          v24 = &v438[v439];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v426);
          --v429;
        }
        while (v429);
        if (v714)
        {
          v10 = v713;
          v440 = &v736[v712];
          v441 = v733;
          v442 = v703;
          if ((unint64_t)v440 < v714)
            v442 = 0;
          v11 = v728 + 4 * v21 + 4 * v442;
          v443 = v708;
          if ((unint64_t)v440 < v714)
            v443 = 0;
          v24 = &v440[v443];
          v12 += 4 * v443 + 4 * v712;
          v428 = (unsigned int *)(v728 + 4 * v21 + 4 * v442);
          v736 = v24;
          v445 = v710;
          v444 = v711;
        }
        else
        {
          v10 = v713;
          v24 += v712;
          v445 = v710;
          v428 += v21;
          v11 = v728;
          v441 = v733;
          v444 = v711;
        }
        v16 += v444;
        v14 += v445;
        v7 += v735;
        v9 = v441 - 1;
        if (!v9)
          return;
      }
    case 21:
      v446 = v26;
      v704 = -(uint64_t)(v21 * v23);
      v709 = -(v20 * v23);
      v447 = 4 * v26;
      v448 = -(uint64_t)v22;
      v449 = (unsigned int *)v11;
      v719 = v448;
      v724 = v26;
      do
      {
        v729 = v11;
        v734 = v9;
        v450 = v10;
        v451 = v738;
        do
        {
          if (*v16)
          {
            v452 = v451 ? COERCE_FLOAT(bswap32(*v449)) : 1.0;
            v453 = (float)*v16 * 0.0039216;
            v454 = v453 * v452;
            if ((float)(v453 * v452) > 0.0)
            {
              v455 = v453 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v456 = COERCE_FLOAT(bswap32(*v7));
                if (v456 <= 0.0)
                  goto LABEL_586;
              }
              else
              {
                v456 = 1.0;
              }
              v457 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v14)), v456, v455, v454);
              v455 = v457;
              if (v737)
              {
                v454 = v458;
                v451 = v738;
                v448 = v719;
                v446 = v724;
LABEL_586:
                *v14 = bswap32(LODWORD(v455));
                *v7 = bswap32(LODWORD(v454));
                goto LABEL_588;
              }
              *v14 = bswap32(LODWORD(v457));
              v451 = v738;
              v448 = v719;
              v446 = v724;
            }
          }
LABEL_588:
          v16 += v446;
          v459 = &v24[v446];
          if ((unint64_t)v459 >= v12)
            v460 = v448;
          else
            v460 = 0;
          v449 += v738 + v460;
          v24 = &v459[v460];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v447);
          --v450;
        }
        while (v450);
        if (v714)
        {
          v10 = v713;
          v461 = &v736[v712];
          v462 = v734;
          v463 = v704;
          if ((unint64_t)v461 < v714)
            v463 = 0;
          v11 = v729 + 4 * v21 + 4 * v463;
          v464 = v709;
          if ((unint64_t)v461 < v714)
            v464 = 0;
          v24 = &v461[v464];
          v12 += 4 * v464 + 4 * v712;
          v449 = (unsigned int *)(v729 + 4 * v21 + 4 * v463);
          v736 = v24;
          v466 = v710;
          v465 = v711;
        }
        else
        {
          v10 = v713;
          v24 += v712;
          v466 = v710;
          v449 += v21;
          v11 = v729;
          v462 = v734;
          v465 = v711;
        }
        v16 += v465;
        v14 += v466;
        v7 += v735;
        v9 = v462 - 1;
      }
      while (v9);
      return;
    case 22:
      v467 = v26;
      v468 = v23;
      v469 = -(v20 * v23);
      v470 = -(uint64_t)(v21 * v468);
      v471 = 4 * v26;
      v472 = -(uint64_t)v22;
      v473 = (unsigned int *)v11;
      while (1)
      {
        v474 = v10;
        do
        {
          if (*v16)
          {
            v475 = v738 ? COERCE_FLOAT(bswap32(*v473)) : 1.0;
            v476 = (float)*v16 * 0.0039216;
            v477 = v476 * v475;
            if (v477 > 0.0)
            {
              v478 = v476 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v479 = COERCE_FLOAT(bswap32(*v7));
                if (v479 <= 0.0)
                  goto LABEL_616;
              }
              else
              {
                v479 = 1.0;
              }
              v480 = COERCE_FLOAT(bswap32(*v14));
              v481 = v478 + v480;
              v482 = v478 * v479;
              v483 = (float)(v477 * v480) - v482;
              v484 = (float)(v481 - (float)(v477 * v480)) - v482;
              if (v483 < 0.0)
                v483 = -v483;
              v478 = v484 + v483;
              if (v737)
              {
                v477 = (float)(v477 + v479) - (float)(v479 * v477);
LABEL_616:
                *v14 = bswap32(LODWORD(v478));
                *v7 = bswap32(LODWORD(v477));
                goto LABEL_618;
              }
              *v14 = bswap32(LODWORD(v478));
            }
          }
LABEL_618:
          v16 += v467;
          v485 = &v24[v467];
          v486 = &v473[v738];
          if ((unint64_t)v485 >= v12)
            v487 = v472;
          else
            v487 = 0;
          v473 = &v486[v487];
          v24 = &v485[v487];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v471);
          --v474;
        }
        while (v474);
        if (v27)
        {
          v488 = &v736[v20];
          if ((unint64_t)v488 >= v27)
            v489 = v470;
          else
            v489 = 0;
          v11 += 4 * v21 + 4 * v489;
          if ((unint64_t)v488 >= v27)
            v490 = v469;
          else
            v490 = 0;
          v24 = &v488[v490];
          v12 += 4 * v490 + 4 * v20;
          v473 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v473 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 23:
      v491 = v26;
      v492 = v23;
      v493 = -(v20 * v23);
      v494 = -(uint64_t)(v21 * v492);
      v495 = 4 * v26;
      v496 = -(uint64_t)v22;
      v497 = (unsigned int *)v11;
      while (1)
      {
        v498 = v10;
        do
        {
          if (*v16)
          {
            v499 = v738 ? COERCE_FLOAT(bswap32(*v497)) : 1.0;
            v500 = (float)*v16 * 0.0039216;
            v501 = v500 * v499;
            if (v501 > 0.0)
            {
              v502 = v500 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v503 = COERCE_FLOAT(bswap32(*v7));
                if (v503 <= 0.0)
                  goto LABEL_646;
              }
              else
              {
                v503 = 1.0;
              }
              v504 = COERCE_FLOAT(bswap32(*v14));
              v502 = (float)(v502 + v504) + (float)((float)(v502 * v504) * -2.0);
              if (v737)
              {
                v501 = (float)(v501 + v503) - (float)(v503 * v501);
LABEL_646:
                *v14 = bswap32(LODWORD(v502));
                *v7 = bswap32(LODWORD(v501));
                goto LABEL_648;
              }
              *v14 = bswap32(LODWORD(v502));
            }
          }
LABEL_648:
          v16 += v491;
          v505 = &v24[v491];
          v506 = &v497[v738];
          if ((unint64_t)v505 >= v12)
            v507 = v496;
          else
            v507 = 0;
          v497 = &v506[v507];
          v24 = &v505[v507];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v495);
          --v498;
        }
        while (v498);
        if (v27)
        {
          v508 = &v736[v20];
          if ((unint64_t)v508 >= v27)
            v509 = v494;
          else
            v509 = 0;
          v11 += 4 * v21 + 4 * v509;
          if ((unint64_t)v508 >= v27)
            v510 = v493;
          else
            v510 = 0;
          v24 = &v508[v510];
          v12 += 4 * v510 + 4 * v20;
          v497 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v497 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 24:
      v511 = v26;
      v512 = v23;
      v513 = -(v20 * v23);
      v514 = -(uint64_t)(v21 * v512);
      v515 = 4 * v26;
      v516 = -(uint64_t)v22;
      v517 = (unsigned int *)v11;
      while (1)
      {
        v518 = v10;
        do
        {
          if (*v16)
          {
            v519 = v738 ? COERCE_FLOAT(bswap32(*v517)) : 1.0;
            v520 = (float)*v16 * 0.0039216;
            v521 = v520 * v519;
            if (v521 > 0.0)
            {
              v522 = v520 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v523 = COERCE_FLOAT(bswap32(*v7));
                if (v523 <= 0.0)
                  goto LABEL_681;
              }
              else
              {
                v523 = 1.0;
              }
              v524 = COERCE_FLOAT(bswap32(*v14));
              v525 = v524;
              if (v521 == 1.0)
              {
                v526 = 0.0;
              }
              else
              {
                v525 = v521 * v524;
                v526 = v524 - (float)(v521 * v524);
              }
              v527 = (float)(v522 + v526) - (float)(v522 * v523);
              if (v523 == 1.0)
                v527 = v526;
              v522 = v525 + v527;
              if (v737)
              {
                v521 = (float)(v521 + v523) - (float)(v521 * v523);
LABEL_681:
                *v14 = bswap32(LODWORD(v522));
                *v7 = bswap32(LODWORD(v521));
                goto LABEL_683;
              }
              *v14 = bswap32(LODWORD(v522));
            }
          }
LABEL_683:
          v16 += v511;
          v528 = &v24[v511];
          v529 = &v517[v738];
          if ((unint64_t)v528 >= v12)
            v530 = v516;
          else
            v530 = 0;
          v517 = &v529[v530];
          v24 = &v528[v530];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v515);
          --v518;
        }
        while (v518);
        if (v27)
        {
          v531 = &v736[v20];
          if ((unint64_t)v531 >= v27)
            v532 = v514;
          else
            v532 = 0;
          v11 += 4 * v21 + 4 * v532;
          if ((unint64_t)v531 >= v27)
            v533 = v513;
          else
            v533 = 0;
          v24 = &v531[v533];
          v12 += 4 * v533 + 4 * v20;
          v517 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v517 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 25:
      v534 = v26;
      v535 = v23;
      v536 = -(v20 * v23);
      v537 = -(uint64_t)(v21 * v535);
      v538 = 4 * v26;
      v539 = -(uint64_t)v22;
      v540 = (unsigned int *)v11;
      while (1)
      {
        v541 = v10;
        do
        {
          if (*v16)
          {
            v542 = v738 ? COERCE_FLOAT(bswap32(*v540)) : 1.0;
            v543 = (float)*v16 * 0.0039216;
            v544 = v543 * v542;
            if (v544 > 0.0)
            {
              v545 = v543 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v546 = COERCE_FLOAT(bswap32(*v7));
                if (v546 <= 0.0)
                  goto LABEL_716;
              }
              else
              {
                v546 = 1.0;
              }
              v547 = COERCE_FLOAT(bswap32(*v14));
              v548 = v547;
              if (v544 == 1.0)
              {
                v549 = 0.0;
              }
              else
              {
                v548 = v544 * v547;
                v549 = v547 - (float)(v544 * v547);
              }
              v550 = (float)(v545 + v549) - (float)(v545 * v546);
              if (v546 == 1.0)
                v550 = v549;
              v545 = v548 + v550;
              if (v737)
              {
                v544 = (float)(v544 + v546) - (float)(v544 * v546);
LABEL_716:
                *v14 = bswap32(LODWORD(v545));
                *v7 = bswap32(LODWORD(v544));
                goto LABEL_718;
              }
              *v14 = bswap32(LODWORD(v545));
            }
          }
LABEL_718:
          v16 += v534;
          v551 = &v24[v534];
          v552 = &v540[v738];
          if ((unint64_t)v551 >= v12)
            v553 = v539;
          else
            v553 = 0;
          v540 = &v552[v553];
          v24 = &v551[v553];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v538);
          --v541;
        }
        while (v541);
        if (v27)
        {
          v554 = &v736[v20];
          if ((unint64_t)v554 >= v27)
            v555 = v537;
          else
            v555 = 0;
          v11 += 4 * v21 + 4 * v555;
          if ((unint64_t)v554 >= v27)
            v556 = v536;
          else
            v556 = 0;
          v24 = &v554[v556];
          v12 += 4 * v556 + 4 * v20;
          v540 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v540 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 26:
      v557 = v26;
      v558 = v23;
      v559 = -(v20 * v23);
      v560 = -(uint64_t)(v21 * v558);
      v561 = 4 * v26;
      v562 = -(uint64_t)v22;
      v563 = (unsigned int *)v11;
      while (1)
      {
        v564 = v10;
        do
        {
          if (*v16)
          {
            v565 = v738 ? COERCE_FLOAT(bswap32(*v563)) : 1.0;
            v566 = (float)*v16 * 0.0039216;
            v567 = v566 * v565;
            if (v567 > 0.0)
            {
              v568 = v566 * COERCE_FLOAT(bswap32(*v24));
              if (v737)
              {
                v569 = COERCE_FLOAT(bswap32(*v7));
                if (v569 <= 0.0)
                  goto LABEL_750;
              }
              else
              {
                v569 = 1.0;
              }
              v570 = COERCE_FLOAT(bswap32(*v14));
              v571 = v570;
              v572 = v568 - (float)(v568 * v569);
              if (v569 == 1.0)
                v572 = 0.0;
              if (v567 != 1.0)
              {
                v571 = v567 * v570;
                v572 = (float)(v572 + v570) - (float)(v567 * v570);
              }
              v568 = v571 + v572;
              if (v737)
              {
                v567 = (float)(v567 + v569) - (float)(v567 * v569);
LABEL_750:
                *v14 = bswap32(LODWORD(v568));
                *v7 = bswap32(LODWORD(v567));
                goto LABEL_752;
              }
              *v14 = bswap32(LODWORD(v568));
            }
          }
LABEL_752:
          v16 += v557;
          v573 = &v24[v557];
          v574 = &v563[v738];
          if ((unint64_t)v573 >= v12)
            v575 = v562;
          else
            v575 = 0;
          v563 = &v574[v575];
          v24 = &v573[v575];
          v7 += v737;
          v14 = (unsigned int *)((char *)v14 + v561);
          --v564;
        }
        while (v564);
        if (v27)
        {
          v576 = &v736[v20];
          if ((unint64_t)v576 >= v27)
            v577 = v560;
          else
            v577 = 0;
          v11 += 4 * v21 + 4 * v577;
          if ((unint64_t)v576 >= v27)
            v578 = v559;
          else
            v578 = 0;
          v24 = &v576[v578];
          v12 += 4 * v578 + 4 * v20;
          v563 = (unsigned int *)v11;
          v736 = v24;
        }
        else
        {
          v24 += v20;
          v563 += v21;
        }
        v16 += v32;
        v14 += v33;
        v7 += v735;
        if (!--v9)
          return;
      }
    case 27:
      v579 = v26;
      v580 = v23;
      v581 = -(v20 * v23);
      v582 = -(uint64_t)(v21 * v580);
      v583 = 4 * v26;
      v584 = -(uint64_t)v22;
      v585 = (unsigned int *)v11;
      break;
    default:
      return;
  }
LABEL_768:
  v586 = v10;
  while (1)
  {
    if (!*v16)
      goto LABEL_786;
    v587 = v738 ? COERCE_FLOAT(bswap32(*v585)) : 1.0;
    v588 = (float)*v16 * 0.0039216;
    v589 = v588 * v587;
    if (v589 <= 0.0)
      goto LABEL_786;
    v590 = v588 * COERCE_FLOAT(bswap32(*v24));
    if (v737)
    {
      v591 = COERCE_FLOAT(bswap32(*v7));
      if (v591 <= 0.0)
        goto LABEL_784;
    }
    else
    {
      v591 = 1.0;
    }
    v592 = COERCE_FLOAT(bswap32(*v14));
    v593 = v592 - (float)(v589 * v592);
    if (v589 == 1.0)
      v593 = 0.0;
    v594 = (float)(v590 + v593) - (float)(v590 * v591);
    if (v591 != 1.0)
    {
      v590 = v590 * v591;
      v593 = v594;
    }
    v590 = v590 + v593;
    if (!v737)
    {
      *v14 = bswap32(LODWORD(v590));
      goto LABEL_786;
    }
    v589 = (float)(v589 + v591) - (float)(v589 * v591);
LABEL_784:
    *v14 = bswap32(LODWORD(v590));
    *v7 = bswap32(LODWORD(v589));
LABEL_786:
    v16 += v579;
    v595 = &v24[v579];
    v596 = &v585[v738];
    if ((unint64_t)v595 >= v12)
      v597 = v584;
    else
      v597 = 0;
    v585 = &v596[v597];
    v24 = &v595[v597];
    v7 += v737;
    v14 = (unsigned int *)((char *)v14 + v583);
    if (!--v586)
    {
      if (v27)
      {
        v598 = &v736[v20];
        if ((unint64_t)v598 >= v27)
          v599 = v582;
        else
          v599 = 0;
        v11 += 4 * v21 + 4 * v599;
        if ((unint64_t)v598 >= v27)
          v600 = v581;
        else
          v600 = 0;
        v24 = &v598[v600];
        v12 += 4 * v600 + 4 * v20;
        v585 = (unsigned int *)v11;
        v736 = v24;
      }
      else
      {
        v24 += v20;
        v585 += v21;
      }
      v16 += v32;
      v14 += v33;
      v7 += v735;
      if (!--v9)
        return;
      goto LABEL_768;
    }
  }
}

uint64_t WF_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  _BOOL4 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int *v23;
  unint64_t v24;
  uint64_t (*v25)(uint64_t, int *, int, int, int, int);
  uint64_t v26;
  int v27;
  int v28;
  uint64_t (*v29)(uint64_t, uint64_t, uint64_t, int);
  unsigned int v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  _OWORD v35[64];
  uint64_t v36;

  v36 = *MEMORY[0x1E0C80C00];
  v6 = (int *)*a1;
  memset(v35, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*((_QWORD *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v29, (uint64_t)v35) < 1)
    return 0xFFFFFFFFLL;
  v18 = *v6;
  v19 = *(_DWORD *)a3;
  v30 = v19;
  v31 = v18;
  if (v19 != 136319237)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      v23 = WF_image_sample;
      v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&WF_image_sample[2 * v20 + 2];
      if (v29)
      {
LABEL_28:
        v30 = *v23;
        if ((v21 & 1) == 0 && (v8 - 1) <= 1 && (v33 & 7) == 3 && (a2[2] == 5 || !a2[2]) && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_RGB32;
              goto LABEL_50;
            case 1u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_RGB32;
              goto LABEL_52;
            case 2u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_W8;
              goto LABEL_50;
            case 3u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_RGB24;
              goto LABEL_50;
            case 4u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_rgb32;
LABEL_50:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 0;
              break;
            case 5u:
              v30 = *(_DWORD *)a3;
              v25 = WF_image_mark_rgb32;
LABEL_52:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 8;
              break;
            default:
              goto LABEL_36;
          }
          WF_image_mark_image(v26, (uint64_t)&v29, v27, v28, (void (*)(uint64_t, _DWORD *))v25);
          return 1;
        }
        goto LABEL_36;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) > 8)
      {
        if ((*(_DWORD *)a3 & 0x3F0000u) >> 16 > 0x10)
          return 0xFFFFFFFFLL;
      }
      else
      {
        v23 = W8_image_sample;
        v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W8_image_sample[2 * v20 + 2];
        if (v29)
        {
LABEL_27:
          v32 = 4;
          goto LABEL_28;
        }
      }
      v23 = W16_image_sample;
      v29 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, int))&W16_image_sample[2 * v20 + 2];
      if (v29)
        goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!v34 && (~v33 & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((v33 & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      WF_mark_inner(*(_QWORD *)(*a1 + 56), v17);
      return 1;
    }
  }
  v29 = Wf_sample_WF_inner;
LABEL_36:
  WF_image_mark((uint64_t)a2, (uint64_t)&v29, v8, v17);
  return 1;
}

uint64_t WF_image_mark_W8(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  unsigned int *v6;
  unsigned int *v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  float v18;
  unsigned int v19;
  float v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t result;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  unsigned int v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  unsigned int v37;
  unsigned __int8 *v38;
  int v39;
  unsigned __int8 *v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned __int8 *v44;
  unsigned __int8 *v45;
  unsigned int v46;
  unsigned __int8 *v47;
  unsigned int v48;
  unsigned __int8 *v49;
  unsigned int v50;
  unsigned __int8 *v51;
  int v52;
  unsigned __int8 *v53;
  float v54;
  unsigned int v55;
  uint64_t *v56;
  float v57;
  unsigned int v58;
  float v59;
  uint64_t *v60;
  uint64_t v61;
  uint64_t v62;
  unsigned __int8 *v63;
  uint64_t *v64;
  uint64_t v65;
  uint64_t v66;
  unsigned __int8 *v67;
  float v68;
  unsigned int v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  int v73;
  uint64_t v74;

  v6 = (unsigned int *)*((_QWORD *)a2 + 2);
  v7 = (unsigned int *)*((_QWORD *)a2 + 4);
  if (v7)
    v74 = *((_QWORD *)a2 + 5) - a5;
  else
    v74 = 0;
  v8 = *((float *)a2 + 2);
  v73 = *a2;
  v9 = *((_QWORD *)a2 + 3) - a5;
  v10 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v12 = *((_QWORD *)a2 + 9);
  v13 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v13 * a4;
  v15 = *(unsigned __int8 **)(a1 + 32);
  v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v17 = 4 * (v7 != 0);
  if (*(_QWORD *)(a1 + 176))
  {
    v71 = *((_QWORD *)a2 + 15);
    v72 = *((_QWORD *)a2 + 13);
    v18 = fminf(v8, 1.0);
    v19 = bswap32(LODWORD(v18));
    v20 = 1.0 - v18;
    v70 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v71 - v14) | (v14 - v72)) < 0)
      {
        v23 = 0;
        v22 = 0;
      }
      else
      {
        v21 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v21 - 7 >= 9)
          v22 = -v10;
        else
          v22 = v10;
        v23 = weights_19497[v21] & 0xF;
      }
      result = v14 >> v12;
      v25 = &v15[(v14 >> v12) * v10];
      if (v73 == 1)
      {
        if (a5 >= 1)
        {
          result = v23;
          v26 = (uint64_t *)v70;
          v27 = a5;
          do
          {
            v28 = *(v26 - 1);
            v29 = *v26;
            v30 = &v25[v28];
            if (v16 >= &v25[v28])
              v31 = &v25[v28];
            else
              v31 = v16;
            if (v15 > v31)
              v31 = v15;
            v32 = *v31;
            if ((v29 & 0xF) != 0)
            {
              v33 = &v30[v29 >> 4];
              if (v16 < v33)
                v33 = v16;
              if (v15 > v33)
                v33 = v15;
              v34 = *v33;
              if (v23)
              {
                v35 = &v30[v22];
                if (v16 >= v35)
                  v36 = v35;
                else
                  v36 = v16;
                if (v15 > v36)
                  v36 = v15;
                v37 = *v36;
                v38 = &v35[v29 >> 4];
                if (v16 < v38)
                  v38 = v16;
                if (v15 > v38)
                  v38 = v15;
                v39 = BLEND8_19499[v23];
                v32 = v32 - ((v39 & v32) >> v23) + ((v39 & v37) >> v23);
                v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
              }
              v32 = v32
                  - ((BLEND8_19499[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_19499[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v23)
            {
              v40 = &v30[v22];
              if (v16 < &v30[v22])
                v40 = v16;
              if (v15 > v40)
                v40 = v15;
              v32 = v32 - ((BLEND8_19499[v23] & v32) >> v23) + ((BLEND8_19499[v23] & *v40) >> v23);
            }
            *v6 = bswap32(COERCE_UNSIGNED_INT(*(float *)&_blt_float[v32] * v18));
            if (v7)
              *v7 = v19;
            v26 += 2;
            ++v6;
            v7 = (unsigned int *)((char *)v7 + v17);
            --v27;
          }
          while (v27);
        }
        goto LABEL_87;
      }
      if (a5 >= 1)
        break;
LABEL_87:
      v6 += v9;
      v14 += v13;
      v7 += v74;
      if (!--a6)
        return result;
    }
    v41 = (uint64_t *)v70;
    result = a5;
    while (1)
    {
      v42 = *(v41 - 1);
      v43 = *v41;
      v44 = &v25[v42];
      if (v16 >= &v25[v42])
        v45 = &v25[v42];
      else
        v45 = v16;
      if (v15 > v45)
        v45 = v15;
      v46 = *v45;
      if ((v43 & 0xF) != 0)
      {
        v47 = &v44[v43 >> 4];
        if (v16 < v47)
          v47 = v16;
        if (v15 > v47)
          v47 = v15;
        v48 = *v47;
        if (v23)
        {
          if (v16 >= &v44[v22])
            v49 = &v44[v22];
          else
            v49 = v16;
          if (v15 > v49)
            v49 = v15;
          v50 = *v49;
          v51 = &v44[v22 + (v43 >> 4)];
          if (v16 < v51)
            v51 = v16;
          if (v15 > v51)
            v51 = v15;
          v52 = BLEND8_19499[v23];
          v46 = v46 - ((v52 & v46) >> v23) + ((v52 & v50) >> v23);
          v48 = v48 - ((v52 & v48) >> v23) + ((v52 & *v51) >> v23);
        }
        v46 = v46
            - ((BLEND8_19499[*v41 & 0xF] & v46) >> (*v41 & 0xF))
            + ((BLEND8_19499[*v41 & 0xF] & v48) >> (*v41 & 0xF));
      }
      else if (v23)
      {
        v53 = &v44[v22];
        if (v16 < &v44[v22])
          v53 = v16;
        if (v15 > v53)
          v53 = v15;
        v46 = v46 - ((BLEND8_19499[v23] & v46) >> v23) + ((BLEND8_19499[v23] & *v53) >> v23);
      }
      v54 = *(float *)&_blt_float[v46] * v18;
      if (v7)
      {
        if (v18 < 1.0)
        {
          if (v18 > 0.0)
          {
            v55 = bswap32(COERCE_UNSIGNED_INT(v18 + (float)(COERCE_FLOAT(bswap32(*v7)) * v20)));
            *v6 = bswap32(COERCE_UNSIGNED_INT(v54 + (float)(COERCE_FLOAT(bswap32(*v6)) * v20)));
            *v7 = v55;
          }
        }
        else
        {
          *v6 = bswap32(LODWORD(v54));
          *v7 = v19;
        }
        goto LABEL_86;
      }
      if (v18 >= 1.0)
        goto LABEL_85;
      if (v18 > 0.0)
        break;
LABEL_86:
      v41 += 2;
      ++v6;
      v7 = (unsigned int *)((char *)v7 + v17);
      if (!--result)
        goto LABEL_87;
    }
    v54 = v54 + (float)(COERCE_FLOAT(bswap32(*v6)) * v20);
LABEL_85:
    *v6 = bswap32(LODWORD(v54));
    goto LABEL_86;
  }
  v56 = (uint64_t *)(v11 + 16 * a3);
  v57 = fminf(v8, 1.0);
  v58 = bswap32(LODWORD(v57));
  v59 = 1.0 - v57;
  do
  {
    result = (uint64_t)&v15[(v14 >> v12) * v10];
    if (v73 != 1)
    {
      v64 = v56;
      v65 = a5;
      if (a5 < 1)
        goto LABEL_116;
      while (1)
      {
        v66 = *v64;
        v64 += 2;
        v67 = (unsigned __int8 *)(result + v66);
        if ((unint64_t)v16 < result + v66)
          v67 = v16;
        if (v15 > v67)
          v67 = v15;
        v68 = *(float *)&_blt_float[*v67] * v57;
        if (v7)
        {
          if (v57 < 1.0)
          {
            if (v57 > 0.0)
            {
              v69 = bswap32(COERCE_UNSIGNED_INT(v57 + (float)(COERCE_FLOAT(bswap32(*v7)) * v59)));
              *v6 = bswap32(COERCE_UNSIGNED_INT(v68 + (float)(COERCE_FLOAT(bswap32(*v6)) * v59)));
              *v7 = v69;
            }
          }
          else
          {
            *v6 = bswap32(LODWORD(v68));
            *v7 = v58;
          }
          goto LABEL_115;
        }
        if (v57 >= 1.0)
          goto LABEL_114;
        if (v57 > 0.0)
          break;
LABEL_115:
        ++v6;
        v7 = (unsigned int *)((char *)v7 + v17);
        if (!--v65)
          goto LABEL_116;
      }
      v68 = v68 + (float)(COERCE_FLOAT(bswap32(*v6)) * v59);
LABEL_114:
      *v6 = bswap32(LODWORD(v68));
      goto LABEL_115;
    }
    if (a5 >= 1)
    {
      v60 = v56;
      v61 = a5;
      do
      {
        v62 = *v60;
        v60 += 2;
        v63 = (unsigned __int8 *)(result + v62);
        if ((unint64_t)v16 < result + v62)
          v63 = v16;
        if (v15 > v63)
          v63 = v15;
        *v6 = bswap32(COERCE_UNSIGNED_INT(*(float *)&_blt_float[*v63] * v57));
        if (v7)
          *v7 = v58;
        ++v6;
        v7 = (unsigned int *)((char *)v7 + v17);
        --v61;
      }
      while (v61);
    }
LABEL_116:
    v6 += v9;
    v14 += v13;
    v7 += v74;
    --a6;
  }
  while (a6);
  return result;
}

void WF_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(uint64_t, _DWORD *))
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unint64_t v13;
  uint64_t *v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char v20;
  uint64_t v21;
  unsigned int v22;
  unint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  unint64_t v35;
  char v36;
  unint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  void *v40;
  int v41;
  int v42;
  int *v43;
  int v44;
  void *v45;
  void *v46;
  int v47;
  int v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  _DWORD v56[4];
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t v71;
  unint64_t v72;
  _QWORD *v73;
  int v74;
  int v75;
  int v76[4];

  v56[0] = a3;
  v56[1] = a4;
  v56[2] = *(_DWORD *)(a2 + 184);
  v8 = (unint64_t)*(int *)(a1 + 28) >> 2;
  v58 = v8;
  if (*(_QWORD *)(a1 + 48))
    v9 = (unint64_t)*(int *)(a1 + 32) >> 2;
  else
    v9 = 0;
  v60 = v9;
  v10 = *(_QWORD *)(a2 + 120);
  v11 = *(_DWORD *)(a2 + 20);
  if (v10)
  {
    v12 = HIBYTE(v11);
    v13 = *(int *)(a2 + 24);
    v14 = (uint64_t *)(a2 + 104);
    v15 = (uint64_t *)(a2 + 72);
    v16 = (uint64_t *)(a2 + 88);
  }
  else
  {
    v12 = BYTE2(v11);
    v13 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v14 = (uint64_t *)(a2 + 96);
    v15 = (uint64_t *)(a2 + 64);
    v16 = (uint64_t *)(a2 + 80);
    v10 = *(_QWORD *)(a2 + 112);
  }
  v17 = *v16;
  v18 = *v15;
  v19 = *v14;
  v20 = v12;
  v63 = v12;
  v61 = v19;
  v71 = v13;
  v69 = v17;
  v67 = v18;
  v65 = v10;
  v21 = *(_QWORD *)(a2 + 128);
  v54 = v18;
  v55 = v17;
  if (v21)
  {
    v22 = BYTE2(v11);
    v23 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v24 = (uint64_t *)(a2 + 96);
    v25 = (uint64_t *)(a2 + 64);
    v26 = (uint64_t *)(a2 + 80);
  }
  else
  {
    v22 = HIBYTE(v11);
    v23 = *(int *)(a2 + 24);
    v24 = (uint64_t *)(a2 + 104);
    v25 = (uint64_t *)(a2 + 72);
    v26 = (uint64_t *)(a2 + 88);
    v21 = *(_QWORD *)(a2 + 136);
  }
  v27 = *v26;
  v28 = *v25;
  v29 = *v24;
  v64 = v22;
  v62 = v29;
  v72 = v23;
  v70 = v27;
  v68 = v28;
  v66 = v21;
  v30 = *(unsigned int *)(a1 + 4);
  if ((v30 & 0x80000000) == 0)
  {
    v31 = malloc_type_malloc(16 * v30, 0x379E47uLL);
    v73 = v31;
    if (v31)
    {
      if (*(_QWORD *)(a2 + 176))
      {
        if ((_DWORD)v30)
        {
          v33 = v31 + 1;
          v34 = v55 - v19;
          do
          {
            if (((v19 - v54) | v34) < 0)
            {
              v37 = 0;
              v38 = 0;
            }
            else
            {
              v35 = ((v19 & (unint64_t)~(-1 << v20)) >> (v20 - 4)) & 0xF;
              v36 = weights_19497[v35];
              if (v35 - 7 >= 9)
                v37 = -(uint64_t)v13;
              else
                v37 = v13;
              v38 = v36 & 0xF;
            }
            *(v33 - 1) = v13 * (v19 >> v20);
            *v33 = v38 | (16 * v37);
            v33 += 2;
            v19 += v10;
            v34 -= v10;
            --v30;
          }
          while (v30);
        }
      }
      else if ((_DWORD)v30)
      {
        v39 = v31 + 1;
        do
        {
          *(v39 - 1) = v13 * (v19 >> v20);
          *v39 = 0;
          v39 += 2;
          v19 += v10;
          --v30;
        }
        while (v30);
      }
      v40 = v31;
      v41 = *(_DWORD *)(a1 + 4);
      v42 = *(_DWORD *)(a1 + 8);
      v74 = v42;
      v75 = v41;
      v43 = *(int **)(a1 + 136);
      if (v43)
      {
        v44 = *(_DWORD *)(a1 + 104);
        v76[0] = *(_DWORD *)(a1 + 108);
        v76[1] = v44;
        shape_enum_clip_alloc((uint64_t)v31, v32, v43, 1, 1, 1, v44, v76[0], v41, v42);
        v46 = v45;
        if (v45)
          goto LABEL_32;
      }
      v47 = 0;
      v48 = 0;
      v46 = 0;
      *(_QWORD *)v76 = 0;
      while (1)
      {
        v49 = *(int *)(a1 + 16) + (uint64_t)v48;
        v50 = *(_QWORD *)(a1 + 48);
        v51 = v47 + *(_DWORD *)(a1 + 12);
        v52 = *(_QWORD *)(a1 + 40) + 4 * v8 * v49 + 4 * v51;
        v53 = v50 + 4 * v9 * v49 + 4 * v51;
        if (!v50)
          v53 = 0;
        v57 = v52;
        v59 = v53;
        a5(a2, v56);
        if (!v46)
          break;
LABEL_32:
        if (!shape_enum_clip_next((uint64_t)v46, &v76[1], v76, &v75, &v74))
        {
          free(v46);
          break;
        }
        v48 = v76[0];
        v47 = v76[1];
        v8 = v58;
        v9 = v60;
      }
      free(v40);
    }
  }
}

uint64_t WF_image_mark_RGB24(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  unsigned int *v6;
  unsigned int *v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  uint64_t result;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  uint64_t v23;
  int v24;
  unsigned __int8 *v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  unsigned __int8 *v31;
  unsigned int v32;
  unsigned __int8 *v33;
  int v34;
  unsigned __int8 *v35;
  int v36;
  unsigned __int8 *v37;
  unsigned int v38;
  unsigned __int8 *v39;
  float v40;
  float v41;
  float v42;
  float v43;
  unsigned int v44;
  uint64_t v45;
  uint64_t *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned __int8 *v49;
  unsigned __int8 *v50;
  unsigned int v51;
  unsigned __int8 *v52;
  int v53;
  unsigned __int8 *v54;
  int v55;
  unsigned __int8 *v56;
  unsigned int v57;
  unsigned __int8 *v58;
  float v59;
  float v60;
  float v61;
  float v62;
  float v63;
  uint64_t *v64;
  float v65;
  float v66;
  float v67;
  unsigned __int8 *v68;
  uint64_t *v69;
  uint64_t v70;
  uint64_t v71;
  unsigned __int8 *v72;
  float v73;
  float v74;
  float v75;
  float v76;
  unsigned int v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned __int8 *v81;
  float v82;
  float v83;
  float v84;
  float v85;
  float v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  int v90;
  uint64_t v91;

  v6 = (unsigned int *)*((_QWORD *)a2 + 2);
  v7 = (unsigned int *)*((_QWORD *)a2 + 4);
  if (v7)
    v91 = *((_QWORD *)a2 + 5) - a5;
  else
    v91 = 0;
  v8 = *((float *)a2 + 2);
  v90 = *a2;
  v9 = *((_QWORD *)a2 + 3) - a5;
  v11 = *((_QWORD *)a2 + 17);
  v10 = *((_QWORD *)a2 + 18);
  v12 = *((_QWORD *)a2 + 9);
  v13 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v13 * a4;
  v15 = *(unsigned __int8 **)(a1 + 32);
  v16 = &v15[(*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
           + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3)];
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v7 != 0);
  if (v17)
  {
    v88 = *((_QWORD *)a2 + 15);
    v89 = *((_QWORD *)a2 + 13);
    v19 = v8 * 0.3;
    v20 = v8 * 0.59;
    v21 = v8 * 0.11;
    v87 = v10 + 16 * a3 + 8;
    while (1)
    {
      if (((v88 - v14) | (v14 - v89)) < 0)
      {
        v24 = 0;
        v23 = 0;
      }
      else
      {
        v22 = ((v14 & (unint64_t)~(-1 << v12)) >> (v12 - 4)) & 0xF;
        if (v22 - 7 >= 9)
          v23 = -v11;
        else
          v23 = v11;
        v24 = weights_19497[v22] & 0xF;
      }
      v25 = &v15[(v14 >> v12) * v11];
      if (v90 == 1)
      {
        if (a5 >= 1)
        {
          v26 = (uint64_t *)v87;
          v27 = a5;
          do
          {
            v28 = *(v26 - 1);
            v29 = *v26;
            v30 = &v25[v28];
            if (v16 >= &v25[v28])
              v31 = &v25[v28];
            else
              v31 = v16;
            if (v15 > v31)
              v31 = v15;
            v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if ((v29 & 0xF) != 0)
            {
              v33 = &v30[v29 >> 4];
              if (v16 < v33)
                v33 = v16;
              if (v15 > v33)
                v33 = v15;
              v34 = (*v33 << 24) | (v33[1] << 16) | (v33[2] << 8);
              if (v24)
              {
                if (v16 >= &v30[v23])
                  v35 = &v30[v23];
                else
                  v35 = v16;
                if (v15 > v35)
                  v35 = v15;
                v36 = (*v35 << 24) | (v35[1] << 16) | (v35[2] << 8);
                v37 = &v30[v23 + (v29 >> 4)];
                if (v16 < v37)
                  v37 = v16;
                if (v15 > v37)
                  v37 = v15;
                v38 = BLEND8_19499[v24];
                v32 = v32 - ((v38 & v32) >> v24) + ((v38 & v36) >> v24);
                v34 = v34 - ((v38 & v34) >> v24) + ((((*v37 << 24) | (v37[1] << 16) | (v37[2] << 8)) & v38) >> v24);
              }
              v32 = v32
                  - ((BLEND8_19499[*v26 & 0xF] & v32) >> (*v26 & 0xF))
                  + ((BLEND8_19499[*v26 & 0xF] & v34) >> (*v26 & 0xF));
            }
            else if (v24)
            {
              v39 = &v30[v23];
              if (v16 < &v30[v23])
                v39 = v16;
              if (v15 > v39)
                v39 = v15;
              v32 = v32
                  - ((BLEND8_19499[v24] & v32) >> v24)
                  + ((((*v39 << 24) | (v39[1] << 16) | (v39[2] << 8)) & BLEND8_19499[v24]) >> v24);
            }
            v40 = *(float *)&_blt_float[HIBYTE(v32)];
            v41 = *(float *)&_blt_float[BYTE2(v32)];
            v42 = *(float *)&_blt_float[BYTE1(v32)];
            if (v8 >= 1.0)
            {
              v43 = (float)((float)(v40 * 0.3) + (float)(v41 * 0.59)) + (float)(v42 * 0.11);
              v44 = 1.0;
            }
            else
            {
              v43 = (float)((float)(v19 * v40) + (float)(v20 * v41)) + (float)(v21 * v42);
              v44 = LODWORD(v8);
            }
            *v6 = bswap32(LODWORD(v43));
            if (v7)
              *v7 = bswap32(v44);
            v26 += 2;
            ++v6;
            v7 = (unsigned int *)((char *)v7 + result);
            --v27;
          }
          while (v27);
        }
        goto LABEL_93;
      }
      if (a5 >= 1)
        break;
LABEL_93:
      v6 += v9;
      v14 += v13;
      v7 += v91;
      if (!--a6)
        return result;
    }
    v46 = (uint64_t *)v87;
    v45 = a5;
    while (1)
    {
      v47 = *(v46 - 1);
      v48 = *v46;
      v49 = &v25[v47];
      if (v16 >= &v25[v47])
        v50 = &v25[v47];
      else
        v50 = v16;
      if (v15 > v50)
        v50 = v15;
      v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      if ((v48 & 0xF) != 0)
      {
        v52 = &v49[v48 >> 4];
        if (v16 < v52)
          v52 = v16;
        if (v15 > v52)
          v52 = v15;
        v53 = (*v52 << 24) | (v52[1] << 16) | (v52[2] << 8);
        if (v24)
        {
          if (v16 >= &v49[v23])
            v54 = &v49[v23];
          else
            v54 = v16;
          if (v15 > v54)
            v54 = v15;
          v55 = (*v54 << 24) | (v54[1] << 16) | (v54[2] << 8);
          v56 = &v49[v23 + (v48 >> 4)];
          if (v16 < v56)
            v56 = v16;
          if (v15 > v56)
            v56 = v15;
          v57 = BLEND8_19499[v24];
          v51 = v51 - ((v57 & v51) >> v24) + ((v57 & v55) >> v24);
          v53 = v53 - ((v57 & v53) >> v24) + ((((*v56 << 24) | (v56[1] << 16) | (v56[2] << 8)) & v57) >> v24);
        }
        v51 = v51
            - ((BLEND8_19499[*v46 & 0xF] & v51) >> (*v46 & 0xF))
            + ((BLEND8_19499[*v46 & 0xF] & v53) >> (*v46 & 0xF));
      }
      else if (v24)
      {
        v58 = &v49[v23];
        if (v16 < &v49[v23])
          v58 = v16;
        if (v15 > v58)
          v58 = v15;
        v51 = v51
            - ((BLEND8_19499[v24] & v51) >> v24)
            + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & BLEND8_19499[v24]) >> v24);
      }
      v59 = *(float *)&_blt_float[HIBYTE(v51)];
      v60 = *(float *)&_blt_float[BYTE2(v51)];
      v61 = *(float *)&_blt_float[BYTE1(v51)];
      if (v8 >= 1.0)
      {
        v62 = (float)((float)(v59 * 0.3) + (float)(v60 * 0.59)) + (float)(v61 * 0.11);
        v63 = 1.0;
      }
      else
      {
        v62 = (float)((float)(v19 * v59) + (float)(v20 * v60)) + (float)(v21 * v61);
        v63 = v8;
      }
      if (v7)
      {
        if (v63 >= 1.0)
          goto LABEL_87;
        if (v63 > 0.0)
        {
          v62 = v62 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v63));
          v63 = v63 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v63));
LABEL_87:
          *v6 = bswap32(LODWORD(v62));
          *v7 = bswap32(LODWORD(v63));
        }
      }
      else
      {
        if (v63 >= 1.0)
          goto LABEL_91;
        if (v63 > 0.0)
        {
          v62 = v62 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v63));
LABEL_91:
          *v6 = bswap32(LODWORD(v62));
        }
      }
      v46 += 2;
      ++v6;
      v7 = (unsigned int *)((char *)v7 + result);
      if (!--v45)
        goto LABEL_93;
    }
  }
  v64 = (uint64_t *)(v10 + 16 * a3);
  v65 = v8 * 0.3;
  v66 = v8 * 0.59;
  v67 = v8 * 0.11;
  do
  {
    v68 = &v15[(v14 >> v12) * v11];
    if (v90 != 1)
    {
      v78 = v64;
      v79 = a5;
      if (a5 < 1)
        goto LABEL_128;
      while (1)
      {
        v80 = *v78;
        v78 += 2;
        v81 = &v68[v80];
        if (v16 < &v68[v80])
          v81 = v16;
        if (v15 > v81)
          v81 = v15;
        v82 = *(float *)&_blt_float[*v81];
        v83 = *(float *)&_blt_float[v81[1]];
        v84 = *(float *)&_blt_float[v81[2]];
        if (v8 >= 1.0)
        {
          v85 = (float)((float)(v82 * 0.3) + (float)(v83 * 0.59)) + (float)(v84 * 0.11);
          v86 = 1.0;
        }
        else
        {
          v85 = (float)((float)(v65 * v82) + (float)(v66 * v83)) + (float)(v67 * v84);
          v86 = v8;
        }
        if (v7)
        {
          if (v86 >= 1.0)
            goto LABEL_122;
          if (v86 > 0.0)
          {
            v85 = v85 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v86));
            v86 = v86 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v86));
LABEL_122:
            *v6 = bswap32(LODWORD(v85));
            *v7 = bswap32(LODWORD(v86));
          }
        }
        else
        {
          if (v86 >= 1.0)
            goto LABEL_126;
          if (v86 > 0.0)
          {
            v85 = v85 + (float)(COERCE_FLOAT(bswap32(*v6)) * (float)(1.0 - v86));
LABEL_126:
            *v6 = bswap32(LODWORD(v85));
          }
        }
        ++v6;
        v7 = (unsigned int *)((char *)v7 + result);
        if (!--v79)
          goto LABEL_128;
      }
    }
    if (a5 >= 1)
    {
      v69 = v64;
      v70 = a5;
      do
      {
        v71 = *v69;
        v69 += 2;
        v72 = &v68[v71];
        if (v16 < &v68[v71])
          v72 = v16;
        if (v15 > v72)
          v72 = v15;
        v73 = *(float *)&_blt_float[*v72];
        v74 = *(float *)&_blt_float[v72[1]];
        v75 = *(float *)&_blt_float[v72[2]];
        if (v8 >= 1.0)
        {
          v76 = (float)((float)(v73 * 0.3) + (float)(v74 * 0.59)) + (float)(v75 * 0.11);
          v77 = 1.0;
        }
        else
        {
          v76 = (float)((float)(v65 * v73) + (float)(v66 * v74)) + (float)(v67 * v75);
          v77 = LODWORD(v8);
        }
        *v6 = bswap32(LODWORD(v76));
        if (v7)
          *v7 = bswap32(v77);
        ++v6;
        v7 = (unsigned int *)((char *)v7 + result);
        --v70;
      }
      while (v70);
    }
LABEL_128:
    v6 += v9;
    v14 += v13;
    v7 += v91;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_image_mark_RGB32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  unsigned int *v8;
  float v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t result;
  char v19;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  int v40;
  unsigned int *v41;
  unsigned int v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int v60;
  unsigned int *v61;
  int v62;
  unsigned int *v63;
  unsigned int v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  uint64_t *v74;
  float v75;
  float v76;
  float v77;
  char *v78;
  uint64_t *v79;
  uint64_t v80;
  uint64_t v81;
  unsigned int *v82;
  unsigned int v83;
  float v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  uint64_t *v91;
  uint64_t v92;
  uint64_t v93;
  unsigned int *v94;
  unsigned int v95;
  float v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  int v110;
  uint64_t v111;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v8 = (unsigned int *)*((_QWORD *)a2 + 4);
  if (v8)
    v111 = *((_QWORD *)a2 + 5) - a5;
  else
    v111 = 0;
  v9 = *((float *)a2 + 2);
  v10 = a2[1];
  v110 = *a2;
  v109 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v108 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v108 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v8 != 0);
  if (v17)
  {
    v107 = *((_QWORD *)a2 + 13);
    v106 = *((_QWORD *)a2 + 15);
    v19 = 32 - v10;
    v20 = v9 * 0.3;
    v21 = v9 * 0.59;
    v22 = v9 * 0.11;
    v105 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v106 - v14) | (v14 - v107)) < 0)
      {
        v25 = 0;
        v24 = 0;
      }
      else
      {
        v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v23 - 7 >= 9)
          v24 = -v12;
        else
          v24 = v12;
        v25 = weights_19497[v23] & 0xF;
      }
      v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v110 == 1)
      {
        if (a5 >= 1)
        {
          v27 = (uint64_t *)v105;
          v28 = a5;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v31 = &v26[v29];
            if (v16 >= (unsigned int *)&v26[v29])
              v32 = (unsigned int *)&v26[v29];
            else
              v32 = v16;
            if (v15 > v32)
              v32 = v15;
            v33 = bswap32(*v32);
            if ((v30 & 0xF) != 0)
            {
              v34 = (unsigned int *)&v31[v30 >> 4];
              if (v16 < v34)
                v34 = v16;
              if (v15 > v34)
                v34 = v15;
              v35 = bswap32(*v34);
              if (v25)
              {
                v36 = (unsigned int *)&v31[v24];
                if (v16 >= v36)
                  v37 = v36;
                else
                  v37 = v16;
                if (v15 > v37)
                  v37 = v15;
                v38 = bswap32(*v37);
                v39 = (unsigned int *)((char *)v36 + (v30 >> 4));
                if (v16 < v39)
                  v39 = v16;
                if (v15 > v39)
                  v39 = v15;
                v40 = BLEND8_19499[v25];
                v33 = v33 - ((v40 & v33) >> v25) + ((v40 & v38) >> v25);
                v35 = v35 - ((v40 & v35) >> v25) + ((bswap32(*v39) & v40) >> v25);
              }
              v33 = v33
                  - ((BLEND8_19499[*v27 & 0xF] & v33) >> (*v27 & 0xF))
                  + ((BLEND8_19499[*v27 & 0xF] & v35) >> (*v27 & 0xF));
            }
            else if (v25)
            {
              v41 = (unsigned int *)&v31[v24];
              if (v16 < (unsigned int *)&v31[v24])
                v41 = v16;
              if (v15 > v41)
                v41 = v15;
              v33 = v33 - ((BLEND8_19499[v25] & v33) >> v25) + ((bswap32(*v41) & BLEND8_19499[v25]) >> v25);
            }
            v42 = __ROL4__(v33, v10);
            v43 = *(float *)&_blt_float[HIBYTE(v42)];
            v44 = *(float *)&_blt_float[BYTE2(v42)];
            v45 = *(float *)&_blt_float[BYTE1(v42)];
            v46 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
            if (v9 >= 1.0)
            {
              v47 = v43 * 0.3;
              v48 = v44 * 0.59;
              v49 = v45 * 0.11;
            }
            else
            {
              v47 = v20 * v43;
              v48 = v21 * v44;
              v49 = v22 * v45;
              v46 = v9 * v46;
            }
            *v7 = bswap32(COERCE_UNSIGNED_INT((float)(v47 + v48) + v49));
            if (v8)
              *v8 = bswap32(LODWORD(v46));
            v27 += 2;
            ++v7;
            v8 = (unsigned int *)((char *)v8 + result);
            --v28;
          }
          while (v28);
        }
        goto LABEL_97;
      }
      if (a5 >= 1)
        break;
LABEL_97:
      v7 += v109;
      v14 += v108;
      v8 += v111;
      if (!--a6)
        return result;
    }
    v51 = (uint64_t *)v105;
    v50 = a5;
    while (1)
    {
      v52 = *(v51 - 1);
      v53 = *v51;
      v54 = &v26[v52];
      if (v16 >= (unsigned int *)&v26[v52])
        v55 = (unsigned int *)&v26[v52];
      else
        v55 = v16;
      if (v15 > v55)
        v55 = v15;
      v56 = bswap32(*v55);
      if ((v53 & 0xF) != 0)
      {
        v57 = (unsigned int *)&v54[v53 >> 4];
        if (v16 < v57)
          v57 = v16;
        if (v15 > v57)
          v57 = v15;
        v58 = bswap32(*v57);
        if (v25)
        {
          if (v16 >= (unsigned int *)&v54[v24])
            v59 = (unsigned int *)&v54[v24];
          else
            v59 = v16;
          if (v15 > v59)
            v59 = v15;
          v60 = bswap32(*v59);
          v61 = (unsigned int *)&v54[v24 + (v53 >> 4)];
          if (v16 < v61)
            v61 = v16;
          if (v15 > v61)
            v61 = v15;
          v62 = BLEND8_19499[v25];
          v56 = v56 - ((v62 & v56) >> v25) + ((v62 & v60) >> v25);
          v58 = v58 - ((v62 & v58) >> v25) + ((bswap32(*v61) & v62) >> v25);
        }
        v56 = v56
            - ((BLEND8_19499[*v51 & 0xF] & v56) >> (*v51 & 0xF))
            + ((BLEND8_19499[*v51 & 0xF] & v58) >> (*v51 & 0xF));
      }
      else if (v25)
      {
        v63 = (unsigned int *)&v54[v24];
        if (v16 < (unsigned int *)&v54[v24])
          v63 = v16;
        if (v15 > v63)
          v63 = v15;
        v56 = v56 - ((BLEND8_19499[v25] & v56) >> v25) + ((bswap32(*v63) & BLEND8_19499[v25]) >> v25);
      }
      v64 = __ROL4__(v56, v10);
      v65 = *(float *)&_blt_float[HIBYTE(v64)];
      v66 = *(float *)&_blt_float[BYTE2(v64)];
      v67 = *(float *)&_blt_float[BYTE1(v64)];
      v68 = *(float *)&_blt_float[(((_BYTE)v56 << v10) | (v56 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        v69 = v65 * 0.3;
        v70 = v66 * 0.59;
        v71 = v67 * 0.11;
      }
      else
      {
        v69 = v20 * v65;
        v70 = v21 * v66;
        v71 = v22 * v67;
        v68 = v9 * v68;
      }
      v72 = (float)(v69 + v70) + v71;
      if (v8)
      {
        if (v68 >= 1.0)
          goto LABEL_90;
        if (v68 > 0.0)
        {
          v72 = v72 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v68));
          v68 = v68 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v68));
LABEL_90:
          *v7 = bswap32(LODWORD(v72));
          *v8 = bswap32(LODWORD(v68));
        }
      }
      else
      {
        if (v68 >= 1.0)
        {
          v73 = v72;
LABEL_95:
          *v7 = bswap32(LODWORD(v73));
          goto LABEL_96;
        }
        if (v68 > 0.0)
        {
          v73 = v72 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v68));
          goto LABEL_95;
        }
      }
LABEL_96:
      v51 += 2;
      ++v7;
      v8 = (unsigned int *)((char *)v8 + result);
      if (!--v50)
        goto LABEL_97;
    }
  }
  v74 = (uint64_t *)(v11 + 16 * a3);
  v75 = v9 * 0.3;
  v76 = v9 * 0.59;
  v77 = v9 * 0.11;
  do
  {
    v78 = (char *)v15 + (v14 >> v13) * v12;
    if (v110 != 1)
    {
      v91 = v74;
      v92 = a5;
      if (a5 < 1)
        goto LABEL_133;
      while (1)
      {
        v93 = *v91;
        v91 += 2;
        v94 = (unsigned int *)&v78[v93];
        if (v16 < (unsigned int *)&v78[v93])
          v94 = v16;
        if (v15 > v94)
          v94 = v15;
        v95 = __ROL4__(bswap32(*v94), v10);
        v96 = *(float *)&_blt_float[HIBYTE(v95)];
        v97 = *(float *)&_blt_float[BYTE2(v95)];
        v98 = *(float *)&_blt_float[BYTE1(v95)];
        v99 = *(float *)&_blt_float[v95 | v6];
        if (v9 >= 1.0)
        {
          v100 = v96 * 0.3;
          v101 = v97 * 0.59;
          v102 = v98 * 0.11;
        }
        else
        {
          v100 = v75 * v96;
          v101 = v76 * v97;
          v102 = v77 * v98;
          v99 = v9 * v99;
        }
        v103 = (float)(v100 + v101) + v102;
        if (v8)
        {
          if (v99 >= 1.0)
            goto LABEL_126;
          if (v99 > 0.0)
          {
            v103 = v103 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v99));
            v99 = v99 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v99));
LABEL_126:
            *v7 = bswap32(LODWORD(v103));
            *v8 = bswap32(LODWORD(v99));
          }
        }
        else
        {
          if (v99 >= 1.0)
          {
            v104 = v103;
LABEL_131:
            *v7 = bswap32(LODWORD(v104));
            goto LABEL_132;
          }
          if (v99 > 0.0)
          {
            v104 = v103 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v99));
            goto LABEL_131;
          }
        }
LABEL_132:
        ++v7;
        v8 = (unsigned int *)((char *)v8 + result);
        if (!--v92)
          goto LABEL_133;
      }
    }
    if (a5 >= 1)
    {
      v79 = v74;
      v80 = a5;
      do
      {
        v81 = *v79;
        v79 += 2;
        v82 = (unsigned int *)&v78[v81];
        if (v16 < (unsigned int *)&v78[v81])
          v82 = v16;
        if (v15 > v82)
          v82 = v15;
        v83 = __ROL4__(bswap32(*v82), v10);
        v84 = *(float *)&_blt_float[HIBYTE(v83)];
        v85 = *(float *)&_blt_float[BYTE2(v83)];
        v86 = *(float *)&_blt_float[BYTE1(v83)];
        v87 = *(float *)&_blt_float[v83 | v6];
        if (v9 >= 1.0)
        {
          v88 = v84 * 0.3;
          v89 = v85 * 0.59;
          v90 = v86 * 0.11;
        }
        else
        {
          v88 = v75 * v84;
          v89 = v76 * v85;
          v90 = v77 * v86;
          v87 = v9 * v87;
        }
        *v7 = bswap32(COERCE_UNSIGNED_INT((float)(v88 + v89) + v90));
        if (v8)
          *v8 = bswap32(LODWORD(v87));
        ++v7;
        v8 = (unsigned int *)((char *)v8 + result);
        --v80;
      }
      while (v80);
    }
LABEL_133:
    v7 += v109;
    v14 += v108;
    v8 += v111;
    --a6;
  }
  while (a6);
  return result;
}

uint64_t WF_image_mark_rgb32(uint64_t a1, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  unsigned int *v8;
  float v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int *v16;
  uint64_t v17;
  uint64_t result;
  char v19;
  float v20;
  float v21;
  float v22;
  unint64_t v23;
  uint64_t v24;
  int v25;
  char *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t v53;
  char *v54;
  unsigned int *v55;
  unsigned int v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int *v62;
  unsigned int v63;
  unsigned int *v64;
  unsigned int v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  uint64_t *v75;
  float v76;
  float v77;
  float v78;
  char *v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  unsigned int *v83;
  unsigned int v84;
  float v85;
  float v86;
  float v87;
  float v88;
  float v89;
  float v90;
  float v91;
  uint64_t *v92;
  uint64_t v93;
  uint64_t v94;
  unsigned int *v95;
  unsigned int v96;
  float v97;
  float v98;
  float v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  uint64_t v112;

  if (*(_QWORD *)(a1 + 40))
    v6 = 0;
  else
    v6 = 255;
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v8 = (unsigned int *)*((_QWORD *)a2 + 4);
  if (v8)
    v112 = *((_QWORD *)a2 + 5) - a5;
  else
    v112 = 0;
  v9 = *((float *)a2 + 2);
  v10 = a2[1];
  v111 = *a2;
  v110 = *((_QWORD *)a2 + 3) - a5;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v109 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v109 * a4;
  v15 = *(unsigned int **)(a1 + 32);
  v16 = (unsigned int *)((char *)v15
                       + (*(_DWORD *)(a1 + 260) - 1) * *(_DWORD *)(a1 + 24)
                       + (((*(_DWORD *)(a1 + 8) >> 22) * *(_DWORD *)(a1 + 256)) >> 3));
  v17 = *(_QWORD *)(a1 + 176);
  result = 4 * (v8 != 0);
  if (v17)
  {
    v108 = *((_QWORD *)a2 + 13);
    v107 = *((_QWORD *)a2 + 15);
    v19 = 32 - v10;
    v20 = v9 * 0.3;
    v21 = v9 * 0.59;
    v22 = v9 * 0.11;
    v106 = v11 + 16 * a3 + 8;
    while (1)
    {
      if (((v107 - v14) | (v14 - v108)) < 0)
      {
        v25 = 0;
        v24 = 0;
      }
      else
      {
        v23 = ((v14 & (unint64_t)~(-1 << v13)) >> (v13 - 4)) & 0xF;
        if (v23 - 7 >= 9)
          v24 = -v12;
        else
          v24 = v12;
        v25 = weights_19497[v23] & 0xF;
      }
      v26 = (char *)v15 + (v14 >> v13) * v12;
      if (v111 == 1)
      {
        if (a5 >= 1)
        {
          v27 = (uint64_t *)v106;
          v28 = a5;
          do
          {
            v29 = *(v27 - 1);
            v30 = *v27;
            v31 = &v26[v29];
            if (v16 >= (unsigned int *)&v26[v29])
              v32 = (unsigned int *)&v26[v29];
            else
              v32 = v16;
            if (v15 > v32)
              v32 = v15;
            v33 = *v32;
            if ((v30 & 0xF) != 0)
            {
              v34 = (unsigned int *)&v31[v30 >> 4];
              if (v16 < v34)
                v34 = v16;
              if (v15 > v34)
                v34 = v15;
              v35 = *v34;
              if (v25)
              {
                v36 = (unsigned int *)&v31[v24];
                if (v16 >= v36)
                  v37 = v36;
                else
                  v37 = v16;
                if (v15 > v37)
                  v37 = v15;
                v38 = *v37;
                v39 = (unsigned int *)((char *)v36 + (v30 >> 4));
                if (v16 < v39)
                  v39 = v16;
                if (v15 > v39)
                  v39 = v15;
                v40 = BLEND8_19499[v25];
                v33 = v33 - ((v40 & v33) >> v25) + ((v40 & v38) >> v25);
                v35 = v35 - ((v40 & v35) >> v25) + ((v40 & *v39) >> v25);
              }
              v33 = v33
                  - ((BLEND8_19499[*v27 & 0xF] & v33) >> (*v27 & 0xF))
                  + ((BLEND8_19499[*v27 & 0xF] & v35) >> (*v27 & 0xF));
            }
            else if (v25)
            {
              v41 = (unsigned int *)&v31[v24];
              if (v16 < (unsigned int *)&v31[v24])
                v41 = v16;
              if (v15 > v41)
                v41 = v15;
              v33 = v33 - ((BLEND8_19499[v25] & v33) >> v25) + ((BLEND8_19499[v25] & *v41) >> v25);
            }
            v42 = __ROL4__(v33, v10);
            v43 = *(float *)&_blt_float[HIBYTE(v42)];
            v44 = *(float *)&_blt_float[BYTE2(v42)];
            v45 = *(float *)&_blt_float[BYTE1(v42)];
            v46 = *(float *)&_blt_float[(((_BYTE)v33 << v10) | (v33 >> v19)) | v6];
            if (v9 >= 1.0)
            {
              v47 = v43 * 0.3;
              v48 = v44 * 0.59;
              v49 = v45 * 0.11;
            }
            else
            {
              v47 = v20 * v43;
              v48 = v21 * v44;
              v49 = v22 * v45;
              v46 = v9 * v46;
            }
            *v7 = bswap32(COERCE_UNSIGNED_INT((float)(v47 + v48) + v49));
            if (v8)
              *v8 = bswap32(LODWORD(v46));
            v27 += 2;
            ++v7;
            v8 = (unsigned int *)((char *)v8 + result);
            --v28;
          }
          while (v28);
        }
        goto LABEL_97;
      }
      if (a5 >= 1)
        break;
LABEL_97:
      v7 += v110;
      v14 += v109;
      v8 += v112;
      if (!--a6)
        return result;
    }
    v51 = (uint64_t *)v106;
    v50 = a5;
    while (1)
    {
      v52 = *(v51 - 1);
      v53 = *v51;
      v54 = &v26[v52];
      if (v16 >= (unsigned int *)&v26[v52])
        v55 = (unsigned int *)&v26[v52];
      else
        v55 = v16;
      if (v15 > v55)
        v55 = v15;
      v56 = *v55;
      if ((v53 & 0xF) != 0)
      {
        v57 = (unsigned int *)&v54[v53 >> 4];
        if (v16 < v57)
          v57 = v16;
        if (v15 > v57)
          v57 = v15;
        v58 = *v57;
        if (v25)
        {
          v59 = (unsigned int *)&v54[v24];
          if (v16 >= v59)
            v60 = v59;
          else
            v60 = v16;
          if (v15 > v60)
            v60 = v15;
          v61 = *v60;
          v62 = (unsigned int *)((char *)v59 + (v53 >> 4));
          if (v16 < v62)
            v62 = v16;
          if (v15 > v62)
            v62 = v15;
          v63 = BLEND8_19499[v25];
          v56 = v56 - ((v63 & v56) >> v25) + ((v63 & v61) >> v25);
          v58 = v58 - ((v63 & v58) >> v25) + ((v63 & *v62) >> v25);
        }
        v56 = v56
            - ((BLEND8_19499[*v51 & 0xF] & v56) >> (*v51 & 0xF))
            + ((BLEND8_19499[*v51 & 0xF] & v58) >> (*v51 & 0xF));
      }
      else if (v25)
      {
        v64 = (unsigned int *)&v54[v24];
        if (v16 < (unsigned int *)&v54[v24])
          v64 = v16;
        if (v15 > v64)
          v64 = v15;
        v56 = v56 - ((BLEND8_19499[v25] & v56) >> v25) + ((BLEND8_19499[v25] & *v64) >> v25);
      }
      v65 = __ROL4__(v56, v10);
      v66 = *(float *)&_blt_float[HIBYTE(v65)];
      v67 = *(float *)&_blt_float[BYTE2(v65)];
      v68 = *(float *)&_blt_float[BYTE1(v65)];
      v69 = *(float *)&_blt_float[(((_BYTE)v56 << v10) | (v56 >> v19)) | v6];
      if (v9 >= 1.0)
      {
        v70 = v66 * 0.3;
        v71 = v67 * 0.59;
        v72 = v68 * 0.11;
      }
      else
      {
        v70 = v20 * v66;
        v71 = v21 * v67;
        v72 = v22 * v68;
        v69 = v9 * v69;
      }
      v73 = (float)(v70 + v71) + v72;
      if (v8)
      {
        if (v69 >= 1.0)
          goto LABEL_90;
        if (v69 > 0.0)
        {
          v73 = v73 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v69));
          v69 = v69 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v69));
LABEL_90:
          *v7 = bswap32(LODWORD(v73));
          *v8 = bswap32(LODWORD(v69));
        }
      }
      else
      {
        if (v69 >= 1.0)
        {
          v74 = v73;
LABEL_95:
          *v7 = bswap32(LODWORD(v74));
          goto LABEL_96;
        }
        if (v69 > 0.0)
        {
          v74 = v73 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v69));
          goto LABEL_95;
        }
      }
LABEL_96:
      v51 += 2;
      ++v7;
      v8 = (unsigned int *)((char *)v8 + result);
      if (!--v50)
        goto LABEL_97;
    }
  }
  v75 = (uint64_t *)(v11 + 16 * a3);
  v76 = v9 * 0.3;
  v77 = v9 * 0.59;
  v78 = v9 * 0.11;
  do
  {
    v79 = (char *)v15 + (v14 >> v13) * v12;
    if (v111 != 1)
    {
      v92 = v75;
      v93 = a5;
      if (a5 < 1)
        goto LABEL_133;
      while (1)
      {
        v94 = *v92;
        v92 += 2;
        v95 = (unsigned int *)&v79[v94];
        if (v16 < (unsigned int *)&v79[v94])
          v95 = v16;
        if (v15 > v95)
          v95 = v15;
        v96 = __ROL4__(*v95, v10);
        v97 = *(float *)&_blt_float[HIBYTE(v96)];
        v98 = *(float *)&_blt_float[BYTE2(v96)];
        v99 = *(float *)&_blt_float[BYTE1(v96)];
        v100 = *(float *)&_blt_float[v96 | v6];
        if (v9 >= 1.0)
        {
          v101 = v97 * 0.3;
          v102 = v98 * 0.59;
          v103 = v99 * 0.11;
        }
        else
        {
          v101 = v76 * v97;
          v102 = v77 * v98;
          v103 = v78 * v99;
          v100 = v9 * v100;
        }
        v104 = (float)(v101 + v102) + v103;
        if (v8)
        {
          if (v100 >= 1.0)
            goto LABEL_126;
          if (v100 > 0.0)
          {
            v104 = v104 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v100));
            v100 = v100 + (float)(COERCE_FLOAT(bswap32(*v8)) * (float)(1.0 - v100));
LABEL_126:
            *v7 = bswap32(LODWORD(v104));
            *v8 = bswap32(LODWORD(v100));
          }
        }
        else
        {
          if (v100 >= 1.0)
          {
            v105 = v104;
LABEL_131:
            *v7 = bswap32(LODWORD(v105));
            goto LABEL_132;
          }
          if (v100 > 0.0)
          {
            v105 = v104 + (float)(COERCE_FLOAT(bswap32(*v7)) * (float)(1.0 - v100));
            goto LABEL_131;
          }
        }
LABEL_132:
        ++v7;
        v8 = (unsigned int *)((char *)v8 + result);
        if (!--v93)
          goto LABEL_133;
      }
    }
    if (a5 >= 1)
    {
      v80 = v75;
      v81 = a5;
      do
      {
        v82 = *v80;
        v80 += 2;
        v83 = (unsigned int *)&v79[v82];
        if (v16 < (unsigned int *)&v79[v82])
          v83 = v16;
        if (v15 > v83)
          v83 = v15;
        v84 = __ROL4__(*v83, v10);
        v85 = *(float *)&_blt_float[HIBYTE(v84)];
        v86 = *(float *)&_blt_float[BYTE2(v84)];
        v87 = *(float *)&_blt_float[BYTE1(v84)];
        v88 = *(float *)&_blt_float[v84 | v6];
        if (v9 >= 1.0)
        {
          v89 = v85 * 0.3;
          v90 = v86 * 0.59;
          v91 = v87 * 0.11;
        }
        else
        {
          v89 = v76 * v85;
          v90 = v77 * v86;
          v91 = v78 * v87;
          v88 = v9 * v88;
        }
        *v7 = bswap32(COERCE_UNSIGNED_INT((float)(v89 + v90) + v91));
        if (v8)
          *v8 = bswap32(LODWORD(v88));
        ++v7;
        v8 = (unsigned int *)((char *)v8 + result);
        --v81;
      }
      while (v81);
    }
LABEL_133:
    v7 += v110;
    v14 += v109;
    v8 += v112;
    --a6;
  }
  while (a6);
  return result;
}

void WF_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  _QWORD *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int *v31;
  uint64_t v32;
  int v33;
  int v34;
  int v35;
  _QWORD *v36;
  uint64_t v37;
  int *v38;
  uint64_t v39;
  unsigned __int8 *v40;
  int *v41;
  int v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  int *v46;
  float32x2_t *v47;
  unsigned __int8 *v48;
  unsigned int v49;
  float v50;
  int v51;
  _BYTE *v52;
  int v53;
  uint64_t v54;
  int v55;
  float v56;
  BOOL v57;
  uint64_t v58;
  uint64_t v59;
  float *v60;
  unint64_t v61;
  unint64_t v62;
  float *v63;
  unint64_t v64;
  unint64_t v65;
  __int128 *v66;
  uint64_t v67;
  int v68;
  unsigned __int8 *v69;
  unsigned int v70;
  float v71;
  unsigned int v72;
  unsigned int v73;
  unsigned __int8 v74;
  unsigned int *v75;
  float *v76;
  unsigned __int8 *v77;
  unsigned int *v78;
  int v79;
  unsigned int v80;
  float v81;
  unsigned int v82;
  float v83;
  unsigned __int8 v84;
  unsigned __int8 v85;
  uint64_t v86;
  _BYTE *v87;
  uint64_t v88;
  unsigned int v89;
  float v90;
  unsigned int v91;
  float v92;
  float v93;
  unsigned int v94;
  unsigned int v95;
  unsigned int *v96;
  float *v97;
  int v98;
  unsigned int v99;
  float v100;
  float v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float *v107;
  int v108;
  unsigned int v109;
  float v110;
  float v111;
  float v112;
  float v113;
  float v114;
  float v115;
  float v116;
  float *v117;
  int v118;
  unsigned int v119;
  unsigned int v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float *v125;
  int v126;
  unsigned int v127;
  unsigned int v128;
  float v129;
  float v130;
  float v131;
  float v132;
  float v133;
  float v134;
  uint64_t v135;
  float *v136;
  int v137;
  unsigned int v138;
  float v139;
  float v140;
  float v141;
  float v142;
  float v143;
  float v144;
  float v145;
  unsigned int v146;
  float v147;
  float v148;
  uint64_t v149;
  float *v150;
  int v151;
  unsigned int v152;
  float v153;
  float v154;
  float v155;
  float v156;
  float v157;
  float v158;
  float v159;
  float v160;
  unsigned int v161;
  float v162;
  float v163;
  float *v164;
  int v165;
  unsigned int v166;
  unsigned int v167;
  float v168;
  float v169;
  float v170;
  float v171;
  float v172;
  float *v173;
  int v174;
  unsigned int v175;
  unsigned int v176;
  float v177;
  float v178;
  float v179;
  float v180;
  uint64_t v181;
  float *v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  float v186;
  float v187;
  float v188;
  float v189;
  float v190;
  float v191;
  unsigned int v192;
  unsigned int v193;
  uint64_t v194;
  float *v195;
  int v196;
  unsigned int v197;
  unsigned int v198;
  float v199;
  float v200;
  float v201;
  float v202;
  float *v203;
  int v204;
  unsigned int v205;
  unsigned int v206;
  float v207;
  float v208;
  float v209;
  float v210;
  float v211;
  float v212;
  float *v213;
  int v214;
  unsigned int v215;
  unsigned int v216;
  float v217;
  float v218;
  float v219;
  float v220;
  float v221;
  float *v222;
  int v223;
  unsigned __int8 *v224;
  unsigned int v225;
  unsigned int v226;
  float v227;
  float v228;
  float v229;
  float v230;
  __int128 *v231;
  float v232;
  float v233;
  float *v234;
  int v235;
  unsigned int v236;
  unsigned int v237;
  float v238;
  float v239;
  float v240;
  float v241;
  float v242;
  float v243;
  float v244;
  float *v245;
  int v246;
  unsigned int v247;
  unsigned int v248;
  float v249;
  float v250;
  float v251;
  float v252;
  float v253;
  float v254;
  float v255;
  float *v256;
  int v257;
  unsigned int v258;
  unsigned int v259;
  float v260;
  float v261;
  float v262;
  float v263;
  __int128 *v264;
  float v265;
  float v266;
  float *v267;
  int v268;
  unsigned int v269;
  unsigned int v270;
  float v271;
  float v272;
  float v273;
  float v274;
  __int128 *v275;
  float v276;
  float v277;
  float *v278;
  int v279;
  unsigned int v280;
  unsigned int v281;
  float v282;
  float v283;
  float v284;
  float v285;
  __int128 *v286;
  float v287;
  float v288;
  float *v289;
  int v290;
  unsigned int v291;
  unsigned int v292;
  float v293;
  float v294;
  float v295;
  float v296;
  __int128 *v297;
  float v298;
  float v299;
  float *v300;
  int v301;
  unsigned int v302;
  unsigned int v303;
  float v304;
  float v305;
  float v306;
  float v307;
  float v308;
  float v309;
  float v310;
  float v311;
  float v312;
  float *v313;
  int v314;
  unsigned int v315;
  unsigned int v316;
  float v317;
  float v318;
  float v319;
  float v320;
  float v321;
  float *v322;
  int v323;
  unsigned int v324;
  unsigned int v325;
  float v326;
  float v327;
  float v328;
  float v329;
  float v330;
  float v331;
  float v332;
  float v333;
  float *v334;
  int v335;
  unsigned int v336;
  unsigned int v337;
  float v338;
  float v339;
  float v340;
  float v341;
  float v342;
  float v343;
  float v344;
  float v345;
  float *v346;
  int v347;
  unsigned int v348;
  unsigned int v349;
  float v350;
  float v351;
  float v352;
  float v353;
  float v354;
  float v355;
  float v356;
  float *v357;
  int v358;
  unsigned int v359;
  unsigned int v360;
  float v361;
  float v362;
  float v363;
  float v364;
  float v365;
  float v366;
  float v367;
  float v368;
  unsigned __int8 *v369;
  unsigned int *v370;
  int v371;
  unsigned int v372;
  float v373;
  unsigned __int8 v374;
  unsigned __int8 *v375;
  int v376;
  unsigned int v377;
  float v378;
  float v379;
  float v380;
  float v381;
  unsigned __int8 v382;
  int v383;
  unsigned __int8 *v384;
  unsigned int v385;
  unsigned int v386;
  float v387;
  unsigned int v388;
  float v389;
  unsigned __int8 v390;
  unsigned int *v391;
  uint64_t v392;
  float v393;
  unsigned int v394;
  float v395;
  float v396;
  unsigned int v397;
  unsigned int v398;
  float v399;
  unsigned __int8 v400;
  float v401;
  float v402;
  float v403;
  float v404;
  unsigned __int8 v405;
  uint64_t v406;
  int v407;
  int v408;
  int v409;
  uint64_t v410;
  unint64_t v411;
  void *v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  _QWORD *v416;
  int v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  __n128 v423;
  uint64_t v424;
  int *v425;
  uint64_t v426;
  int v427;
  int v428;
  uint64_t v429;

  v417 = a3;
  v429 = *MEMORY[0x1E0C80C00];
  v4 = *(unsigned int *)(a1 + 4);
  v415 = (int)v4;
  v5 = ((int)v4 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v5 <= 0x1FFFFFF)
  {
    v7 = *(int *)(a1 + 28);
    v9 = *(_QWORD *)(a1 + 40);
    v8 = *(_QWORD *)(a1 + 48);
    a4.n128_u32[0] = *(_DWORD *)(a2 + 184);
    v423 = a4;
    v425 = *(int **)(a1 + 136);
    v10 = *(_QWORD *)(a2 + 104);
    v418 = *(_QWORD *)(a2 + 96);
    v419 = v10;
    v12 = *(int *)(a1 + 12);
    v11 = *(int *)(a1 + 16);
    v427 = *(_DWORD *)(a1 + 8);
    v416 = (_QWORD *)a2;
    v13 = *(int *)(a2 + 16);
    v14 = (v13 + 10) * v5;
    if (v14 > 65439)
    {
      v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0xD472E71uLL);
      v16 = v17;
      v19 = v17;
      v20 = v416;
      if (!v17)
        return;
    }
    else
    {
      MEMORY[0x1E0C80A78](a1, a4);
      v16 = (char *)&v411 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, v15);
      v19 = 0;
      v20 = v416;
    }
    v412 = v19;
    v21 = v7 >> 2;
    v22 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
    v23 = v22 + ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((_DWORD)v13)
      v24 = 8 * v5;
    else
      v24 = 0;
    v25 = v23 + v24;
    v20[18] = v22;
    v20[19] = v23 + v24;
    v20[20] = v23;
    if (v8)
    {
      v26 = (unint64_t)*(int *)(a1 + 32) >> 2;
      v27 = (unsigned int *)(v8 + 4 * (v12 + v26 * v11));
      v28 = v415;
      v424 = v26 - v415;
      v29 = 1;
    }
    else
    {
      v27 = 0;
      v424 = 0;
      v29 = 0;
      v28 = v415;
    }
    v30 = v418;
    v31 = (unsigned int *)(v9 + 4 * (v12 + v21 * v11));
    v422 = v21 - v28;
    v32 = *(int *)(a1 + 104);
    v33 = *(_DWORD *)(a1 + 108);
    v34 = *(unsigned __int8 *)(a1 + 2);
    if (v34 == 6 || v34 == 1)
    {
      v35 = v417;
      v36 = v416;
      v37 = v419;
      if (v425)
      {
        v411 = v21;
        v38 = 0;
        v428 = 0;
        v39 = *(int *)(a1 + 124);
        v40 = (unsigned __int8 *)v425 + v32 + (int)v39 * (uint64_t)v33;
        v28 = v415;
        v421 = v39 - v415;
        goto LABEL_21;
      }
LABEL_596:
      if (v412)
        free(v412);
      return;
    }
    v411 = v21;
    if (!v425)
    {
      v421 = 0;
      v38 = 0;
      v40 = 0;
      v428 = 0;
      v35 = v417;
      v36 = v416;
      v37 = v419;
      goto LABEL_21;
    }
    v426 = v29;
    shape_enum_clip_alloc((uint64_t)v17, v18, v425, 1, 1, 1, v32, v33, v4, v427);
    if (!v41)
      goto LABEL_596;
    v42 = 0;
    v43 = (int)((v13 * v5 + 15) & 0xFFFFFFF0);
    if (!(_DWORD)v13)
      v43 = 8 * v5;
    v44 = v415;
    v36 = v416;
    v421 = -v415;
    v40 = (unsigned __int8 *)(v25 + v43 + 16);
    v35 = v417;
    v38 = v41;
LABEL_584:
    v406 = v424 + v44;
    while (1)
    {
      v428 = v42;
      while (1)
      {
        v407 = *((_DWORD *)v40 - 4);
        v408 = v407 - v42;
        if (v407 > v42)
          break;
        if (v42 < *((_DWORD *)v40 - 3) + v407)
        {
          v28 = v415;
          v37 = v419;
          v29 = v426;
LABEL_21:
          v413 = -v28;
          v414 = (v4 - 1) + 1;
          v45 = 4 * v29;
          v46 = v38;
          v420 = v4;
          v426 = v29;
LABEL_22:
          v425 = v46;
          ((void (*)(_QWORD *, uint64_t, uint64_t, uint64_t))*v36)(v36, v30, v37, v4);
          v47 = (float32x2_t *)v36[20];
          v48 = (unsigned __int8 *)v36[18];
          v49 = *((_DWORD *)v36 + 2);
          if (v49 == *((_DWORD *)v36 + 3))
          {
            v50 = v423.n128_f32[0];
            if (v423.n128_f32[0] >= 1.0)
            {
              v53 = v426;
            }
            else
            {
              v51 = v4;
              v52 = (_BYTE *)v36[18];
              v53 = v426;
              do
              {
                if (*v52)
                  *v47 = vmul_n_f32(*v47, v50);
                ++v52;
                ++v47;
                --v51;
              }
              while (v51);
              v47 += v413;
              v48 += v414 + v413;
            }
          }
          else
          {
            v54 = v36[19];
            v55 = HIWORD(v49) & 0x3F;
            v56 = v423.n128_f32[0];
            if (v55 == 16)
            {
              v53 = v426;
              v59 = 0;
              v60 = (float *)v47 + 1;
              if (v423.n128_f32[0] >= 1.0)
              {
                do
                {
                  if (v48[v59])
                  {
                    v62 = *(unsigned int *)(v54 + 4 * v59);
                    *(v60 - 1) = *(float *)&_blt_float[v62 + 256]
                               + *(float *)&_blt_float[BYTE1(v62) + 512];
                    *v60 = *(float *)&_blt_float[BYTE2(v62) + 256]
                         + *(float *)((char *)&_blt_float[512] + ((v62 >> 22) & 0x3FC));
                  }
                  ++v59;
                  v60 += 2;
                }
                while ((_DWORD)v4 != (_DWORD)v59);
              }
              else
              {
                do
                {
                  if (v48[v59])
                  {
                    v61 = *(unsigned int *)(v54 + 4 * v59);
                    *(v60 - 1) = v56
                               * (float)(*(float *)&_blt_float[v61 + 256]
                                       + *(float *)&_blt_float[BYTE1(v61) + 512]);
                    *v60 = v56
                         * (float)(*(float *)&_blt_float[BYTE2(v61) + 256]
                                 + *(float *)((char *)&_blt_float[512] + ((v61 >> 22) & 0x3FC)));
                  }
                  ++v59;
                  v60 += 2;
                }
                while ((_DWORD)v4 != (_DWORD)v59);
              }
            }
            else
            {
              v57 = v55 == 32;
              v53 = v426;
              v58 = 0;
              if (v57)
              {
                if (v423.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v48[v58])
                      v47[v58] = *(float32x2_t *)(v54 + 8 * v58);
                    ++v58;
                  }
                  while ((_DWORD)v4 != (_DWORD)v58);
                }
                else
                {
                  do
                  {
                    if (v48[v58])
                      v47[v58] = vmul_n_f32(*(float32x2_t *)(v54 + 8 * v58), v56);
                    ++v58;
                  }
                  while ((_DWORD)v4 != (_DWORD)v58);
                }
              }
              else
              {
                v63 = (float *)v47 + 1;
                if (v423.n128_f32[0] >= 1.0)
                {
                  do
                  {
                    if (v48[v58])
                    {
                      v65 = *(unsigned int *)(v54 + 4 * v58);
                      *(v63 - 1) = *(float *)&_blt_float[*(_DWORD *)(v54 + 4 * v58)];
                      *v63 = *(float *)((char *)_blt_float + ((v65 >> 22) & 0x3FC));
                    }
                    ++v58;
                    v63 += 2;
                  }
                  while ((_DWORD)v4 != (_DWORD)v58);
                }
                else
                {
                  do
                  {
                    if (v48[v58])
                    {
                      v64 = *(unsigned int *)(v54 + 4 * v58);
                      *(v63 - 1) = v56 * *(float *)&_blt_float[*(_DWORD *)(v54 + 4 * v58)];
                      *v63 = v56 * *(float *)((char *)_blt_float + ((v64 >> 22) & 0x3FC));
                    }
                    ++v58;
                    v63 += 2;
                  }
                  while ((_DWORD)v4 != (_DWORD)v58);
                }
              }
            }
          }
          v66 = &xmmword_185005000;
          switch(v35)
          {
            case 0:
              v67 = v40 != 0;
              v68 = v4;
              v69 = v40;
              if (v53)
              {
                do
                {
                  v70 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v70 = (*v69 * v70 + ((*v69 * v70) >> 8) + 1) >> 8;
                    if ((_BYTE)v70)
                    {
                      if (v70 == 255)
                      {
                        *v27 = 0;
                        *v31 = 0;
                      }
                      else
                      {
                        v71 = (float)((float)v70 * -0.0039216) + 1.0;
                        *(float *)&v72 = v71 * COERCE_FLOAT(bswap32(*v27));
                        *v31 = bswap32(COERCE_UNSIGNED_INT(v71 * COERCE_FLOAT(bswap32(*v31))));
                        *v27 = bswap32(v72);
                      }
                    }
                  }
                  ++v48;
                  v69 += v67;
                  ++v31;
                  ++v27;
                  --v68;
                }
                while (v68);
              }
              else
              {
                do
                {
                  v73 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v73 = (*v69 * v73 + ((*v69 * v73) >> 8) + 1) >> 8;
                    if ((_BYTE)v73)
                    {
                      if (v73 == 255)
                        *v31 = 0;
                      else
                        *v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)((float)v73 * -0.0039216) + 1.0)* COERCE_FLOAT(bswap32(*v31))));
                    }
                  }
                  ++v48;
                  v69 += v67;
                  ++v31;
                  --v68;
                }
                while (v68);
              }
              goto LABEL_499;
            case 1:
              v74 = *v48;
              if (v53)
              {
                v75 = v31 - 1;
                v76 = (float *)v47 + 1;
                v77 = v48 + 1;
                v78 = v27 - 1;
                v79 = v4;
                if (v40)
                {
                  v38 = v425;
                  do
                  {
                    if (v74)
                    {
                      v80 = ((unsigned __int16)(*v40 * v74 + ((*v40 * v74) >> 8) + 1) >> 8);
                      if (v80)
                      {
                        if (v80 == 255)
                        {
                          v81 = *v76;
                          v82 = bswap32(*((_DWORD *)v76 - 1));
                        }
                        else
                        {
                          v83 = (float)v80 * 0.0039216;
                          v82 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v83) * COERCE_FLOAT(bswap32(v75[1])))+ (float)(*(v76 - 1) * v83)));
                          v81 = (float)((float)(1.0 - v83) * COERCE_FLOAT(bswap32(v78[1]))) + (float)(*v76 * v83);
                        }
                        v75[1] = v82;
                        v78[1] = bswap32(LODWORD(v81));
                      }
                    }
                    v84 = *v77++;
                    v74 = v84;
                    ++v40;
                    ++v75;
                    v76 += 2;
                    ++v78;
                    --v79;
                  }
                  while (v79);
                  v40 += v421;
                }
                else
                {
                  v38 = v425;
                  do
                  {
                    if (v74)
                    {
                      if (v74 == 255)
                      {
                        v387 = *v76;
                        v388 = bswap32(*((_DWORD *)v76 - 1));
                      }
                      else
                      {
                        v389 = (float)v74 * 0.0039216;
                        v388 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v389) * COERCE_FLOAT(bswap32(v75[1])))+ (float)(*(v76 - 1) * v389)));
                        v387 = (float)((float)(1.0 - v389) * COERCE_FLOAT(bswap32(v78[1]))) + (float)(*v76 * v389);
                      }
                      v75[1] = v388;
                      v78[1] = bswap32(LODWORD(v387));
                    }
                    v390 = *v77++;
                    v74 = v390;
                    ++v75;
                    v76 += 2;
                    ++v78;
                    --v79;
                  }
                  while (v79);
                  v40 = 0;
                }
                v391 = &v75[v422];
                goto LABEL_561;
              }
              v369 = v48 + 1;
              v370 = v31 - 1;
              v371 = v4;
              if (v40)
              {
                v38 = v425;
                do
                {
                  if (v74)
                  {
                    v372 = ((unsigned __int16)(*v40 * v74 + ((*v40 * v74) >> 8) + 1) >> 8);
                    if (v372)
                    {
                      if (v372 == 255)
                        v373 = v47->f32[0];
                      else
                        v373 = (float)((float)(1.0 - (float)((float)v372 * 0.0039216)) * COERCE_FLOAT(bswap32(v370[1])))
                             + (float)(v47->f32[0] * (float)((float)v372 * 0.0039216));
                      v370[1] = bswap32(LODWORD(v373));
                    }
                  }
                  v374 = *v369++;
                  v74 = v374;
                  ++v47;
                  ++v40;
                  ++v370;
                  --v371;
                }
                while (v371);
                goto LABEL_529;
              }
              v38 = v425;
              do
              {
                if (v74)
                {
                  if (v74 == 255)
                    v399 = v47->f32[0];
                  else
                    v399 = (float)((float)(1.0 - (float)((float)v74 * 0.0039216)) * COERCE_FLOAT(bswap32(v370[1])))
                         + (float)(v47->f32[0] * (float)((float)v74 * 0.0039216));
                  v370[1] = bswap32(LODWORD(v399));
                }
                v400 = *v369++;
                v74 = v400;
                ++v47;
                ++v370;
                --v371;
              }
              while (v371);
              goto LABEL_582;
            case 2:
              v85 = *v48;
              if (v53)
              {
                v86 = 0;
                v87 = v48 + 1;
                if (v40)
                {
                  v88 = 0x3FFFFFFFFFFFFFFFLL;
                  v38 = v425;
                  while (1)
                  {
                    if (!v85)
                      goto LABEL_104;
                    v89 = ((unsigned __int16)(v40[v86] * v85 + ((v40[v86] * v85) >> 8) + 1) >> 8);
                    if (!v89)
                      goto LABEL_104;
                    if (v89 == 255)
                    {
                      v90 = v47->f32[1];
                      if (v90 >= 1.0)
                      {
                        v95 = v47->i32[0];
                        goto LABEL_103;
                      }
                      if (v90 > 0.0)
                      {
                        v91 = v31[v86];
                        v92 = v47->f32[0];
                        goto LABEL_101;
                      }
                    }
                    else
                    {
                      v93 = (float)v89 * 0.0039216;
                      v90 = v93 * v47->f32[1];
                      if (v90 > 0.0)
                      {
                        v91 = v31[v86];
                        v92 = v93 * v47->f32[0];
LABEL_101:
                        *(float *)&v94 = v92 + (float)(COERCE_FLOAT(bswap32(v91)) * (float)(1.0 - v90));
                        v90 = v90 + (float)(COERCE_FLOAT(bswap32(v27[v86])) * (float)(1.0 - v90));
                        v95 = v94;
LABEL_103:
                        v31[v86] = bswap32(v95);
                        v27[v86] = bswap32(LODWORD(v90));
                      }
                    }
LABEL_104:
                    v85 = v87[v86];
                    ++v47;
                    ++v86;
                    ++v88;
                    if ((_DWORD)v4 == (_DWORD)v86)
                    {
                      v96 = &v31[v88];
                      v78 = &v27[v88];
                      v40 += v86 + v421;
LABEL_560:
                      v391 = &v96[v422];
LABEL_561:
                      v31 = v391 + 1;
                      v27 = &v78[v424 + 1];
LABEL_502:
                      if (v427 == 1)
                        goto LABEL_594;
                      --v427;
                      v46 = 0;
                      ++v428;
                      v30 += v36[16];
                      v37 += v36[17];
                      if (v38)
                      {
                        v419 = v37;
                        v44 = v415;
                        v42 = v428;
                        goto LABEL_584;
                      }
                      goto LABEL_22;
                    }
                  }
                }
                v392 = 4;
                v38 = v425;
                while (1)
                {
                  if (v85)
                  {
                    if (v85 == 255)
                    {
                      v393 = v47->f32[1];
                      if (v393 >= 1.0)
                      {
                        v398 = v47->i32[0];
                        goto LABEL_557;
                      }
                      if (v393 > 0.0)
                      {
                        v394 = v31[v86];
                        v395 = v47->f32[0];
                        goto LABEL_555;
                      }
                    }
                    else
                    {
                      v396 = (float)v85 * 0.0039216;
                      v393 = v396 * v47->f32[1];
                      if (v393 > 0.0)
                      {
                        v394 = v31[v86];
                        v395 = v396 * v47->f32[0];
LABEL_555:
                        *(float *)&v397 = v395 + (float)(COERCE_FLOAT(bswap32(v394)) * (float)(1.0 - v393));
                        v393 = v393 + (float)(COERCE_FLOAT(bswap32(v27[v86])) * (float)(1.0 - v393));
                        v398 = v397;
LABEL_557:
                        v31[v86] = bswap32(v398);
                        v27[v86] = bswap32(LODWORD(v393));
                      }
                    }
                  }
                  v85 = v87[v86];
                  ++v47;
                  ++v86;
                  v392 -= 4;
                  if ((_DWORD)v4 == (_DWORD)v86)
                  {
                    v40 = 0;
                    v78 = &v27[v392 / 0xFFFFFFFFFFFFFFFCLL];
                    v96 = &v31[v392 / 0xFFFFFFFFFFFFFFFCLL];
                    goto LABEL_560;
                  }
                }
              }
              v375 = v48 + 1;
              v370 = v31 - 1;
              v376 = v4;
              if (v40)
              {
                v38 = v425;
                while (1)
                {
                  if (!v85)
                    goto LABEL_528;
                  v377 = ((unsigned __int16)(*v40 * v85 + ((*v40 * v85) >> 8) + 1) >> 8);
                  if (!v377)
                    goto LABEL_528;
                  if (v377 == 255)
                  {
                    v378 = v47->f32[1];
                    if (v378 >= 1.0)
                    {
                      v381 = v47->f32[0];
                      goto LABEL_527;
                    }
                    if (v378 > 0.0)
                    {
                      v379 = v47->f32[0];
                      goto LABEL_525;
                    }
                  }
                  else
                  {
                    v380 = (float)v377 * 0.0039216;
                    v378 = v380 * v47->f32[1];
                    if (v378 > 0.0)
                    {
                      v379 = v380 * v47->f32[0];
LABEL_525:
                      v381 = v379 + (float)(COERCE_FLOAT(bswap32(v370[1])) * (float)(1.0 - v378));
LABEL_527:
                      v370[1] = bswap32(LODWORD(v381));
                    }
                  }
LABEL_528:
                  v382 = *v375++;
                  v85 = v382;
                  ++v47;
                  ++v40;
                  ++v370;
                  if (!--v376)
                  {
LABEL_529:
                    v40 += v421;
LABEL_583:
                    v31 = &v370[v422 + 1];
                    v27 += v424;
                    goto LABEL_502;
                  }
                }
              }
              v38 = v425;
              while (1)
              {
                if (v85)
                {
                  if (v85 == 255)
                  {
                    v401 = v47->f32[1];
                    if (v401 >= 1.0)
                    {
                      v404 = v47->f32[0];
                      goto LABEL_580;
                    }
                    if (v401 > 0.0)
                    {
                      v402 = v47->f32[0];
                      goto LABEL_578;
                    }
                  }
                  else
                  {
                    v403 = (float)v85 * 0.0039216;
                    v401 = v403 * v47->f32[1];
                    if (v401 > 0.0)
                    {
                      v402 = v403 * v47->f32[0];
LABEL_578:
                      v404 = v402 + (float)(COERCE_FLOAT(bswap32(v370[1])) * (float)(1.0 - v401));
LABEL_580:
                      v370[1] = bswap32(LODWORD(v404));
                    }
                  }
                }
                v405 = *v375++;
                v85 = v405;
                ++v47;
                ++v370;
                if (!--v376)
                {
LABEL_582:
                  v40 = 0;
                  goto LABEL_583;
                }
              }
            case 3:
              v97 = (float *)v47 + 1;
              v98 = v4;
              v69 = v40;
              do
              {
                v99 = *v48;
                if (*v48)
                {
                  if (v40)
                    v99 = (*v69 * v99 + ((*v69 * v99) >> 8) + 1) >> 8;
                  if ((_BYTE)v99)
                  {
                    if (v99 == 255)
                    {
                      v100 = COERCE_FLOAT(bswap32(*v27));
                      v101 = *(v97 - 1) * v100;
                      v102 = *v97 * v100;
                    }
                    else
                    {
                      v103 = (float)v99 * 0.0039216;
                      v104 = COERCE_FLOAT(bswap32(*v27));
                      v105 = v103 * v104;
                      v106 = 1.0 - v103;
                      v101 = (float)((float)(1.0 - v103) * COERCE_FLOAT(bswap32(*v31)))
                           + (float)(*(v97 - 1) * (float)(v103 * v104));
                      v102 = (float)(v106 * v104) + (float)(*v97 * v105);
                    }
                    *v31 = bswap32(LODWORD(v101));
                    *v27 = bswap32(LODWORD(v102));
                  }
                }
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v97 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                --v98;
              }
              while (v98);
              goto LABEL_499;
            case 4:
              v107 = (float *)v47 + 1;
              v108 = v4;
              v69 = v40;
              do
              {
                v109 = *v48;
                if (*v48)
                {
                  if (v40)
                    v109 = (*v69 * v109 + ((*v69 * v109) >> 8) + 1) >> 8;
                  if ((_BYTE)v109)
                  {
                    if (v109 == 255)
                    {
                      v110 = 1.0 - COERCE_FLOAT(bswap32(*v27));
                      v111 = *(v107 - 1) * v110;
                      v112 = *v107 * v110;
                    }
                    else
                    {
                      v113 = (float)v109 * 0.0039216;
                      v114 = COERCE_FLOAT(bswap32(*v27));
                      v115 = v113 * (float)(1.0 - v114);
                      v116 = 1.0 - v113;
                      v111 = (float)((float)(1.0 - v113) * COERCE_FLOAT(bswap32(*v31))) + (float)(*(v107 - 1) * v115);
                      v112 = (float)(v116 * v114) + (float)(*v107 * v115);
                    }
                    *v31 = bswap32(LODWORD(v111));
                    *v27 = bswap32(LODWORD(v112));
                  }
                }
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v107 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                --v108;
              }
              while (v108);
              goto LABEL_499;
            case 5:
              v117 = (float *)v47 + 1;
              v118 = v4;
              v69 = v40;
              while (1)
              {
                v119 = *v48;
                if (*v48)
                {
                  if (!v40)
                    goto LABEL_133;
                  v120 = *v69 * v119 + ((*v69 * v119) >> 8) + 1;
                  if (BYTE1(v120))
                    break;
                }
LABEL_134:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v117 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v118)
                  goto LABEL_499;
              }
              v119 = v120 >> 8;
LABEL_133:
              v121 = COERCE_FLOAT(bswap32(*v27));
              v122 = (float)v119 * 0.0039216;
              v123 = *(v117 - 1) * v122;
              v124 = v122 * *v117;
              *v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v124) * COERCE_FLOAT(bswap32(*v31))) + (float)(v123 * v121)));
              *v27 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v124) * v121) + (float)(v124 * v121)));
              goto LABEL_134;
            case 6:
              v125 = (float *)v47 + 1;
              v126 = v4;
              v69 = v40;
              while (1)
              {
                v127 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v128 = *v69 * v127 + ((*v69 * v127) >> 8) + 1;
                    if (!BYTE1(v128))
                      goto LABEL_146;
                    v127 = v128 >> 8;
                  }
                  v129 = COERCE_FLOAT(bswap32(*v27));
                  v130 = 1.0 - v129;
                  if ((float)(1.0 - v129) >= 1.0)
                  {
                    v134 = (float)v127 * 0.0039216;
                    v132 = v134 * *(v125 - 1);
                    v133 = v134 * *v125;
                    goto LABEL_145;
                  }
                  if (v130 > 0.0)
                  {
                    v131 = (float)((float)v127 * 0.0039216) * v130;
                    v132 = COERCE_FLOAT(bswap32(*v31)) + (float)(*(v125 - 1) * v131);
                    v133 = v129 + (float)(*v125 * v131);
LABEL_145:
                    *v31 = bswap32(LODWORD(v132));
                    *v27 = bswap32(LODWORD(v133));
                  }
                }
LABEL_146:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v125 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v126)
                  goto LABEL_499;
              }
            case 7:
              v135 = v40 != 0;
              v136 = (float *)v47 + 1;
              v137 = v4;
              v69 = v40;
              if (v53)
              {
                do
                {
                  v138 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v138 = (*v69 * v138 + ((*v69 * v138) >> 8) + 1) >> 8;
                    if ((_BYTE)v138)
                    {
                      if (v138 == 255)
                      {
                        v139 = *v136 * COERCE_FLOAT(bswap32(*v31));
                        v140 = *v136 * COERCE_FLOAT(bswap32(*v27));
                      }
                      else
                      {
                        v141 = (float)v138 * 0.0039216;
                        v142 = COERCE_FLOAT(bswap32(*v27));
                        v143 = COERCE_FLOAT(bswap32(*v31));
                        v144 = v141 * *v136;
                        v145 = 1.0 - v141;
                        v139 = (float)((float)(1.0 - v141) * v143) + (float)(v143 * v144);
                        v140 = (float)(v145 * v142) + (float)(v142 * v144);
                      }
                      *v31 = bswap32(LODWORD(v139));
                      *v27 = bswap32(LODWORD(v140));
                    }
                  }
                  ++v48;
                  v69 += v135;
                  ++v31;
                  ++v27;
                  v136 += 2;
                  --v137;
                }
                while (v137);
              }
              else
              {
                do
                {
                  v146 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v146 = (*v69 * v146 + ((*v69 * v146) >> 8) + 1) >> 8;
                    if ((_BYTE)v146)
                    {
                      if (v146 == 255)
                      {
                        v147 = *v136 * COERCE_FLOAT(bswap32(*v31));
                      }
                      else
                      {
                        v148 = COERCE_FLOAT(bswap32(*v31));
                        v147 = (float)((float)(1.0 - (float)((float)v146 * 0.0039216)) * v148)
                             + (float)(v148 * (float)((float)((float)v146 * 0.0039216) * *v136));
                      }
                      *v31 = bswap32(LODWORD(v147));
                    }
                  }
                  ++v48;
                  v69 += v135;
                  ++v31;
                  v136 += 2;
                  --v137;
                }
                while (v137);
              }
              goto LABEL_499;
            case 8:
              v149 = v40 != 0;
              v150 = (float *)v47 + 1;
              v151 = v4;
              v69 = v40;
              if (v53)
              {
                do
                {
                  v152 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v152 = (*v69 * v152 + ((*v69 * v152) >> 8) + 1) >> 8;
                    if ((_BYTE)v152)
                    {
                      if (v152 == 255)
                      {
                        v153 = 1.0 - *v150;
                        v154 = v153 * COERCE_FLOAT(bswap32(*v31));
                        v155 = v153 * COERCE_FLOAT(bswap32(*v27));
                      }
                      else
                      {
                        v156 = (float)v152 * 0.0039216;
                        v157 = COERCE_FLOAT(bswap32(*v27));
                        v158 = COERCE_FLOAT(bswap32(*v31));
                        v159 = v156 * (float)(1.0 - *v150);
                        v160 = 1.0 - v156;
                        v154 = (float)((float)(1.0 - v156) * v158) + (float)(v158 * v159);
                        v155 = (float)(v160 * v157) + (float)(v157 * v159);
                      }
                      *v31 = bswap32(LODWORD(v154));
                      *v27 = bswap32(LODWORD(v155));
                    }
                  }
                  ++v48;
                  v69 += v149;
                  ++v31;
                  ++v27;
                  v150 += 2;
                  --v151;
                }
                while (v151);
              }
              else
              {
                do
                {
                  v161 = *v48;
                  if (*v48)
                  {
                    if (v40)
                      v161 = (*v69 * v161 + ((*v69 * v161) >> 8) + 1) >> 8;
                    if ((_BYTE)v161)
                    {
                      if (v161 == 255)
                      {
                        v162 = (float)(1.0 - *v150) * COERCE_FLOAT(bswap32(*v31));
                      }
                      else
                      {
                        v163 = COERCE_FLOAT(bswap32(*v31));
                        v162 = (float)((float)(1.0 - (float)((float)v161 * 0.0039216)) * v163)
                             + (float)(v163
                                     * (float)((float)((float)v161 * 0.0039216) * (float)(1.0 - *v150)));
                      }
                      *v31 = bswap32(LODWORD(v162));
                    }
                  }
                  ++v48;
                  v69 += v149;
                  ++v31;
                  v150 += 2;
                  --v151;
                }
                while (v151);
              }
              goto LABEL_499;
            case 9:
              v164 = (float *)v47 + 1;
              v165 = v4;
              v69 = v40;
              while (1)
              {
                v166 = *v48;
                if (*v48)
                {
                  if (!v40)
                    goto LABEL_195;
                  v167 = *v69 * v166 + ((*v69 * v166) >> 8) + 1;
                  if (BYTE1(v167))
                    break;
                }
LABEL_196:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v164 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v165)
                  goto LABEL_499;
              }
              v166 = v167 >> 8;
LABEL_195:
              v168 = COERCE_FLOAT(bswap32(*v27));
              v169 = (float)v166 * 0.0039216;
              v170 = *(v164 - 1) * v169;
              v171 = v169 * *v164;
              v172 = (float)(1.0 - v169) + v171;
              *v31 = bswap32(COERCE_UNSIGNED_INT((float)(v172 * COERCE_FLOAT(bswap32(*v31))) + (float)(v170 * (float)(1.0 - v168))));
              *v27 = bswap32(COERCE_UNSIGNED_INT((float)(v172 * v168) + (float)(v171 * (float)(1.0 - v168))));
              goto LABEL_196;
            case 10:
              v173 = (float *)v47 + 1;
              v174 = v4;
              v69 = v40;
              while (1)
              {
                v175 = *v48;
                if (*v48)
                {
                  if (!v40)
                    goto LABEL_203;
                  v176 = *v69 * v175 + ((*v69 * v175) >> 8) + 1;
                  if (BYTE1(v176))
                    break;
                }
LABEL_204:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v173 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v174)
                  goto LABEL_499;
              }
              v175 = v176 >> 8;
LABEL_203:
              v177 = COERCE_FLOAT(bswap32(*v27));
              v178 = (float)v175 * 0.0039216;
              v179 = *(v173 - 1) * v178;
              v180 = v178 * *v173;
              *v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v180) * COERCE_FLOAT(bswap32(*v31)))+ (float)(v179 * (float)(1.0 - v177))));
              *v27 = bswap32(COERCE_UNSIGNED_INT((float)((float)(1.0 - v180) * v177) + (float)(v180 * (float)(1.0 - v177))));
              goto LABEL_204;
            case 11:
              v181 = v40 != 0;
              v182 = (float *)v47 + 1;
              v183 = v4;
              v69 = v40;
              if (v53)
              {
                while (1)
                {
                  v184 = *v48;
                  if (*v48)
                  {
                    if (!v40)
                      goto LABEL_211;
                    v185 = *v69 * v184 + ((*v69 * v184) >> 8) + 1;
                    if (BYTE1(v185))
                      break;
                  }
LABEL_214:
                  ++v48;
                  v69 += v181;
                  ++v31;
                  ++v27;
                  v182 += 2;
                  if (!--v183)
                    goto LABEL_499;
                }
                v184 = v185 >> 8;
LABEL_211:
                v186 = (float)v184 * 0.0039216;
                v187 = *(v182 - 1) * v186;
                v188 = *v182 * v186;
                v189 = COERCE_FLOAT(bswap32(*v31));
                v190 = COERCE_FLOAT(bswap32(*v27));
                v191 = v188 + v190;
                if ((float)(v188 + v190) > 1.0)
                  v191 = 1.0;
                *v31 = bswap32(COERCE_UNSIGNED_INT((float)(v188 - v187) + (float)(v191 - (float)(v190 - v189))));
                *v27 = bswap32(LODWORD(v191));
                goto LABEL_214;
              }
              while (1)
              {
                v192 = *v48;
                if (*v48)
                {
                  if (!v40)
                    goto LABEL_220;
                  v193 = *v69 * v192 + ((*v69 * v192) >> 8) + 1;
                  if (BYTE1(v193))
                    break;
                }
LABEL_221:
                ++v48;
                v69 += v181;
                ++v31;
                v182 += 2;
                if (!--v183)
                  goto LABEL_499;
              }
              v192 = v193 >> 8;
LABEL_220:
              *v31 = bswap32(COERCE_UNSIGNED_INT((float)((float)(*v182 * (float)((float)v192 * 0.0039216))- (float)(*(v182 - 1) * (float)((float)v192 * 0.0039216)))+ COERCE_FLOAT(bswap32(*v31))));
              goto LABEL_221;
            case 12:
              v194 = v40 != 0;
              if (v53)
              {
                v195 = (float *)v47 + 1;
                v196 = v4;
                v69 = v40;
                while (1)
                {
                  v197 = *v48;
                  if (*v48)
                  {
                    if (!v40)
                      goto LABEL_229;
                    v198 = *v69 * v197 + ((*v69 * v197) >> 8) + 1;
                    if (BYTE1(v198))
                      break;
                  }
LABEL_232:
                  ++v48;
                  v69 += v194;
                  ++v31;
                  ++v27;
                  v195 += 2;
                  if (!--v196)
                    goto LABEL_499;
                }
                v197 = v198 >> 8;
LABEL_229:
                v199 = (float)v197 * 0.0039216;
                v200 = *(v195 - 1) * v199;
                v201 = (float)(*v195 * v199) + COERCE_FLOAT(bswap32(*v27));
                v202 = v200 + COERCE_FLOAT(bswap32(*v31));
                if (v201 > 1.0)
                  v201 = 1.0;
                *v31 = bswap32(LODWORD(v202));
                *v27 = bswap32(LODWORD(v201));
                goto LABEL_232;
              }
              v383 = v4;
              v384 = v40;
              while (1)
              {
                v385 = *v48;
                if (*v48)
                {
                  if (!v40)
                    goto LABEL_535;
                  v386 = *v384 * v385 + ((*v384 * v385) >> 8) + 1;
                  if (BYTE1(v386))
                    break;
                }
LABEL_536:
                ++v48;
                ++v47;
                v384 += v194;
                ++v31;
                if (!--v383)
                {
                  v40 = &v384[v421];
LABEL_500:
                  v31 += v422;
                  v27 += v424;
LABEL_501:
                  v38 = v425;
                  goto LABEL_502;
                }
              }
              v385 = v386 >> 8;
LABEL_535:
              *v31 = bswap32(COERCE_UNSIGNED_INT((float)(v47->f32[0] * (float)((float)v385 * 0.0039216))+ COERCE_FLOAT(bswap32(*v31))));
              goto LABEL_536;
            case 13:
              v203 = (float *)v47 + 1;
              v204 = v4;
              v69 = v40;
              while (1)
              {
                v205 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v206 = *v69 * v205 + ((*v69 * v205) >> 8) + 1;
                    if (!BYTE1(v206))
                      goto LABEL_250;
                    v205 = v206 >> 8;
                  }
                  v207 = (float)v205 * 0.0039216;
                  v208 = *v203 * v207;
                  if (v208 > 0.0)
                  {
                    v209 = *(v203 - 1) * v207;
                    v210 = 1.0;
                    if (!v53 || (v210 = COERCE_FLOAT(bswap32(*v27)), v210 > 0.0))
                    {
                      v211 = COERCE_FLOAT(bswap32(*v31));
                      v212 = (float)(v209 * v211) + (float)(v211 * (float)(1.0 - v208));
                      if (v208 == 1.0)
                        v212 = v209 * v211;
                      v209 = v212 + (float)(v209 * (float)(1.0 - v210));
                      if (v210 == 1.0)
                        v209 = v212;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v209));
                        goto LABEL_250;
                      }
                      v208 = (float)(v208 + v210) - (float)(v210 * v208);
                    }
                    *v31 = bswap32(LODWORD(v209));
                    *v27 = bswap32(LODWORD(v208));
                  }
                }
LABEL_250:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v203 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v204)
                  goto LABEL_499;
              }
            case 14:
              v213 = (float *)v47 + 1;
              v214 = v4;
              v69 = v40;
              while (1)
              {
                v215 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v216 = *v69 * v215 + ((*v69 * v215) >> 8) + 1;
                    if (!BYTE1(v216))
                      goto LABEL_264;
                    v215 = v216 >> 8;
                  }
                  v217 = (float)v215 * 0.0039216;
                  v218 = *v213 * v217;
                  if (v218 > 0.0)
                  {
                    v219 = *(v213 - 1) * v217;
                    v220 = 1.0;
                    if (!v53 || (v220 = COERCE_FLOAT(bswap32(*v27)), v220 > 0.0))
                    {
                      v221 = COERCE_FLOAT(bswap32(*v31));
                      v219 = v221 + (float)(v219 * (float)(1.0 - v221));
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v219));
                        goto LABEL_264;
                      }
                      v218 = (float)(v218 + v220) - (float)(v220 * v218);
                    }
                    *v31 = bswap32(LODWORD(v219));
                    *v27 = bswap32(LODWORD(v218));
                  }
                }
LABEL_264:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v213 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v214)
                  goto LABEL_499;
              }
            case 15:
              v418 = v30;
              v419 = v37;
              v222 = (float *)v47 + 1;
              v223 = v4;
              v224 = v40;
              while (1)
              {
                v225 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v226 = *v224 * v225 + ((*v224 * v225) >> 8) + 1;
                    if (!BYTE1(v226))
                      goto LABEL_280;
                    v225 = v226 >> 8;
                  }
                  v227 = (float)v225 * *((float *)v66 + 159);
                  v228 = *v222 * v227;
                  if (v228 > 0.0)
                  {
                    v229 = *(v222 - 1) * v227;
                    if (v53)
                    {
                      v230 = COERCE_FLOAT(bswap32(*v27));
                      if (v230 <= 0.0)
                      {
LABEL_278:
                        *v31 = bswap32(LODWORD(v229));
                        *v27 = bswap32(LODWORD(v228));
                        goto LABEL_280;
                      }
                    }
                    else
                    {
                      v230 = 1.0;
                    }
                    v231 = v66;
                    v232 = PDAoverlayPDA(COERCE_FLOAT(bswap32(*v31)), v230, v229, v228);
                    v53 = v426;
                    v229 = v232;
                    if (!(_DWORD)v426)
                    {
                      *v31 = bswap32(LODWORD(v232));
                      v66 = v231;
                      v4 = v420;
                      goto LABEL_280;
                    }
                    v228 = v233;
                    v66 = v231;
                    v4 = v420;
                    goto LABEL_278;
                  }
                }
LABEL_280:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v222 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v223)
                  goto LABEL_385;
              }
            case 16:
              v234 = (float *)v47 + 1;
              v235 = v4;
              v69 = v40;
              while (1)
              {
                v236 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v237 = *v69 * v236 + ((*v69 * v236) >> 8) + 1;
                    if (!BYTE1(v237))
                      goto LABEL_300;
                    v236 = v237 >> 8;
                  }
                  v238 = (float)v236 * 0.0039216;
                  v239 = *v234 * v238;
                  if (v239 > 0.0)
                  {
                    v240 = *(v234 - 1) * v238;
                    v241 = 1.0;
                    if (!v53 || (v241 = COERCE_FLOAT(bswap32(*v27)), v241 > 0.0))
                    {
                      v242 = COERCE_FLOAT(bswap32(*v31));
                      v243 = v239 * v242;
                      if ((float)(v240 * v241) < (float)(v239 * v242))
                        v243 = v240 * v241;
                      v244 = v243 + (float)(v242 * (float)(1.0 - v239));
                      if (v239 == 1.0)
                        v244 = v243;
                      v240 = v244 + (float)(v240 * (float)(1.0 - v241));
                      if (v241 == 1.0)
                        v240 = v244;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v240));
                        goto LABEL_300;
                      }
                      v239 = (float)(v239 + v241) - (float)(v241 * v239);
                    }
                    *v31 = bswap32(LODWORD(v240));
                    *v27 = bswap32(LODWORD(v239));
                  }
                }
LABEL_300:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v234 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v235)
                  goto LABEL_499;
              }
            case 17:
              v245 = (float *)v47 + 1;
              v246 = v4;
              v69 = v40;
              while (1)
              {
                v247 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v248 = *v69 * v247 + ((*v69 * v247) >> 8) + 1;
                    if (!BYTE1(v248))
                      goto LABEL_320;
                    v247 = v248 >> 8;
                  }
                  v249 = (float)v247 * 0.0039216;
                  v250 = *v245 * v249;
                  if (v250 > 0.0)
                  {
                    v251 = *(v245 - 1) * v249;
                    v252 = 1.0;
                    if (!v53 || (v252 = COERCE_FLOAT(bswap32(*v27)), v252 > 0.0))
                    {
                      v253 = COERCE_FLOAT(bswap32(*v31));
                      v254 = v250 * v253;
                      if ((float)(v251 * v252) > (float)(v250 * v253))
                        v254 = v251 * v252;
                      v255 = v254 + (float)(v253 * (float)(1.0 - v250));
                      if (v250 == 1.0)
                        v255 = v254;
                      v251 = v255 + (float)(v251 * (float)(1.0 - v252));
                      if (v252 == 1.0)
                        v251 = v255;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v251));
                        goto LABEL_320;
                      }
                      v250 = (float)(v250 + v252) - (float)(v252 * v250);
                    }
                    *v31 = bswap32(LODWORD(v251));
                    *v27 = bswap32(LODWORD(v250));
                  }
                }
LABEL_320:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v245 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v246)
                  goto LABEL_499;
              }
            case 18:
              v418 = v30;
              v419 = v37;
              v256 = (float *)v47 + 1;
              v257 = v4;
              v224 = v40;
              while (1)
              {
                v258 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v259 = *v224 * v258 + ((*v224 * v258) >> 8) + 1;
                    if (!BYTE1(v259))
                      goto LABEL_336;
                    v258 = v259 >> 8;
                  }
                  v260 = (float)v258 * *((float *)v66 + 159);
                  v261 = *v256 * v260;
                  if (v261 > 0.0)
                  {
                    v262 = *(v256 - 1) * v260;
                    if (v53)
                    {
                      v263 = COERCE_FLOAT(bswap32(*v27));
                      if (v263 <= 0.0)
                      {
LABEL_334:
                        *v31 = bswap32(LODWORD(v262));
                        *v27 = bswap32(LODWORD(v261));
                        goto LABEL_336;
                      }
                    }
                    else
                    {
                      v263 = 1.0;
                    }
                    v264 = v66;
                    v265 = PDAcolordodgePDA(COERCE_FLOAT(bswap32(*v31)), v263, v262, v261);
                    v53 = v426;
                    v262 = v265;
                    if (!(_DWORD)v426)
                    {
                      *v31 = bswap32(LODWORD(v265));
                      v66 = v264;
                      v4 = v420;
                      goto LABEL_336;
                    }
                    v261 = v266;
                    v66 = v264;
                    v4 = v420;
                    goto LABEL_334;
                  }
                }
LABEL_336:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v256 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v257)
                  goto LABEL_385;
              }
            case 19:
              v418 = v30;
              v419 = v37;
              v267 = (float *)v47 + 1;
              v268 = v4;
              v224 = v40;
              while (1)
              {
                v269 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v270 = *v224 * v269 + ((*v224 * v269) >> 8) + 1;
                    if (!BYTE1(v270))
                      goto LABEL_352;
                    v269 = v270 >> 8;
                  }
                  v271 = (float)v269 * *((float *)v66 + 159);
                  v272 = *v267 * v271;
                  if (v272 > 0.0)
                  {
                    v273 = *(v267 - 1) * v271;
                    if (v53)
                    {
                      v274 = COERCE_FLOAT(bswap32(*v27));
                      if (v274 <= 0.0)
                      {
LABEL_350:
                        *v31 = bswap32(LODWORD(v273));
                        *v27 = bswap32(LODWORD(v272));
                        goto LABEL_352;
                      }
                    }
                    else
                    {
                      v274 = 1.0;
                    }
                    v275 = v66;
                    v276 = PDAcolorburnPDA(COERCE_FLOAT(bswap32(*v31)), v274, v273, v272);
                    v53 = v426;
                    v273 = v276;
                    if (!(_DWORD)v426)
                    {
                      *v31 = bswap32(LODWORD(v276));
                      v66 = v275;
                      v4 = v420;
                      goto LABEL_352;
                    }
                    v272 = v277;
                    v66 = v275;
                    v4 = v420;
                    goto LABEL_350;
                  }
                }
LABEL_352:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v267 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v268)
                  goto LABEL_385;
              }
            case 20:
              v418 = v30;
              v419 = v37;
              v278 = (float *)v47 + 1;
              v279 = v4;
              v224 = v40;
              while (1)
              {
                v280 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v281 = *v224 * v280 + ((*v224 * v280) >> 8) + 1;
                    if (!BYTE1(v281))
                      goto LABEL_368;
                    v280 = v281 >> 8;
                  }
                  v282 = (float)v280 * *((float *)v66 + 159);
                  v283 = *v278 * v282;
                  if (v283 > 0.0)
                  {
                    v284 = *(v278 - 1) * v282;
                    if (v53)
                    {
                      v285 = COERCE_FLOAT(bswap32(*v27));
                      if (v285 <= 0.0)
                      {
LABEL_366:
                        *v31 = bswap32(LODWORD(v284));
                        *v27 = bswap32(LODWORD(v283));
                        goto LABEL_368;
                      }
                    }
                    else
                    {
                      v285 = 1.0;
                    }
                    v286 = v66;
                    v287 = PDAsoftlightPDA(COERCE_FLOAT(bswap32(*v31)), v285, v284, v283);
                    v53 = v426;
                    v284 = v287;
                    if (!(_DWORD)v426)
                    {
                      *v31 = bswap32(LODWORD(v287));
                      v66 = v286;
                      v4 = v420;
                      goto LABEL_368;
                    }
                    v283 = v288;
                    v66 = v286;
                    v4 = v420;
                    goto LABEL_366;
                  }
                }
LABEL_368:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v278 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v279)
                  goto LABEL_385;
              }
            case 21:
              v418 = v30;
              v419 = v37;
              v289 = (float *)v47 + 1;
              v290 = v4;
              v224 = v40;
              while (1)
              {
                v291 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v292 = *v224 * v291 + ((*v224 * v291) >> 8) + 1;
                    if (!BYTE1(v292))
                      goto LABEL_384;
                    v291 = v292 >> 8;
                  }
                  v293 = (float)v291 * *((float *)v66 + 159);
                  v294 = *v289 * v293;
                  if (v294 > 0.0)
                  {
                    v295 = *(v289 - 1) * v293;
                    if (v53)
                    {
                      v296 = COERCE_FLOAT(bswap32(*v27));
                      if (v296 <= 0.0)
                      {
LABEL_382:
                        *v31 = bswap32(LODWORD(v295));
                        *v27 = bswap32(LODWORD(v294));
                        goto LABEL_384;
                      }
                    }
                    else
                    {
                      v296 = 1.0;
                    }
                    v297 = v66;
                    v298 = PDAhardlightPDA(COERCE_FLOAT(bswap32(*v31)), v296, v295, v294);
                    v53 = v426;
                    v295 = v298;
                    if (!(_DWORD)v426)
                    {
                      *v31 = bswap32(LODWORD(v298));
                      v66 = v297;
                      v4 = v420;
                      goto LABEL_384;
                    }
                    v294 = v299;
                    v66 = v297;
                    v4 = v420;
                    goto LABEL_382;
                  }
                }
LABEL_384:
                ++v48;
                v224 += v40 != 0;
                ++v31;
                v289 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v290)
                {
LABEL_385:
                  v40 = &v224[v421];
                  v31 += v422;
                  v27 += v424;
                  v35 = v417;
                  v36 = v416;
                  v30 = v418;
                  v37 = v419;
                  goto LABEL_501;
                }
              }
            case 22:
              v300 = (float *)v47 + 1;
              v301 = v4;
              v69 = v40;
              while (1)
              {
                v302 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v303 = *v69 * v302 + ((*v69 * v302) >> 8) + 1;
                    if (!BYTE1(v303))
                      goto LABEL_402;
                    v302 = v303 >> 8;
                  }
                  v304 = (float)v302 * 0.0039216;
                  v305 = *v300 * v304;
                  if (v305 > 0.0)
                  {
                    v306 = *(v300 - 1) * v304;
                    if (v53)
                    {
                      v307 = COERCE_FLOAT(bswap32(*v27));
                      if (v307 <= 0.0)
                      {
LABEL_400:
                        *v31 = bswap32(LODWORD(v306));
                        *v27 = bswap32(LODWORD(v305));
                        goto LABEL_402;
                      }
                    }
                    else
                    {
                      v307 = 1.0;
                    }
                    v308 = COERCE_FLOAT(bswap32(*v31));
                    v309 = v306 + v308;
                    v310 = v306 * v307;
                    v311 = (float)(v305 * v308) - v310;
                    v312 = (float)(v309 - (float)(v305 * v308)) - v310;
                    if (v311 < 0.0)
                      v311 = -v311;
                    v306 = v312 + v311;
                    if (!v53)
                    {
                      *v31 = bswap32(LODWORD(v306));
                      goto LABEL_402;
                    }
                    v305 = (float)(v305 + v307) - (float)(v307 * v305);
                    goto LABEL_400;
                  }
                }
LABEL_402:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v300 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v301)
                  goto LABEL_499;
              }
            case 23:
              v313 = (float *)v47 + 1;
              v314 = v4;
              v69 = v40;
              while (1)
              {
                v315 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v316 = *v69 * v315 + ((*v69 * v315) >> 8) + 1;
                    if (!BYTE1(v316))
                      goto LABEL_418;
                    v315 = v316 >> 8;
                  }
                  v317 = (float)v315 * 0.0039216;
                  v318 = *v313 * v317;
                  if (v318 > 0.0)
                  {
                    v319 = *(v313 - 1) * v317;
                    if (v53)
                    {
                      v320 = COERCE_FLOAT(bswap32(*v27));
                      if (v320 <= 0.0)
                      {
LABEL_416:
                        *v31 = bswap32(LODWORD(v319));
                        *v27 = bswap32(LODWORD(v318));
                        goto LABEL_418;
                      }
                    }
                    else
                    {
                      v320 = 1.0;
                    }
                    v321 = COERCE_FLOAT(bswap32(*v31));
                    v319 = (float)(v319 + v321) + (float)((float)(v319 * v321) * -2.0);
                    if (!v53)
                    {
                      *v31 = bswap32(LODWORD(v319));
                      goto LABEL_418;
                    }
                    v318 = (float)(v318 + v320) - (float)(v320 * v318);
                    goto LABEL_416;
                  }
                }
LABEL_418:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v313 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v314)
                  goto LABEL_499;
              }
            case 24:
              v322 = (float *)v47 + 1;
              v323 = v4;
              v69 = v40;
              while (1)
              {
                v324 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v325 = *v69 * v324 + ((*v69 * v324) >> 8) + 1;
                    if (!BYTE1(v325))
                      goto LABEL_438;
                    v324 = v325 >> 8;
                  }
                  v326 = (float)v324 * 0.0039216;
                  v327 = *v322 * v326;
                  if (v327 > 0.0)
                  {
                    v328 = *(v322 - 1) * v326;
                    v329 = 1.0;
                    if (!v53 || (v329 = COERCE_FLOAT(bswap32(*v27)), v329 > 0.0))
                    {
                      v330 = COERCE_FLOAT(bswap32(*v31));
                      v331 = v330;
                      if (v327 != 1.0)
                        v331 = v327 * v330;
                      v332 = 0.0;
                      if (v327 != 1.0)
                        v332 = v330 - (float)(v327 * v330);
                      v333 = (float)(v328 + v332) - (float)(v328 * v329);
                      if (v329 == 1.0)
                        v333 = v332;
                      v328 = v331 + v333;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v328));
                        goto LABEL_438;
                      }
                      v327 = (float)(v327 + v329) - (float)(v327 * v329);
                    }
                    *v31 = bswap32(LODWORD(v328));
                    *v27 = bswap32(LODWORD(v327));
                  }
                }
LABEL_438:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v322 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v323)
                  goto LABEL_499;
              }
            case 25:
              v334 = (float *)v47 + 1;
              v69 = v40;
              v335 = v4;
              while (1)
              {
                v336 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v337 = *v69 * v336 + ((*v69 * v336) >> 8) + 1;
                    if (!BYTE1(v337))
                      goto LABEL_458;
                    v336 = v337 >> 8;
                  }
                  v338 = (float)v336 * 0.0039216;
                  v339 = *v334 * v338;
                  if (v339 > 0.0)
                  {
                    v340 = *(v334 - 1) * v338;
                    v341 = 1.0;
                    if (!v53 || (v341 = COERCE_FLOAT(bswap32(*v27)), v341 > 0.0))
                    {
                      v342 = COERCE_FLOAT(bswap32(*v31));
                      v343 = v342;
                      if (v339 != 1.0)
                        v343 = v339 * v342;
                      v344 = 0.0;
                      if (v339 != 1.0)
                        v344 = v342 - (float)(v339 * v342);
                      v345 = (float)(v340 + v344) - (float)(v340 * v341);
                      if (v341 == 1.0)
                        v345 = v344;
                      v340 = v343 + v345;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v340));
                        goto LABEL_458;
                      }
                      v339 = (float)(v339 + v341) - (float)(v339 * v341);
                    }
                    *v31 = bswap32(LODWORD(v340));
                    *v27 = bswap32(LODWORD(v339));
                  }
                }
LABEL_458:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v334 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v335)
                  goto LABEL_499;
              }
            case 26:
              v346 = (float *)v47 + 1;
              v69 = v40;
              v347 = v4;
              while (1)
              {
                v348 = *v48;
                if (*v48)
                {
                  if (v40)
                  {
                    v349 = *v69 * v348 + ((*v69 * v348) >> 8) + 1;
                    if (!BYTE1(v349))
                      goto LABEL_479;
                    v348 = v349 >> 8;
                  }
                  v350 = (float)v348 * 0.0039216;
                  v351 = *v346 * v350;
                  if (v351 > 0.0)
                  {
                    v352 = *(v346 - 1) * v350;
                    v353 = 1.0;
                    if (!v53 || (v353 = COERCE_FLOAT(bswap32(*v27)), v353 > 0.0))
                    {
                      v354 = COERCE_FLOAT(bswap32(*v31));
                      v355 = v352 - (float)(v352 * v353);
                      if (v353 == 1.0)
                        v355 = 0.0;
                      if (v351 == 1.0)
                        v356 = v354;
                      else
                        v356 = v351 * v354;
                      if (v351 != 1.0)
                        v355 = (float)(v355 + v354) - (float)(v351 * v354);
                      v352 = v356 + v355;
                      if (!v53)
                      {
                        *v31 = bswap32(LODWORD(v352));
                        goto LABEL_479;
                      }
                      v351 = (float)(v351 + v353) - (float)(v351 * v353);
                    }
                    *v31 = bswap32(LODWORD(v352));
                    *v27 = bswap32(LODWORD(v351));
                  }
                }
LABEL_479:
                ++v48;
                v69 += v40 != 0;
                ++v31;
                v346 += 2;
                v27 = (unsigned int *)((char *)v27 + v45);
                if (!--v347)
                  goto LABEL_499;
              }
            case 27:
              v357 = (float *)v47 + 1;
              v69 = v40;
              v358 = v4;
              break;
            default:
              goto LABEL_501;
          }
          while (2)
          {
            v359 = *v48;
            if (*v48)
            {
              if (!v40)
                goto LABEL_486;
              v360 = *v69 * v359 + ((*v69 * v359) >> 8) + 1;
              if (BYTE1(v360))
              {
                v359 = v360 >> 8;
LABEL_486:
                v361 = (float)v359 * 0.0039216;
                v362 = *v357 * v361;
                if (v362 > 0.0)
                {
                  v363 = *(v357 - 1) * v361;
                  v364 = 1.0;
                  if (v53 && (v364 = COERCE_FLOAT(bswap32(*v27)), v364 <= 0.0))
                  {
LABEL_496:
                    *v31 = bswap32(LODWORD(v363));
                    *v27 = bswap32(LODWORD(v362));
                  }
                  else
                  {
                    v365 = COERCE_FLOAT(bswap32(*v31));
                    v366 = v365 - (float)(v362 * v365);
                    if (v362 == 1.0)
                      v366 = 0.0;
                    v367 = (float)(v363 + v366) - (float)(v363 * v364);
                    if (v364 == 1.0)
                    {
                      v368 = v366;
                    }
                    else
                    {
                      v363 = v363 * v364;
                      v368 = v367;
                    }
                    v363 = v363 + v368;
                    if (v53)
                    {
                      v362 = (float)(v362 + v364) - (float)(v362 * v364);
                      goto LABEL_496;
                    }
                    *v31 = bswap32(LODWORD(v363));
                  }
                }
              }
            }
            ++v48;
            v69 += v40 != 0;
            ++v31;
            v357 += 2;
            v27 = (unsigned int *)((char *)v27 + v45);
            if (!--v358)
            {
LABEL_499:
              v40 = &v69[v421];
              goto LABEL_500;
            }
            continue;
          }
        }
        v409 = shape_enum_clip_scan((uint64_t)v38, (_DWORD *)v40 - 4);
        v42 = v428;
        if (!v409)
          goto LABEL_594;
      }
      v427 -= v408;
      if (v427 < 1)
      {
LABEL_594:
        if (v38)
          free(v38);
        goto LABEL_596;
      }
      v30 += v36[16] * v408;
      v419 += v36[17] * v408;
      v31 += v411 * v408;
      v410 = v406 * v408;
      if (!(_DWORD)v426)
        v410 = 0;
      v27 += v410;
      v42 = v407;
    }
  }
}

uint64_t WF_shade(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int *v7;
  _BOOL8 v8;
  int v9;
  __n128 v11;
  void *v12;
  void *v13;
  int v14;
  int v15;
  uint64_t v16;
  void *v17;
  _BYTE v18[36];
  char v19;
  _QWORD v20[483];

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v20[482] = *MEMORY[0x1E0C80C00];
  v7 = *(int **)v2;
  v8 = !*((_QWORD *)v3 + 12) && !*(_QWORD *)(v4 + 72) && *(float *)(v4 + 4) >= 1.0;
  v9 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56) + 16 * *v3 + 8 * v8 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v9 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)&v13, (uint64_t)v18) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) != 0x1000000)
  {
    if (v13)
      goto LABEL_22;
    return 0xFFFFFFFFLL;
  }
  if (*(_QWORD *)(v5 + 16))
  {
    v12 = Wf_shade_radial_W;
  }
  else if (*(_QWORD *)(v5 + 24))
  {
    v12 = Wf_shade_conic_W;
  }
  else if (v16 < 2)
  {
    v12 = Wf_shade_axial_W;
  }
  else
  {
    v12 = Wf_shade_custom_W;
  }
  v13 = v12;
LABEL_22:
  v14 = *v7;
  v15 = v14;
  WF_image_mark(v6, (uint64_t)&v13, v9, v11);
  if (v17 && (v17 < &v19 || v20 < v17))
    free(v17);
  return 1;
}

uint64_t (**cg_cmap_library_link_symbol())()
{
  return &cg_cmap_vtable;
}

uint64_t create_with_data(const void *a1)
{
  _DWORD *v2;
  _QWORD *v3;
  _BYTE *v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v10;
  _BYTE *v11;
  _BYTE *v12;
  _BYTE *v13;
  uint64_t v14;
  char v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  unsigned int v24;
  FILE **v25;
  unint64_t v26;
  unint64_t v27;
  const char *v28;
  unint64_t v29;
  unint64_t *v30;
  uint64_t v31;
  char *v32;
  char *v33;
  _BYTE *v34;
  uint64_t v35;
  uint64_t v36;
  int64_t v37;
  char *v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t buffer;
  _BYTE *v45;
  _BYTE *v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  unint64_t *v52;
  _BYTE *v53;
  int v54;
  _BYTE *v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  _BYTE *v63;
  char *v64;
  int v65;
  int v66;
  char v67;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  char *v72;
  void *v73;
  uint64_t v74;
  uint64_t v75;
  char *v76;
  size_t v77;
  size_t v78;
  int v79;
  BOOL v80;
  size_t v81;
  int v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  _BYTE *v91;
  size_t v92;
  size_t v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  int v101;
  int previous_state;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  int v107;
  const char *v108;
  unsigned int v109;
  FILE *v110;
  FILE *v111;
  uint64_t v112;
  unint64_t v113;
  FILE *v114;
  FILE *v115;
  int v116;
  uint64_t v117;
  unint64_t v118;
  unint64_t *v119;
  int v120;
  uint64_t v121;
  uint64_t v122;
  int v123;
  FILE *v124;
  FILE *v125;
  int v126;
  uint64_t v127;
  int v128;
  unint64_t *v129;
  void *v130;
  unint64_t *v131;
  void **v132;
  unint64_t *v133;
  unint64_t *v134;
  uint64_t (*v135)(void *);
  unint64_t *v136;
  uint64_t v137;
  uint64_t v138;
  unsigned int v139;
  unsigned int v140;
  unsigned __int8 *v141;
  unint64_t *v142;
  unint64_t v143;
  unint64_t v144;
  FILE *v145;
  uint64_t v146;
  FILE *v147;
  unint64_t *v148;
  int v149;
  uint64_t v150;
  unint64_t v151;
  unint64_t v152;
  unint64_t *v153;
  uint64_t v154;
  unint64_t *v155;
  _QWORD *v156;
  void **v157;
  void **v158;
  char *v159;
  unint64_t *v160;
  __int128 v161;
  uint64_t v162;
  unsigned int v163;
  int v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  unsigned int v168;
  int v169;
  uint64_t v170;
  uint64_t v171;
  unint64_t v172;
  unsigned __int8 *v173;
  int v174;
  unint64_t v175;
  size_t v176;
  unint64_t v177;
  uint64_t v178;
  int v179;
  int v180;
  char v181;
  unint64_t v182;
  int v183;
  char v184;
  char *v185;
  const char *v186;
  uint64_t v187;
  uint64_t v188;
  size_t v189;
  _BYTE *v190;
  unint64_t v191;
  int v192;
  char *v193;
  char *v194;
  void **v195;
  uint64_t v196;
  void ***v197;
  uint64_t v198;
  uint64_t v199;
  void **v200;
  _BYTE *v201;
  uint64_t v202;
  const __CFArray *v203;
  CFIndex Count;
  CFIndex v205;
  CFIndex i;
  uint64_t v207;
  unint64_t *v209;
  __int16 *v210;
  int v211;
  __int16 *v212;
  int v213;
  _BYTE *v214;
  int v215;
  int v216;
  unint64_t *v217;
  unint64_t *v218;
  uint64_t v219;
  int v220[2];
  void *v221;
  uint64_t v222;
  _BYTE *v223;
  _BYTE *v224;
  int v225;
  char *v226;
  unint64_t v227;
  unint64_t v228;
  void *__src;
  unint64_t *v230;
  __int128 v231;
  char *v232;
  _BYTE v233[3200];
  _BYTE v234[400];
  _BYTE v235[128];
  uint64_t v236;

  v236 = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v2 = malloc_type_calloc(1uLL, 0x10uLL, 0x10800407411B482uLL);
  if (!v2)
    return 0;
  v3 = v2;
  *v2 = 0;
  *((_QWORD *)v2 + 1) = 0;
  v4 = malloc_type_calloc(1uLL, 0x38uLL, 0x10300405646078BuLL);
  v5 = (uint64_t)v4;
  if (!v4)
    goto LABEL_352;
  *(_DWORD *)v4 = 1;
  v4[41] = 0;
  v6 = malloc_type_malloc(0xA0uLL, 0x8B871889uLL);
  if (!v6)
  {
    *__error() = 12;
    goto LABEL_351;
  }
  v7 = (uint64_t)v6;
  v6[8] = 0u;
  v6[9] = 0u;
  v6[6] = 0u;
  v6[7] = 0u;
  v6[4] = 0u;
  v6[5] = 0u;
  v6[2] = 0u;
  v6[3] = 0u;
  *v6 = 0u;
  v6[1] = 0u;
  *(_QWORD *)v6 = CFRetain(a1);
  BytePtr = CFDataGetBytePtr((CFDataRef)a1);
  Length = CFDataGetLength((CFDataRef)a1);
  v10 = (int)Length;
  v11 = malloc_type_malloc((int)Length + 2, 0x8B871889uLL);
  if (!v11)
    goto LABEL_367;
  v12 = v11;
  if (Length << 32)
  {
    v13 = v11;
    v14 = (int)Length;
    do
    {
      v15 = *BytePtr++;
      *v13++ = v15;
      --v14;
    }
    while (v14);
    *(_WORD *)&v11[(int)Length] = 0;
    if ((unint64_t)(Length << 32) > 0xFFFFFFFD00000000)
LABEL_367:
      fatal_scanner_error();
  }
  else
  {
    *(_WORD *)&v11[(int)Length] = 0;
  }
  v16 = malloc_type_malloc(0x48uLL, 0x8B871889uLL);
  if (!v16)
    goto LABEL_367;
  v17 = v16;
  v16[2] = v12;
  v16[3] = v10;
  *v16 = 0;
  v16[1] = v12;
  v16[4] = v10;
  v16[5] = 0;
  *((_DWORD *)v16 + 12) = 1;
  *(_QWORD *)((char *)v16 + 60) = 0;
  cmap_yyensure_buffer_stack((_QWORD *)v7);
  v18 = *(_QWORD *)(v7 + 40);
  v19 = *(_QWORD *)(v7 + 24);
  v20 = *(_QWORD **)(v18 + 8 * v19);
  if (v20 != v17)
  {
    if (v20)
    {
      **(_BYTE **)(v7 + 72) = *(_BYTE *)(v7 + 48);
      v18 = *(_QWORD *)(v7 + 40);
      v19 = *(_QWORD *)(v7 + 24);
      *(_QWORD *)(*(_QWORD *)(v18 + 8 * v19) + 16) = *(_QWORD *)(v7 + 72);
      *(_QWORD *)(*(_QWORD *)(v18 + 8 * v19) + 32) = *(_QWORD *)(v7 + 56);
    }
    *(_QWORD *)(v18 + 8 * v19) = v17;
    v21 = *(_QWORD *)(v7 + 40);
    v22 = *(_QWORD *)(v21 + 8 * v19);
    *(_QWORD *)(v7 + 56) = *(_QWORD *)(v22 + 32);
    v23 = *(_BYTE **)(v22 + 16);
    *(_QWORD *)(v7 + 72) = v23;
    *(_QWORD *)(v7 + 136) = v23;
    *(_QWORD *)(v7 + 8) = **(_QWORD **)(v21 + 8 * v19);
    *(_BYTE *)(v7 + 48) = *v23;
    *(_DWORD *)(v7 + 88) = 1;
  }
  *(_QWORD *)v220 = v5;
  *((_DWORD *)v17 + 10) = 1;
  v3[1] = get_used_cmap;
  v24 = *(_DWORD *)v3;
  cmap_yydebug = *(_DWORD *)v3 & 1;
  *(_DWORD *)(v7 + 132) = (v24 >> 1) & 1;
  v231 = 0uLL;
  v25 = (FILE **)MEMORY[0x1E0C80C10];
  if ((v24 & 1) != 0)
    fwrite("Starting parse\n", 0xFuLL, 1uLL, (FILE *)*MEMORY[0x1E0C80C10]);
  v26 = 0u;
  LODWORD(v219) = 0;
  v217 = (unint64_t *)(v7 + 120);
  v218 = (unint64_t *)(v7 + 72);
  v221 = v233;
  v27 = 200;
  v28 = "nterm %s (";
  __src = v234;
  v29 = (unint64_t)v234;
  v30 = (unint64_t *)v233;
  LODWORD(v223) = -2;
  v222 = v7;
  while (1)
  {
    *(_WORD *)v29 = v26;
    v228 = v26;
    if ((unint64_t)__src + 2 * v27 - 2 <= v29)
    {
      if (v27 >> 4 > 0x270
        || (2 * v27 >= 0x2710 ? (v31 = 10000) : (v31 = 2 * v27),
            (v32 = (char *)malloc_type_malloc(18 * v31 + 15, 0x50DDE130uLL)) == 0))
      {
        v226 = (char *)v29;
        v215 = 0;
        LODWORD(v29) = 0;
        v214 = v235;
        goto LABEL_316;
      }
      v33 = v32;
      v34 = __src;
      v35 = (uint64_t)(v29 - (_QWORD)__src) >> 1;
      v36 = v35 + 1;
      memcpy(v32, __src, 2 * (v35 + 1));
      v37 = v31;
      v38 = &v33[(2 * v31 + 15) & 0xFFFFFFFFFFFFFFF0];
      memcpy(v38, v221, 16 * (v35 + 1));
      if (v34 != v234)
        free(v34);
      if (cmap_yydebug)
        fprintf((FILE *)*MEMORY[0x1E0C80C10], "Stack size increased to %lu\n", v37);
      v29 = (unint64_t)&v33[2 * v35];
      v30 = (unint64_t *)&v38[16 * v36 - 16];
      if (v37 <= v36)
      {
        v226 = (char *)v29;
        v215 = 0;
        LODWORD(v29) = 0;
        v214 = v235;
        __src = v33;
        v7 = v222;
        goto LABEL_316;
      }
      __src = v33;
      v221 = v38;
      v25 = (FILE **)MEMORY[0x1E0C80C10];
      v27 = v37;
      v7 = v222;
      v28 = "nterm %s (";
      LODWORD(v26) = v228;
    }
    if (cmap_yydebug)
    {
      fprintf(*v25, "Entering state %d\n", v26);
      LODWORD(v26) = v228;
    }
    v39 = yypact[(int)v26];
    v230 = v30;
    v227 = v27;
    if (v39 != -31)
    {
      v40 = (int)v223;
      v225 = v39;
      if ((_DWORD)v223 == -2)
      {
        if (cmap_yydebug)
          fwrite("Reading a token: ", 0x11uLL, 1uLL, *v25);
        *(_QWORD *)(v7 + 152) = &v231;
        if (!*(_DWORD *)(v7 + 80))
        {
          *(_DWORD *)(v7 + 80) = 1;
          if (!*(_DWORD *)(v7 + 84))
            *(_DWORD *)(v7 + 84) = 1;
          if (!*(_QWORD *)(v7 + 8))
            *(_QWORD *)(v7 + 8) = *MEMORY[0x1E0C80C18];
          if (!*(_QWORD *)(v7 + 16))
            *(_QWORD *)(v7 + 16) = *MEMORY[0x1E0C80C20];
          v41 = *(_QWORD *)(v7 + 40);
          if (!v41 || (v42 = *(_QWORD *)(v7 + 24), (v43 = *(_QWORD *)(v41 + 8 * v42)) == 0))
          {
            cmap_yyensure_buffer_stack((_QWORD *)v7);
            buffer = cmap_yy_create_buffer(*(_QWORD *)(v7 + 8), v7);
            v42 = *(_QWORD *)(v7 + 24);
            *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * v42) = buffer;
            v41 = *(_QWORD *)(v7 + 40);
            v43 = *(_QWORD *)(v41 + 8 * v42);
          }
          *(_QWORD *)(v7 + 56) = *(_QWORD *)(v43 + 32);
          v45 = *(_BYTE **)(v43 + 16);
          *(_QWORD *)(v7 + 72) = v45;
          *(_QWORD *)(v7 + 136) = v45;
          *(_QWORD *)(v7 + 8) = **(_QWORD **)(v41 + 8 * v42);
          *(_BYTE *)(v7 + 48) = *v45;
        }
LABEL_51:
        v46 = *(_BYTE **)(v7 + 72);
        *v46 = *(_BYTE *)(v7 + 48);
        v47 = *(_DWORD *)(v7 + 84);
        v223 = v46;
        while (1)
        {
          while (1)
          {
            do
            {
              v48 = yy_ec[*v46];
              if (yy_accept[v47])
              {
                *(_DWORD *)(v7 + 112) = v47;
                *(_QWORD *)(v7 + 120) = v46;
              }
              v49 = v47;
              v50 = yy_base[v47] + v48;
              if (v47 != (__int16)yy_chk[v50])
              {
                do
                {
                  v49 = yy_def[v49];
                  if (v49 >= 253)
                    v48 = yy_meta[v48];
                  v50 = yy_base[v49] + v48;
                }
                while (yy_chk[v50] != (unsigned __int16)v49);
              }
              v47 = yy_nxt[v50];
              ++v46;
            }
            while (v47 != 252);
LABEL_59:
            while (2)
            {
              v51 = *(_DWORD *)(v7 + 112);
              v52 = v217;
LABEL_60:
              v53 = (_BYTE *)*v52;
              v54 = (__int16)yy_accept[v51];
              v55 = v223;
              *(_QWORD *)(v7 + 136) = v223;
              *(_QWORD *)(v7 + 64) = v53 - v55;
              *(_BYTE *)(v7 + 48) = *v53;
              *v53 = 0;
              v224 = v53;
              *(_QWORD *)(v7 + 72) = v53;
LABEL_61:
              if (!*(_DWORD *)(v7 + 132))
                goto LABEL_70;
              if (!v54)
              {
                fwrite("--scanner backing up\n", 0x15uLL, 1uLL, *v25);
LABEL_141:
                *v224 = *(_BYTE *)(v7 + 48);
                continue;
              }
              break;
            }
            if (v54 <= 43)
            {
              fprintf(*v25, "--accepting rule at line %ld (\"%s\")\n", yy_rule_linenum[v54], *(const char **)(v7 + 136));
              goto LABEL_70;
            }
            if (v54 != 45)
            {
              if (v54 == 44)
              {
                fprintf(*v25, "--accepting default rule (\"%s\")\n", *(const char **)(v7 + 136));
                fatal_scanner_error();
              }
              v56 = *(_DWORD *)(v7 + 84);
              if (v56 >= 1)
                --v56;
              fprintf(*v25, "--EOF (start condition %d)\n", v56 >> 1);
LABEL_70:
              switch(v54)
              {
                case 0:
                  goto LABEL_141;
                case 1:
                case 7:
                case 41:
                case 42:
                  goto LABEL_51;
                case 2:
                case 3:
                  v40 = **(char **)(v7 + 136);
                  goto LABEL_151;
                case 4:
                  v108 = v28;
                  v40 = 0x11Fu;
                  goto LABEL_153;
                case 5:
                  v108 = v28;
                  v40 = 0x120u;
                  goto LABEL_153;
                case 6:
                  v108 = v28;
                  v232 = 0;
                  **(_DWORD **)(v7 + 152) = strtol_l(*(const char **)(v7 + 136), &v232, 10, 0);
                  v40 = 0x122u;
                  goto LABEL_153;
                case 8:
                  v175 = *(_QWORD *)(v7 + 64);
                  if (v175 <= 1)
                    goto LABEL_370;
                  v108 = v28;
                  v176 = v175 - 2;
                  **(_QWORD **)(v7 + 152) = malloc_type_malloc(v175 - 1, 0x142A60F1uLL);
                  strncpy(**(char ***)(v7 + 152), (const char *)(*(_QWORD *)(v7 + 136) + 1), v176);
                  *(_BYTE *)(**(_QWORD **)(v7 + 152) + v176) = 0;
                  v40 = 0x124u;
                  goto LABEL_153;
                case 9:
                  v177 = *(_QWORD *)(v7 + 64);
                  if (v177 <= 1)
LABEL_370:
                    abort();
                  *(_QWORD *)(*(_QWORD *)(v7 + 152) + 8) = malloc_type_malloc(v177 + 1, 0xEAA13950uLL);
                  v178 = *(_QWORD *)(v7 + 64);
                  if ((unint64_t)(v178 - 3) > 0xFFFFFFFFFFFFFFFDLL)
                  {
                    v179 = 0;
                  }
                  else
                  {
                    v179 = 0;
                    v180 = 0;
                    v181 = 0;
                    v182 = 1;
                    do
                    {
                      v183 = *(unsigned __int8 *)(*(_QWORD *)(v7 + 136) + v182);
                      v184 = v183 - 48;
                      if ((v183 - 48) <= 0x36 && ((0x7E0000007E03FFuLL >> v184) & 1) != 0)
                      {
                        v180 = (dword_185003DC0[v184] + v183) | (16 * v180);
                        if ((v181 & 1) != 0)
                        {
                          *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v7 + 152) + 8) + v179++) = v180;
                          v178 = *(_QWORD *)(v7 + 64);
                        }
                        ++v181;
                      }
                      ++v182;
                    }
                    while (v182 < v178 - 1);
                    if ((v181 & 1) != 0)
                      *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(v7 + 152) + 8) + v179++) = 16 * v180;
                  }
                  v108 = v28;
                  **(_QWORD **)(v7 + 152) = v179;
                  v40 = 0x125u;
                  goto LABEL_153;
                case 10:
                  v108 = v28;
                  v40 = 0x118u;
                  goto LABEL_153;
                case 11:
                  v108 = v28;
                  v40 = 0x119u;
                  goto LABEL_153;
                case 12:
                  v108 = v28;
                  v40 = 0x11Bu;
                  goto LABEL_153;
                case 13:
                  v108 = v28;
                  v40 = 0x11Cu;
                  goto LABEL_153;
                case 14:
                  v108 = v28;
                  v40 = 0x11Du;
                  goto LABEL_153;
                case 15:
                  v108 = v28;
                  v40 = 0x11Au;
                  goto LABEL_153;
                case 16:
                  v108 = v28;
                  **(_QWORD **)(v7 + 152) = malloc_type_malloc(*(_QWORD *)(v7 + 64) + 1, 0x591FCFE5uLL);
                  v185 = **(char ***)(v7 + 152);
                  v186 = (const char *)(*(_QWORD *)(v7 + 136) + 1);
                  goto LABEL_295;
                case 17:
                  v108 = v28;
                  v40 = 0x102u;
                  goto LABEL_153;
                case 18:
                  v108 = v28;
                  v40 = 0x103u;
                  goto LABEL_153;
                case 19:
                  v108 = v28;
                  v40 = 0x104u;
                  goto LABEL_153;
                case 20:
                  v108 = v28;
                  v40 = 0x105u;
                  goto LABEL_153;
                case 21:
                  v108 = v28;
                  v40 = 0x106u;
                  goto LABEL_153;
                case 22:
                  v108 = v28;
                  v40 = 0x107u;
                  goto LABEL_153;
                case 23:
                  v108 = v28;
                  v40 = 0x108u;
                  goto LABEL_153;
                case 24:
                  v108 = v28;
                  v40 = 0x109u;
                  goto LABEL_153;
                case 25:
                  v108 = v28;
                  v40 = 0x10Au;
                  goto LABEL_153;
                case 26:
                  v108 = v28;
                  v40 = 0x10Bu;
                  goto LABEL_153;
                case 27:
                  v108 = v28;
                  v40 = 0x10Cu;
                  goto LABEL_153;
                case 28:
                  v108 = v28;
                  v40 = 0x10Du;
                  goto LABEL_153;
                case 29:
                  v108 = v28;
                  v40 = 0x10Eu;
                  goto LABEL_153;
                case 30:
                  v108 = v28;
                  v40 = 0x10Fu;
                  goto LABEL_153;
                case 31:
                  v108 = v28;
                  v40 = 0x110u;
                  goto LABEL_153;
                case 32:
                  v108 = v28;
                  v40 = 0x111u;
                  goto LABEL_153;
                case 33:
                  v108 = v28;
                  v40 = 0x112u;
                  goto LABEL_153;
                case 34:
                  v108 = v28;
                  v40 = 0x113u;
                  goto LABEL_153;
                case 35:
                  v108 = v28;
                  v40 = 0x114u;
                  goto LABEL_153;
                case 36:
                  v108 = v28;
                  v40 = 0x115u;
                  goto LABEL_153;
                case 37:
                  v108 = v28;
                  v40 = 0x116u;
                  goto LABEL_153;
                case 38:
                  v108 = v28;
                  v40 = 0x117u;
                  goto LABEL_153;
                case 39:
                  v108 = v28;
                  v40 = 0x11Eu;
                  goto LABEL_153;
                case 40:
                  v108 = v28;
                  **(_QWORD **)(v7 + 152) = malloc_type_malloc(*(_QWORD *)(v7 + 64) + 1, 0x39DB8847uLL);
                  v185 = **(char ***)(v7 + 152);
                  v186 = *(const char **)(v7 + 136);
LABEL_295:
                  strcpy(v185, v186);
                  v40 = 0x123u;
                  goto LABEL_153;
                case 43:
                  v108 = v28;
                  v40 = 0x121u;
                  goto LABEL_153;
                case 45:
                  goto LABEL_72;
                case 46:
                  goto LABEL_154;
                default:
                  goto LABEL_367;
              }
            }
            fwrite("--(end of buffer or a NUL)\n", 0x1BuLL, 1uLL, *v25);
LABEL_72:
            v57 = *(_QWORD *)(v7 + 136);
            *v224 = *(_BYTE *)(v7 + 48);
            v58 = *(_QWORD *)(v7 + 40);
            v59 = *(_QWORD *)(v7 + 24);
            v60 = *(_QWORD *)(v58 + 8 * v59);
            if (*(_DWORD *)(v60 + 64))
            {
              v61 = *(_QWORD *)(v7 + 56);
            }
            else
            {
              v61 = *(_QWORD *)(v60 + 32);
              *(_QWORD *)(v7 + 56) = v61;
              *(_QWORD *)v60 = *(_QWORD *)(v7 + 8);
              v60 = *(_QWORD *)(v58 + 8 * v59);
              *(_DWORD *)(v60 + 64) = 1;
            }
            v62 = *v218;
            v63 = *(_BYTE **)(v60 + 8);
            if (*v218 > (unint64_t)&v63[v61])
              break;
            *(_QWORD *)(v7 + 72) = *(_QWORD *)(v7 + 136) + ~(_DWORD)v57 + (int)v224;
            previous_state = yy_get_previous_state(v7);
            if (yy_accept[previous_state])
            {
              v103 = *(_QWORD *)(v7 + 72);
              *(_DWORD *)(v7 + 112) = previous_state;
              *(_QWORD *)(v7 + 120) = v103;
            }
            v104 = previous_state;
            v105 = yy_base[previous_state] + 2;
            v27 = v227;
            if (previous_state != (__int16)yy_chk[v105])
            {
              do
              {
                v106 = (unsigned __int16)yy_def[v104];
                v104 = (__int16)v106;
                v105 = yy_base[(__int16)v106] + 2;
              }
              while (v106 != yy_chk[v105]);
            }
            v223 = *(_BYTE **)(v7 + 136);
            if (!v105)
              goto LABEL_59;
            v107 = (unsigned __int16)yy_nxt[v105];
            if (v107 == 252)
              goto LABEL_59;
            v47 = (__int16)v107;
            v46 = (_BYTE *)(*v218 + 1);
            *v218 = (unint64_t)v46;
          }
          v219 = v57;
          if (v62 > (unint64_t)&v63[v61 + 1])
            goto LABEL_367;
          v64 = *(char **)(v7 + 136);
          if (!*(_DWORD *)(v60 + 60))
          {
            v27 = v227;
            if (v62 - (_QWORD)v64 != 1)
              goto LABEL_139;
            goto LABEL_132;
          }
          v65 = ~(_DWORD)v64 + v62;
          if (v65 >= 1)
          {
            v66 = ~(_DWORD)v64 + v62;
            do
            {
              v67 = *v64++;
              *v63++ = v67;
              --v66;
            }
            while (v66);
            v58 = *(_QWORD *)(v7 + 40);
            v59 = *(_QWORD *)(v7 + 24);
            v60 = *(_QWORD *)(v58 + 8 * v59);
          }
          v68 = v65;
          if (*(_DWORD *)(v60 + 64) == 2)
          {
            *(_QWORD *)(v7 + 56) = 0;
LABEL_84:
            *(_QWORD *)(v60 + 32) = 0;
            goto LABEL_119;
          }
          v69 = ~(uint64_t)v65;
          v70 = *(_QWORD *)(v60 + 24);
          v71 = v70 + v69;
          v216 = v65;
          if (!(v70 + v69))
          {
            v226 = (char *)v29;
            v72 = (char *)*v218;
            do
            {
              if (!*(_DWORD *)(v60 + 40))
              {
                *(_QWORD *)(v60 + 8) = 0;
                fatal_scanner_error();
              }
              v73 = *(void **)(v60 + 8);
              v74 = 2 * v70;
              v75 = v70 + (v70 >> 3);
              if (v74)
                v75 = v74;
              *(_QWORD *)(v60 + 24) = v75;
              v76 = (char *)malloc_type_realloc(v73, v75 + 2, 0xF93AD230uLL);
              *(_QWORD *)(v60 + 8) = v76;
              if (!v76)
                goto LABEL_367;
              v72 = &v76[(int)v72 - (int)v73];
              *(_QWORD *)(v7 + 72) = v72;
              v60 = *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * *(_QWORD *)(v7 + 24));
              v70 = *(_QWORD *)(v60 + 24);
              v71 = v70 + v69;
            }
            while (!(v70 + v69));
            v29 = (unint64_t)v226;
          }
          if (v71 >= 0x2000)
            v77 = 0x2000;
          else
            v77 = v71;
          if (!*(_DWORD *)(v60 + 44))
          {
            *__error() = 0;
            while (1)
            {
              v81 = fread((void *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * *(_QWORD *)(v7 + 24)) + 8) + v68), 1uLL, v77, *(FILE **)(v7 + 8));
              v78 = (int)v81;
              *(_QWORD *)(v7 + 56) = (int)v81;
              if (v81 << 32)
                goto LABEL_117;
              if (!ferror(*(FILE **)(v7 + 8)))
                break;
              if (*__error() != 4)
                goto LABEL_367;
              *__error() = 0;
              clearerr(*(FILE **)(v7 + 8));
            }
            v58 = *(_QWORD *)(v7 + 40);
            v59 = *(_QWORD *)(v7 + 24);
            v60 = *(_QWORD *)(v58 + 8 * v59);
            v65 = v216;
            goto LABEL_84;
          }
          v78 = 0;
          do
          {
            v79 = getc(*(FILE **)(v7 + 8));
            v80 = v79 == -1 || v79 == 10;
            if (v80)
              goto LABEL_106;
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * *(_QWORD *)(v7 + 24)) + 8) + v68 + v78++) = v79;
          }
          while (v77 != v78);
          v78 = v77;
LABEL_106:
          if (v79 == -1)
          {
            if (ferror(*(FILE **)(v7 + 8)))
              goto LABEL_367;
          }
          else if (v79 == 10)
          {
            *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * *(_QWORD *)(v7 + 24)) + 8) + v68 + v78++) = 10;
          }
          *(_QWORD *)(v7 + 56) = v78;
LABEL_117:
          v58 = *(_QWORD *)(v7 + 40);
          v59 = *(_QWORD *)(v7 + 24);
          v60 = *(_QWORD *)(v58 + 8 * v59);
          *(_QWORD *)(v60 + 32) = v78;
          v65 = v216;
          if (v78)
          {
            v82 = 0;
            goto LABEL_127;
          }
LABEL_119:
          if (v65)
          {
            v78 = 0;
            v82 = 2;
            *(_DWORD *)(v60 + 64) = 2;
          }
          else
          {
            v83 = *(_QWORD *)(v7 + 8);
            v84 = *(_QWORD *)(v58 + 8 * v59);
            if (!v84)
            {
              cmap_yyensure_buffer_stack((_QWORD *)v7);
              v85 = cmap_yy_create_buffer(*(_QWORD *)(v7 + 8), v7);
              v86 = *(_QWORD *)(v7 + 24);
              *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * v86) = v85;
              v87 = *(_QWORD *)(v7 + 40);
              if (v87)
                v84 = *(_QWORD *)(v87 + 8 * v86);
              else
                v84 = 0;
            }
            cmap_yy_init_buffer(v84, v83, v7);
            v88 = *(_QWORD *)(v7 + 40);
            v89 = *(_QWORD *)(v7 + 24);
            v90 = *(_QWORD *)(v88 + 8 * v89);
            v78 = *(_QWORD *)(v90 + 32);
            *(_QWORD *)(v7 + 56) = v78;
            v91 = *(_BYTE **)(v90 + 16);
            *(_QWORD *)(v7 + 72) = v91;
            *(_QWORD *)(v7 + 136) = v91;
            *(_QWORD *)(v7 + 8) = **(_QWORD **)(v88 + 8 * v89);
            *(_BYTE *)(v7 + 48) = *v91;
            v60 = *(_QWORD *)(v88 + 8 * v89);
            v82 = 1;
            v65 = 0;
          }
LABEL_127:
          v92 = v78 + v65;
          if (v92 <= *(_QWORD *)(v60 + 24))
          {
            v98 = *(_QWORD *)(v60 + 8);
            v27 = v227;
          }
          else
          {
            v93 = v92 + (v78 >> 1);
            v94 = malloc_type_realloc(*(void **)(v60 + 8), v93, 0xF93AD230uLL);
            v95 = *(_QWORD *)(v7 + 40);
            v96 = *(_QWORD *)(v7 + 24);
            *(_QWORD *)(*(_QWORD *)(v95 + 8 * v96) + 8) = v94;
            v97 = *(_QWORD *)(v95 + 8 * v96);
            v98 = *(_QWORD *)(v97 + 8);
            if (!v98)
              goto LABEL_367;
            *(_QWORD *)(v97 + 24) = (int)v93 - 2;
            v92 = *(_QWORD *)(v7 + 56) + v68;
            v27 = v227;
          }
          *(_QWORD *)(v7 + 56) = v92;
          *(_BYTE *)(v98 + v92) = 0;
          *(_BYTE *)(*(_QWORD *)(v7 + 56)
                   + *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * *(_QWORD *)(v7 + 24)) + 8)
                   + 1) = 0;
          v99 = *(_QWORD *)(v7 + 40);
          v100 = *(_QWORD *)(v7 + 24);
          v64 = *(char **)(*(_QWORD *)(v99 + 8 * v100) + 8);
          *(_QWORD *)(v7 + 136) = v64;
          v25 = (FILE **)MEMORY[0x1E0C80C10];
          if (v82 == 1)
          {
LABEL_132:
            *(_DWORD *)(v7 + 88) = 0;
            *(_QWORD *)(v7 + 72) = v64;
            v101 = *(_DWORD *)(v7 + 84);
            if (v101 >= 1)
              --v101;
            v54 = (v101 >> 1) + 46;
            v30 = v230;
            goto LABEL_61;
          }
          if (v82)
          {
            v80 = v82 == 2;
            v30 = v230;
            if (!v80)
              goto LABEL_51;
            v63 = *(_BYTE **)(*(_QWORD *)(v99 + 8 * v100) + 8);
            v61 = *(_QWORD *)(v7 + 56);
LABEL_139:
            *(_QWORD *)(v7 + 72) = &v63[v61];
            v51 = yy_get_previous_state(v7);
            v223 = *(_BYTE **)(v7 + 136);
            v52 = v218;
            v30 = v230;
            goto LABEL_60;
          }
          *(_QWORD *)(v7 + 72) = &v64[~(_DWORD)v219 + (int)v224];
          v47 = yy_get_previous_state(v7);
          v46 = *(_BYTE **)(v7 + 72);
          v223 = *(_BYTE **)(v7 + 136);
          v30 = v230;
        }
      }
LABEL_151:
      if (v40 <= 0)
      {
LABEL_154:
        v108 = v28;
        if (cmap_yydebug)
          fwrite("Now at end of input.\n", 0x15uLL, 1uLL, *v25);
        v109 = 0;
        LODWORD(v223) = 0;
      }
      else
      {
        v108 = v28;
        if (v40 >= 0x127)
          v109 = 2;
        else
LABEL_153:
          v109 = yytranslate[v40];
        LODWORD(v223) = v40;
        if (cmap_yydebug)
        {
          fprintf(*v25, "%s ", "Next token is");
          v110 = (FILE *)*MEMORY[0x1E0C80C10];
          if (v109 >= 0x2A)
            fprintf(v110, v108, yytname[v109]);
          else
            fprintf(v110, "token %s (");
          v111 = v110;
          v25 = (FILE **)MEMORY[0x1E0C80C10];
          fputc(41, v111);
          fputc(10, *v25);
        }
      }
      LODWORD(v26) = v228;
      v112 = v109 + v225;
      LODWORD(v219) = v109;
      if (v112 <= 0x72 && v109 == yycheck[v112])
        break;
    }
    v117 = yydefact[(int)v26];
    if (!yydefact[(int)v26])
    {
      v30 = v230;
LABEL_301:
      v187 = yysyntax_error(0, v26, v223);
      v188 = v187;
      v214 = v235;
      if ((unint64_t)v187 < 0x81)
      {
        v191 = 128;
      }
      else
      {
        if (v187 < 0)
          v189 = -1;
        else
          v189 = 2 * v187;
        v190 = malloc_type_malloc(v189, 0x93DF3029uLL);
        if (v190)
          v214 = v190;
        v191 = 128;
        if (v190)
          v191 = v189;
      }
      if (v188 - 1 >= v191)
      {
        if (v188)
        {
          v226 = (char *)v29;
          v215 = 0;
          LODWORD(v29) = 0;
          goto LABEL_316;
        }
LABEL_358:
        v192 = (int)v223;
      }
      else
      {
        v192 = (int)v223;
        yysyntax_error(v214, v228, v223);
      }
      if ((void *)v29 == __src)
      {
        v215 = 0;
        LODWORD(v29) = 0;
        v226 = (char *)__src;
      }
      else
      {
        v210 = (__int16 *)(v29 - 2);
        v211 = v228;
        v212 = (__int16 *)__src;
        do
        {
          yydestruct("Error: popping", yystos[v211], (void **)v30);
          v211 = *v210;
          if (cmap_yydebug)
          {
            v213 = *v210;
            yy_stack_print(v212, (unint64_t)v210);
            v211 = v213;
          }
          v30 -= 2;
          v80 = v210-- == v212;
        }
        while (!v80);
        v215 = 0;
        LODWORD(v29) = 0;
        v226 = (char *)__src;
      }
      goto LABEL_317;
    }
    v226 = (char *)v29;
    v118 = yyr2[v117];
    v119 = &v230[2 * (1 - v118)];
    v228 = *v119;
    v120 = *((_DWORD *)v119 + 2);
    LODWORD(v119) = *((_DWORD *)v119 + 3);
    v225 = v120;
    LODWORD(v224) = (_DWORD)v119;
    v121 = v117;
    if (cmap_yydebug)
    {
      fprintf(*v25, "Reducing stack by rule %d (line %lu):\n", v117 - 1, yyrline[v117]);
      if ((_DWORD)v118)
      {
        v122 = 0;
        do
        {
          v123 = v122 + 1;
          fprintf(*v25, "   $%d = ", v122 + 1);
          v124 = (FILE *)*MEMORY[0x1E0C80C10];
          if (yyrhs[yyprhs[v121] + v122] < 42)
            fprintf(v124, "token %s (");
          else
            fprintf(v124, "nterm %s (");
          v125 = v124;
          v25 = (FILE **)MEMORY[0x1E0C80C10];
          fputc(41, v125);
          fputc(10, *v25);
          ++v122;
        }
        while ((_DWORD)v118 != v123);
      }
    }
    v126 = v121 - 21;
    v127 = v121;
    v28 = "nterm %s (";
    v7 = v222;
    v29 = v118;
    v128 = v225;
    switch(v126)
    {
      case 0:
      case 2:
        v129 = v230;
        cmap_set_name(*(uint64_t *)v220, (char *)*(v230 - 2));
        v130 = (void *)*(v129 - 2);
        goto LABEL_209;
      case 1:
        v132 = (void **)v230;
        cmap_set_name(*(uint64_t *)v220, (char *)*v230);
        v130 = *v132;
        goto LABEL_209;
      case 3:
      case 12:
      case 13:
      case 14:
      case 15:
      case 16:
      case 18:
      case 19:
      case 20:
      case 22:
      case 27:
      case 28:
      case 29:
      case 31:
      case 33:
      case 34:
      case 35:
      case 37:
      case 40:
      case 41:
      case 42:
      case 43:
      case 44:
        goto LABEL_210;
      case 4:
        v133 = v230;
        cmap_set_ros(*(uint64_t *)v220, (char *)*(v230 - 10), (const char *)*(v230 - 6), *((_DWORD *)v230 - 4));
        goto LABEL_191;
      case 5:
        v133 = v230;
        cmap_set_ros(*(uint64_t *)v220, (char *)*(v230 - 14), (const char *)*(v230 - 10), *((_DWORD *)v230 - 4));
        free((void *)*(v133 - 14));
LABEL_191:
        free((void *)*(v133 - 10));
        v130 = (void *)*(v133 - 6);
        goto LABEL_209;
      case 6:
      case 9:
        v131 = v230;
        cmap_set_ros(*(uint64_t *)v220, (char *)*(v230 - 16), (const char *)*(v230 - 10), *((_DWORD *)v230 - 8));
        free((void *)*(v131 - 16));
        v130 = (void *)*(v131 - 10);
        goto LABEL_209;
      case 7:
        v130 = (void *)*(v230 - 6);
        goto LABEL_209;
      case 8:
        v134 = v230;
        cmap_set_ros(*(uint64_t *)v220, (char *)*(v230 - 14), (const char *)*(v230 - 8), *((_DWORD *)v230 - 4));
        free((void *)*(v134 - 14));
        v130 = (void *)*(v134 - 8);
        goto LABEL_209;
      case 10:
        *(_DWORD *)(*(_QWORD *)v220 + 24) = *((_DWORD *)v230 - 4);
        goto LABEL_210;
      case 11:
        v135 = (uint64_t (*)(void *))v3[1];
        v136 = v230;
        v130 = (void *)*(v230 - 2);
        if (!v135)
          goto LABEL_209;
        v137 = v135(v130);
        free((void *)*(v136 - 2));
        if (v137)
        {
          cmap_set_used_cmap(*(uint64_t *)v220, v137);
          cmap_release(v137);
        }
LABEL_229:
        v25 = (FILE **)MEMORY[0x1E0C80C10];
        goto LABEL_210;
      case 17:
        v138 = *(v230 - 2);
        if (v138 == *v230)
        {
          v139 = *((_DWORD *)v230 - 2);
          v140 = *((_DWORD *)v230 + 2);
          v141 = *(unsigned __int8 **)(*(_QWORD *)v220 + 48);
          if (!v141)
          {
            v141 = (unsigned __int8 *)cmap_csr_set_create();
            *(_QWORD *)(*(_QWORD *)v220 + 48) = v141;
          }
          cmap_csr_set_add_codespace_range(v141, v138, v139, v140);
        }
        goto LABEL_229;
      case 21:
        v142 = v230;
        v143 = *(v230 - 2);
        if (v143 <= 2)
          add_bf_range(*(uint64_t *)v220, v143, *(v230 - 1), *(v230 - 2), *(v230 - 1), v230);
        v130 = (void *)v142[1];
        goto LABEL_209;
      case 23:
        v144 = *(v230 - 4);
        if (v144 == *(v230 - 2) && v144 <= 2)
          add_bf_range(*(uint64_t *)v220, v144, *(v230 - 3), *(v230 - 4), *(v230 - 1), v230);
        goto LABEL_208;
      case 24:
        v151 = *(v230 - 8);
        if (v151 == *(v230 - 6) && v151 <= 2)
        {
          v152 = *(v230 - 5);
          v153 = v230 - 2;
          v154 = -1;
          v155 = v230 - 2;
          do
          {
            v155 = (unint64_t *)*v155;
            ++v154;
          }
          while (v155);
          if (v154 + *((unsigned int *)v230 - 14) - 1 == v152)
          {
            v156 = (_QWORD *)*v153;
            if (*v153)
            {
              do
              {
                add_bf_range(*(uint64_t *)v220, v151, v152, v151, v152, v156 + 1);
                v152 = (v152 - 1) | v152 & 0xFFFFFFFF00000000;
                v156 = (_QWORD *)*v156;
              }
              while (v156);
            }
          }
        }
        v157 = (void **)*(v230 - 2);
        if (v157)
        {
          do
          {
            v158 = (void **)*v157;
            free(v157[2]);
            free(v157);
            v157 = v158;
          }
          while (v158);
        }
        goto LABEL_229;
      case 25:
        v228 = 0;
        goto LABEL_210;
      case 26:
        v159 = (char *)malloc_type_malloc(0x18uLL, 0x1030040CE42941AuLL);
        v160 = v230;
        *(_QWORD *)v159 = *(v230 - 2);
        v161 = *(_OWORD *)v160;
        v228 = (unint64_t)v159;
        *(_OWORD *)(v159 + 8) = v161;
        goto LABEL_210;
      case 30:
        v162 = *(v230 - 2);
        v163 = *((_DWORD *)v230 - 2);
        v164 = *(unsigned __int16 *)v230;
        v165 = *(_QWORD *)(*(_QWORD *)v220 + 48);
        v166 = v163;
        goto LABEL_235;
      case 32:
        v162 = *(v230 - 4);
        if (v162 != *(v230 - 2))
          goto LABEL_210;
        v163 = *((_DWORD *)v230 - 6);
        v166 = *((unsigned int *)v230 - 2);
        v164 = *(unsigned __int16 *)v230;
        v165 = *(_QWORD *)(*(_QWORD *)v220 + 48);
LABEL_235:
        cmap_add_cid_range(v165, v162, v163, v166, v164);
        goto LABEL_210;
      case 36:
        v167 = *(v230 - 2);
        v168 = *((_DWORD *)v230 - 2);
        v169 = *(unsigned __int16 *)v230;
        v170 = *(_QWORD *)(*(_QWORD *)v220 + 48);
        v171 = v168;
        goto LABEL_239;
      case 38:
        v167 = *(v230 - 4);
        if (v167 != *(v230 - 2))
          goto LABEL_210;
        v168 = *((_DWORD *)v230 - 6);
        v171 = *((unsigned int *)v230 - 2);
        v169 = *(unsigned __int16 *)v230;
        v170 = *(_QWORD *)(*(_QWORD *)v220 + 48);
LABEL_239:
        cmap_add_notdef_range(v170, v167, v168, v171, v169);
        goto LABEL_210;
      case 39:
        v172 = *v230;
        if (*v230 > 4)
        {
          v209 = &v230[-2 * v118];
          v29 = (unint64_t)&v226[-2 * v118];
          if (cmap_yydebug)
            yy_stack_print((__int16 *)__src, v29);
          v228 = *(__int16 *)v29;
          v214 = v235;
          v30 = v209;
          goto LABEL_358;
        }
        v128 = 0;
        if (v172)
        {
          v173 = (unsigned __int8 *)v230[1];
          do
          {
            v174 = *v173++;
            v128 = v174 | (v128 << 8);
            --v172;
          }
          while (v172);
        }
        free((void *)v230[1]);
        v228 = *v230;
LABEL_210:
        if (cmap_yydebug)
        {
          fprintf(*v25, "%s ", "-> $$ =");
          v145 = (FILE *)*MEMORY[0x1E0C80C10];
          v146 = yyr1[v127];
          fprintf((FILE *)*MEMORY[0x1E0C80C10], "nterm %s (", yytname[v146]);
          v147 = v145;
          v25 = (FILE **)MEMORY[0x1E0C80C10];
          fputc(41, v147);
          fputc(10, *v25);
          v148 = &v230[-2 * v29];
          v29 = (unint64_t)&v226[-2 * v29];
          if (cmap_yydebug)
            yy_stack_print((__int16 *)__src, v29);
        }
        else
        {
          v146 = yyr1[v127];
          v148 = &v230[-2 * v29];
          v29 = (unint64_t)&v226[-2 * v29];
        }
        v149 = (int)v224;
        v148[2] = v228;
        v30 = v148 + 2;
        *((_DWORD *)v30 + 2) = v128;
        *((_DWORD *)v30 + 3) = v149;
        v150 = (*(__int16 *)v29 + yypgoto[v146 - 42]);
        if (v150 <= 0x72 && *(unsigned __int16 *)v29 == (unsigned __int16)yycheck[v150])
          v26 = yytable[v150];
        else
          v26 = yydefgoto[v146 - 42];
        v27 = v227;
LABEL_219:
        v29 += 2;
        break;
      case 45:
      case 46:
        v130 = (void *)*v230;
        goto LABEL_209;
      case 47:
LABEL_208:
        v130 = (void *)v230[1];
LABEL_209:
        free(v130);
        goto LABEL_210;
      default:
        v28 = "nterm %s (";
        v7 = v222;
        v29 = (unint64_t)yy_chk;
        v128 = v225;
        if ((_DWORD)v127 != 2)
          goto LABEL_210;
        v214 = v235;
        v215 = 1;
        v30 = v230;
        goto LABEL_316;
    }
  }
  v113 = yytable[v112];
  if (!yytable[v112])
    goto LABEL_301;
  if ((_DWORD)v112 != 8)
  {
    v28 = v108;
    if (cmap_yydebug)
    {
      fprintf(*v25, "%s ", "Shifting");
      v114 = (FILE *)*MEMORY[0x1E0C80C10];
      if (v219 >= 0x2A)
        fprintf(v114, v108, yytname[v219]);
      else
        fprintf(v114, "token %s (");
      v115 = v114;
      v25 = (FILE **)MEMORY[0x1E0C80C10];
      fputc(41, v115);
      fputc(10, *v25);
    }
    if ((_DWORD)v223)
      v116 = -2;
    else
      v116 = 0;
    LODWORD(v223) = v116;
    *((_OWORD *)v30 + 1) = v231;
    v30 += 2;
    v26 = v113;
    goto LABEL_219;
  }
  v226 = (char *)v29;
  LODWORD(v29) = 0;
  v214 = v235;
  v215 = 1;
LABEL_316:
  v192 = (int)v223;
LABEL_317:
  if (v192 != -2 && v192)
    yydestruct("Cleanup: discarding lookahead", v219, (void **)&v231);
  v193 = &v226[-2 * v29];
  v194 = (char *)__src;
  if (cmap_yydebug)
    yy_stack_print((__int16 *)__src, (unint64_t)&v226[-2 * v29]);
  if (v193 != v194)
  {
    v195 = (void **)&v30[-2 * v29];
    do
    {
      v196 = *(__int16 *)v193;
      v193 -= 2;
      yydestruct("Cleanup: popping", yystos[v196], v195);
      v195 -= 2;
    }
    while (v193 != v194);
  }
  if (v194 != v234)
    free(v194);
  v5 = *(_QWORD *)v220;
  if (v214 != v235)
    free(v214);
  if (*(_QWORD *)v7)
    CFRelease(*(CFTypeRef *)v7);
  v197 = *(void ****)(v7 + 40);
  if (v197)
  {
    v198 = *(_QWORD *)(v7 + 24);
    while (v197[v198])
    {
      cmap_yy_delete_buffer(v197[v198], v7);
      v198 = *(_QWORD *)(v7 + 24);
      *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * v198) = 0;
      v197 = *(void ****)(v7 + 40);
      if (!v197)
        break;
      if (v197[v198])
      {
        cmap_yy_delete_buffer(v197[v198], v7);
        v199 = *(_QWORD *)(v7 + 24);
        *(_QWORD *)(*(_QWORD *)(v7 + 40) + 8 * v199) = 0;
        if (v199)
        {
          v198 = v199 - 1;
          *(_QWORD *)(v7 + 24) = v199 - 1;
        }
        else
        {
          v198 = 0;
        }
        v197 = *(void ****)(v7 + 40);
        if (!v197)
          break;
        v200 = v197[v198];
        if (v200)
        {
          *(_QWORD *)(v7 + 56) = v200[4];
          v201 = v200[2];
          *(_QWORD *)(v7 + 72) = v201;
          *(_QWORD *)(v7 + 136) = v201;
          *(_QWORD *)(v7 + 8) = *v197[v198];
          *(_BYTE *)(v7 + 48) = *v201;
          *(_DWORD *)(v7 + 88) = 1;
        }
      }
    }
  }
  free(v197);
  *(_QWORD *)(v7 + 40) = 0;
  free(*(void **)(v7 + 104));
  free((void *)v7);
  if (!v215)
  {
LABEL_351:
    cmap_release(v5);
    v5 = 0;
    goto LABEL_352;
  }
  v202 = *(_QWORD *)(v5 + 48);
  if (v202)
  {
    v203 = *(const __CFArray **)(v202 + 8);
    if (v203)
    {
      Count = CFArrayGetCount(v203);
      if (Count)
      {
        v205 = Count;
        for (i = 0; i != v205; ++i)
        {
          v207 = *((_QWORD *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v202 + 8), i) + 2);
          if (v207)
            cmap_cid_set_normalize(v207);
        }
      }
    }
  }
LABEL_352:
  free(v3);
  return v5;
}

uint64_t get_name(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 8);
  return result;
}

uint64_t get_ros(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t get_wmode(uint64_t a1)
{
  return *(unsigned int *)(a1 + 24);
}

uint64_t get_max_unicodes(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 48);
  if (v1 && (v2 = *(_QWORD *)(v1 + 16)) != 0)
    return *(_QWORD *)(v2 + 40);
  else
    return 0;
}

unint64_t get_unicodes_for_index(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  v8 = *(_QWORD *)(a1 + 48);
  if (v8)
    return cmap_bf_set_get_unichars(*(_QWORD *)(v8 + 16), a2, a3, a4, a5, a6, a7, a8);
  else
    return 0;
}

uint64_t get_index_for_unicodes(uint64_t a1, unsigned __int16 *a2, uint64_t a3)
{
  uint64_t v3;
  int8x8_t *v4;
  BOOL v5;
  int8x8_t v6;
  unint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  uint64_t ***v11;
  uint64_t **i;
  unint64_t v13;

  v3 = *(_QWORD *)(a1 + 48);
  if (!v3)
    return 0;
  v4 = *(int8x8_t **)(v3 + 16);
  if (v4)
    v5 = a3 == 1;
  else
    v5 = 0;
  if (v5)
  {
    v6 = v4[7];
    if (v6)
    {
      v7 = *a2;
      v8 = (uint8x8_t)vcnt_s8(v6);
      v8.i16[0] = vaddlv_u8(v8);
      if (v8.u32[0] > 1uLL)
      {
        v9 = *a2;
        if (*(_QWORD *)&v6 <= v7)
          v9 = v7 % *(_QWORD *)&v6;
      }
      else
      {
        v9 = (v6.i32[0] - 1) & v7;
      }
      v11 = *(uint64_t ****)(*(_QWORD *)&v4[6] + 8 * v9);
      if (v11)
      {
        for (i = *v11; i; i = (uint64_t **)*i)
        {
          v13 = (unint64_t)i[1];
          if (v13 == v7)
          {
            if (*((unsigned __int16 *)i + 8) == (_DWORD)v7)
              return *((unsigned __int16 *)i + 9);
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v13 >= *(_QWORD *)&v6)
                v13 %= *(_QWORD *)&v6;
            }
            else
            {
              v13 &= *(_QWORD *)&v6 - 1;
            }
            if (v13 != v9)
              return 0xFFFFFFFFLL;
          }
        }
      }
    }
  }
  return 0xFFFFFFFFLL;
}

_QWORD *zapf_table(_QWORD *a1)
{
  _QWORD *v1;
  __CFWriteStream *v2;
  __CFWriteStream *v3;
  uint64_t v4;
  int *v5;
  int v6;
  unsigned __int16 *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 *v13;
  unsigned int v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int16 v21;
  uint64_t v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;
  unsigned __int16 *v31;
  unsigned int v32;
  unsigned int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t unichars;
  unint64_t v48;
  unsigned __int16 *v49;
  unsigned int v50;
  int v51;
  int v52;
  uint64_t v54;
  unsigned __int16 *v55;
  UInt8 buffer[4];

  v1 = a1;
  if (a1)
  {
    v2 = CFWriteStreamCreateWithAllocatedBuffers(0, 0);
    if (v2)
    {
      v3 = v2;
      CFWriteStreamOpen(v2);
      *(_WORD *)buffer = 512;
      CFWriteStreamWrite(v3, buffer, 2);
      *(_WORD *)buffer = 0;
      CFWriteStreamWrite(v3, buffer, 2);
      *(_DWORD *)buffer = 0;
      CFWriteStreamWrite(v3, buffer, 4);
      v4 = v1[6];
      if (v4)
      {
        if (*(_QWORD *)(v4 + 16))
        {
          *(_WORD *)buffer = 1536;
          CFWriteStreamWrite(v3, buffer, 2);
          v5 = *(int **)(v4 + 16);
          v6 = *v5;
          v7 = (unsigned __int16 *)malloc_type_malloc(2 * *((_QWORD *)v5 + 5), 0x1000040BDFB0063uLL);
          if (v7)
          {
            v13 = v7;
            v14 = 0;
            v15 = 0;
            do
            {
              if (cmap_bf_set_get_unichars(*(_QWORD *)(v4 + 16), v15, (uint64_t)v13, v8, v9, v10, v11, v12))
                ++v14;
              ++v15;
            }
            while (v15 <= (unsigned __int16)v6);
            v55 = (unsigned __int16 *)malloc_type_malloc(2 * (unsigned __int16)v14, 0x1000040BDFB0063uLL);
            if (v55)
            {
              v21 = 0;
              v22 = 0;
              do
              {
                if (cmap_bf_set_get_unichars(*(_QWORD *)(v4 + 16), v21, (uint64_t)v13, v16, v17, v18, v19, v20))
                  v55[v22++] = v21;
                ++v21;
              }
              while (v21 <= (unsigned __int16)v6);
              *(_WORD *)buffer = 1536;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(v14) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              v54 = (unsigned __int16)v14;
              if ((unsigned __int16)v14 <= 0x8000u)
              {
                if ((unsigned __int16)v14 < 2u)
                {
                  v24 = 0;
                  v23 = 0xFFFF;
                }
                else
                {
                  v25 = 0;
                  LOWORD(v26) = 1;
                  do
                  {
                    v23 = v25++;
                    v26 = 2 * (v26 & 0x7FFF);
                  }
                  while (v26 < (unsigned __int16)v14);
                  v24 = v26 >> 1;
                }
              }
              else
              {
                v23 = 15;
                v24 = 0x8000;
              }
              *(_WORD *)buffer = bswap32(6 * v24) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(v23) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = bswap32(6 * (v14 - v24)) >> 16;
              CFWriteStreamWrite(v3, buffer, 2);
              v27 = 6 * (unsigned __int16)v14 + 26;
              v28 = v27 & 2;
              v29 = v28 + v27;
              if ((_WORD)v14)
              {
                v30 = (unsigned __int16)v14;
                v31 = v55;
                v32 = v28 + v27;
                do
                {
                  v33 = *v31++;
                  *(_WORD *)buffer = __rev16(v33);
                  CFWriteStreamWrite(v3, buffer, 2);
                  *(_DWORD *)buffer = bswap32(v32);
                  CFWriteStreamWrite(v3, buffer, 4);
                  v39 = v32
                      + 2 * cmap_bf_set_get_unichars(*(_QWORD *)(v4 + 16), v33, (uint64_t)v13, v34, v35, v36, v37, v38)
                      + 12;
                  LOWORD(v40) = v39 & 3;
                  if (v39 <= 0)
                    v40 = -(-v39 & 3);
                  v32 = v39 + (unsigned __int16)v40;
                  --v30;
                }
                while (v30);
              }
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              *(_WORD *)buffer = -1;
              CFWriteStreamWrite(v3, buffer, 2);
              for (; v28; --v28)
              {
                buffer[0] = 0;
                CFWriteStreamWrite(v3, buffer, 1);
              }
              if ((_WORD)v14)
              {
                v46 = 0;
                do
                {
                  unichars = cmap_bf_set_get_unichars(*(_QWORD *)(v4 + 16), v55[v46], (uint64_t)v13, v41, v42, v43, v44, v45);
                  *(_DWORD *)buffer = -1;
                  CFWriteStreamWrite(v3, buffer, 4);
                  *(_DWORD *)buffer = -1;
                  CFWriteStreamWrite(v3, buffer, 4);
                  *(_WORD *)buffer = bswap32(unichars) >> 16;
                  CFWriteStreamWrite(v3, buffer, 2);
                  if (unichars)
                  {
                    v48 = unichars;
                    v49 = v13;
                    do
                    {
                      v50 = *v49++;
                      *(_WORD *)buffer = bswap32(v50) >> 16;
                      CFWriteStreamWrite(v3, buffer, 2);
                      --v48;
                    }
                    while (v48);
                  }
                  *(_WORD *)buffer = 0;
                  CFWriteStreamWrite(v3, buffer, 2);
                  v51 = v29 + 2 * unichars + 12;
                  if ((v51 & 3) != 0)
                  {
                    v52 = v51 & 3;
                    do
                    {
                      buffer[0] = 0;
                      CFWriteStreamWrite(v3, buffer, 1);
                      --v52;
                    }
                    while ((_WORD)v52);
                  }
                  v29 = (v51 & 3) + v51;
                  ++v46;
                }
                while (v46 != v54);
              }
              free(v55);
              free(v13);
            }
          }
        }
      }
      v1 = CFWriteStreamCopyProperty(v3, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
      CFWriteStreamClose(v3);
      CFRelease(v3);
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t color_space_state_create_with_profile_sets(unint64_t a1, unint64_t theArray)
{
  void *profile_from_set_f;
  CFIndex v4;
  const __CFDictionary *ValueAtIndex;
  const void *Value;
  const __CFData *number_of_components_f;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  char *v21;
  char *v22;
  CFTypeRef v23;
  CFTypeRef v24;
  CFTypeID v25;
  CFDictionaryRef v26;
  const __CFDictionary *v27;
  void *v28;
  const __CFData *v29;
  CGDataProviderRef v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  CGColorSpaceRef DeviceCMYK;
  unsigned int v38;
  BOOL v39;
  size_t v40;
  char *v41;
  unint64_t v42;
  char *v43;
  CC_MD5_CTX *MD5;
  CC_MD5_CTX *v45;
  uint64_t v46;
  unsigned int v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  __int128 v51;
  __int128 v53;
  void *keys[38];
  void *values[2];
  const __CFString *v56;
  const __CFString *v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  if (!(a1 | theArray))
    return 0;
  profile_from_set_f = (void *)a1;
  if (a1)
  {
    v4 = 0;
  }
  else
  {
    v4 = CFArrayGetCount((CFArrayRef)theArray) - 1;
    a1 = theArray;
  }
  ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)a1, v4);
  if (!ValueAtIndex)
    return 0;
  Value = CFDictionaryGetValue(ValueAtIndex, CFSTR("ColorSyncProfile"));
  if (profile_sets_get_number_of_components_cglibrarypredicate != -1)
    dispatch_once(&profile_sets_get_number_of_components_cglibrarypredicate, &__block_literal_global_12_4937);
  number_of_components_f = (const __CFData *)profile_sets_get_number_of_components_f(Value);
  v8 = (uint64_t)number_of_components_f;
  if (number_of_components_f)
  {
    v9 = *((_DWORD *)CFDataGetBytePtr(number_of_components_f) + 4);
    if (v9 > 1213421087)
    {
      if (v9 <= 1296255028)
      {
        if (v9 == 1213421088 || v9 == 1281450528)
          goto LABEL_36;
        v11 = 1282766368;
      }
      else
      {
        if (v9 <= 1380401695)
        {
          switch(v9)
          {
            case 1296255029:
              goto LABEL_19;
            case 1296255030:
              goto LABEL_54;
            case 1296255031:
              goto LABEL_55;
            case 1296255032:
              goto LABEL_56;
            default:
              goto LABEL_100;
          }
        }
        if (v9 == 1380401696 || v9 == 1501067552)
          goto LABEL_36;
        v11 = 1482250784;
      }
    }
    else
    {
      if (v9 <= 943934545)
      {
        if (v9 > 893602897)
        {
          switch(v9)
          {
            case 893602898:
LABEL_19:
              v10 = 5;
              break;
            case 910380114:
LABEL_54:
              v10 = 6;
              break;
            case 927157330:
LABEL_55:
              v10 = 7;
              break;
            default:
              goto LABEL_100;
          }
LABEL_37:
          CFRelease((CFTypeRef)v8);
          v12 = (char *)malloc_type_calloc(0x70uLL, 1uLL, 0xC37FA958uLL);
          v8 = (uint64_t)v12;
          if (!v12)
            return v8;
          *(_DWORD *)v12 = 1;
          *((_WORD *)v12 + 4) = 0;
          v12[10] = theArray != 0;
          *(_QWORD *)(v12 + 20) = -4294967286;
          v12[11] = 0;
          *((_QWORD *)v12 + 5) = v10;
          v20 = (uint64_t *)(v12 + 40);
          *((_WORD *)v12 + 7) = 0;
          *((_QWORD *)v12 + 13) = profile_sets_vtable;
          *((_DWORD *)v12 + 7) = -1;
          *((_QWORD *)v12 + 9) = 0;
          *((_QWORD *)v12 + 10) = 0;
          *((_QWORD *)v12 + 4) = icc_get_default_color_components(v10, v13, v14, v15, v16, v17, v18, v19);
          v21 = (char *)malloc_type_calloc(0x90uLL, 1uLL, 0x2D9ADD68uLL);
          *(_QWORD *)(v8 + 88) = v21;
          if (!v21)
          {
            free((void *)v8);
            return 0;
          }
          v22 = v21;
          if (profile_from_set_f)
            v23 = CFRetain(profile_from_set_f);
          else
            v23 = 0;
          *((_QWORD *)v22 + 1) = v23;
          if (theArray)
            v24 = CFRetain((CFTypeRef)theArray);
          else
            v24 = 0;
          *((_QWORD *)v22 + 2) = v24;
          if (profile_from_set_f)
          {
            v25 = CFGetTypeID(profile_from_set_f);
            if (v25 == CFArrayGetTypeID())
            {
              if (CFArrayGetCount((CFArrayRef)profile_from_set_f) < 2)
              {
                v27 = (const __CFDictionary *)CFArrayGetValueAtIndex((CFArrayRef)profile_from_set_f, 0);
                v28 = (void *)CFDictionaryGetValue(v27, CFSTR("ColorSyncProfile"));
                profile_from_set_f = v28;
                if (v28)
                  CFRetain(v28);
              }
              else
              {
                *(_OWORD *)keys = xmmword_1E1644EB0;
                *(_OWORD *)&keys[2] = *(_OWORD *)off_1E1644EC0;
                values[0] = CFSTR("concatenate");
                values[1] = profile_from_set_f;
                v56 = CFSTR("scnr");
                v57 = CFSTR("CG Platform Set Input Profile");
                v26 = CFDictionaryCreate(0, (const void **)keys, (const void **)values, 4, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
                if (create_profile_from_set_cglibrarypredicate != -1)
                  dispatch_once(&create_profile_from_set_cglibrarypredicate, &__block_literal_global_48_4941);
                profile_from_set_f = (void *)create_profile_from_set_f(v26);
                if (v26)
                  CFRelease(v26);
              }
            }
            else
            {
              profile_from_set_f = 0;
            }
          }
          if (color_space_state_create_with_profile_sets_cglibrarypredicate != -1)
            dispatch_once(&color_space_state_create_with_profile_sets_cglibrarypredicate, &__block_literal_global_4942);
          v29 = (const __CFData *)color_space_state_create_with_profile_sets_f(profile_from_set_f, 0);
          v30 = CGDataProviderCreateWithCFData(v29);
          *(_QWORD *)v22 = v30;
          if (v29)
          {
            CFRelease(v29);
            v30 = *(CGDataProviderRef *)v22;
          }
          if (v30)
          {
            if (color_space_state_create_with_profile_sets_cglibrarypredicate_3 != -1)
              dispatch_once(&color_space_state_create_with_profile_sets_cglibrarypredicate_3, &__block_literal_global_5_4943);
            *((_QWORD *)v22 + 7) = color_space_state_create_with_profile_sets_f_2(profile_from_set_f);
            memcpy(keys, &CGICCProfileInfoInitializer, 0x128uLL);
            CGCMSUtilsGetICCProfileInfo(profile_from_set_f, (uint64_t)keys, 0, v31, v32, v33, v34, v35);
            if (profile_from_set_f)
              CFRelease(profile_from_set_f);
            v36 = (int)keys[0];
            *(_DWORD *)(v8 + 24) = keys[0];
            *(_DWORD *)(v8 + 28) = v36;
            *(_BYTE *)(v8 + 12) = 0;
            *(_OWORD *)(v22 + 24) = *(_OWORD *)((char *)keys + 4);
            switch(v10)
            {
              case 4:
                DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
                break;
              case 3:
                DeviceCMYK = CGColorSpaceCreateDeviceRGB();
                break;
              case 1:
                DeviceCMYK = CGColorSpaceCreateDeviceGray();
                break;
              default:
                DeviceCMYK = 0;
                break;
            }
            *((_QWORD *)v22 + 6) = DeviceCMYK;
            v40 = 16 * v10;
            v41 = (char *)malloc_type_malloc(v40, 0x100004000313F17uLL);
            *((_QWORD *)v22 + 8) = v41;
            if (v41)
            {
              v42 = 0;
              do
              {
                v43 = &v41[v42];
                *(_QWORD *)v43 = keys[v42 / 8 + 3];
                *((_QWORD *)v43 + 1) = keys[v42 / 8 + 4];
                v42 += 16;
              }
              while (v40 != v42);
              values[0] = 0;
              values[1] = 0;
              MD5 = CGDigesterCreateMD5();
              v45 = MD5;
              if (MD5)
              {
                CC_MD5_Update(MD5, (const void *)(v8 + 20), 4u);
                CC_MD5_Update(v45, (const void *)(v8 + 40), 8u);
                v46 = *(_QWORD *)(v8 + 88);
                CC_MD5_Update(v45, (const void *)(v46 + 24), 0x10u);
              }
              else
              {
                v46 = *(_QWORD *)(v8 + 88);
              }
              if (*(_QWORD *)(v46 + 64))
              {
                v48 = *v20;
                if ((*v20 & 0x7FFFFFFFFFFFFFFFLL) != 0)
                {
                  v49 = 0;
                  v50 = 0;
                  do
                  {
                    if (v45)
                    {
                      CC_MD5_Update(v45, (const void *)(*(_QWORD *)(v46 + 64) + v49), 8u);
                      v48 = *v20;
                    }
                    ++v50;
                    v49 += 8;
                  }
                  while (v50 < 2 * v48);
                }
              }
              if (v45)
              {
                CC_MD5_Final((unsigned __int8 *)values, v45);
                v51 = *(_OWORD *)values;
              }
              else
              {
                v51 = 0uLL;
              }
              v53 = v51;
              free(v45);
              *(_OWORD *)(v8 + 56) = v53;
              return v8;
            }
            do
            {
              v47 = __ldxr((unsigned int *)v8);
              v39 = --v47 == 0;
            }
            while (__stxr(v47, (unsigned int *)v8));
          }
          else
          {
            if (profile_from_set_f)
              CFRelease(profile_from_set_f);
            do
              v38 = __ldxr((unsigned int *)v8);
            while (__stxr(v38 - 1, (unsigned int *)v8));
            v39 = v38 == 1;
          }
          if (v39)
            color_space_state_dealloc(v8);
          return 0;
        }
        if (v9 != 860048466)
        {
          if (v9 == 876825682)
            goto LABEL_32;
LABEL_100:
          CFRelease((CFTypeRef)v8);
          return 0;
        }
LABEL_36:
        v10 = 3;
        goto LABEL_37;
      }
      if (v9 <= 1129142602)
      {
        if (v9 == 943934546)
        {
LABEL_56:
          v10 = 8;
          goto LABEL_37;
        }
        v11 = 1129142560;
      }
      else
      {
        if (v9 == 1129142603)
        {
LABEL_32:
          v10 = 4;
          goto LABEL_37;
        }
        if (v9 == 1196573017)
        {
          v10 = 1;
          goto LABEL_37;
        }
        v11 = 1212961568;
      }
    }
    if (v9 != v11)
      goto LABEL_100;
    goto LABEL_36;
  }
  return v8;
}

uint64_t (*__color_space_state_create_with_profile_sets_block_invoke_2())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  v1 = colorsync_smart_null_4947;
  if (result)
    v1 = result;
  color_space_state_create_with_profile_sets_f_2 = (uint64_t (*)(_QWORD))v1;
  return result;
}

uint64_t colorsync_smart_null_4947()
{
  return 0;
}

uint64_t (*__color_space_state_create_with_profile_sets_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyData");
  v1 = colorsync_smart_null_4947;
  if (result)
    v1 = result;
  color_space_state_create_with_profile_sets_f = (uint64_t (*)(_QWORD, _QWORD))v1;
  return result;
}

uint64_t (*__create_profile_from_set_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncMakeProfile");
  v1 = colorsync_smart_null_4947;
  if (result)
    v1 = result;
  create_profile_from_set_f = (uint64_t (*)(_QWORD))v1;
  return result;
}

void profile_sets_finalize(uint64_t a1)
{
  uint64_t v1;
  const void *v2;
  const void *v3;
  const void *v4;
  const void *v5;
  const void *v6;

  v1 = *(_QWORD *)(a1 + 88);
  if (v1)
  {
    CGDataProviderRelease(*(CGDataProviderRef *)v1);
    v2 = *(const void **)(v1 + 8);
    if (v2)
      CFRelease(v2);
    v3 = *(const void **)(v1 + 16);
    if (v3)
      CFRelease(v3);
    v4 = *(const void **)(v1 + 40);
    if (v4)
      CFRelease(v4);
    v5 = *(const void **)(v1 + 48);
    if (v5)
      CFRelease(v5);
    v6 = *(const void **)(v1 + 56);
    if (v6)
      CFRelease(v6);
    free(*(void **)(v1 + 64));
  }
}

uint64_t profile_sets_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

CFTypeRef profile_sets_create_icc_profile_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  unint64_t *v11;
  const void *v12;
  __CFString *v13;
  CFTypeRef v14;

  if (!a1)
    return 0;
  v8 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v8 + 20) != 10)
    _CGHandleAssert("profile_sets_create_icc_profile_description", 122, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ProfileSets.c", "space->state->type == kCGColorSpaceProfileSets", "type %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
  v9 = *(_QWORD *)(v8 + 88);
  v12 = *(const void **)(v9 + 40);
  v11 = (unint64_t *)(v9 + 40);
  v10 = v12;
  if (v12)
    return CFRetain(v10);
  v13 = *(_QWORD *)(*(_QWORD *)(v8 + 88) + 56)
      ? *(__CFString **)(*(_QWORD *)(v8 + 88) + 56)
      : CFSTR("<no description>");
  v14 = CFRetain(v13);
  while (!__ldxr(v11))
  {
    if (!__stxr((unint64_t)v14, v11))
      goto LABEL_13;
  }
  __clrex();
  if (v14)
    CFRelease(v14);
LABEL_13:
  v10 = (const void *)*v11;
  if (*v11)
    return CFRetain(v10);
  else
    return 0;
}

__CFString *copy_debug_description(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  __CFString *Mutable;
  __CFString *v11;
  uint64_t v12;
  char i;
  char v14;
  uint64_t v15;
  const __CFArray *v16;
  char *v17;
  CFTypeID v18;
  CFIndex Count;
  uint64_t v20;
  const char *v21;
  CFIndex v22;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v24;
  CFTypeID v25;
  CFTypeID TypeID;
  const __CFString *v27;
  const void *Value;
  const __CFString *v29;
  const __CFString *v30;
  const __CFString *v31;

  if (a1)
  {
    v8 = *(_QWORD *)(a1 + 24);
    if (*(_DWORD *)(v8 + 20) != 10)
      _CGHandleAssert("copy_debug_description", 70, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/ColorSpaces/CGColorSpace_ProfileSets.c", "space->state->type == kCGColorSpaceProfileSets", "type %d", a6, a7, a8, *(_DWORD *)(v8 + 20));
    v9 = *(_QWORD *)(v8 + 88);
    if (v9)
    {
      if (*(_QWORD *)(v9 + 8) && os_variant_has_internal_content())
      {
        Mutable = CFStringCreateMutable(0, 0);
        v11 = 0;
        v12 = 0;
        for (i = 1; ; i = 0)
        {
          v14 = i;
          v15 = v9 + 8 * v12;
          v16 = *(const __CFArray **)(v15 + 8);
          if (v16)
          {
            v17 = off_1E1644E60[v12];
            v18 = CFGetTypeID(*(CFTypeRef *)(v15 + 8));
            if (v18 == CFArrayGetTypeID())
            {
              Count = CFArrayGetCount(v16);
              v20 = Count;
              v21 = "profiles";
              if (Count == 1)
                v21 = "profile";
              CFStringAppendFormat(Mutable, 0, CFSTR("\n\t\t%ld %s in %s set:\n\t\t\t"), Count, v21, v17);
              v11 = Mutable;
              if (v20 >= 1)
                break;
            }
          }
LABEL_28:
          v12 = 1;
          if ((v14 & 1) == 0)
            return v11;
        }
        v22 = 0;
        while (1)
        {
          ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v16, v22);
          if (ValueAtIndex)
          {
            v24 = ValueAtIndex;
            v25 = CFGetTypeID(ValueAtIndex);
            TypeID = CFDictionaryGetTypeID();
            v27 = CFSTR(";?;");
            if (v25 == TypeID)
            {
              Value = CFDictionaryGetValue(v24, CFSTR("ColorSyncProfile"));
              if (copy_debug_description_cglibrarypredicate != -1)
                dispatch_once(&copy_debug_description_cglibrarypredicate, &__block_literal_global_26_4970);
              v29 = (const __CFString *)copy_debug_description_f(Value);
              v30 = v29;
              v31 = v29 ? v29 : CFSTR("no profile description");
              CFStringAppend(Mutable, v31);
              if (v30)
                CFRelease(v30);
              v27 = CFSTR("; ");
              if (v22 >= v20 - 1)
                goto LABEL_26;
            }
          }
          else
          {
            v27 = CFSTR(";?;");
          }
          CFStringAppend(Mutable, v27);
LABEL_26:
          if (v20 == ++v22)
          {
            v11 = Mutable;
            goto LABEL_28;
          }
        }
      }
    }
  }
  return 0;
}

uint64_t (*__copy_debug_description_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyDescriptionString");
  v1 = colorsync_smart_null_4947;
  if (result)
    v1 = result;
  copy_debug_description_f = (uint64_t (*)(_QWORD))v1;
  return result;
}

uint64_t (*__profile_sets_get_number_of_components_block_invoke())()
{
  uint64_t (*result)();
  uint64_t (*v1)();

  if (CGLibraryLoadColorSyncDYLD_once != -1)
    dispatch_once(&CGLibraryLoadColorSyncDYLD_once, &__block_literal_global_19700);
  result = (uint64_t (*)())CGLibraryLoadColorSyncDYLD_handle;
  if (CGLibraryLoadColorSyncDYLD_handle)
    result = (uint64_t (*)())dlsym((void *)CGLibraryLoadColorSyncDYLD_handle, "ColorSyncProfileCopyHeader");
  v1 = colorsync_smart_null_4947;
  if (result)
    v1 = result;
  profile_sets_get_number_of_components_f = (uint64_t (*)(_QWORD))v1;
  return result;
}

CGColorSpaceRef CGColorSpaceConcatenate(CGColorSpace *a1, uint64_t a2, CGColorSpace *a3)
{
  uint64_t Pattern;
  CGColorSpace *v4;
  unsigned int Type;
  unsigned int v8;
  uint64_t v9;
  int v10;
  CGColorSpace **v11;
  const __CFArray *ProfileSetForColorSpace;
  const __CFArray *v13;
  __CFArray *v14;
  const __CFArray *v15;
  const __CFArray *v16;
  __CFArray *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  CGColorSpace *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  CGColorSpace *v34;
  const __CFData *v35;
  const __CFData *v36;
  uint64_t v37;
  size_t v38;
  const unsigned __int8 *BytePtr;
  CGColorSpaceRef Indexed;

  Pattern = 0;
  if (!a3)
    return (CGColorSpaceRef)Pattern;
  v4 = a1;
  if (!a1)
    return (CGColorSpaceRef)Pattern;
  while (1)
  {
    Type = CGColorSpaceGetType(a3);
    if (Type < 0xA && ((0x387u >> Type) & 1) != 0)
      return 0;
    v8 = CGColorSpaceGetType(v4);
    if (v8 != 8)
      break;
    v9 = *((_QWORD *)v4 + 3);
    v10 = *(_DWORD *)(v9 + 20);
    switch(v10)
    {
      case 6:
        v11 = (CGColorSpace **)(*(_QWORD *)(v9 + 88) + 56);
        break;
      case 10:
        v11 = (CGColorSpace **)(*(_QWORD *)(v9 + 88) + 48);
        break;
      case 8:
        v11 = (CGColorSpace **)(*(_QWORD *)(v9 + 88) + 8);
        break;
      default:
        return 0;
    }
    v4 = *v11;
    if (!*v11)
      return 0;
  }
  Pattern = 0;
  if (v8 > 0xB)
    return (CGColorSpaceRef)Pattern;
  if (((1 << v8) & 0xC78) != 0)
  {
    ProfileSetForColorSpace = CGCMSUtilsCreateProfileSetForColorSpace(v4, CFSTR("ColorSyncTransformDeviceToPCS"), 0, 0, *(unsigned __int8 *)(*((_QWORD *)v4 + 3) + 13), 0);
    v13 = CGCMSUtilsCreateProfileSetForColorSpace(a3, CFSTR("ColorSyncTransformPCSToPCS"), 0, 0, *(unsigned __int8 *)(*((_QWORD *)a3 + 3) + 13), 0);
    v14 = concatenate_sets(ProfileSetForColorSpace, v13);
    if (ProfileSetForColorSpace)
      CFRelease(ProfileSetForColorSpace);
    if (v13)
      CFRelease(v13);
    v15 = CGCMSUtilsCreateProfileSetForColorSpace(a3, CFSTR("ColorSyncTransformPCSToPCS"), 0, 0, *(unsigned __int8 *)(*((_QWORD *)a3 + 3) + 13), 1u);
    v16 = CGCMSUtilsCreateProfileSetForColorSpace(v4, CFSTR("ColorSyncTransformPCSToDevice"), 0, 0, *(unsigned __int8 *)(*((_QWORD *)v4 + 3) + 13), 1u);
    v17 = concatenate_sets(v15, v16);
    if (v15)
      CFRelease(v15);
    if (v16)
      CFRelease(v16);
    v25 = (unsigned int *)color_space_state_create_with_profile_sets((unint64_t)v14, (unint64_t)v17);
    if (v14)
      CFRelease(v14);
    if (v17)
      CFRelease(v17);
    Pattern = CGColorSpaceCreateWithState(v25, v18, v19, v20, v21, v22, v23, v24);
    if (v25)
    {
      do
      {
        v26 = __ldxr(v25);
        v27 = v26 - 1;
      }
      while (__stxr(v27, v25));
      if (!v27)
        color_space_state_dealloc((uint64_t)v25);
    }
    return (CGColorSpaceRef)Pattern;
  }
  if (v8 != 7)
  {
    if (v8 != 9)
      return (CGColorSpaceRef)Pattern;
    v28 = *((_QWORD *)v4 + 3);
    if ((*(_DWORD *)(v28 + 24) - 5) <= 1)
    {
      v29 = **(_QWORD **)(v28 + 88);
      if (v29)
      {
        v30 = (CGColorSpace *)CGColorSpaceConcatenate(v29, a2, a3);
        Pattern = (uint64_t)CGColorSpaceCreatePattern(v30);
        if (v30)
          CFRelease(v30);
        return (CGColorSpaceRef)Pattern;
      }
    }
    return 0;
  }
  v31 = *((_QWORD *)v4 + 3);
  if ((*(_DWORD *)(v31 + 24) - 5) > 1)
    v32 = 0;
  else
    v32 = **(_QWORD **)(v31 + 88);
  v33 = CGColorSpaceConcatenate(v32, a2, a3);
  if (!v33)
    return 0;
  v34 = (CGColorSpace *)v33;
  v35 = CGColorSpaceCopyColorTable((uint64_t)v4);
  v36 = v35;
  v37 = *((_QWORD *)v4 + 3);
  if (*(_DWORD *)(v37 + 24) == 5)
    v38 = *(_QWORD *)(*(_QWORD *)(v37 + 88) + 8);
  else
    v38 = -1;
  BytePtr = CFDataGetBytePtr(v35);
  Indexed = CGColorSpaceCreateIndexed(v34, v38, BytePtr);
  CFRelease(v36);
  CFRelease(v34);
  return Indexed;
}

__CFArray *concatenate_sets(const __CFArray *a1, const __CFArray *a2)
{
  __CFArray *Mutable;
  CFRange v6;
  CFRange v7;

  if (!((unint64_t)a1 | (unint64_t)a2))
    return 0;
  Mutable = CFArrayCreateMutable(0, 0, MEMORY[0x1E0C9B378]);
  if (Mutable)
  {
    if (a1)
    {
      v6.length = CFArrayGetCount(a1);
      v6.location = 0;
      CFArrayAppendArray(Mutable, a1, v6);
    }
    if (a2)
    {
      v7.length = CFArrayGetCount(a2);
      v7.location = 0;
      CFArrayAppendArray(Mutable, a2, v7);
    }
  }
  return Mutable;
}

const void *CGColorSpaceProfileSetsGetDestinationProfile(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  const __CFArray *v3;
  CFTypeID v4;
  const __CFDictionary *ValueAtIndex;
  const __CFDictionary *v6;
  CFTypeID v7;

  v1 = *(_QWORD *)(a1 + 24);
  if (*(_DWORD *)(v1 + 20) == 10
    && (v2 = *(_QWORD *)(v1 + 88), (v3 = *(const __CFArray **)(v2 + 16)) != 0)
    && (v4 = CFGetTypeID(*(CFTypeRef *)(v2 + 16)), v4 == CFArrayGetTypeID())
    && (ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v3, 0)) != 0
    && (v6 = ValueAtIndex, v7 = CFGetTypeID(ValueAtIndex), v7 == CFDictionaryGetTypeID()))
  {
    return CFDictionaryGetValue(v6, CFSTR("ColorSyncProfile"));
  }
  else
  {
    return 0;
  }
}

uint64_t device_gray_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t device_rgb_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t device_cmyk_get_descriptor(uint64_t a1)
{
  return *(_QWORD *)(a1 + 88);
}

uint64_t CGSCombineDeepMaskToDeepMask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  int v9;
  uint64_t result;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;

  if (a8 < 1)
    return 0xFFFFFFFFLL;
  v9 = 0;
  result = 0;
  do
  {
    if (a7 >= 1)
    {
      v11 = 0;
      v12 = a7 + 1;
      do
      {
        v13 = *(unsigned __int16 *)(a1 + 2 * v11);
        v14 = *(unsigned __int8 *)(a3 + v11);
        v9 |= v14;
        v15 = ((((v13 >> 5) & 0x1F) * v14 + ((((v13 >> 5) & 0x1F) * v14) >> 8) + 1) >> 3) & 0x3E0 | (((v13 & 0x1F) * v14 + (((v13 & 0x1F) * v14) >> 8) + 1) >> 8) | (4 * (((*(_WORD *)(a1 + 2 * v11) >> 10) & 0x1F) * (_WORD)v14 + (unsigned __int16)((((v13 >> 10) & 0x1F) * v14) >> 8)) + 4) & 0x7C00;
        result = v15 ^ v13 | result;
        *(_WORD *)(a5 + 2 * v11) = v15;
        --v12;
        ++v11;
      }
      while (v12 > 1);
    }
    a5 += a6;
    a1 += a2;
    a3 += a4;
  }
  while (a8-- > 1);
  if (!v9)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t CGSCombineMaskToMask(uint64_t a1, int a2, uint64_t a3, int a4, uint64_t a5, int a6, int a7, int a8)
{
  uint64_t result;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;

  if (a8 < 1)
    return 0xFFFFFFFFLL;
  result = 0;
  v10 = 0;
  v11 = a5 - 1;
  v12 = a3 - 1;
  v13 = a1 - 1;
  do
  {
    if (a7 >= 1)
    {
      v14 = a7 + 1;
      do
      {
        v16 = *(unsigned __int8 *)++v12;
        v15 = v16;
        v17 = *(unsigned __int8 *)++v13;
        v10 |= v15;
        v18 = v17 * v15 + ((v17 * v15) >> 8) + 1;
        result = v17 ^ (v18 >> 8) | result;
        *(_BYTE *)++v11 = BYTE1(v18);
        --v14;
      }
      while (v14 > 1);
    }
    v13 += a2 - (uint64_t)a7;
    v12 += a4 - (uint64_t)a7;
    v11 += a6 - (uint64_t)a7;
  }
  while (a8-- > 1);
  if (!v10)
    return 0xFFFFFFFFLL;
  return result;
}

uint64_t CGSCombineDeepMask(char *a1, int a2, char *a3, int a4, int a5, int a6, unsigned int a7)
{
  int v9;
  char *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  char *v24;
  char *v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned __int16 *v32;
  char *v33;
  unsigned int v34;
  unsigned __int16 *v35;
  _WORD *v36;
  unsigned int v37;
  unsigned int v38;
  char *v39;
  int v40;
  unsigned __int16 *v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  unsigned int v48;

  v9 = a2;
  v10 = a1;
  v11 = HIBYTE(a7);
  if (a5 == 1)
  {
    v12 = BYTE1(a7) + v11;
    v13 = 255;
    if (v12 <= 0xFE)
      v14 = 255 - v12;
    else
      v14 = 0;
    v15 = v14 > 0xFE;
  }
  else
  {
    if (a5 < 2)
      return 0;
    v14 = v11 ^ 0xFF;
    v13 = BYTE1(a7) ^ 0xFF;
    if (v11)
      v16 = -2;
    else
      v16 = -1;
    v17 = v16 + a5;
    if (BYTE1(a7))
      v15 = v17;
    else
      v15 = v17 + 1;
  }
  if (a6 != 1)
  {
    if (a6 >= 2)
    {
      v20 = BYTE2(a7) ^ 0xFF;
      v19 = a7 ^ 0xFF;
      if ((_BYTE)a7)
        v22 = -2;
      else
        v22 = -1;
      v23 = v22 + a6;
      if (BYTE2(a7))
        v21 = v23;
      else
        v21 = v23 + 1;
      goto LABEL_25;
    }
    return 0;
  }
  v18 = BYTE2(a7) + a7;
  v19 = 255;
  if (v18 <= 0xFE)
    v20 = 255 - v18;
  else
    v20 = 0;
  v21 = v20 > 0xFE;
LABEL_25:
  if (a1 != a3 || a2 != a4)
  {
    CGBlt_copyBytes(2 * a5, a6, a1, a3, a2, a4);
    v9 = a4;
    v10 = a3;
  }
  if (v20 <= 0xFE)
  {
    v24 = a3;
    v25 = v10;
    if (v14 <= 0xFE)
    {
      v25 = v10 + 2;
      v26 = *(unsigned __int16 *)v10;
      v27 = (v20 * v14 + ((v20 * v14) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v26 >> 5) & 0x1F) * v27 + ((((v26 >> 5) & 0x1F) * v27) >> 8) + 1) >> 3) & 0x3E0 | (((v26 & 0x1F) * v27 + (((v26 & 0x1F) * v27) >> 8) + 1) >> 8) | (4 * (((v26 >> 10) & 0x1F) * v27 + ((((v26 >> 10) & 0x1F) * v27) >> 8)) + 4) & 0x7C00;
      v24 = a3 + 2;
    }
    if (v15)
    {
      v28 = v15 + 1;
      do
      {
        v29 = *(unsigned __int16 *)v25;
        v25 += 2;
        *(_WORD *)v24 = ((((v29 >> 5) & 0x1F) * v20 + ((((v29 >> 5) & 0x1F) * v20) >> 8) + 1) >> 3) & 0x3E0 | (((v29 & 0x1F) * v20 + (((v29 & 0x1F) * v20) >> 8) + 1) >> 8) & 0x1F | (4 * (((v29 >> 10) & 0x1F) * v20 + ((((v29 >> 10) & 0x1F) * v20) >> 8)) + 4) & 0x7C00;
        v24 += 2;
        --v28;
      }
      while (v28 > 1);
    }
    if (v13 <= 0xFE)
    {
      v30 = *(unsigned __int16 *)v25;
      v31 = (v20 * v13 + ((v20 * v13) >> 8) + 1) >> 8;
      *(_WORD *)v24 = ((((v30 >> 5) & 0x1F) * v31 + ((((v30 >> 5) & 0x1F) * v31) >> 8) + 1) >> 3) & 0x3E0 | (((v30 & 0x1F) * v31 + (((v30 & 0x1F) * v31) >> 8) + 1) >> 8) & 0x1F | (4 * (((v30 >> 10) & 0x1F) * v31 + ((((v30 >> 10) & 0x1F) * v31) >> 8)) + 4) & 0x7C00;
    }
    v10 += v9;
    a3 += a4;
  }
  if (v21 >= 1)
  {
    v32 = (unsigned __int16 *)v10;
    v33 = a3;
    if (v14 <= 0xFE)
    {
      v34 = v21 + 1;
      v35 = (unsigned __int16 *)v10;
      v36 = a3;
      do
      {
        v37 = *v35;
        v35 = (unsigned __int16 *)((char *)v35 + v9);
        *v36 = ((((v37 >> 5) & 0x1F) * v14 + ((((v37 >> 5) & 0x1F) * v14) >> 8) + 1) >> 3) & 0x3E0 | (((v37 & 0x1F) * v14 + (((v37 & 0x1F) * v14) >> 8) + 1) >> 8) & 0x1F | (4 * (((v37 >> 10) & 0x1F) * v14 + ((((v37 >> 10) & 0x1F) * v14) >> 8)) + 4) & 0x7C00;
        v36 = (_WORD *)((char *)v36 + a4);
        --v34;
      }
      while (v34 > 1);
      v32 = (unsigned __int16 *)(v10 + 2);
      v33 = a3 + 2;
    }
    if (v13 <= 0xFE)
    {
      v38 = v15 & ~(v15 >> 31);
      v39 = &v33[2 * v38];
      v40 = v21 + 1;
      v41 = &v32[v38];
      do
      {
        v42 = *v41;
        v41 = (unsigned __int16 *)((char *)v41 + v9);
        *(_WORD *)v39 = ((((v42 >> 5) & 0x1F) * v13 + ((((v42 >> 5) & 0x1F) * v13) >> 8) + 1) >> 3) & 0x3E0 | (((v42 & 0x1F) * v13 + (((v42 & 0x1F) * v13) >> 8) + 1) >> 8) & 0x1F | (4 * (((v42 >> 10) & 0x1F) * v13 + ((((v42 >> 10) & 0x1F) * v13) >> 8)) + 4) & 0x7C00;
        v39 += a4;
        --v40;
      }
      while (v40 > 1);
    }
    v10 += v9 * v21;
    a3 += v21 * a4;
  }
  if (v19 <= 0xFE)
  {
    if (v14 <= 0xFE)
    {
      v43 = *(unsigned __int16 *)v10;
      v10 += 2;
      v44 = (v19 * v14 + ((v19 * v14) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v43 >> 5) & 0x1F) * v44 + ((((v43 >> 5) & 0x1F) * v44) >> 8) + 1) >> 3) & 0x3E0 | (((v43 & 0x1F) * v44 + (((v43 & 0x1F) * v44) >> 8) + 1) >> 8) | (4 * (((v43 >> 10) & 0x1F) * v44 + ((((v43 >> 10) & 0x1F) * v44) >> 8)) + 4) & 0x7C00;
      a3 += 2;
    }
    if (v15 >= 1)
    {
      v45 = v15 + 1;
      do
      {
        v46 = *(unsigned __int16 *)v10;
        v10 += 2;
        *(_WORD *)a3 = ((((v46 >> 5) & 0x1F) * v19 + ((((v46 >> 5) & 0x1F) * v19) >> 8) + 1) >> 3) & 0x3E0 | (((v46 & 0x1F) * v19 + (((v46 & 0x1F) * v19) >> 8) + 1) >> 8) & 0x1F | (4 * (((v46 >> 10) & 0x1F) * v19 + ((((v46 >> 10) & 0x1F) * v19) >> 8)) + 4) & 0x7C00;
        a3 += 2;
        --v45;
      }
      while (v45 > 1);
    }
    if (v13 <= 0xFE)
    {
      v47 = *(unsigned __int16 *)v10;
      v48 = (v19 * v13 + ((v19 * v13) >> 8) + 1) >> 8;
      *(_WORD *)a3 = ((((v47 >> 5) & 0x1F) * v48 + ((((v47 >> 5) & 0x1F) * v48) >> 8) + 1) >> 3) & 0x3E0 | (((v47 & 0x1F) * v48 + (((v47 & 0x1F) * v48) >> 8) + 1) >> 8) & 0x1F | (4 * (((v47 >> 10) & 0x1F) * v48 + ((((v47 >> 10) & 0x1F) * v48) >> 8)) + 4) & 0x7C00;
    }
  }
  return 1;
}

char *CGClipMaskCreate(const CGAffineTransform *a1, const void *a2, double a3, double a4, double a5, double a6)
{
  char *v12;
  char *v13;
  const CGAffineTransform *v14;
  __int128 v15;
  __int128 v16;

  if (!a2)
    return 0;
  v12 = (char *)malloc_type_malloc(0x60uLL, 0x2062DE7BuLL);
  v13 = v12;
  *(_DWORD *)v12 = 1;
  v14 = &CGAffineTransformIdentity;
  if (a1)
    v14 = a1;
  v16 = *(_OWORD *)&v14->c;
  v15 = *(_OWORD *)&v14->tx;
  *(_OWORD *)(v12 + 8) = *(_OWORD *)&v14->a;
  *(_OWORD *)(v12 + 24) = v16;
  *(_OWORD *)(v12 + 40) = v15;
  CFRetain(a2);
  *((_QWORD *)v13 + 7) = a2;
  *((double *)v13 + 8) = a3;
  *((double *)v13 + 9) = a4;
  *((double *)v13 + 10) = a5;
  *((double *)v13 + 11) = a6;
  return v13;
}

unsigned int *CGClipMaskCreateCopy(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

unsigned int *CGClipMaskRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

char *CGClipMaskCreateCopyByApplyingTransform(char *result, double *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  unsigned int v14;
  CGAffineTransform v15;

  if (result)
  {
    if (a2)
    {
      v2 = *((double *)result + 1);
      v3 = *((double *)result + 2);
      v4 = *((double *)result + 3);
      v5 = *((double *)result + 4);
      v6 = *((double *)result + 5);
      v7 = *((double *)result + 6);
      v8 = *a2;
      v9 = a2[1];
      v10 = a2[2];
      v11 = a2[3];
      v12 = a2[4];
      v13 = a2[5];
      v15.a = v3 * v10 + v2 * *a2;
      v15.b = v3 * v11 + v2 * v9;
      v15.c = v5 * v10 + v4 * v8;
      v15.d = v5 * v11 + v4 * v9;
      v15.tx = v12 + v10 * v7 + v6 * v8;
      v15.ty = v11 * v7 + v6 * v9 + v13;
      return CGClipMaskCreate(&v15, *((const void **)result + 7), *((double *)result + 8), *((double *)result + 9), *((double *)result + 10), *((double *)result + 11));
    }
    else
    {
      do
        v14 = __ldxr((unsigned int *)result);
      while (__stxr(v14 + 1, (unsigned int *)result));
    }
  }
  return result;
}

BOOL CGClipMaskEqualToClipMask(uint64_t a1, uint64_t a2)
{
  _BOOL8 result;

  if (a1 == a2)
    return 1;
  result = 0;
  if (a1 && a2)
  {
    if (*(_QWORD *)(a1 + 56) != *(_QWORD *)(a2 + 56))
      return 0;
    result = CGRectEqualToRect(*(CGRect *)(a1 + 64), *(CGRect *)(a2 + 64));
    if (result)
    {
      if (*(double *)(a1 + 8) != *(double *)(a2 + 8))
        return 0;
      return vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vuzp1q_s32((int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 16), *(float64x2_t *)(a2 + 16)), (int32x4_t)vceqq_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)(a2 + 32)))), 0xFuLL))) & (*(double *)(a1 + 48) == *(double *)(a2 + 48));
    }
  }
  return result;
}

__n128 CGClipMaskGetMatrix@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  const CGAffineTransform *v2;
  __int128 v3;
  __n128 result;

  v2 = (const CGAffineTransform *)(a1 + 8);
  if (!a1)
    v2 = &CGAffineTransformIdentity;
  v3 = *(_OWORD *)&v2->c;
  *(_OWORD *)a2 = *(_OWORD *)&v2->a;
  *(_OWORD *)(a2 + 16) = v3;
  result = *(__n128 *)&v2->tx;
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t CGClipMaskGetImage(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 56);
  return result;
}

CGFloat CGClipMaskGetRect(const CGRect *a1)
{
  const CGRect *v1;

  v1 = &CGRectNull;
  if (a1)
    v1 = a1 + 2;
  return v1->origin.x;
}

void region_enumerator_finalize(_QWORD *a1)
{
  const void *v2;
  void *v3;
  void *v4;

  v2 = (const void *)a1[2];
  if (v2)
    CFRelease(v2);
  v3 = (void *)a1[3];
  if (v3)
    free(v3);
  v4 = (void *)a1[4];
  if (v4)
    free(v4);
}

CFStringRef region_enumerator_copy_format_description(const void *a1, const __CFDictionary *a2)
{
  const __CFAllocator *v4;

  v4 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v4, a2, CFSTR("<CGSRegionEnumerator %p>"), a1);
}

CFStringRef region_enumerator_copy_debug_description(const void *a1)
{
  const __CFAllocator *v2;

  v2 = CFGetAllocator(a1);
  return CFStringCreateWithFormat(v2, 0, CFSTR("<CGSRegionEnumerator %p>"), a1);
}

_QWORD *CGSRegionEnumerator(_DWORD **a1)
{
  return CGSRegionEnumeratorWithDirection(a1, 0, 0);
}

_QWORD *CGSRegionEnumeratorWithDirection(_DWORD **a1, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  CFTypeID v13;
  _QWORD *v14;
  uint64_t v15;
  CFTypeID v17;
  const __CFString *v18;
  char CStringPtr;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  if (!a1)
    return 0;
  v13 = CFGetTypeID(a1);
  if (CGRegionGetTypeID_initOnce != -1)
    dispatch_once(&CGRegionGetTypeID_initOnce, &__block_literal_global_13431);
  if (v13 != __kCGRegionTypeID)
  {
    v17 = CFGetTypeID(a1);
    v18 = CFCopyTypeIDDescription(v17);
    CStringPtr = CFStringGetCStringPtr(v18, 0x8000100u);
    _CGHandleAssert("CGSRegionEnumeratorWithDirection", 108, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "CFGetTypeID(region) == CGRegionGetTypeID()", "CFType %s %p is not a CGRegion", v20, v21, v22, CStringPtr);
  }
  v14 = (_QWORD *)CGSRegionEnumeratorCreate(a1, v6, v7, v8, v9, v10, v11, v12);
  shape_enum_alloc((uint64_t)v14, a1[2], a3, a2);
  v14[3] = v15;
  if (!v15)
  {
    CGSReleaseRegionEnumerator(v14);
    return 0;
  }
  return v14;
}

uint64_t CGSRegionEnumeratorCreate(const void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t Instance;

  if (_block_invoke_once_5004 != -1)
    dispatch_once(&_block_invoke_once_5004, &__block_literal_global_4_5005);
  Instance = CGTypeCreateInstance(CGSRegionEnumeratorGetTypeID_region_enumerator_type_id, 56, a3, a4, a5, a6, a7, a8);
  if (a1)
    CFRetain(a1);
  *(_QWORD *)(Instance + 24) = 0;
  *(_QWORD *)(Instance + 32) = 0;
  *(_QWORD *)(Instance + 16) = a1;
  *(CGRect *)(Instance + 40) = CGRectNull;
  return Instance;
}

uint64_t CGSReleaseRegionEnumerator(const void *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFTypeID v5;

  if (a1)
  {
    v5 = CFGetTypeID(a1);
    if (_block_invoke_once_5004 != -1)
      dispatch_once(&_block_invoke_once_5004, &__block_literal_global_4_5005);
    if (v5 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id)
      _CGHandleAssert("CGSReleaseRegionEnumerator", 165, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e)", "enumerator: %p", v2, v3, v4, (char)a1);
    CFRelease(a1);
  }
  return 0;
}

uint64_t CGSRegionPathEnumerator(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeID v9;
  uint64_t v10;
  _DWORD *v11;
  uint64_t v12;
  _DWORD *v13;
  int v15;
  _DWORD *v16;
  uint64_t v17;
  char *v18;
  int *v19;
  int v20;
  char *v21;
  int v22;
  uint64_t v23;
  int *v24;
  int *v25;
  int v26;
  CFTypeID v27;
  const __CFString *v28;
  char CStringPtr;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v9 = CFGetTypeID(a1);
  if (CGRegionGetTypeID_initOnce != -1)
    dispatch_once(&CGRegionGetTypeID_initOnce, &__block_literal_global_13431);
  if (v9 != __kCGRegionTypeID)
  {
    v27 = CFGetTypeID(a1);
    v28 = CFCopyTypeIDDescription(v27);
    CStringPtr = CFStringGetCStringPtr(v28, 0x8000100u);
    _CGHandleAssert("CGSRegionPathEnumerator", 124, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "CFGetTypeID(region) == CGRegionGetTypeID()", "CFType %s %p is not a CGRegion", v30, v31, v32, CStringPtr);
  }
  v10 = CGSRegionEnumeratorCreate(a1, v2, v3, v4, v5, v6, v7, v8);
  v11 = (_DWORD *)a1[2];
  if (v11 && *v11 == 0x80000000 && (v12 = v11[1], (int)v12 >= 1))
  {
    if (v11 == (_DWORD *)&the_empty_shape || v11[v12] == 0x7FFFFFFF)
    {
      v13 = malloc_type_malloc(0x200uLL, 0x705560E0uLL);
      if (v13)
      {
        v13[8] = 0;
        *(_QWORD *)v13 = 0;
        *((_QWORD *)v13 + 1) = 0;
      }
    }
    else
    {
      v15 = 0;
      v16 = v11;
      do
      {
        v17 = (int)v16[1];
        v15 = v15 + v17 - 2;
        v16 += v17;
      }
      while (*v16 != 0x7FFFFFFF);
      v13 = malloc_type_malloc((32 * v15 + 551) & 0xFFFFFFFFFFFFFE00, 0x705560E0uLL);
      if (v13)
      {
        v18 = (char *)(v13 + 10);
        *(_QWORD *)v13 = v13 + 10;
        *((_QWORD *)v13 + 1) = v13 + 10;
        v13[8] = 0;
        *((_QWORD *)v13 + 2) = 0x8000000080000000;
        v19 = &v11[v11[1]];
        v20 = *v19;
        if (*v19 != 0x7FFFFFFF)
        {
          v21 = 0;
          do
          {
            v22 = v20;
            v23 = v19[1];
            v24 = &v19[v23];
            v20 = *v24;
            if ((int)v23 >= 3)
            {
              v25 = v19 + 2;
              do
              {
                v26 = v25[1];
                *((_DWORD *)v18 + 4) = *v25;
                *((_DWORD *)v18 + 5) = v20;
                *(_QWORD *)v18 = v21;
                *((_DWORD *)v18 + 6) = v22;
                *((_DWORD *)v18 + 7) = 0;
                if (v21)
                  *((_QWORD *)v21 + 1) = v18;
                v21 = v18 + 32;
                *((_DWORD *)v18 + 12) = v26;
                *((_DWORD *)v18 + 13) = v22;
                *((_QWORD *)v18 + 4) = v18;
                *((_QWORD *)v18 + 5) = 0;
                *((_DWORD *)v18 + 14) = v20;
                *((_DWORD *)v18 + 15) = 0;
                *((_QWORD *)v18 + 1) = v18 + 32;
                v18 += 64;
                v25 += 2;
              }
              while (v25 < v24);
              v21 = v18 - 32;
            }
            v19 = v24;
          }
          while (v20 != 0x7FFFFFFF);
        }
      }
    }
  }
  else
  {
    v13 = 0;
  }
  *(_QWORD *)(v10 + 32) = v13;
  *(_OWORD *)(v10 + 40) = 0u;
  *(_OWORD *)(v10 + 56) = 0u;
  return v10;
}

double *CGSNextRect(double *cf)
{
  double *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFTypeID v5;
  uint64_t v6;
  double v7;
  double v8;
  double v9;
  uint64_t v11;
  int v12;
  int v13;

  v1 = cf;
  if (cf)
  {
    v5 = CFGetTypeID(cf);
    if (_block_invoke_once_5004 != -1)
      dispatch_once(&_block_invoke_once_5004, &__block_literal_global_4_5005);
    if (v5 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id || (v6 = *((_QWORD *)v1 + 3)) == 0)
      _CGHandleAssert("CGSNextRect", 138, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e) && e->shape_enumerator != NULL", "enumerator: %p", v2, v3, v4, (char)v1);
    v13 = 0;
    v12 = 0;
    v11 = 0;
    if (shape_enum_next(v6, &v13, &v12, (_DWORD *)&v11 + 1, &v11))
    {
      v7 = (double)v12;
      v8 = (double)(HIDWORD(v11) - v13);
      v9 = (double)((int)v11 - v12);
      v1[5] = (double)v13;
      v1[6] = v7;
      v1 += 5;
      v1[2] = v8;
      v1[3] = v9;
    }
    else
    {
      return 0;
    }
  }
  return v1;
}

uint64_t CGSNextPoint(uint64_t result, double *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  CFTypeID v7;
  uint64_t *v8;
  int v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  _DWORD *v17;
  _DWORD *v18;
  _DWORD *v19;
  _DWORD *v20;
  _DWORD *v21;
  signed int v22;
  int v23;
  int v24;
  signed int v25;
  int v26;
  int v27;
  int v28;
  _DWORD *v37;
  int v38;
  int v39;
  int v40;
  char v49;
  BOOL v50;
  _BOOL4 v51;
  _DWORD *v52;
  BOOL v53;
  BOOL v54;
  char v55;
  _BOOL4 v56;
  BOOL v57;
  _DWORD *v58;
  uint64_t i;

  if (result)
  {
    v3 = result;
    v7 = CFGetTypeID((CFTypeRef)result);
    if (_block_invoke_once_5004 != -1)
      dispatch_once(&_block_invoke_once_5004, &__block_literal_global_4_5005);
    if (v7 != CGSRegionEnumeratorGetTypeID_region_enumerator_type_id || (v8 = *(uint64_t **)(v3 + 32)) == 0)
      _CGHandleAssert("CGSNextPoint", 152, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/Regions/CGSRegionEnumerator.c", "REGION_IS_REGION_ENUM(e) && e->path_enumerator != NULL", "enumerator: %p", v4, v5, v6, v3);
    if (*((_DWORD *)v8 + 8))
    {
      v9 = *((_DWORD *)v8 + 6);
      v10 = *((_DWORD *)v8 + 7);
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v10;
      *((_DWORD *)v8 + 8) = 0;
      result = 1;
LABEL_8:
      *a2 = (double)v9;
      a2[1] = (double)v10;
      *(double *)(v3 + 40) = (double)v9;
      *(double *)(v3 + 48) = (double)v10;
      return result;
    }
    v11 = *v8;
    if (!*v8)
      return 0;
    v12 = (_DWORD *)v8[1];
    v9 = *(_DWORD *)(v11 + 16);
    if ((_DWORD *)v11 == v12)
    {
      v13 = *(_DWORD *)(v11 + 20);
      v15 = *(_DWORD *)(v11 + 24);
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v13;
      *((_DWORD *)v8 + 6) = v9;
      *((_DWORD *)v8 + 7) = v15;
      *((_DWORD *)v8 + 9) = v15 < v13;
      result = 0xFFFFFFFFLL;
      v14 = 1;
    }
    else
    {
      v13 = *(_DWORD *)(v11 + 20);
      if (v9 == *((_DWORD *)v8 + 4) && v13 == *((_DWORD *)v8 + 5))
      {
        v14 = 0;
        v15 = *(_DWORD *)(v11 + 24);
        *((_DWORD *)v8 + 4) = v9;
        *((_DWORD *)v8 + 5) = v15;
        result = 1;
        v10 = v15;
        goto LABEL_19;
      }
      *((_DWORD *)v8 + 4) = v9;
      *((_DWORD *)v8 + 5) = v13;
      v15 = *(_DWORD *)(v11 + 24);
      *((_DWORD *)v8 + 6) = v9;
      *((_DWORD *)v8 + 7) = v15;
      v14 = 1;
      result = 1;
    }
    v10 = v13;
LABEL_19:
    *((_DWORD *)v8 + 8) = v14;
    v16 = *(_QWORD *)(v11 + 8);
    if (v16)
    {
      v17 = 0;
      v18 = 0;
      v19 = 0;
      v20 = 0;
      v21 = 0;
      v22 = 0x80000000;
      v23 = 0x7FFFFFFF;
      v24 = 0x7FFFFFFF;
      v25 = 0x80000000;
      do
      {
        v26 = *(_DWORD *)(v16 + 20);
        if (v26 != v15 && *(_DWORD *)(v16 + 24) != v15)
          break;
        v27 = *(_DWORD *)(v16 + 16);
        v28 = v27 - v9;
        if (v26 == v13 || *(_DWORD *)(v16 + 24) == v13)
        {
          if (v28 >= 1 && v28 <= v24)
          {
            v19 = (_DWORD *)v16;
            v24 = v28;
          }
          if (v28 < 0 && v28 >= v25)
          {
            v21 = (_DWORD *)v16;
            v25 = v28;
          }
        }
        else
        {
          if (v28 >= 1 && v28 <= v23)
          {
            v18 = (_DWORD *)v16;
            v23 = v27 - v9;
          }
          if (v28 < 0 && v28 >= v22)
          {
            v20 = (_DWORD *)v16;
            v22 = v27 - v9;
          }
          if (v27 == v9)
            v17 = (_DWORD *)v16;
        }
        v16 = *(_QWORD *)(v16 + 8);
      }
      while (v16);
    }
    else
    {
      v21 = 0;
      v20 = 0;
      v19 = 0;
      v18 = 0;
      v17 = 0;
      v24 = 0x7FFFFFFF;
      v25 = 0x80000000;
      v22 = 0x80000000;
      v23 = 0x7FFFFFFF;
    }
    v37 = *(_DWORD **)v11;
    if (*(_QWORD *)v11)
    {
      do
      {
        v38 = v37[5];
        if (v38 != v15 && v37[6] != v15)
          break;
        v39 = v37[4];
        v40 = v39 - v9;
        if (v38 == v13 || v37[6] == v13)
        {
          if (v40 >= 1 && v40 <= v24)
          {
            v19 = v37;
            v24 = v40;
          }
          if (v40 < 0 && v40 >= v25)
          {
            v21 = v37;
            v25 = v40;
          }
        }
        else
        {
          if (v40 >= 1 && v40 <= v23)
          {
            v18 = v37;
            v23 = v39 - v9;
          }
          if (v40 < 0 && v40 >= v22)
          {
            v20 = v37;
            v22 = v39 - v9;
          }
          if (v39 == v9)
            v17 = v37;
        }
        v37 = *(_DWORD **)v37;
      }
      while (v37);
    }
    if (v17 && v15 <= v13)
    {
      v22 = 0;
    }
    else
    {
      if (v17)
      {
        v23 = 0;
        v18 = v17;
      }
      if (!v20)
      {
        v17 = 0;
        v49 = 1;
        goto LABEL_123;
      }
      v17 = v20;
    }
    v49 = 0;
    if (v17[5] == v15 && v22 >= v25)
    {
      v49 = 0;
      v50 = v22 > v25 || v15 <= v13;
      v51 = !v50;
      if (!v17[7])
      {
        v52 = v17;
        if (!v51)
        {
LABEL_149:
          *v8 = (uint64_t)v52;
          if ((_DWORD *)v11 != v12)
            *(_DWORD *)(v11 + 28) = 1;
          if (v52 == v12)
          {
            v12[7] = 1;
            for (i = v8[1]; i; i = *(_QWORD *)(i + 8))
            {
              if (!*(_DWORD *)(i + 28))
                break;
            }
            *v8 = i;
            v8[1] = i;
          }
          goto LABEL_8;
        }
      }
    }
LABEL_123:
    if (!v18
      || (v18[5] == v15 ? (v53 = v23 <= v24) : (v53 = 0),
          !v53
       || (v23 >= v24 ? (v54 = v15 <= v13) : (v54 = 0),
           v54 ? (v55 = 0) : (v55 = 1),
           v18[7] || (v52 = v18, (v55 & 1) == 0))))
    {
      v56 = (v49 & 1) == 0 && v17[6] < v17[5];
      v57 = !v56;
      if (v56)
        v58 = v21;
      else
        v58 = v19;
      if (v57)
        v19 = v21;
      if (v15 > v13)
        v52 = v19;
      else
        v52 = v58;
    }
    goto LABEL_149;
  }
  return result;
}

uint64_t CGPDFArrayFinalize(uint64_t a1)
{
  _DWORD *v2;
  _DWORD *v3;

  CGPDFAssociationRelease(*(const void ***)(a1 + 56));
  v2 = *(_DWORD **)(a1 + 24);
  if (v2)
  {
    do
    {
      v3 = *(_DWORD **)v2;
      if ((v2[2] - 5) <= 4)
        pdf_object_release_compound_value((uint64_t)v2);
      free(v2);
      v2 = v3;
    }
    while (v3);
  }
  return pthread_mutex_destroy((pthread_mutex_t *)(a1 + 64));
}

CFTypeRef CGPDFArrayRetain(CFTypeRef cf)
{
  if (cf)
    CFRetain(cf);
  return cf;
}

void CGPDFArrayRelease(CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
}

size_t CGPDFArrayGetCount(size_t array)
{
  if (array)
    return *(_QWORD *)(array + 16);
  return array;
}

BOOL CGPDFArrayGetNull(CGPDFArrayRef array, size_t index)
{
  _BOOL4 Object;
  CGPDFObjectRef value;

  value = 0;
  Object = CGPDFArrayGetObject(array, index, &value);
  if (Object)
  {
    if (value)
      LOBYTE(Object) = *((_DWORD *)value + 2) == 1;
    else
      LOBYTE(Object) = 0;
  }
  return Object;
}

BOOL CGPDFArrayGetBoolean(CGPDFArrayRef array, size_t index, CGPDFBoolean *value)
{
  _BOOL4 Object;
  CGPDFObjectRef valuea;

  valuea = 0;
  Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 2)
    {
      if (value)
        *value = *((_BYTE *)valuea + 32);
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetInteger(CGPDFArrayRef array, size_t index, CGPDFInteger *value)
{
  _BOOL4 Object;
  int v5;
  BOOL v6;
  CGPDFObjectRef valuea;

  valuea = 0;
  Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && ((v5 = *((_DWORD *)valuea + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (value)
        *value = *((_QWORD *)valuea + 4);
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetString(CGPDFArrayRef array, size_t index, CGPDFStringRef *value)
{
  _BOOL4 Object;
  CGPDFObjectRef valuea;

  valuea = 0;
  Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 6)
    {
      if (value)
        *value = (CGPDFStringRef)*((_QWORD *)valuea + 4);
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

BOOL CGPDFArrayGetArray(CGPDFArrayRef array, size_t index, CGPDFArrayRef *value)
{
  _BOOL4 Object;
  CGPDFObjectRef valuea;

  valuea = 0;
  Object = CGPDFArrayGetObject(array, index, &valuea);
  if (Object)
  {
    if (valuea && *((_DWORD *)valuea + 2) == 7)
    {
      if (value)
        *value = (CGPDFArrayRef)*((_QWORD *)valuea + 4);
      LOBYTE(Object) = 1;
    }
    else
    {
      LOBYTE(Object) = 0;
    }
  }
  return Object;
}

void CGPDFArrayApplyBlock(CGPDFArrayRef array, CGPDFArrayApplierBlock block, void *info)
{
  uint64_t v5;
  size_t i;
  CGPDFObjectRef value;

  if (array)
  {
    if (block)
    {
      v5 = *((_QWORD *)array + 2);
      if (v5)
      {
        for (i = 0; i != v5; ++i)
        {
          value = 0;
          if (CGPDFArrayGetObject(array, i, &value)
            && !(*((unsigned int (**)(CGPDFArrayApplierBlock, size_t, CGPDFObjectRef, void *))block + 2))(block, i, value, info))
          {
            break;
          }
        }
      }
    }
  }
}

BOOL CGPDFArrayGetOffset(CGPDFArray *a1, size_t a2, _QWORD *a3)
{
  _BOOL8 result;
  int v5;
  BOOL v6;
  CGPDFObjectRef value;

  value = 0;
  result = CGPDFArrayGetObject(a1, a2, &value);
  if (result)
  {
    if (value && ((v5 = *((_DWORD *)value + 2), v5 != 12) ? (v6 = v5 == 3) : (v6 = 1), v6))
    {
      if (a3)
        *a3 = *((_QWORD *)value + 4);
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return result;
}

uint64_t CGPDFArrayGetIntegers(uint64_t array, uint64_t a2, uint64_t a3)
{
  CGPDFArray *v4;
  size_t v6;
  CGPDFInteger value;

  if (array)
  {
    v4 = (CGPDFArray *)array;
    if (*(_QWORD *)(array + 16) == a3)
    {
      if (a3)
      {
        v6 = 0;
        value = 0;
        do
        {
          array = CGPDFArrayGetInteger(v4, v6, &value);
          if (!(_DWORD)array)
            break;
          *(_QWORD *)(a2 + 8 * v6++) = value;
        }
        while (a3 != v6);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return array;
}

uint64_t CGPDFArrayGetNumbers(uint64_t array, uint64_t a2, uint64_t a3)
{
  CGPDFArray *v4;
  size_t v6;
  CGPDFReal value;

  if (array)
  {
    v4 = (CGPDFArray *)array;
    if (*(_QWORD *)(array + 16) == a3)
    {
      if (a3)
      {
        v6 = 0;
        value = 0.0;
        do
        {
          array = CGPDFArrayGetNumber(v4, v6, &value);
          if (!(_DWORD)array)
            break;
          *(CGPDFReal *)(a2 + 8 * v6++) = value;
        }
        while (a3 != v6);
      }
      else
      {
        return 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return array;
}

uint64_t CGPDFArrayPrint(uint64_t a1, FILE *a2)
{
  return CGPDFArrayPrintWithIndent(a1, a2, 0);
}

uint64_t CGPDFArrayPrintWithIndent(uint64_t result, FILE *a2, int a3)
{
  uint64_t v4;
  FILE *v5;
  _QWORD *i;

  if (result)
  {
    v4 = result;
    if (a2)
      v5 = a2;
    else
      v5 = (FILE *)*MEMORY[0x1E0C80C10];
    fwrite("[\n", 2uLL, 1uLL, v5);
    for (i = *(_QWORD **)(v4 + 24); i; i = (_QWORD *)*i)
    {
      fprintf(v5, "%*s", a3 + 2, "");
      CGPDFObjectPrintWithIndent(i, v5, (a3 + 2));
      fputc(10, v5);
    }
    return fprintf(v5, "%*s]", a3, "");
  }
  return result;
}

uint64_t compareZoneReadingOrder(void *a1, void *a2)
{
  int v4;
  int v5;
  uint64_t v6;
  uint64_t result;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;

  v4 = objc_msgSend(a1, "count");
  v5 = objc_msgSend(a2, "count");
  if (v4 | v5)
    v6 = -1;
  else
    v6 = 0;
  if (v4)
    result = 1;
  else
    result = v6;
  if (v4 && v5)
  {
    v8 = keyPointOfZone(a1);
    v10 = v9;
    v11 = keyPointOfZone(a2);
    v13 = 1;
    v14 = -1;
    if (v8 >= v11)
      v14 = v8 > v11;
    if (v10 >= v12)
      v13 = v14;
    if (v10 <= v12)
      return v13;
    else
      return -1;
  }
  return result;
}

uint64_t compareLayoutReadingOrder(void *a1, void *a2)
{
  double v4;
  double v5;
  double v6;
  uint64_t v7;
  double v9;
  double v10;
  double width;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  double v17;
  double v18;
  CGRect v20;

  v4 = keyPointOfLayoutArea(a1);
  v6 = v5;
  objc_msgSend((id)objc_msgSend(a1, "firstChild"), "normalizedBounds");
  width = v9;
  if (v9 < 0.0 || v10 < 0.0)
  {
    v20 = CGRectStandardize(*(CGRect *)&v7);
    width = v20.size.width;
  }
  v12 = keyPointOfLayoutArea(a2);
  v14 = v13;
  objc_msgSend((id)objc_msgSend(a2, "firstChild"), "normalizedBounds");
  if (v4 + width * 0.5 < v12)
    return -1;
  if (v17 < 0.0 || v18 < 0.0)
    *(CGRect *)(&v17 - 2) = CGRectStandardize(*(CGRect *)&v15);
  if (v12 + v17 * 0.5 < v4)
    return 1;
  if (v6 <= v14)
    return v6 < v14;
  return -1;
}

double keyPointOfLayoutArea(void *a1)
{
  CGFloat v1;
  double v2;
  double v3;
  double v4;
  CGFloat v5;
  CGFloat v6;
  CGFloat v7;
  CGFloat v8;
  double v9;
  CGRect v11;

  objc_msgSend((id)objc_msgSend(a1, "firstChild"), "normalizedBounds");
  v5 = v1;
  v6 = v2;
  v7 = v3;
  v8 = v4;
  if (v3 >= 0.0 && v4 >= 0.0)
    return v1;
  *(_QWORD *)&v9 = (unint64_t)CGRectStandardize(*(CGRect *)&v1);
  v11.origin.x = v5;
  v11.origin.y = v6;
  v11.size.width = v7;
  v11.size.height = v8;
  CGRectStandardize(v11);
  return v9;
}

double keyPointOfZone(void *a1)
{
  unsigned int v2;
  unsigned int v3;
  double *v4;
  double v5;
  double v6;
  double v7;
  void *v8;
  unsigned int v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double height;
  uint64_t v18;
  uint64_t i;
  CGFloat v20;
  CGFloat v21;
  CGFloat v22;
  CGFloat v23;
  double v24;
  double v25;
  double v26;
  _BOOL4 v27;
  double v28;
  double v29;
  double v30;
  double v31;
  __double2 v32;
  CGFloat v33;
  double v34;
  uint64_t v35;
  double *v36;
  double v37;
  uint64_t v38;
  float64x2_t v39;
  float64x2_t v40;
  double *v41;
  double v42;
  double v43;
  double __base;
  double v46;
  double v47;
  double v48;
  double v49;
  double y;
  double v51;
  double v52;
  uint64_t v53;
  float64x2x2_t v54;
  float64x2x2_t v55;
  CGRect v56;
  CGRect v57;
  CGRect v58;
  CGRect v59;
  CGRect v60;
  CGRect v61;
  CGRect v62;
  CGRect v63;
  CGRect v64;

  v53 = *MEMORY[0x1E0C80C00];
  v2 = objc_msgSend(a1, "vertexCount");
  if (v2)
  {
    v3 = v2;
    v4 = (double *)objc_msgSend(a1, "outerVertices");
    v6 = *v4;
    v5 = v4[1];
    if (v3 == 1)
    {
      return *v4;
    }
    else
    {
      v35 = v3 - 1;
      v36 = v4 + 3;
      do
      {
        v7 = *(v36 - 1);
        v37 = *v36;
        if (v7 >= v6 && (v7 != v6 || v37 <= v5))
        {
          v7 = v6;
          v37 = v5;
        }
        v36 += 2;
        v5 = v37;
        v6 = v7;
        --v35;
      }
      while (v35);
    }
  }
  else
  {
    v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99DE8]), "initWithCapacity:", 1);
    objc_msgSend(a1, "descendantsOfClass:to:", objc_opt_class(), v8);
    v9 = objc_msgSend(v8, "count");
    if (v9)
    {
      objc_msgSend((id)objc_msgSend(v8, "objectAtIndex:", 0), "normalizedBounds");
      v11 = v10;
      v13 = v12;
      v15 = v14;
      height = v16;
      if (v9 != 1)
      {
        v18 = v9;
        for (i = 1; i != v18; ++i)
        {
          objc_msgSend((id)objc_msgSend(v8, "objectAtIndex:", i), "normalizedBounds");
          v64.origin.x = v20;
          v64.origin.y = v21;
          v64.size.width = v22;
          v64.size.height = v23;
          v56.origin.x = v11;
          v56.origin.y = v13;
          v56.size.width = v15;
          v56.size.height = height;
          *(CGRect *)&v10 = CGRectUnion(v56, v64);
          v11 = v10;
          v13 = v24;
          v15 = v25;
          height = v26;
        }
      }
      v27 = height < 0.0 || v15 < 0.0;
      v7 = v11;
      v28 = v13;
      v29 = height;
      if (v27)
      {
        v57.origin.x = v11;
        v57.origin.y = v13;
        v57.size.width = v15;
        v57.size.height = height;
        *(_QWORD *)&v7 = (unint64_t)CGRectStandardize(v57);
        v58.origin.x = v11;
        v58.origin.y = v13;
        v58.size.width = v15;
        v58.size.height = height;
        *(CGRect *)&v10 = CGRectStandardize(v58);
      }
      v30 = v28 + v29;
      objc_msgSend(a1, "rotationAngle", v10);
      if (v31 != 0.0)
      {
        v32 = __sincos_stret(v31);
        __base = v11;
        v46 = v13;
        v47 = v7;
        v48 = v30;
        if (v27)
        {
          v59.origin.x = v11;
          v59.origin.y = v13;
          v59.size.width = v15;
          v59.size.height = height;
          v60 = CGRectStandardize(v59);
          v33 = v60.origin.x + v60.size.width;
          v60.origin.x = v11;
          v60.origin.y = v13;
          v60.size.width = v15;
          v60.size.height = height;
          v61 = CGRectStandardize(v60);
          v49 = v33;
          y = v61.origin.y;
          v61.origin.x = v11;
          v61.origin.y = v13;
          v61.size.width = v15;
          v61.size.height = height;
          v62 = CGRectStandardize(v61);
          v34 = v62.origin.x + v62.size.width;
          v62.origin.x = v11;
          v62.origin.y = v13;
          v62.size.width = v15;
          v62.size.height = height;
          v63 = CGRectStandardize(v62);
          v13 = v63.origin.y;
          height = v63.size.height;
        }
        else
        {
          v34 = v11 + v15;
          v49 = v11 + v15;
          y = v13;
        }
        v38 = 0;
        v51 = v34;
        v52 = v13 + height;
        v39 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.__cosval, 0);
        v40 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.__sinval, 0);
        do
        {
          v41 = (double *)((char *)&__base + v38);
          v54 = vld2q_f64(v41);
          v55.val[0] = vaddq_f64(vmlaq_f64(vmulq_n_f64(v54.val[1], -v32.__sinval), v54.val[0], v39), (float64x2_t)0);
          v55.val[1] = vaddq_f64(vmlaq_f64(vmulq_n_f64(v54.val[1], v32.__cosval), v54.val[0], v40), (float64x2_t)0);
          vst2q_f64(v41, v55);
          v38 += 32;
        }
        while (v38 != 64);
        qsort(&__base, 4uLL, 0x10uLL, (int (__cdecl *)(const void *, const void *))left);
        v7 = __base;
        v42 = v47;
        if (__base == v47)
        {
          v43 = v48;
          if (v46 >= v48)
          {
            v43 = v46;
            v42 = __base;
          }
          if (v42 == v49 && v43 < y)
            v7 = v49;
          else
            v7 = v42;
        }
      }

    }
    else
    {

      return 0.0;
    }
  }
  return v7;
}

std::ios_base *__cdecl left(std::ios_base *__str)
{
  double *v1;

  if (*(double *)&__str->__vftable < *v1)
    return (std::ios_base *)0xFFFFFFFFLL;
  else
    return (std::ios_base *)(*v1 < *(double *)&__str->__vftable);
}

uint64_t compareKeyOrder(void *a1, void *a2)
{
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return compareLayoutReadingOrder(a1, a2);
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
      return compareZoneReadingOrder(a1, a2);
  }
  v5 = keyPoint(a1);
  v7 = v6;
  v8 = keyPoint(a2);
  if (v7 > v9)
    return -1;
  if (v7 < v9)
    return 1;
  if (v5 >= v8)
    return v5 > v8;
  return -1;
}

CGFloat keyPoint(void *a1)
{
  void *v3;
  double v4;
  CGFloat v6;
  double v7;
  double v8;
  double v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  CGRect v14;

  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    return keyPointOfZone(a1);
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v3 = a1;
    return keyPointOfLayoutArea(v3);
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v3 = (void *)objc_msgSend(a1, "firstChild");
    return keyPointOfLayoutArea(v3);
  }
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
    objc_msgSend(a1, "tableBounds");
  else
    objc_msgSend(a1, "renderedBounds");
  v10 = v6;
  v11 = v7;
  v12 = v8;
  v13 = v9;
  if (v8 >= 0.0 && v9 >= 0.0)
    return v6;
  *(_QWORD *)&v4 = (unint64_t)CGRectStandardize(*(CGRect *)&v6);
  v14.origin.x = v10;
  v14.origin.y = v11;
  v14.size.width = v12;
  v14.size.height = v13;
  CGRectStandardize(v14);
  return v4;
}

uint64_t cmyk32_sample_W8(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  unsigned __int8 *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  unsigned __int8 *v41;
  unsigned __int8 *v42;
  unsigned int v43;
  unint64_t v44;
  unsigned __int8 *v45;
  unsigned __int8 *v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned __int8 *v50;
  unsigned int v51;
  unint64_t v52;
  unsigned __int8 *v53;
  unsigned __int8 *v54;
  unsigned int v55;
  unsigned __int8 *v56;
  unint64_t v57;
  unint64_t v58;
  unsigned __int8 *v59;
  unsigned __int8 *v60;
  int v61;
  char v62;
  unsigned int v63;
  unsigned int v64;
  int v65;
  int v66;
  char v67;
  unsigned int v68;
  unsigned int v69;
  unsigned __int8 *v70;
  unsigned int v71;
  unsigned __int8 *v72;
  int v73;
  char v74;
  unsigned int v75;
  unsigned __int8 *v76;
  int v77;
  unsigned __int8 *v78;
  int v79;
  int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unsigned __int8 *v85;
  unsigned __int8 *v86;
  unint64_t v87;
  unsigned int v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v90 = *(_QWORD *)(result + 80);
  v92 = *(_QWORD *)(result + 88);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v11 = *(_QWORD *)(result + 152) - 8;
  v12 = *(_QWORD *)(result + 144) - 1;
  if (v5)
    v13 = 0;
  else
    v13 = -16777216;
  v14 = *(_DWORD *)(result + 260) - 1;
  v15 = *(unsigned int *)(result + 256);
  v16 = (unsigned __int8 *)(v5 + (v15 - 1) + (v14 * v7));
  v89 = *(_DWORD *)(result + 188);
  v17 = v4 + v15 + (v14 * v6) - 1;
  v91 = *(_QWORD *)(result + 64);
  v93 = *(_QWORD *)(result + 72);
  do
  {
    while (1)
    {
      if (a3 >= v93)
      {
        if (a3 <= v92)
        {
          v26 = ((unint64_t)a3 >> 22) & 0x3C0;
          v27 = 0x3FFFFFFF;
          v28 = a3;
          v29 = v91;
        }
        else
        {
          v22 = *(_QWORD *)(result + 216);
          v23 = *(_QWORD *)(result + 224) + v92;
          v24 = v23 - a3 + (v22 >> 1);
          if (v24 < 1)
            goto LABEL_43;
          if (v24 >= v22)
            LODWORD(v25) = 0x3FFFFFFF;
          else
            v25 = (unint64_t)(*(_QWORD *)(result + 232) * v24) >> 32;
          v29 = v91;
          v27 = v89 | v25;
          v28 = v23 - 0x1000000;
          v26 = 448;
        }
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = v93 - *(_QWORD *)(result + 224);
        v20 = a3 - v19 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_43;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v29 = v91;
        v27 = v89 | v21;
        v28 = v19 + 0x1000000;
        v26 = 512;
      }
      if (a2 >= v29)
        break;
      v30 = *(_QWORD *)(result + 192);
      v31 = v29 - *(_QWORD *)(result + 200);
      v32 = a2 - v31 + (v30 >> 1);
      if (v32 >= 1)
      {
        if (v32 < v30)
          v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v89;
        v33 = v31 + 0x1000000;
        v34 = 32;
        goto LABEL_29;
      }
LABEL_43:
      --a4;
      a2 += v10;
      a3 += v9;
      v11 += 8;
      *(_BYTE *)++v12 = 0;
      if (!a4)
        return result;
    }
    if (a2 <= v90)
    {
      v34 = ((unint64_t)a2 >> 26) & 0x3C;
      v33 = a2;
      goto LABEL_29;
    }
    v35 = *(_QWORD *)(result + 192);
    v36 = *(_QWORD *)(result + 200) + v90;
    v37 = v36 - a2 + (v35 >> 1);
    if (v37 < 1)
      goto LABEL_43;
    if (v37 < v35)
      v27 = ((v27 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v37) >> 32) >> 15)) | v89;
    v33 = v36 - 0x1000000;
    v34 = 28;
LABEL_29:
    if (v27 < 0x400000)
      goto LABEL_43;
    v38 = v28 >> 32;
    v39 = v4 + (int)v38 * (uint64_t)v6;
    v40 = v39 + (v33 >> 32);
    v41 = *(unsigned __int8 **)(result + 32);
    if (v17 >= v40)
      v42 = (unsigned __int8 *)(v39 + (v33 >> 32));
    else
      v42 = (unsigned __int8 *)v17;
    if (v42 < v41)
      v42 = *(unsigned __int8 **)(result + 32);
    v43 = *v42;
    if (v5)
    {
      v44 = v5 + (int)v38 * (uint64_t)v7 + (v33 >> 32);
      v45 = *(unsigned __int8 **)(result + 40);
      if ((unint64_t)v16 >= v44)
        v46 = (unsigned __int8 *)v44;
      else
        v46 = v16;
      if (v46 >= v45)
        v45 = v46;
      v43 |= *v45 << 24;
      if (!v8)
        goto LABEL_104;
    }
    else
    {
      v44 = 0;
      if (!v8)
        goto LABEL_104;
    }
    v47 = *(_DWORD *)(v8 + (v34 | v26));
LABEL_48:
    v48 = v47 & 0xF;
    v49 = HIBYTE(v47) & 3;
    switch(v48)
    {
      case 1:
        v70 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        if (v17 < (unint64_t)v70)
          v70 = (unsigned __int8 *)v17;
        if (v70 < v41)
          v70 = v41;
        v71 = *v70;
        if (v5)
        {
          v72 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          if (v16 < v72)
            v72 = v16;
          if ((unint64_t)v72 < *(_QWORD *)(result + 40))
            v72 = *(unsigned __int8 **)(result + 40);
          v71 |= *v72 << 24;
        }
        v73 = interpolate_8888_19472[v49];
        v74 = v49 + 1;
        v68 = v43 - ((v73 & v43) >> v74);
        v75 = (v73 & v71) >> v74;
        goto LABEL_103;
      case 2:
        v76 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v76)
          v76 = (unsigned __int8 *)v17;
        if (v76 < v41)
          v76 = v41;
        v77 = *v76;
        if (v5)
        {
          v78 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          if (v16 < v78)
            v78 = v16;
          if ((unint64_t)v78 < *(_QWORD *)(result + 40))
            v78 = *(unsigned __int8 **)(result + 40);
          v77 |= *v78 << 24;
        }
        v79 = (v47 >> 28) & 3;
        v80 = interpolate_8888_19472[v79];
        v67 = v79 + 1;
        v68 = v43 - ((v80 & v43) >> v67);
        v69 = v80 & v77;
        goto LABEL_102;
      case 3:
        v50 = (unsigned __int8 *)(v40 + SBYTE2(v47));
        if (v17 < (unint64_t)v50)
          v50 = (unsigned __int8 *)v17;
        if (v50 < v41)
          v50 = v41;
        v51 = *v50;
        v52 = v40 + SBYTE1(v47) * (uint64_t)v6;
        if (v17 >= v52)
          v53 = (unsigned __int8 *)(v40 + SBYTE1(v47) * (uint64_t)v6);
        else
          v53 = (unsigned __int8 *)v17;
        if (v53 < v41)
          v53 = v41;
        v88 = *v53;
        v54 = (unsigned __int8 *)(v52 + SBYTE2(v47));
        if (v17 < (unint64_t)v54)
          v54 = (unsigned __int8 *)v17;
        if (v54 < v41)
          v54 = v41;
        v55 = *v54;
        if (v5)
        {
          v56 = (unsigned __int8 *)(v44 + SBYTE2(v47));
          v57 = *(_QWORD *)(result + 40);
          if (v16 < v56)
            v56 = v16;
          if ((unint64_t)v56 < v57)
            v56 = *(unsigned __int8 **)(result + 40);
          v51 |= *v56 << 24;
          v58 = v44 + SBYTE1(v47) * (uint64_t)v7;
          if ((unint64_t)v16 >= v58)
            v59 = (unsigned __int8 *)(v44 + SBYTE1(v47) * (uint64_t)v7);
          else
            v59 = v16;
          if ((unint64_t)v59 < v57)
            v59 = *(unsigned __int8 **)(result + 40);
          v88 |= *v59 << 24;
          v60 = (unsigned __int8 *)(v58 + SBYTE2(v47));
          if (v16 < v60)
            v60 = v16;
          if ((unint64_t)v60 < v57)
            v60 = *(unsigned __int8 **)(result + 40);
          v55 |= *v60 << 24;
        }
        v61 = interpolate_8888_19472[v49];
        v62 = v49 + 1;
        v63 = v43 - ((v61 & v43) >> v62) + ((v61 & v88) >> v62);
        v64 = v51 - ((v61 & v51) >> v62) + ((v61 & v55) >> v62);
        v65 = (v47 >> 28) & 3;
        v66 = interpolate_8888_19472[v65];
        v67 = v65 + 1;
        v68 = v63 - ((v63 & v66) >> v67);
        v69 = v64 & v66;
LABEL_102:
        v75 = v69 >> v67;
LABEL_103:
        v43 = v68 + v75;
        break;
    }
LABEL_104:
    *(_QWORD *)(v11 + 8) = (((v43 | v13) >> 24) - ((v43 | v13) != 0)) | ((unint64_t)((v43 | v13) >> 24) << 32);
    *(_BYTE *)(v12 + 1) = v27 >> 22;
    if (a4 == 1)
      break;
    v81 = 0;
    a2 += v10;
    v82 = v90 - a2;
    a3 += v9;
    v83 = v92 - a3;
    v84 = -8;
    while (((v83 | v82 | (a3 - v93) | (a2 - v91)) & 0x8000000000000000) == 0)
    {
      v40 = v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32);
      v41 = *(unsigned __int8 **)(result + 32);
      if (v17 >= v40)
        v85 = (unsigned __int8 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + (a2 >> 32));
      else
        v85 = (unsigned __int8 *)v17;
      if (v85 < v41)
        v85 = *(unsigned __int8 **)(result + 32);
      v43 = *v85;
      if (v5)
      {
        v44 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        v86 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v16 >= v44)
          v87 = v5 + SHIDWORD(a3) * (uint64_t)v7 + (a2 >> 32);
        else
          v87 = (unint64_t)v16;
        if (v87 >= (unint64_t)v86)
          v86 = (unsigned __int8 *)v87;
        v43 |= *v86 << 24;
      }
      if (v8)
      {
        v47 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v47 & 0xF) != 0)
        {
          v12 += v81 + 1;
          v11 -= v84;
          a4 += ~(_DWORD)v81;
          v27 = -1;
          goto LABEL_48;
        }
      }
      *(_QWORD *)(v11 + 8 * v81 + 16) = (((v43 | v13) >> 24) - ((v43 | v13) != 0)) | ((unint64_t)((v43 | v13) >> 24) << 32);
      *(_BYTE *)(v12 + v81++ + 2) = -1;
      v84 -= 8;
      a2 += v10;
      v82 -= v10;
      a3 += v9;
      v83 -= v9;
      if (a4 - 1 == (_DWORD)v81)
        return result;
    }
    v12 += v81 + 1;
    v11 -= v84;
    a4 += ~(_DWORD)v81;
  }
  while (a4);
  return result;
}

uint64_t cmyk32_sample_RGB555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  unsigned int v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int64_t v46;
  unsigned __int16 *v47;
  unsigned int v48;
  unint64_t v49;
  unsigned __int16 *v50;
  unsigned int v51;
  unsigned __int16 *v52;
  unsigned int v53;
  unsigned __int8 *v54;
  unint64_t v55;
  unint64_t v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  int v59;
  char v60;
  unsigned int v61;
  int v62;
  int v63;
  char v64;
  unsigned int v65;
  unsigned int v66;
  unsigned __int16 *v67;
  unsigned int v68;
  unsigned __int8 *v69;
  int v70;
  char v71;
  unsigned int v72;
  unsigned __int16 *v73;
  unsigned int v74;
  unsigned __int8 *v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int16 *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unsigned __int8 *v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v88 = *(_QWORD *)(result + 88);
  v101 = *(_QWORD *)(result + 120);
  v102 = *(_QWORD *)(result + 112);
  v8 = (unint64_t *)(*(_QWORD *)(result + 152) - 8);
  v91 = *(_QWORD *)(result + 144) - 1;
  if (v6)
    v9 = 0;
  else
    v9 = -16777216;
  v96 = v9;
  v10 = *(_DWORD *)(result + 260) - 1;
  v99 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v11 = *(unsigned int *)(result + 256);
  v86 = *(_DWORD *)(result + 188);
  v93 = *(_DWORD *)(result + 28);
  v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  v100 = v95 + (v10 * v99) + 2 * v11 - 4;
  v89 = *(_QWORD *)(result + 72);
  v90 = *(_QWORD *)(result + 64);
  v97 = *(_QWORD *)(result + 40);
  v98 = result;
  while (1)
  {
    if (a3 >= v89)
    {
      if (a3 <= v88)
      {
        v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        v24 = a3;
        v15 = a4;
        v16 = v90;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v88;
        v20 = v19 - a3 + (v18 >> 1);
        v15 = a4;
        v16 = v90;
        if (v20 < 1)
          goto LABEL_41;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v23 = v86 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v12 = *(_QWORD *)(result + 216);
      v13 = v89 - *(_QWORD *)(result + 224);
      v14 = a3 - v13 + (v12 >> 1);
      v15 = a4;
      v16 = v90;
      if (v14 < 1)
        goto LABEL_41;
      if (v14 >= v12)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v14) >> 32;
      v23 = v86 | v17;
      v24 = v13 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        v29 = ((unint64_t)a2 >> 26) & 0x3C;
        v28 = a2;
      }
      else
      {
        v30 = *(_QWORD *)(result + 192);
        v31 = *(_QWORD *)(result + 200) + v87;
        v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1)
          goto LABEL_41;
        if (v32 < v30)
          v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v86;
        v28 = v31 - 0x1000000;
        v29 = 28;
      }
    }
    else
    {
      v25 = *(_QWORD *)(result + 192);
      v26 = v16 - *(_QWORD *)(result + 200);
      v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1)
        goto LABEL_41;
      if (v27 < v25)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v86;
      v28 = v26 + 0x1000000;
      v29 = 32;
    }
    if (v23 >= 0x400000)
      break;
LABEL_41:
    v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(_BYTE *)++v91 = 0;
LABEL_42:
    a4 = v42;
    if (!v42)
      return result;
  }
  v33 = v24 >> 32;
  v34 = v28 >> 32;
  v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 2 * (v28 >> 32);
  v36 = *(unsigned __int16 **)(result + 32);
  v37 = (unsigned __int16 *)v100;
  if (v100 >= v35)
    v37 = (unsigned __int16 *)v35;
  if (v37 < v36)
    v37 = *(unsigned __int16 **)(result + 32);
  v38 = bswap32(*v37) >> 16;
  if (v6)
  {
    v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    v40 = *(unsigned __int8 **)(result + 40);
    v41 = v94;
    v92 = v39;
    if ((unint64_t)v94 >= v39)
      v41 = (unsigned __int8 *)v39;
    if (v41 >= v40)
      v40 = v41;
    v38 |= *v40 << 24;
    if (!v7)
      goto LABEL_103;
  }
  else
  {
    v92 = 0;
    if (!v7)
      goto LABEL_103;
  }
  v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_47:
  v44 = v43 & 0xF;
  v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    v67 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67)
      v67 = (unsigned __int16 *)v100;
    if (v67 >= v36)
      v36 = v67;
    v68 = bswap32(*v36) >> 16;
    if (v6)
    {
      v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69)
        v69 = v94;
      if ((unint64_t)v69 < *(_QWORD *)(result + 40))
        v69 = *(unsigned __int8 **)(result + 40);
      v68 |= *v69 << 24;
    }
    v70 = interpolate_8555_19473[v45];
    v71 = v45 + 1;
    v65 = v38 - ((v70 & v38) >> v71);
    v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      v73 = (unsigned __int16 *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 55));
      if (v100 < (unint64_t)v73)
        v73 = (unsigned __int16 *)v100;
      if (v73 >= v36)
        v36 = v73;
      v74 = bswap32(*v36) >> 16;
      if (v6)
      {
        v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75)
          v75 = v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned __int8 **)(result + 40);
        v74 |= *v75 << 24;
      }
      v76 = (v43 >> 28) & 3;
      v77 = interpolate_8555_19473[v76];
      v64 = v76 + 1;
      v65 = v38 - ((v77 & v38) >> v64);
      v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3)
        goto LABEL_103;
      v46 = (unint64_t)HIWORD(v43) << 56;
      v47 = (unsigned __int16 *)(v35 + (v46 >> 55));
      if (v100 < (unint64_t)v47)
        v47 = (unsigned __int16 *)v100;
      if (v47 < v36)
        v47 = v36;
      v48 = bswap32(*v47) >> 16;
      v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49)
        v50 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      else
        v50 = (unsigned __int16 *)v100;
      if (v50 < v36)
        v50 = v36;
      v51 = bswap32(*v50) >> 16;
      v52 = (unsigned __int16 *)(v49 + (v46 >> 55));
      if (v100 < (unint64_t)v52)
        v52 = (unsigned __int16 *)v100;
      if (v52 >= v36)
        v36 = v52;
      v53 = bswap32(*v36) >> 16;
      if (v6)
      {
        v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        v55 = *(_QWORD *)(result + 40);
        if (v94 < v54)
          v54 = v94;
        if ((unint64_t)v54 < v55)
          v54 = *(unsigned __int8 **)(result + 40);
        v48 |= *v54 << 24;
        v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56)
          v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        else
          v57 = v94;
        if ((unint64_t)v57 < v55)
          v57 = *(unsigned __int8 **)(result + 40);
        v51 |= *v57 << 24;
        v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58)
          v58 = v94;
        if ((unint64_t)v58 < v55)
          v58 = *(unsigned __int8 **)(result + 40);
        v53 |= *v58 << 24;
      }
      v59 = interpolate_8555_19473[v45];
      v60 = v45 + 1;
      v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      v62 = (v43 >> 28) & 3;
      v63 = interpolate_8555_19473[v62];
      v64 = v62 + 1;
      v65 = v61 - ((v61 & v63) >> v64);
      v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    v72 = v66 >> v64;
  }
  v38 = v65 + v72;
LABEL_103:
  v78 = 0;
  ++v8;
  v85 = v15;
  v79 = v15 - 1;
  a3 += v101;
  v80 = v88 - a3;
  a2 += v102;
  v81 = v87 - a2;
  while (1)
  {
    RGB555(v8, v96 | (v38 >> 29 << 24) | v38);
    *(_BYTE *)(v91 + 1 + v78) = v23 >> 22;
    v6 = v97;
    result = v98;
    if (v79 == (_DWORD)v78)
      return result;
    if ((v80 | v81 | (a3 - v89) | (a2 - v90)) < 0)
    {
      v91 += v78 + 1;
      v42 = ~(_DWORD)v78 + v85;
      goto LABEL_42;
    }
    v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32);
    v36 = *(unsigned __int16 **)(v98 + 32);
    v82 = (unsigned __int16 *)v100;
    if (v100 >= v35)
      v82 = (unsigned __int16 *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32));
    if (v82 < v36)
      v82 = *(unsigned __int16 **)(v98 + 32);
    v38 = bswap32(*v82) >> 16;
    if (v97)
    {
      v83 = *(unsigned __int8 **)(v98 + 40);
      v84 = (unint64_t)v94;
      v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92)
        v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v38 |= *v83 << 24;
    }
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        v15 = ~(_DWORD)v78 + v85;
        v23 = -1;
        goto LABEL_47;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    v23 = -1;
  }
}

uint64_t cmyk32_sample_rgb555(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t *v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned __int16 *v36;
  unsigned __int16 *v37;
  unsigned int v38;
  unint64_t v39;
  unsigned __int8 *v40;
  unsigned __int8 *v41;
  int v42;
  unsigned int v43;
  int v44;
  int v45;
  int64_t v46;
  unsigned __int16 *v47;
  unsigned int v48;
  unint64_t v49;
  unsigned __int16 *v50;
  unsigned int v51;
  unsigned __int16 *v52;
  unsigned int v53;
  unsigned __int8 *v54;
  unint64_t v55;
  unint64_t v56;
  unsigned __int8 *v57;
  unsigned __int8 *v58;
  int v59;
  char v60;
  unsigned int v61;
  int v62;
  int v63;
  char v64;
  unsigned int v65;
  unsigned int v66;
  unsigned __int16 *v67;
  unsigned int v68;
  unsigned __int8 *v69;
  int v70;
  char v71;
  unsigned int v72;
  unsigned __int16 *v73;
  int v74;
  unsigned __int8 *v75;
  int v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  unsigned __int16 *v82;
  unsigned __int8 *v83;
  unint64_t v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unsigned __int8 *v94;
  uint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  int v99;
  unint64_t v100;
  uint64_t v101;
  uint64_t v102;

  v6 = *(_QWORD *)(result + 40);
  v7 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v88 = *(_QWORD *)(result + 88);
  v101 = *(_QWORD *)(result + 120);
  v102 = *(_QWORD *)(result + 112);
  v8 = (unint64_t *)(*(_QWORD *)(result + 152) - 8);
  v91 = *(_QWORD *)(result + 144) - 1;
  if (v6)
    v9 = 0;
  else
    v9 = -16777216;
  v96 = v9;
  v10 = *(_DWORD *)(result + 260) - 1;
  v99 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v11 = *(unsigned int *)(result + 256);
  v86 = *(_DWORD *)(result + 188);
  v93 = *(_DWORD *)(result + 28);
  v94 = (unsigned __int8 *)(v6 + (v11 - 1) + (v10 * v93));
  v100 = v95 + (v10 * v99) + 2 * v11 - 4;
  v89 = *(_QWORD *)(result + 72);
  v90 = *(_QWORD *)(result + 64);
  v97 = *(_QWORD *)(result + 40);
  v98 = result;
  while (1)
  {
    if (a3 >= v89)
    {
      if (a3 <= v88)
      {
        v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        v24 = a3;
        v15 = a4;
        v16 = v90;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v88;
        v20 = v19 - a3 + (v18 >> 1);
        v15 = a4;
        v16 = v90;
        if (v20 < 1)
          goto LABEL_41;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v23 = v86 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v12 = *(_QWORD *)(result + 216);
      v13 = v89 - *(_QWORD *)(result + 224);
      v14 = a3 - v13 + (v12 >> 1);
      v15 = a4;
      v16 = v90;
      if (v14 < 1)
        goto LABEL_41;
      if (v14 >= v12)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v14) >> 32;
      v23 = v86 | v17;
      v24 = v13 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v16)
    {
      if (a2 <= v87)
      {
        v29 = ((unint64_t)a2 >> 26) & 0x3C;
        v28 = a2;
      }
      else
      {
        v30 = *(_QWORD *)(result + 192);
        v31 = *(_QWORD *)(result + 200) + v87;
        v32 = v31 - a2 + (v30 >> 1);
        if (v32 < 1)
          goto LABEL_41;
        if (v32 < v30)
          v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v86;
        v28 = v31 - 0x1000000;
        v29 = 28;
      }
    }
    else
    {
      v25 = *(_QWORD *)(result + 192);
      v26 = v16 - *(_QWORD *)(result + 200);
      v27 = a2 - v26 + (v25 >> 1);
      if (v27 < 1)
        goto LABEL_41;
      if (v27 < v25)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v86;
      v28 = v26 + 0x1000000;
      v29 = 32;
    }
    if (v23 >= 0x400000)
      break;
LABEL_41:
    v42 = v15 - 1;
    a2 += v102;
    a3 += v101;
    ++v8;
    *(_BYTE *)++v91 = 0;
LABEL_42:
    a4 = v42;
    if (!v42)
      return result;
  }
  v33 = v24 >> 32;
  v34 = v28 >> 32;
  v35 = v95 + SHIDWORD(v24) * (uint64_t)v99 + 2 * (v28 >> 32);
  v36 = *(unsigned __int16 **)(result + 32);
  v37 = (unsigned __int16 *)v100;
  if (v100 >= v35)
    v37 = (unsigned __int16 *)v35;
  if (v37 < v36)
    v37 = *(unsigned __int16 **)(result + 32);
  v38 = *v37;
  if (v6)
  {
    v39 = v6 + (int)v33 * (uint64_t)v93 + v34;
    v40 = *(unsigned __int8 **)(result + 40);
    v41 = v94;
    v92 = v39;
    if ((unint64_t)v94 >= v39)
      v41 = (unsigned __int8 *)v39;
    if (v41 >= v40)
      v40 = v41;
    v38 |= *v40 << 24;
    if (!v7)
      goto LABEL_103;
  }
  else
  {
    v92 = 0;
    if (!v7)
      goto LABEL_103;
  }
  v43 = *(_DWORD *)(v7 + (v29 | v22));
LABEL_47:
  v44 = v43 & 0xF;
  v45 = HIBYTE(v43) & 3;
  if (v44 == 1)
  {
    v67 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
    if (v100 < (unint64_t)v67)
      v67 = (unsigned __int16 *)v100;
    if (v67 >= v36)
      v36 = v67;
    v68 = *v36;
    if (v6)
    {
      v69 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
      if (v94 < v69)
        v69 = v94;
      if ((unint64_t)v69 < *(_QWORD *)(result + 40))
        v69 = *(unsigned __int8 **)(result + 40);
      v68 |= *v69 << 24;
    }
    v70 = interpolate_8555_19473[v45];
    v71 = v45 + 1;
    v65 = v38 - ((v70 & v38) >> v71);
    v72 = (v70 & v68) >> v71;
  }
  else
  {
    if (v44 == 2)
    {
      v73 = (unsigned __int16 *)(v35 + ((uint64_t)((unint64_t)HIWORD(v43) << 56) >> 55));
      if (v100 < (unint64_t)v73)
        v73 = (unsigned __int16 *)v100;
      if (v73 >= v36)
        v36 = v73;
      v74 = *v36;
      if (v6)
      {
        v75 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        if (v94 < v75)
          v75 = v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned __int8 **)(result + 40);
        v74 |= *v75 << 24;
      }
      v76 = (v43 >> 28) & 3;
      v77 = interpolate_8555_19473[v76];
      v64 = v76 + 1;
      v65 = v38 - ((v77 & v38) >> v64);
      v66 = v77 & v74;
    }
    else
    {
      if (v44 != 3)
        goto LABEL_103;
      v46 = (unint64_t)HIWORD(v43) << 56;
      v47 = (unsigned __int16 *)(v35 + (v46 >> 55));
      if (v100 < (unint64_t)v47)
        v47 = (unsigned __int16 *)v100;
      if (v47 < v36)
        v47 = v36;
      v48 = *v47;
      v49 = v35 + SBYTE1(v43) * (uint64_t)v99;
      if (v100 >= v49)
        v50 = (unsigned __int16 *)(v35 + SBYTE1(v43) * (uint64_t)v99);
      else
        v50 = (unsigned __int16 *)v100;
      if (v50 < v36)
        v50 = v36;
      v51 = *v50;
      v52 = (unsigned __int16 *)(v49 + (v46 >> 55));
      if (v100 < (unint64_t)v52)
        v52 = (unsigned __int16 *)v100;
      if (v52 >= v36)
        v36 = v52;
      v53 = *v36;
      if (v6)
      {
        v54 = (unsigned __int8 *)(v92 + SBYTE2(v43));
        v55 = *(_QWORD *)(result + 40);
        if (v94 < v54)
          v54 = v94;
        if ((unint64_t)v54 < v55)
          v54 = *(unsigned __int8 **)(result + 40);
        v48 |= *v54 << 24;
        v56 = v92 + SBYTE1(v43) * (uint64_t)v93;
        if ((unint64_t)v94 >= v56)
          v57 = (unsigned __int8 *)(v92 + SBYTE1(v43) * (uint64_t)v93);
        else
          v57 = v94;
        if ((unint64_t)v57 < v55)
          v57 = *(unsigned __int8 **)(result + 40);
        v51 |= *v57 << 24;
        v58 = (unsigned __int8 *)(v56 + SBYTE2(v43));
        if (v94 < v58)
          v58 = v94;
        if ((unint64_t)v58 < v55)
          v58 = *(unsigned __int8 **)(result + 40);
        v53 |= *v58 << 24;
      }
      v59 = interpolate_8555_19473[v45];
      v60 = v45 + 1;
      v61 = v38 - ((v59 & v38) >> v60) + ((v59 & v51) >> v60);
      v62 = (v43 >> 28) & 3;
      v63 = interpolate_8555_19473[v62];
      v64 = v62 + 1;
      v65 = v61 - ((v61 & v63) >> v64);
      v66 = (v48 - ((v59 & v48) >> v60) + ((v59 & v53) >> v60)) & v63;
    }
    v72 = v66 >> v64;
  }
  v38 = v65 + v72;
LABEL_103:
  v78 = 0;
  ++v8;
  v85 = v15;
  v79 = v15 - 1;
  a3 += v101;
  v80 = v88 - a3;
  a2 += v102;
  v81 = v87 - a2;
  while (1)
  {
    RGB555(v8, v96 | (v38 >> 29 << 24) | v38);
    *(_BYTE *)(v91 + 1 + v78) = v23 >> 22;
    v6 = v97;
    result = v98;
    if (v79 == (_DWORD)v78)
      return result;
    if ((v80 | v81 | (a3 - v89) | (a2 - v90)) < 0)
    {
      v91 += v78 + 1;
      v42 = ~(_DWORD)v78 + v85;
      goto LABEL_42;
    }
    v35 = v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32);
    v36 = *(unsigned __int16 **)(v98 + 32);
    v82 = (unsigned __int16 *)v100;
    if (v100 >= v35)
      v82 = (unsigned __int16 *)(v95 + SHIDWORD(a3) * (uint64_t)v99 + 2 * (a2 >> 32));
    if (v82 < v36)
      v82 = *(unsigned __int16 **)(v98 + 32);
    v38 = *v82;
    if (v97)
    {
      v83 = *(unsigned __int8 **)(v98 + 40);
      v84 = (unint64_t)v94;
      v92 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if ((unint64_t)v94 >= v92)
        v84 = v97 + SHIDWORD(a3) * (uint64_t)v93 + (a2 >> 32);
      if (v84 >= (unint64_t)v83)
        v83 = (unsigned __int8 *)v84;
      v38 |= *v83 << 24;
    }
    if (v7)
    {
      v43 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v43 & 0xF) != 0)
      {
        v91 += v78 + 1;
        v15 = ~(_DWORD)v78 + v85;
        v23 = -1;
        goto LABEL_47;
      }
    }
    ++v8;
    ++v78;
    a3 += v101;
    v80 -= v101;
    a2 += v102;
    v81 -= v102;
    v23 = -1;
  }
}

uint64_t cmyk32_sample_RGB24(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned __int8 *v36;
  unsigned __int8 *v37;
  unsigned int v38;
  unsigned int v39;
  int v40;
  int v41;
  uint64_t v42;
  unsigned __int8 *v43;
  int v44;
  unint64_t v45;
  unsigned __int8 *v46;
  int v47;
  unsigned __int8 *v48;
  unsigned int v49;
  char v50;
  unsigned int v51;
  int v52;
  int v53;
  unsigned int v54;
  char v55;
  unsigned int v56;
  unsigned __int8 *v57;
  unsigned int v58;
  char v59;
  unsigned int v60;
  unsigned __int8 *v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unsigned int v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  unsigned __int8 *v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_DWORD *)(result + 24);
  v6 = *(_QWORD *)(result + 176);
  v7 = *(_QWORD *)(result + 72);
  v74 = *(_QWORD *)(result + 80);
  v75 = *(_QWORD *)(result + 88);
  v8 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v10 = *(_QWORD *)(result + 152) - 8;
  v11 = *(_QWORD *)(result + 144) - 1;
  v72 = *(_DWORD *)(result + 188);
  v12 = v4 + (3 * *(_DWORD *)(result + 256)) + ((*(_DWORD *)(result + 260) - 1) * v5) - 3;
  v73 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v7)
    {
      if ((uint64_t)a3 <= v75)
      {
        v21 = (a3 >> 22) & 0x3C0;
        v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        v24 = v73;
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = *(_QWORD *)(result + 224) + v75;
        v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1)
          goto LABEL_34;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v24 = v73;
        v22 = v72 | v20;
        v23 = v18 - 0x1000000;
        v21 = 448;
      }
    }
    else
    {
      v13 = *(_QWORD *)(result + 216);
      v14 = v7 - *(_QWORD *)(result + 224);
      v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1)
        goto LABEL_34;
      if (v15 >= v13)
        LODWORD(v16) = 0x3FFFFFFF;
      else
        v16 = (unint64_t)(*(_QWORD *)(result + 232) * v15) >> 32;
      v24 = v73;
      v22 = v72 | v16;
      v23 = v14 + 0x1000000;
      v21 = 512;
    }
    if (a2 >= v24)
      break;
    v25 = *(_QWORD *)(result + 192);
    v26 = v24 - *(_QWORD *)(result + 200);
    v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25)
        v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v72;
      v28 = v26 + 0x1000000;
      v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v8;
    a3 += v9;
    v10 += 8;
    *(_BYTE *)++v11 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v74)
  {
    v29 = ((unint64_t)a2 >> 26) & 0x3C;
    v28 = a2;
    goto LABEL_26;
  }
  v30 = *(_QWORD *)(result + 192);
  v31 = *(_QWORD *)(result + 200) + v74;
  v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1)
    goto LABEL_34;
  if (v32 < v30)
    v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v72;
  v28 = v31 - 0x1000000;
  v29 = 28;
LABEL_26:
  if (v22 < 0x400000)
    goto LABEL_34;
  v33 = v4 + SHIDWORD(v23) * (uint64_t)v5;
  v34 = 3 * (v28 >> 32);
  v35 = v33 + v34;
  v36 = *(unsigned __int8 **)(result + 32);
  if (v12 >= v33 + v34)
    v37 = (unsigned __int8 *)(v33 + v34);
  else
    v37 = (unsigned __int8 *)v12;
  if (v37 < v36)
    v37 = *(unsigned __int8 **)(result + 32);
  v38 = (v37[1] << 16) | (*v37 << 24) | (v37[2] << 8) | 0xFF;
  if (!v6)
    goto LABEL_66;
  v39 = *(_DWORD *)(v6 + (v29 | v21));
LABEL_37:
  v40 = v39 & 0xF;
  v41 = HIBYTE(v39) & 3;
  switch(v40)
  {
    case 1:
      v57 = (unsigned __int8 *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      if (v12 < (unint64_t)v57)
        v57 = (unsigned __int8 *)v12;
      if (v57 < v36)
        v57 = v36;
      v58 = interpolate_8888_19472[v41];
      v59 = v41 + 1;
      v56 = v38 - ((v58 & v38) >> v59);
      v60 = (((v57[1] << 16) | (*v57 << 24) | (v57[2] << 8) | 0xFF) & v58) >> v59;
LABEL_65:
      v38 = v56 + v60;
      break;
    case 2:
      v61 = (unsigned __int8 *)(v35 + 3 * SBYTE2(v39));
      if (v12 < (unint64_t)v61)
        v61 = (unsigned __int8 *)v12;
      if (v61 < v36)
        v61 = v36;
      v52 = (v61[1] << 16) | (*v61 << 24) | (v61[2] << 8) | 0xFF;
      v62 = (v39 >> 28) & 3;
      v54 = interpolate_8888_19472[v62];
      v55 = v62 + 1;
      v56 = v38 - ((v54 & v38) >> v55);
LABEL_64:
      v60 = (v52 & v54) >> v55;
      goto LABEL_65;
    case 3:
      v42 = 3 * SBYTE2(v39);
      v43 = (unsigned __int8 *)(v35 + v42);
      if (v12 < v35 + v42)
        v43 = (unsigned __int8 *)v12;
      if (v43 < v36)
        v43 = v36;
      v44 = (v43[1] << 16) | (*v43 << 24) | (v43[2] << 8) | 0xFF;
      v45 = v35 + SBYTE1(v39) * (uint64_t)v5;
      if (v12 >= v45)
        v46 = (unsigned __int8 *)(v35 + SBYTE1(v39) * (uint64_t)v5);
      else
        v46 = (unsigned __int8 *)v12;
      if (v46 < v36)
        v46 = v36;
      v47 = (v46[1] << 16) | (*v46 << 24) | (v46[2] << 8) | 0xFF;
      v48 = (unsigned __int8 *)(v45 + v42);
      if (v12 < (unint64_t)v48)
        v48 = (unsigned __int8 *)v12;
      if (v48 < v36)
        v48 = v36;
      v49 = interpolate_8888_19472[v41];
      v50 = v41 + 1;
      v51 = v38 - ((v49 & v38) >> v50) + ((v47 & v49) >> v50);
      v52 = v44 - ((v49 & v44) >> v50) + ((((v48[1] << 16) | (*v48 << 24) | (v48[2] << 8) | 0xFF) & v49) >> v50);
      v53 = (v39 >> 28) & 3;
      v54 = interpolate_8888_19472[v53];
      v55 = v53 + 1;
      v56 = v51 - ((v51 & v54) >> v55);
      goto LABEL_64;
  }
LABEL_66:
  v63 = 0;
  v64 = 0;
  a3 += v9;
  v65 = v75 - a3;
  a2 += v8;
  v66 = v74 - a2;
  while (1)
  {
    v67 = HIBYTE(v38);
    v68 = BYTE1(v38);
    if (HIBYTE(v38) <= BYTE2(v38))
      v67 = BYTE2(v38);
    if (v67 > BYTE1(v38))
      v68 = v67;
    *(_QWORD *)(v10 + 8 + 8 * v64) = (int)((v38 - v68) | ((v68 - BYTE2(v38)) << 16) | ((v68 - HIBYTE(v38)) << 24) | ((v68 - BYTE1(v38)) << 8)) | ((unint64_t)v38 << 32);
    *(_BYTE *)(v11 + 1 + v64) = v22 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v65 | v66 | (a3 - v7) | (a2 - v73)) & 0x8000000000000000) != 0)
    {
      v11 += v64 + 1;
      v10 = v10 - v63 + 8;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v69 = v4 + SHIDWORD(a3) * (uint64_t)v5;
    v70 = 3 * (a2 >> 32);
    v35 = v69 + v70;
    v36 = *(unsigned __int8 **)(result + 32);
    if (v12 >= v69 + v70)
      v71 = (unsigned __int8 *)(v69 + v70);
    else
      v71 = (unsigned __int8 *)v12;
    if (v71 < v36)
      v71 = *(unsigned __int8 **)(result + 32);
    v38 = (v71[1] << 16) | (*v71 << 24) | (v71[2] << 8) | 0xFF;
    if (v6)
    {
      v39 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v11 += v64 + 1;
        v10 = v10 - v63 + 8;
        a4 += ~(_DWORD)v64;
        v22 = -1;
        goto LABEL_37;
      }
    }
    ++v64;
    v63 -= 8;
    a3 += v9;
    v65 -= v9;
    a2 += v8;
    v66 -= v8;
    v22 = -1;
  }
}

uint64_t cmyk32_sample_RGBA32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  int v42;
  int64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  int v50;
  char v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  char v56;
  unsigned int v57;
  unsigned int *v58;
  int v59;
  char v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  unsigned int v68;
  uint64_t v69;
  uint64_t v70;
  unsigned int *v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v72 = *(_QWORD *)(result + 80);
  v75 = *(_QWORD *)(result + 72);
  v76 = *(_QWORD *)(result + 88);
  v6 = *(_QWORD *)(result + 112);
  v7 = *(_QWORD *)(result + 120);
  v8 = *(_QWORD *)(result + 152) - 8;
  v9 = *(_QWORD *)(result + 144) - 1;
  v11 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 40);
  v73 = *(_DWORD *)(result + 188);
  v12 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  v74 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v75)
    {
      if ((uint64_t)a3 <= v76)
      {
        v21 = (a3 >> 22) & 0x3C0;
        v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        v24 = v74;
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = *(_QWORD *)(result + 224) + v76;
        v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1)
          goto LABEL_34;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v24 = v74;
        v22 = v73 | v20;
        v23 = v18 - 0x1000000;
        v21 = 448;
      }
    }
    else
    {
      v13 = *(_QWORD *)(result + 216);
      v14 = v75 - *(_QWORD *)(result + 224);
      v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1)
        goto LABEL_34;
      if (v15 >= v13)
        LODWORD(v16) = 0x3FFFFFFF;
      else
        v16 = (unint64_t)(*(_QWORD *)(result + 232) * v15) >> 32;
      v24 = v74;
      v22 = v73 | v16;
      v23 = v14 + 0x1000000;
      v21 = 512;
    }
    if (a2 >= v24)
      break;
    v25 = *(_QWORD *)(result + 192);
    v26 = v24 - *(_QWORD *)(result + 200);
    v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25)
        v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v73;
      v28 = v26 + 0x1000000;
      v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v6;
    a3 += v7;
    v8 += 8;
    *(_BYTE *)++v9 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v72)
  {
    v29 = ((unint64_t)a2 >> 26) & 0x3C;
    v28 = a2;
    goto LABEL_26;
  }
  v30 = *(_QWORD *)(result + 192);
  v31 = *(_QWORD *)(result + 200) + v72;
  v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1)
    goto LABEL_34;
  if (v32 < v30)
    v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v73;
  v28 = v31 - 0x1000000;
  v29 = 28;
LABEL_26:
  if (v22 < 0x400000)
    goto LABEL_34;
  v33 = v11 + SHIDWORD(v23) * (uint64_t)v4;
  v34 = v28 >> 32;
  v35 = v33 + 4 * v34;
  v36 = *(unsigned int **)(result + 32);
  if (v12 >= v35)
    v37 = (unsigned int *)(v33 + 4 * v34);
  else
    v37 = (unsigned int *)v12;
  if (v37 < v36)
    v37 = *(unsigned int **)(result + 32);
  v38 = bswap32(*v37);
  if (!v5)
  {
    v40 = v72;
    goto LABEL_67;
  }
  v39 = *(_DWORD *)(v5 + (v29 | v21));
LABEL_38:
  v41 = v39 & 0xF;
  v42 = HIBYTE(v39) & 3;
  v40 = v72;
  switch(v41)
  {
    case 1:
      v58 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v12 < (unint64_t)v58)
        v58 = (unsigned int *)v12;
      if (v58 < v36)
        v58 = v36;
      v59 = interpolate_8888_19472[v42];
      v60 = v42 + 1;
      v57 = v38 - ((v59 & v38) >> v60);
      v61 = (bswap32(*v58) & v59) >> v60;
LABEL_66:
      v38 = v57 + v61;
      break;
    case 2:
      v62 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 54));
      if (v12 < (unint64_t)v62)
        v62 = (unsigned int *)v12;
      if (v62 < v36)
        v62 = v36;
      v53 = bswap32(*v62);
      v63 = (v39 >> 28) & 3;
      v55 = interpolate_8888_19472[v63];
      v56 = v63 + 1;
      v57 = v38 - ((v55 & v38) >> v56);
LABEL_65:
      v61 = (v53 & v55) >> v56;
      goto LABEL_66;
    case 3:
      v43 = (unint64_t)HIWORD(v39) << 56;
      v44 = (unsigned int *)(v35 + (v43 >> 54));
      if (v12 < (unint64_t)v44)
        v44 = (unsigned int *)v12;
      if (v44 < v36)
        v44 = v36;
      v45 = bswap32(*v44);
      v46 = v35 + SBYTE1(v39) * (uint64_t)v4;
      if (v12 >= v46)
        v47 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      else
        v47 = (unsigned int *)v12;
      if (v47 < v36)
        v47 = v36;
      v48 = bswap32(*v47);
      v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v12 < (unint64_t)v49)
        v49 = (unsigned int *)v12;
      if (v49 < v36)
        v49 = v36;
      v50 = interpolate_8888_19472[v42];
      v51 = v42 + 1;
      v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((bswap32(*v49) & v50) >> v51);
      v54 = (v39 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      goto LABEL_65;
  }
LABEL_67:
  v64 = 0;
  v65 = 0;
  a3 += v7;
  v66 = v76 - a3;
  a2 += v6;
  v67 = v40 - a2;
  while (1)
  {
    v68 = HIBYTE(v38);
    if (HIBYTE(v38) <= BYTE2(v38))
      v68 = BYTE2(v38);
    if (v68 <= BYTE1(v38))
      v68 = BYTE1(v38);
    v69 = v10 ? v38 : 255;
    *(_QWORD *)(v8 + 8 + 8 * v64) = (int)((v69 - v68) | ((v68 - BYTE2(v38)) << 16) | ((v68 - HIBYTE(v38)) << 24) | ((v68 - BYTE1(v38)) << 8)) | (unint64_t)(v69 << 32);
    *(_BYTE *)(v9 + 1 + v64) = v22 >> 22;
    if (a4 - 1 == (_DWORD)v64)
      return result;
    if (((v66 | v67 | (a3 - v75) | (a2 - v74)) & 0x8000000000000000) != 0)
    {
      v8 = v8 - v65 + 8;
      v9 += v64 + 1;
      a4 += ~(_DWORD)v64;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v70 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    v35 = v70 + 4 * (a2 >> 32);
    v36 = *(unsigned int **)(result + 32);
    if (v12 >= v35)
      v71 = (unsigned int *)(v70 + 4 * (a2 >> 32));
    else
      v71 = (unsigned int *)v12;
    if (v71 < v36)
      v71 = *(unsigned int **)(result + 32);
    v38 = bswap32(*v71);
    if (v5)
    {
      v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v8 = v8 - v65 + 8;
        v9 += v64 + 1;
        a4 += ~(_DWORD)v64;
        v22 = -1;
        goto LABEL_38;
      }
    }
    v65 -= 8;
    ++v64;
    a3 += v7;
    v66 -= v7;
    a2 += v6;
    v67 -= v6;
    v22 = -1;
  }
}

uint64_t cmyk32_sample_rgba32(uint64_t result, uint64_t a2, unint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  unsigned int *v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  int v41;
  int v42;
  int64_t v43;
  unsigned int *v44;
  unsigned int v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int v48;
  unsigned int *v49;
  unsigned int v50;
  char v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  int v55;
  char v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int v60;
  char v61;
  unsigned int v62;
  unsigned int *v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  unsigned int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;

  v4 = *(_DWORD *)(result + 24);
  v5 = *(_QWORD *)(result + 176);
  v74 = *(_QWORD *)(result + 80);
  v77 = *(_QWORD *)(result + 72);
  v78 = *(_QWORD *)(result + 88);
  v6 = *(_QWORD *)(result + 112);
  v7 = *(_QWORD *)(result + 120);
  v8 = *(_QWORD *)(result + 152) - 8;
  v9 = *(_QWORD *)(result + 144) - 1;
  v11 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 40);
  v75 = *(_DWORD *)(result + 188);
  v12 = v11 + ((*(_DWORD *)(result + 260) - 1) * v4) + 4 * *(unsigned int *)(result + 256) - 4;
  v76 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if ((uint64_t)a3 >= v77)
    {
      if ((uint64_t)a3 <= v78)
      {
        v21 = (a3 >> 22) & 0x3C0;
        v22 = 0x3FFFFFFF;
        HIDWORD(v23) = HIDWORD(a3);
        v24 = v76;
      }
      else
      {
        v17 = *(_QWORD *)(result + 216);
        v18 = *(_QWORD *)(result + 224) + v78;
        v19 = v18 - a3 + (v17 >> 1);
        if (v19 < 1)
          goto LABEL_34;
        if (v19 >= v17)
          LODWORD(v20) = 0x3FFFFFFF;
        else
          v20 = (unint64_t)(*(_QWORD *)(result + 232) * v19) >> 32;
        v24 = v76;
        v22 = v75 | v20;
        v23 = v18 - 0x1000000;
        v21 = 448;
      }
    }
    else
    {
      v13 = *(_QWORD *)(result + 216);
      v14 = v77 - *(_QWORD *)(result + 224);
      v15 = a3 - v14 + (v13 >> 1);
      if (v15 < 1)
        goto LABEL_34;
      if (v15 >= v13)
        LODWORD(v16) = 0x3FFFFFFF;
      else
        v16 = (unint64_t)(*(_QWORD *)(result + 232) * v15) >> 32;
      v24 = v76;
      v22 = v75 | v16;
      v23 = v14 + 0x1000000;
      v21 = 512;
    }
    if (a2 >= v24)
      break;
    v25 = *(_QWORD *)(result + 192);
    v26 = v24 - *(_QWORD *)(result + 200);
    v27 = a2 - v26 + (v25 >> 1);
    if (v27 >= 1)
    {
      if (v27 < v25)
        v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v27) >> 32) >> 15)) | v75;
      v28 = v26 + 0x1000000;
      v29 = 32;
      goto LABEL_26;
    }
LABEL_34:
    --a4;
    a2 += v6;
    a3 += v7;
    v8 += 8;
    *(_BYTE *)++v9 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v74)
  {
    v29 = ((unint64_t)a2 >> 26) & 0x3C;
    v28 = a2;
    goto LABEL_26;
  }
  v30 = *(_QWORD *)(result + 192);
  v31 = *(_QWORD *)(result + 200) + v74;
  v32 = v31 - a2 + (v30 >> 1);
  if (v32 < 1)
    goto LABEL_34;
  if (v32 < v30)
    v22 = ((v22 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v32) >> 32) >> 15)) | v75;
  v28 = v31 - 0x1000000;
  v29 = 28;
LABEL_26:
  if (v22 < 0x400000)
    goto LABEL_34;
  v33 = v11 + SHIDWORD(v23) * (uint64_t)v4;
  v34 = v28 >> 32;
  v35 = v33 + 4 * v34;
  v36 = *(unsigned int **)(result + 32);
  if (v12 >= v35)
    v37 = (unsigned int *)(v33 + 4 * v34);
  else
    v37 = (unsigned int *)v12;
  if (v37 < v36)
    v37 = *(unsigned int **)(result + 32);
  v38 = *v37;
  if (!v5)
  {
    v40 = v74;
    goto LABEL_67;
  }
  v39 = *(_DWORD *)(v5 + (v29 | v21));
LABEL_38:
  v41 = v39 & 0xF;
  v42 = HIBYTE(v39) & 3;
  v40 = v74;
  switch(v41)
  {
    case 1:
      v59 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      if (v12 < (unint64_t)v59)
        v59 = (unsigned int *)v12;
      if (v59 < v36)
        v59 = v36;
      v60 = interpolate_8888_19472[v42];
      v61 = v42 + 1;
      v57 = v38 - ((v60 & v38) >> v61);
      v62 = (v60 & *v59) >> v61;
LABEL_66:
      v38 = v57 + v62;
      break;
    case 2:
      v63 = (unsigned int *)(v35 + ((uint64_t)((unint64_t)HIWORD(v39) << 56) >> 54));
      if (v12 < (unint64_t)v63)
        v63 = (unsigned int *)v12;
      if (v63 < v36)
        v63 = v36;
      v64 = (v39 >> 28) & 3;
      v65 = interpolate_8888_19472[v64];
      v56 = v64 + 1;
      v57 = v38 - ((v65 & v38) >> v56);
      v58 = v65 & *v63;
LABEL_65:
      v62 = v58 >> v56;
      goto LABEL_66;
    case 3:
      v43 = (unint64_t)HIWORD(v39) << 56;
      v44 = (unsigned int *)(v35 + (v43 >> 54));
      if (v12 < (unint64_t)v44)
        v44 = (unsigned int *)v12;
      if (v44 < v36)
        v44 = v36;
      v45 = *v44;
      v46 = v35 + SBYTE1(v39) * (uint64_t)v4;
      if (v12 >= v46)
        v47 = (unsigned int *)(v35 + SBYTE1(v39) * (uint64_t)v4);
      else
        v47 = (unsigned int *)v12;
      if (v47 < v36)
        v47 = v36;
      v48 = *v47;
      v49 = (unsigned int *)(v46 + (v43 >> 54));
      if (v12 < (unint64_t)v49)
        v49 = (unsigned int *)v12;
      if (v49 < v36)
        v49 = v36;
      v50 = interpolate_8888_19472[v42];
      v51 = v42 + 1;
      v52 = v38 - ((v50 & v38) >> v51) + ((v50 & v48) >> v51);
      v53 = v45 - ((v50 & v45) >> v51) + ((v50 & *v49) >> v51);
      v54 = (v39 >> 28) & 3;
      v55 = interpolate_8888_19472[v54];
      v56 = v54 + 1;
      v57 = v52 - ((v52 & v55) >> v56);
      v58 = v53 & v55;
      goto LABEL_65;
  }
LABEL_67:
  v66 = 0;
  v67 = 0;
  a3 += v7;
  v68 = v78 - a3;
  a2 += v6;
  v69 = v40 - a2;
  while (1)
  {
    v70 = HIBYTE(v38);
    if (HIBYTE(v38) <= BYTE2(v38))
      v70 = BYTE2(v38);
    if (v70 <= BYTE1(v38))
      v70 = BYTE1(v38);
    v71 = v10 ? v38 : 255;
    *(_QWORD *)(v8 + 8 + 8 * v66) = (int)((v71 - v70) | ((v70 - BYTE2(v38)) << 16) | ((v70 - HIBYTE(v38)) << 24) | ((v70 - BYTE1(v38)) << 8)) | (unint64_t)(v71 << 32);
    *(_BYTE *)(v9 + 1 + v66) = v22 >> 22;
    if (a4 - 1 == (_DWORD)v66)
      return result;
    if (((v68 | v69 | (a3 - v77) | (a2 - v76)) & 0x8000000000000000) != 0)
    {
      v8 = v8 - v67 + 8;
      v9 += v66 + 1;
      a4 += ~(_DWORD)v66;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v72 = v11 + SHIDWORD(a3) * (uint64_t)v4;
    v35 = v72 + 4 * (a2 >> 32);
    v36 = *(unsigned int **)(result + 32);
    if (v12 >= v35)
      v73 = (unsigned int *)(v72 + 4 * (a2 >> 32));
    else
      v73 = (unsigned int *)v12;
    if (v73 < v36)
      v73 = *(unsigned int **)(result + 32);
    v38 = *v73;
    if (v5)
    {
      v39 = *(_DWORD *)(v5 + (((unint64_t)a2 >> 26) & 0x3C | (a3 >> 22) & 0x3C0));
      if ((v39 & 0xF) != 0)
      {
        v8 = v8 - v67 + 8;
        v9 += v66 + 1;
        a4 += ~(_DWORD)v66;
        v22 = -1;
        goto LABEL_38;
      }
    }
    v67 -= 8;
    ++v66;
    a3 += v7;
    v68 -= v7;
    a2 += v6;
    v69 -= v6;
    v22 = -1;
  }
}

unint64_t *cmyk32_sample_ARGB32(unint64_t *result, uint64_t a2, int64_t a3, int a4)
{
  unint64_t v6;
  unint64_t *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int64_t v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  int v45;
  char v46;
  unsigned int v47;
  int v48;
  int v49;
  unsigned int v50;
  unsigned int *v51;
  int v52;
  char v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int *v56;
  char v57;
  uint64_t v58;
  int v59;
  int64_t v60;
  uint64_t v61;
  unsigned int *v62;
  int v63;
  int v64;
  uint64_t v65;
  unint64_t v66;
  int64_t v67;
  int64_t v68;
  uint64_t v69;
  unint64_t v70;
  int v71;
  int v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  unint64_t *v76;

  v6 = result[22];
  v65 = result[10];
  v68 = result[11];
  v75 = result[14];
  v74 = result[15];
  v64 = *((_DWORD *)result + 47);
  v7 = (unint64_t *)(result[19] - 8);
  v69 = result[18] - 1;
  if (result[5])
    v8 = 0;
  else
    v8 = -16777216;
  v71 = v8;
  v72 = *((_DWORD *)result + 6);
  v70 = result[4];
  v76 = result;
  v73 = v70 + ((*((_DWORD *)result + 65) - 1) * v72) + 4 * *((unsigned int *)result + 64) - 4;
  v66 = result[8];
  v67 = result[9];
  while (1)
  {
    if (a3 >= v67)
    {
      if (a3 <= v68)
      {
        v19 = ((unint64_t)a3 >> 22) & 0x3C0;
        v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        v12 = a4;
        v13 = v66;
      }
      else
      {
        v15 = v76[27];
        v16 = v76[28] + v68;
        v17 = v16 - a3 + (v15 >> 1);
        v12 = a4;
        v13 = v66;
        if (v17 < 1)
          goto LABEL_36;
        if (v17 >= v15)
          LODWORD(v18) = 0x3FFFFFFF;
        else
          v18 = (v76[29] * v17) >> 32;
        v20 = v64 | v18;
        v21 = v16 - 0x1000000;
        v19 = 448;
      }
    }
    else
    {
      v9 = v76[27];
      v10 = v67 - v76[28];
      v11 = a3 - v10 + (v9 >> 1);
      v12 = a4;
      v13 = v66;
      if (v11 < 1)
        goto LABEL_36;
      if (v11 >= v9)
        LODWORD(v14) = 0x3FFFFFFF;
      else
        v14 = (v76[29] * v11) >> 32;
      v20 = v64 | v14;
      v21 = v10 + 0x1000000;
      v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v65)
      {
        v26 = ((unint64_t)a2 >> 26) & 0x3C;
        v25 = a2;
      }
      else
      {
        v27 = v76[24];
        v28 = v76[25] + v65;
        v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1)
          goto LABEL_36;
        if (v29 < v27)
          v20 = ((v20 >> 15) * (((v76[26] * v29) >> 32) >> 15)) | v64;
        v25 = v28 - 0x1000000;
        v26 = 28;
      }
    }
    else
    {
      v22 = v76[24];
      v23 = v13 - v76[25];
      v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_36;
      if (v24 < v22)
        v20 = ((v20 >> 15) * (((v76[26] * v24) >> 32) >> 15)) | v64;
      v25 = v23 + 0x1000000;
      v26 = 32;
    }
    if (v20 >= 0x400000)
      break;
LABEL_36:
    v35 = v12 - 1;
    a2 += v75;
    a3 += v74;
    ++v7;
    *(_BYTE *)++v69 = 0;
LABEL_37:
    a4 = v35;
    if (!v35)
      return result;
  }
  v30 = v70 + SHIDWORD(v21) * (uint64_t)v72 + 4 * (v25 >> 32);
  v31 = (unsigned int *)v76[4];
  v32 = (unsigned int *)v73;
  if (v73 >= v30)
    v32 = (unsigned int *)v30;
  if (v32 < v31)
    v32 = (unsigned int *)v76[4];
  v33 = bswap32(*v32);
  if (!v6)
    goto LABEL_69;
  v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_40:
  v36 = v34 & 0xF;
  v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      v51 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 < (unint64_t)v51)
        v51 = (unsigned int *)v73;
      if (v51 >= v31)
        v31 = v51;
      v52 = interpolate_8888_19472[v37];
      v53 = v37 + 1;
      v54 = v33 - ((v52 & v33) >> v53);
      v55 = (bswap32(*v31) & v52) >> v53;
LABEL_68:
      v33 = v54 + v55;
      break;
    case 2:
      v56 = (unsigned int *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 54));
      if (v73 < (unint64_t)v56)
        v56 = (unsigned int *)v73;
      if (v56 >= v31)
        v31 = v56;
      v47 = bswap32(*v31);
      v48 = (v34 >> 28) & 3;
      v49 = interpolate_8888_19472[v48];
      v50 = v49 & v33;
LABEL_67:
      v57 = v48 + 1;
      v54 = v33 - (v50 >> v57);
      v55 = (v47 & v49) >> v57;
      goto LABEL_68;
    case 3:
      v38 = (unint64_t)HIWORD(v34) << 56;
      v39 = (unsigned int *)(v30 + (v38 >> 54));
      if (v73 < (unint64_t)v39)
        v39 = (unsigned int *)v73;
      if (v39 < v31)
        v39 = v31;
      v40 = bswap32(*v39);
      v41 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v72);
      if (v73 >= (unint64_t)v41)
        v42 = v41;
      else
        v42 = (unsigned int *)v73;
      if (v42 < v31)
        v42 = v31;
      v43 = bswap32(*v42);
      v44 = (unsigned int *)((char *)v41 + (v38 >> 54));
      if (v73 < (unint64_t)v44)
        v44 = (unsigned int *)v73;
      if (v44 >= v31)
        v31 = v44;
      v45 = interpolate_8888_19472[v37];
      v46 = v37 + 1;
      v33 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      v47 = v40 - ((v45 & v40) >> v46) + ((bswap32(*v31) & v45) >> v46);
      v48 = (v34 >> 28) & 3;
      v49 = interpolate_8888_19472[v48];
      v50 = v33 & v49;
      goto LABEL_67;
  }
LABEL_69:
  v58 = 0;
  ++v7;
  v63 = v12;
  v59 = v12 - 1;
  a3 += v74;
  v60 = v68 - a3;
  a2 += v75;
  v61 = v65 - a2;
  while (1)
  {
    result = ARGB32(v7, v33 | v71);
    *(_BYTE *)(v69 + 1 + v58) = v20 >> 22;
    if (v59 == (_DWORD)v58)
      return result;
    if (((v60 | v61 | (a3 - v67) | (a2 - v66)) & 0x8000000000000000) != 0)
    {
      v69 += v58 + 1;
      v35 = ~(_DWORD)v58 + v63;
      goto LABEL_37;
    }
    v30 = v70 + SHIDWORD(a3) * (uint64_t)v72 + 4 * (a2 >> 32);
    v31 = (unsigned int *)v76[4];
    v62 = (unsigned int *)v73;
    if (v73 >= v30)
      v62 = (unsigned int *)(v70 + SHIDWORD(a3) * (uint64_t)v72 + 4 * (a2 >> 32));
    if (v62 < v31)
      v62 = (unsigned int *)v76[4];
    v33 = bswap32(*v62);
    if (v6)
    {
      v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v69 += v58 + 1;
        v12 = ~(_DWORD)v58 + v63;
        v20 = -1;
        goto LABEL_40;
      }
    }
    ++v7;
    ++v58;
    a3 += v74;
    v60 -= v74;
    a2 += v75;
    v61 -= v75;
    v20 = -1;
  }
}

unint64_t *cmyk32_sample_argb32(unint64_t *result, uint64_t a2, int64_t a3, int a4)
{
  unint64_t v6;
  unint64_t *v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unsigned int *v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  int v35;
  int v36;
  int v37;
  int64_t v38;
  unsigned int *v39;
  unsigned int v40;
  unsigned int *v41;
  unsigned int *v42;
  unsigned int v43;
  unsigned int *v44;
  unsigned int v45;
  char v46;
  unsigned int v47;
  unsigned int v48;
  int v49;
  int v50;
  char v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int *v54;
  unsigned int v55;
  char v56;
  unsigned int v57;
  unsigned int *v58;
  int v59;
  int v60;
  uint64_t v61;
  int v62;
  int64_t v63;
  uint64_t v64;
  unsigned int *v65;
  int v66;
  int v67;
  uint64_t v68;
  unint64_t v69;
  int64_t v70;
  int64_t v71;
  uint64_t v72;
  unint64_t v73;
  int v74;
  int v75;
  unint64_t v76;
  unint64_t v77;
  unint64_t v78;
  unint64_t *v79;

  v6 = result[22];
  v68 = result[10];
  v71 = result[11];
  v78 = result[14];
  v77 = result[15];
  v67 = *((_DWORD *)result + 47);
  v7 = (unint64_t *)(result[19] - 8);
  v72 = result[18] - 1;
  if (result[5])
    v8 = 0;
  else
    v8 = -16777216;
  v74 = v8;
  v75 = *((_DWORD *)result + 6);
  v73 = result[4];
  v79 = result;
  v76 = v73 + ((*((_DWORD *)result + 65) - 1) * v75) + 4 * *((unsigned int *)result + 64) - 4;
  v69 = result[8];
  v70 = result[9];
  while (1)
  {
    if (a3 >= v70)
    {
      if (a3 <= v71)
      {
        v19 = ((unint64_t)a3 >> 22) & 0x3C0;
        v20 = 0x3FFFFFFF;
        HIDWORD(v21) = HIDWORD(a3);
        v12 = a4;
        v13 = v69;
      }
      else
      {
        v15 = v79[27];
        v16 = v79[28] + v71;
        v17 = v16 - a3 + (v15 >> 1);
        v12 = a4;
        v13 = v69;
        if (v17 < 1)
          goto LABEL_36;
        if (v17 >= v15)
          LODWORD(v18) = 0x3FFFFFFF;
        else
          v18 = (v79[29] * v17) >> 32;
        v20 = v67 | v18;
        v21 = v16 - 0x1000000;
        v19 = 448;
      }
    }
    else
    {
      v9 = v79[27];
      v10 = v70 - v79[28];
      v11 = a3 - v10 + (v9 >> 1);
      v12 = a4;
      v13 = v69;
      if (v11 < 1)
        goto LABEL_36;
      if (v11 >= v9)
        LODWORD(v14) = 0x3FFFFFFF;
      else
        v14 = (v79[29] * v11) >> 32;
      v20 = v67 | v14;
      v21 = v10 + 0x1000000;
      v19 = 512;
    }
    if (a2 >= v13)
    {
      if (a2 <= v68)
      {
        v26 = ((unint64_t)a2 >> 26) & 0x3C;
        v25 = a2;
      }
      else
      {
        v27 = v79[24];
        v28 = v79[25] + v68;
        v29 = v28 - a2 + (v27 >> 1);
        if (v29 < 1)
          goto LABEL_36;
        if (v29 < v27)
          v20 = ((v20 >> 15) * (((v79[26] * v29) >> 32) >> 15)) | v67;
        v25 = v28 - 0x1000000;
        v26 = 28;
      }
    }
    else
    {
      v22 = v79[24];
      v23 = v13 - v79[25];
      v24 = a2 - v23 + (v22 >> 1);
      if (v24 < 1)
        goto LABEL_36;
      if (v24 < v22)
        v20 = ((v20 >> 15) * (((v79[26] * v24) >> 32) >> 15)) | v67;
      v25 = v23 + 0x1000000;
      v26 = 32;
    }
    if (v20 >= 0x400000)
      break;
LABEL_36:
    v35 = v12 - 1;
    a2 += v78;
    a3 += v77;
    ++v7;
    *(_BYTE *)++v72 = 0;
LABEL_37:
    a4 = v35;
    if (!v35)
      return result;
  }
  v30 = v73 + SHIDWORD(v21) * (uint64_t)v75 + 4 * (v25 >> 32);
  v31 = (unsigned int *)v79[4];
  v32 = (unsigned int *)v76;
  if (v76 >= v30)
    v32 = (unsigned int *)v30;
  if (v32 < v31)
    v32 = (unsigned int *)v79[4];
  v33 = *v32;
  if (!v6)
    goto LABEL_69;
  v34 = *(_DWORD *)(v6 + (v26 | v19));
LABEL_40:
  v36 = v34 & 0xF;
  v37 = HIBYTE(v34) & 3;
  switch(v36)
  {
    case 1:
      v54 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 < (unint64_t)v54)
        v54 = (unsigned int *)v76;
      if (v54 >= v31)
        v31 = v54;
      v55 = interpolate_8888_19472[v37];
      v56 = v37 + 1;
      v52 = v33 - ((v55 & v33) >> v56);
      v57 = (v55 & *v31) >> v56;
LABEL_68:
      v33 = v52 + v57;
      break;
    case 2:
      v58 = (unsigned int *)(v30 + ((uint64_t)((unint64_t)HIWORD(v34) << 56) >> 54));
      if (v76 < (unint64_t)v58)
        v58 = (unsigned int *)v76;
      if (v58 >= v31)
        v31 = v58;
      v59 = (v34 >> 28) & 3;
      v60 = interpolate_8888_19472[v59];
      v51 = v59 + 1;
      v52 = v33 - ((v60 & v33) >> v51);
      v53 = v60 & *v31;
LABEL_67:
      v57 = v53 >> v51;
      goto LABEL_68;
    case 3:
      v38 = (unint64_t)HIWORD(v34) << 56;
      v39 = (unsigned int *)(v30 + (v38 >> 54));
      if (v76 < (unint64_t)v39)
        v39 = (unsigned int *)v76;
      if (v39 < v31)
        v39 = v31;
      v40 = *v39;
      v41 = (unsigned int *)(v30 + SBYTE1(v34) * (uint64_t)v75);
      if (v76 >= (unint64_t)v41)
        v42 = v41;
      else
        v42 = (unsigned int *)v76;
      if (v42 < v31)
        v42 = v31;
      v43 = *v42;
      v44 = (unsigned int *)((char *)v41 + (v38 >> 54));
      if (v76 < (unint64_t)v44)
        v44 = (unsigned int *)v76;
      if (v44 >= v31)
        v31 = v44;
      v45 = interpolate_8888_19472[v37];
      v46 = v37 + 1;
      v47 = v33 - ((v45 & v33) >> v46) + ((v45 & v43) >> v46);
      v48 = v40 - ((v45 & v40) >> v46) + ((v45 & *v31) >> v46);
      v49 = (v34 >> 28) & 3;
      v50 = interpolate_8888_19472[v49];
      v51 = v49 + 1;
      v52 = v47 - ((v47 & v50) >> v51);
      v53 = v48 & v50;
      goto LABEL_67;
  }
LABEL_69:
  v61 = 0;
  ++v7;
  v66 = v12;
  v62 = v12 - 1;
  a3 += v77;
  v63 = v71 - a3;
  a2 += v78;
  v64 = v68 - a2;
  while (1)
  {
    result = ARGB32(v7, v33 | v74);
    *(_BYTE *)(v72 + 1 + v61) = v20 >> 22;
    if (v62 == (_DWORD)v61)
      return result;
    if (((v63 | v64 | (a3 - v70) | (a2 - v69)) & 0x8000000000000000) != 0)
    {
      v72 += v61 + 1;
      v35 = ~(_DWORD)v61 + v66;
      goto LABEL_37;
    }
    v30 = v73 + SHIDWORD(a3) * (uint64_t)v75 + 4 * (a2 >> 32);
    v31 = (unsigned int *)v79[4];
    v65 = (unsigned int *)v76;
    if (v76 >= v30)
      v65 = (unsigned int *)(v73 + SHIDWORD(a3) * (uint64_t)v75 + 4 * (a2 >> 32));
    if (v65 < v31)
      v65 = (unsigned int *)v79[4];
    v33 = *v65;
    if (v6)
    {
      v34 = *(_DWORD *)(v6 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v34 & 0xF) != 0)
      {
        v72 += v61 + 1;
        v12 = ~(_DWORD)v61 + v66;
        v20 = -1;
        goto LABEL_40;
      }
    }
    ++v7;
    ++v61;
    a3 += v77;
    v63 -= v77;
    a2 += v78;
    v64 -= v78;
    v20 = -1;
  }
}

uint64_t cmyk32_sample_CMYK32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unsigned int *v51;
  unsigned int *v52;
  unint64_t v53;
  unint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  int v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int *v74;
  unint64_t v75;
  unint64_t v76;
  unsigned int *v77;
  unint64_t v78;
  unsigned int *v79;
  unint64_t v80;
  unsigned __int8 *v81;
  unint64_t v82;
  unint64_t v83;
  unsigned __int8 *v84;
  unsigned __int8 *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int *v93;
  unint64_t v94;
  unsigned __int8 *v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  int64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int *v104;
  unint64_t v105;
  unsigned __int8 *v106;
  unsigned int v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int *v122;
  unsigned __int8 *v123;
  unsigned __int8 *v124;
  int v125;
  unsigned int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;

  v4 = *(_DWORD *)(result + 24);
  v134 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v133 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v133 = v5 % v6;
  }
  else
  {
    v133 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v135 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v132 = v11;
  }
  else
  {
    v132 = 0;
  }
  v131 = *(_QWORD *)(result + 80);
  v129 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 8;
  v13 = *(_QWORD *)(result + 144) - 1;
  if (v9)
    v14 = 0;
  else
    v14 = 0xFF00000000;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v127 = *(_DWORD *)(result + 188);
  v17 = (unsigned __int8 *)(v9 + (v16 - 1) + (v15 * v134));
  v18 = v135 + (v15 * v4) + 4 * v16 - 8;
  v128 = *(_QWORD *)(result + 64);
  v130 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 >= v130)
    {
      v22 = a4;
      if (a3 <= v129)
      {
        v28 = 0;
        v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        v30 = 0x3FFFFFFF;
        v31 = a3;
        v32 = v128;
        v33 = v131;
      }
      else
      {
        v24 = *(_QWORD *)(result + 216);
        v25 = *(_QWORD *)(result + 224) + v129;
        v26 = v25 - a3 + (v24 >> 1);
        if (v26 < 1)
          goto LABEL_60;
        if (v26 >= v24)
          LODWORD(v27) = 0x3FFFFFFF;
        else
          v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
        v32 = v128;
        v33 = v131;
        v30 = v127 | v27;
        v31 = v25 - 0x1000000;
        v28 = a3 - v31;
        v29 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v130 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      if (v21 < 1)
        goto LABEL_60;
      if (v21 >= v19)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v32 = v128;
      v33 = v131;
      v30 = v127 | v23;
      v31 = v20 + 0x1000000;
      v28 = a3 - v31;
      v29 = 512;
    }
    if (a2 >= v32)
      break;
    v34 = *(_QWORD *)(result + 192);
    v35 = v32 - *(_QWORD *)(result + 200);
    v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v127;
      v37 = v35 + 0x1000000;
      v38 = a2 - (v35 + 0x1000000);
      v39 = 32;
      goto LABEL_38;
    }
LABEL_60:
    v57 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 8;
    *(_BYTE *)++v13 = 0;
LABEL_61:
    a4 = v57;
    if (!v57)
      return result;
  }
  if (a2 <= v33)
  {
    v38 = 0;
    v39 = ((unint64_t)a2 >> 26) & 0x3C;
    v37 = a2;
    goto LABEL_38;
  }
  v40 = *(_QWORD *)(result + 192);
  v41 = *(_QWORD *)(result + 200) + v33;
  v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1)
    goto LABEL_60;
  if (v42 < v40)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v127;
  v37 = v41 - 0x1000000;
  v38 = a2 - (v41 - 0x1000000);
  v39 = 28;
LABEL_38:
  if (v30 < 0x400000)
    goto LABEL_60;
  if (v6)
  {
    v43 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    v44 = (v6 & ((v37 % v6) >> 63)) + v37 % v6;
    if (v43 >= v7)
      v45 = v7;
    else
      v45 = 0;
    v31 = v43 - v45;
    if (v44 >= v6)
      v46 = v6;
    else
      v46 = 0;
    v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  v47 = v31 >> 32;
  v48 = v37 >> 32;
  v49 = v135 + (int)v47 * (uint64_t)v4;
  v50 = v49 + 4 * v48;
  v51 = *(unsigned int **)(result + 32);
  if (v18 >= v50)
    v52 = (unsigned int *)(v49 + 4 * v48);
  else
    v52 = (unsigned int *)v18;
  if (v52 < v51)
    v52 = *(unsigned int **)(result + 32);
  v53 = bswap32(*v52);
  if (!v9)
  {
    v54 = 0;
    if (!v8)
      goto LABEL_139;
LABEL_64:
    v58 = *(_DWORD *)(v8 + (v39 | v29));
LABEL_66:
    v59 = v58 & 0xF;
    v60 = v58 >> 8;
    v61 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      LODWORD(v88) = SBYTE1(v58);
      if (v6)
      {
        v89 = v60 << 56;
        v90 = v28 + (v89 >> 24);
        v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7)
          v92 = v7;
        else
          v92 = 0;
        v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      v93 = (unsigned int *)(v50 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93)
        v93 = (unsigned int *)v18;
      if (v93 < v51)
        v93 = v51;
      v94 = bswap32(*v93);
      if (v9)
      {
        v95 = (unsigned __int8 *)(v54 + (int)v88 * (uint64_t)v134);
        if (v17 < v95)
          v95 = v17;
        if ((unint64_t)v95 < *(_QWORD *)(result + 40))
          v95 = *(unsigned __int8 **)(result + 40);
        v94 |= (unint64_t)*v95 << 32;
      }
      v96 = interpolate_cif10a[v61];
      v97 = v53 - ((v96 & v53) >> (v61 + 1));
      v98 = (v96 & v94) >> (v61 + 1);
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          v62 = HIBYTE(v58) & 3;
          v126 = v30;
          v125 = v22;
          LODWORD(v63) = SBYTE1(v58);
          v64 = SBYTE2(v58);
          if (v6)
          {
            v65 = v60 << 56;
            v66 = (unint64_t)HIWORD(v58) << 56;
            v67 = v28 + (v65 >> 24);
            v68 = v38 + (v66 >> 24);
            v69 = v7 & (v67 >> 63);
            v70 = v6 & (v68 >> 63);
            v71 = v70 + v68;
            if (v69 + v67 >= v7)
              v72 = v7;
            else
              v72 = 0;
            if (v71 >= v6)
              v73 = v6;
            else
              v73 = 0;
            v63 = (v69 + (v65 >> 24) - v72) >> 32;
            v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          v74 = (unsigned int *)(v50 + 4 * v64);
          if (v18 < (unint64_t)v74)
            v74 = (unsigned int *)v18;
          if (v74 < v51)
            v74 = v51;
          v75 = bswap32(*v74);
          v76 = v50 + (int)v63 * (uint64_t)v4;
          if (v18 >= v76)
            v77 = (unsigned int *)(v50 + (int)v63 * (uint64_t)v4);
          else
            v77 = (unsigned int *)v18;
          if (v77 < v51)
            v77 = v51;
          v78 = bswap32(*v77);
          v79 = (unsigned int *)(v76 + 4 * v64);
          if (v18 < (unint64_t)v79)
            v79 = (unsigned int *)v18;
          if (v79 >= v51)
            v51 = v79;
          v80 = bswap32(*v51);
          if (v9)
          {
            v81 = (unsigned __int8 *)(v54 + v64);
            v82 = *(_QWORD *)(result + 40);
            if ((unint64_t)v17 < v54 + v64)
              v81 = v17;
            if ((unint64_t)v81 < v82)
              v81 = *(unsigned __int8 **)(result + 40);
            v75 |= (unint64_t)*v81 << 32;
            v83 = v54 + (int)v63 * (uint64_t)v134;
            if ((unint64_t)v17 >= v83)
              v84 = (unsigned __int8 *)(v54 + (int)v63 * (uint64_t)v134);
            else
              v84 = v17;
            if ((unint64_t)v84 < v82)
              v84 = *(unsigned __int8 **)(result + 40);
            v78 |= (unint64_t)*v84 << 32;
            v85 = (unsigned __int8 *)(v83 + v64);
            if (v17 < v85)
              v85 = v17;
            if ((unint64_t)v85 < v82)
              v85 = *(unsigned __int8 **)(result + 40);
            v80 |= (unint64_t)*v85 << 32;
          }
          v86 = interpolate_cif10a[v62];
          v87 = v53 - ((v86 & v53) >> (v62 + 1)) + ((v86 & v78) >> (v62 + 1));
          v53 = v87
              - ((v87 & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1))
              + (((v75 - ((v86 & v75) >> (v62 + 1)) + ((v86 & v80) >> (v62 + 1))) & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1));
          v22 = v125;
          v30 = v126;
        }
        goto LABEL_139;
      }
      v99 = SBYTE2(v58);
      if (v6)
      {
        v100 = (unint64_t)HIWORD(v58) << 56;
        v101 = v38 + (v100 >> 24);
        v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6)
          v103 = v6;
        else
          v103 = 0;
        v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      v104 = (unsigned int *)(v50 + 4 * v99);
      if (v18 < (unint64_t)v104)
        v104 = (unsigned int *)v18;
      if (v104 < v51)
        v104 = v51;
      v105 = bswap32(*v104);
      if (v9)
      {
        v106 = (unsigned __int8 *)(v54 + v99);
        if (v17 < v106)
          v106 = v17;
        if ((unint64_t)v106 < *(_QWORD *)(result + 40))
          v106 = *(unsigned __int8 **)(result + 40);
        v105 |= (unint64_t)*v106 << 32;
      }
      v107 = (v58 >> 28) & 3;
      v108 = interpolate_cif10a[v107];
      LOBYTE(v107) = v107 + 1;
      v97 = v53 - ((v108 & v53) >> v107);
      v98 = (v108 & v105) >> v107;
    }
    v53 = v97 + v98;
    goto LABEL_139;
  }
  v54 = v9 + (int)v47 * (uint64_t)v134 + v48;
  v55 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v17 >= v54)
    v56 = (unsigned __int8 *)v54;
  else
    v56 = v17;
  if (v56 >= v55)
    v55 = v56;
  v53 |= (unint64_t)*v55 << 32;
  if (v8)
    goto LABEL_64;
LABEL_139:
  *(_QWORD *)(v12 + 8) = v53 | v14;
  *(_BYTE *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    v109 = v22;
    v110 = 0;
    a2 += v5;
    v111 = v131 - a2;
    a3 += v10;
    v112 = v129 - a3;
    v113 = -8;
    while (((v112 | v111 | (a3 - v130) | (a2 - v128)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        v115 = (v6 & ((v38 + v133) >> 63)) + v38 + v133;
        if (v114 >= v7)
          v116 = v7;
        else
          v116 = 0;
        v117 = v114 - v116;
        if (v115 >= v6)
          v118 = v6;
        else
          v118 = 0;
        v119 = v115 - v118;
        v38 = v119;
        v28 = v117;
      }
      else
      {
        v119 = a2;
        v117 = a3;
      }
      v120 = v117 >> 32;
      v121 = v119 >> 32;
      v50 = v135 + SHIDWORD(v117) * (uint64_t)v4 + 4 * (v119 >> 32);
      v51 = *(unsigned int **)(result + 32);
      if (v18 >= v50)
        v122 = (unsigned int *)v50;
      else
        v122 = (unsigned int *)v18;
      if (v122 < v51)
        v122 = *(unsigned int **)(result + 32);
      v53 = bswap32(*v122);
      if (v9)
      {
        v54 = v9 + (int)v120 * (uint64_t)v134 + v121;
        v123 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v17 >= v54)
          v124 = (unsigned __int8 *)v54;
        else
          v124 = v17;
        if (v124 >= v123)
          v123 = v124;
        v53 |= (unint64_t)*v123 << 32;
      }
      if (v8)
      {
        v58 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v58 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          v22 = ~(_DWORD)v110 + v109;
          v30 = -1;
          goto LABEL_66;
        }
      }
      *(_QWORD *)(v12 + 8 * v110 + 16) = v53 | v14;
      *(_BYTE *)(v13 + v110++ + 2) = -1;
      v113 -= 8;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == (_DWORD)v110)
        return result;
    }
    v13 += v110 + 1;
    v12 -= v113;
    v57 = ~(_DWORD)v110 + v109;
    goto LABEL_61;
  }
  return result;
}

uint64_t cmyk32_sample_cmyk32(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  unsigned __int8 *v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unsigned int *v51;
  unsigned int *v52;
  unint64_t v53;
  unint64_t v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  int v57;
  unsigned int v58;
  int v59;
  uint64_t v60;
  int v61;
  int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unsigned int *v74;
  unint64_t v75;
  unint64_t v76;
  unsigned int *v77;
  unint64_t v78;
  unsigned int *v79;
  unint64_t v80;
  unsigned __int8 *v81;
  unint64_t v82;
  unint64_t v83;
  unsigned __int8 *v84;
  unsigned __int8 *v85;
  uint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unsigned int *v93;
  unint64_t v94;
  unsigned __int8 *v95;
  uint64_t v96;
  unint64_t v97;
  unint64_t v98;
  uint64_t v99;
  int64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  unsigned int *v104;
  unint64_t v105;
  unsigned __int8 *v106;
  int v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unsigned int *v122;
  unsigned __int8 *v123;
  unsigned __int8 *v124;
  int v125;
  unsigned int v126;
  int v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;

  v4 = *(_DWORD *)(result + 24);
  v134 = *(_DWORD *)(result + 28);
  v5 = *(_QWORD *)(result + 112);
  v6 = *(_QWORD *)(result + 48);
  v7 = *(_QWORD *)(result + 56);
  if (v6)
  {
    v133 = *(_QWORD *)(result + 112);
    if (v5 > v6)
      v133 = v5 % v6;
  }
  else
  {
    v133 = 0;
  }
  v8 = *(_QWORD *)(result + 176);
  v9 = *(_QWORD *)(result + 40);
  v135 = *(_QWORD *)(result + 32);
  v10 = *(_QWORD *)(result + 120);
  if (v7)
  {
    v11 = v10 % v7;
    if (v10 <= v7)
      v11 = *(_QWORD *)(result + 120);
    v132 = v11;
  }
  else
  {
    v132 = 0;
  }
  v131 = *(_QWORD *)(result + 80);
  v129 = *(_QWORD *)(result + 88);
  v12 = *(_QWORD *)(result + 152) - 8;
  v13 = *(_QWORD *)(result + 144) - 1;
  if (v9)
    v14 = 0;
  else
    v14 = 0xFF00000000;
  v15 = *(_DWORD *)(result + 260) - 1;
  v16 = *(unsigned int *)(result + 256);
  v127 = *(_DWORD *)(result + 188);
  v17 = (unsigned __int8 *)(v9 + (v16 - 1) + (v15 * v134));
  v18 = v135 + (v15 * v4) + 4 * v16 - 8;
  v128 = *(_QWORD *)(result + 64);
  v130 = *(_QWORD *)(result + 72);
  while (1)
  {
    if (a3 >= v130)
    {
      v22 = a4;
      if (a3 <= v129)
      {
        v28 = 0;
        v29 = ((unint64_t)a3 >> 22) & 0x3C0;
        v30 = 0x3FFFFFFF;
        v31 = a3;
        v32 = v128;
        v33 = v131;
      }
      else
      {
        v24 = *(_QWORD *)(result + 216);
        v25 = *(_QWORD *)(result + 224) + v129;
        v26 = v25 - a3 + (v24 >> 1);
        if (v26 < 1)
          goto LABEL_60;
        if (v26 >= v24)
          LODWORD(v27) = 0x3FFFFFFF;
        else
          v27 = (unint64_t)(*(_QWORD *)(result + 232) * v26) >> 32;
        v32 = v128;
        v33 = v131;
        v30 = v127 | v27;
        v31 = v25 - 0x1000000;
        v28 = a3 - (v25 - 0x1000000);
        v29 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v130 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      if (v21 < 1)
        goto LABEL_60;
      if (v21 >= v19)
        LODWORD(v23) = 0x3FFFFFFF;
      else
        v23 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v32 = v128;
      v33 = v131;
      v30 = v127 | v23;
      v31 = v20 + 0x1000000;
      v28 = a3 - (v20 + 0x1000000);
      v29 = 512;
    }
    if (a2 >= v32)
      break;
    v34 = *(_QWORD *)(result + 192);
    v35 = v32 - *(_QWORD *)(result + 200);
    v36 = a2 - v35 + (v34 >> 1);
    if (v36 >= 1)
    {
      if (v36 < v34)
        v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v36) >> 32) >> 15)) | v127;
      v37 = v35 + 0x1000000;
      v38 = a2 - (v35 + 0x1000000);
      v39 = 32;
      goto LABEL_38;
    }
LABEL_60:
    v57 = v22 - 1;
    a2 += v5;
    a3 += v10;
    v12 += 8;
    *(_BYTE *)++v13 = 0;
LABEL_61:
    a4 = v57;
    if (!v57)
      return result;
  }
  if (a2 <= v33)
  {
    v38 = 0;
    v39 = ((unint64_t)a2 >> 26) & 0x3C;
    v37 = a2;
    goto LABEL_38;
  }
  v40 = *(_QWORD *)(result + 192);
  v41 = *(_QWORD *)(result + 200) + v33;
  v42 = v41 - a2 + (v40 >> 1);
  if (v42 < 1)
    goto LABEL_60;
  if (v42 < v40)
    v30 = ((v30 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v42) >> 32) >> 15)) | v127;
  v37 = v41 - 0x1000000;
  v38 = a2 - (v41 - 0x1000000);
  v39 = 28;
LABEL_38:
  if (v30 < 0x400000)
    goto LABEL_60;
  if (v6)
  {
    v43 = (v7 & ((v31 % v7) >> 63)) + v31 % v7;
    v44 = (v6 & ((v37 % v6) >> 63)) + v37 % v6;
    if (v43 >= v7)
      v45 = v7;
    else
      v45 = 0;
    v31 = v43 - v45;
    if (v44 >= v6)
      v46 = v6;
    else
      v46 = 0;
    v37 = v44 - v46;
    v28 += v31;
    v38 += v37;
  }
  v47 = v31 >> 32;
  v48 = v37 >> 32;
  v49 = v135 + SHIDWORD(v31) * (uint64_t)v4;
  v50 = v49 + 4 * v48;
  v51 = *(unsigned int **)(result + 32);
  if (v18 >= v50)
    v52 = (unsigned int *)(v49 + 4 * v48);
  else
    v52 = (unsigned int *)v18;
  if (v52 < v51)
    v52 = *(unsigned int **)(result + 32);
  v53 = *v52;
  if (!v9)
  {
    v54 = 0;
    if (!v8)
      goto LABEL_139;
LABEL_64:
    v58 = *(_DWORD *)(v8 + (v39 | v29));
LABEL_66:
    v59 = v58 & 0xF;
    v60 = v58 >> 8;
    v61 = HIBYTE(v58) & 3;
    if (v59 == 1)
    {
      LODWORD(v88) = SBYTE1(v58);
      if (v6)
      {
        v89 = v60 << 56;
        v90 = v28 + (v89 >> 24);
        v91 = v7 & (v90 >> 63);
        if (v91 + v90 >= v7)
          v92 = v7;
        else
          v92 = 0;
        v88 = (v91 + (v89 >> 24) - v92) >> 32;
      }
      v93 = (unsigned int *)(v50 + (int)v88 * (uint64_t)v4);
      if (v18 < (unint64_t)v93)
        v93 = (unsigned int *)v18;
      if (v93 < v51)
        v93 = v51;
      v94 = *v93;
      if (v9)
      {
        v95 = (unsigned __int8 *)(v54 + (int)v88 * (uint64_t)v134);
        if (v17 < v95)
          v95 = v17;
        if ((unint64_t)v95 < *(_QWORD *)(result + 40))
          v95 = *(unsigned __int8 **)(result + 40);
        v94 |= (unint64_t)*v95 << 32;
      }
      v96 = interpolate_cif10a[v61];
      v97 = v53 - ((v96 & v53) >> (v61 + 1));
      v98 = (v96 & v94) >> (v61 + 1);
    }
    else
    {
      if (v59 != 2)
      {
        if (v59 == 3)
        {
          v62 = HIBYTE(v58) & 3;
          v126 = v30;
          v125 = v22;
          LODWORD(v63) = SBYTE1(v58);
          v64 = SBYTE2(v58);
          if (v6)
          {
            v65 = v60 << 56;
            v66 = (unint64_t)HIWORD(v58) << 56;
            v67 = v28 + (v65 >> 24);
            v68 = v38 + (v66 >> 24);
            v69 = v7 & (v67 >> 63);
            v70 = v6 & (v68 >> 63);
            v71 = v70 + v68;
            if (v69 + v67 >= v7)
              v72 = v7;
            else
              v72 = 0;
            if (v71 >= v6)
              v73 = v6;
            else
              v73 = 0;
            v63 = (v69 + (v65 >> 24) - v72) >> 32;
            v64 = (v70 + (v66 >> 24) - v73) >> 32;
          }
          v74 = (unsigned int *)(v50 + 4 * v64);
          if (v18 < (unint64_t)v74)
            v74 = (unsigned int *)v18;
          if (v74 < v51)
            v74 = v51;
          v75 = *v74;
          v76 = v50 + (int)v63 * (uint64_t)v4;
          if (v18 >= v76)
            v77 = (unsigned int *)(v50 + (int)v63 * (uint64_t)v4);
          else
            v77 = (unsigned int *)v18;
          if (v77 < v51)
            v77 = v51;
          v78 = *v77;
          v79 = (unsigned int *)(v76 + 4 * v64);
          if (v18 < (unint64_t)v79)
            v79 = (unsigned int *)v18;
          if (v79 >= v51)
            v51 = v79;
          v80 = *v51;
          if (v9)
          {
            v81 = (unsigned __int8 *)(v54 + v64);
            v82 = *(_QWORD *)(result + 40);
            if ((unint64_t)v17 < v54 + v64)
              v81 = v17;
            if ((unint64_t)v81 < v82)
              v81 = *(unsigned __int8 **)(result + 40);
            v75 |= (unint64_t)*v81 << 32;
            v83 = v54 + (int)v63 * (uint64_t)v134;
            if ((unint64_t)v17 >= v83)
              v84 = (unsigned __int8 *)(v54 + (int)v63 * (uint64_t)v134);
            else
              v84 = v17;
            if ((unint64_t)v84 < v82)
              v84 = *(unsigned __int8 **)(result + 40);
            v78 |= (unint64_t)*v84 << 32;
            v85 = (unsigned __int8 *)(v83 + v64);
            if (v17 < v85)
              v85 = v17;
            if ((unint64_t)v85 < v82)
              v85 = *(unsigned __int8 **)(result + 40);
            v80 |= (unint64_t)*v85 << 32;
          }
          v86 = interpolate_cif10a[v62];
          v87 = v53 - ((v86 & v53) >> (v62 + 1)) + ((v86 & v78) >> (v62 + 1));
          v53 = v87
              - ((v87 & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1))
              + (((v75 - ((v86 & v75) >> (v62 + 1)) + ((v86 & v80) >> (v62 + 1))) & interpolate_cif10a[(v58 >> 28) & 3]) >> (((v58 >> 28) & 3) + 1));
          v22 = v125;
          v30 = v126;
        }
        goto LABEL_139;
      }
      v99 = SBYTE2(v58);
      if (v6)
      {
        v100 = (unint64_t)HIWORD(v58) << 56;
        v101 = v38 + (v100 >> 24);
        v102 = v6 & (v101 >> 63);
        if (v102 + v101 >= v6)
          v103 = v6;
        else
          v103 = 0;
        v99 = (v102 + (v100 >> 24) - v103) >> 32;
      }
      v104 = (unsigned int *)(v50 + 4 * v99);
      if (v18 < (unint64_t)v104)
        v104 = (unsigned int *)v18;
      if (v104 < v51)
        v104 = v51;
      v105 = *v104;
      if (v9)
      {
        v106 = (unsigned __int8 *)(v54 + v99);
        if (v17 < v106)
          v106 = v17;
        if ((unint64_t)v106 < *(_QWORD *)(result + 40))
          v106 = *(unsigned __int8 **)(result + 40);
        v105 |= (unint64_t)*v106 << 32;
      }
      v107 = (v58 >> 28) & 3;
      v108 = interpolate_cif10a[v107];
      LOBYTE(v107) = v107 + 1;
      v97 = v53 - ((v108 & v53) >> v107);
      v98 = (v108 & v105) >> v107;
    }
    v53 = v97 + v98;
    goto LABEL_139;
  }
  v54 = v9 + (int)v47 * (uint64_t)v134 + v48;
  v55 = *(unsigned __int8 **)(result + 40);
  if ((unint64_t)v17 >= v54)
    v56 = (unsigned __int8 *)v54;
  else
    v56 = v17;
  if (v56 >= v55)
    v55 = v56;
  v53 |= (unint64_t)*v55 << 32;
  if (v8)
    goto LABEL_64;
LABEL_139:
  *(_QWORD *)(v12 + 8) = v53 | v14;
  *(_BYTE *)(v13 + 1) = v30 >> 22;
  if (v22 != 1)
  {
    v109 = v22;
    v110 = 0;
    a2 += v5;
    v111 = v131 - a2;
    a3 += v10;
    v112 = v129 - a3;
    v113 = -8;
    while (((v112 | v111 | (a3 - v130) | (a2 - v128)) & 0x8000000000000000) == 0)
    {
      if (v6)
      {
        v114 = (v7 & ((v28 + v132) >> 63)) + v28 + v132;
        v115 = (v6 & ((v38 + v133) >> 63)) + v38 + v133;
        if (v114 >= v7)
          v116 = v7;
        else
          v116 = 0;
        v117 = v114 - v116;
        if (v115 >= v6)
          v118 = v6;
        else
          v118 = 0;
        v119 = v115 - v118;
        v38 = v119;
        v28 = v117;
      }
      else
      {
        v119 = a2;
        v117 = a3;
      }
      v120 = v117 >> 32;
      v121 = v119 >> 32;
      v50 = v135 + SHIDWORD(v117) * (uint64_t)v4 + 4 * (v119 >> 32);
      v51 = *(unsigned int **)(result + 32);
      if (v18 >= v50)
        v122 = (unsigned int *)v50;
      else
        v122 = (unsigned int *)v18;
      if (v122 < v51)
        v122 = *(unsigned int **)(result + 32);
      v53 = *v122;
      if (v9)
      {
        v54 = v9 + (int)v120 * (uint64_t)v134 + v121;
        v123 = *(unsigned __int8 **)(result + 40);
        if ((unint64_t)v17 >= v54)
          v124 = (unsigned __int8 *)v54;
        else
          v124 = v17;
        if (v124 >= v123)
          v123 = v124;
        v53 |= (unint64_t)*v123 << 32;
      }
      if (v8)
      {
        v58 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
        if ((v58 & 0xF) != 0)
        {
          v13 += v110 + 1;
          v12 -= v113;
          v22 = ~(_DWORD)v110 + v109;
          v30 = -1;
          goto LABEL_66;
        }
      }
      *(_QWORD *)(v12 + 8 * v110 + 16) = v53 | v14;
      *(_BYTE *)(v13 + v110++ + 2) = -1;
      v113 -= 8;
      a2 += v5;
      v111 -= v5;
      a3 += v10;
      v112 -= v10;
      if (v109 - 1 == (_DWORD)v110)
        return result;
    }
    v13 += v110 + 1;
    v12 -= v113;
    v57 = ~(_DWORD)v110 + v109;
    goto LABEL_61;
  }
  return result;
}

uint64_t cmyk32_sample_CMYK64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned __int16 *v39;
  unsigned __int16 *v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  int64_t v49;
  unsigned __int16 *v50;
  unint64_t v51;
  unint64_t v52;
  unsigned __int16 *v53;
  unsigned __int16 *v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unsigned int v58;
  unsigned __int16 *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned __int16 *v63;
  char *v64;
  uint64_t v65;
  char v66;
  unint64_t v67;
  unint64_t v68;
  unsigned int v69;
  unint64_t v70;
  char *v71;
  uint64_t v72;
  unint64_t v73;
  unsigned int v74;
  unsigned int v75;
  unsigned __int16 *v76;
  unint64_t v77;
  unsigned int v78;
  unsigned __int16 *v79;
  char *v80;
  int v81;
  int64_t v82;
  unsigned __int16 *v83;
  unint64_t v84;
  unsigned int v85;
  unsigned __int16 *v86;
  unsigned int v87;
  char *v88;
  uint64_t v89;
  unint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  unsigned __int16 *v96;
  unsigned __int16 *v97;
  unint64_t v98;
  unint64_t v99;
  int v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_QWORD *)(result + 176);
  v103 = *(_QWORD *)(result + 88);
  v104 = *(_QWORD *)(result + 80);
  v9 = *(_QWORD *)(result + 112);
  v8 = *(_QWORD *)(result + 120);
  v105 = *(_QWORD *)(result + 144) - 1;
  v106 = *(_QWORD *)(result + 152) - 8;
  v10 = *(_DWORD *)(result + 260) - 1;
  v11 = *(unsigned int *)(result + 256);
  v107 = *(_DWORD *)(result + 28);
  v100 = *(_DWORD *)(result + 188);
  v12 = v5 + (v10 * v107) + 2 * (v11 - 1);
  v13 = v4 + (v10 * v6) + 8 * v11 - 16;
  v101 = *(_QWORD *)(result + 64);
  v102 = *(_QWORD *)(result + 72);
  while (1)
  {
LABEL_2:
    if (a3 >= v102)
    {
      if (a3 <= v103)
      {
        v22 = ((unint64_t)a3 >> 22) & 0x3C0;
        v23 = 0x3FFFFFFF;
        v24 = a3;
        v25 = v101;
        v26 = v104;
      }
      else
      {
        v18 = *(_QWORD *)(result + 216);
        v19 = *(_QWORD *)(result + 224) + v103;
        v20 = v19 - a3 + (v18 >> 1);
        if (v20 < 1)
          goto LABEL_39;
        if (v20 >= v18)
          LODWORD(v21) = 0x3FFFFFFF;
        else
          v21 = (unint64_t)(*(_QWORD *)(result + 232) * v20) >> 32;
        v25 = v101;
        v26 = v104;
        v23 = v100 | v21;
        v24 = v19 - 0x1000000;
        v22 = 448;
      }
    }
    else
    {
      v14 = *(_QWORD *)(result + 216);
      v15 = v102 - *(_QWORD *)(result + 224);
      v16 = a3 - v15 + (v14 >> 1);
      if (v16 < 1)
        goto LABEL_39;
      if (v16 >= v14)
        LODWORD(v17) = 0x3FFFFFFF;
      else
        v17 = (unint64_t)(*(_QWORD *)(result + 232) * v16) >> 32;
      v25 = v101;
      v26 = v104;
      v23 = v100 | v17;
      v24 = v15 + 0x1000000;
      v22 = 512;
    }
    if (a2 >= v25)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v25 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v100;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v9;
    a3 += v8;
    v106 += 8;
    *(_BYTE *)++v105 = 0;
    if (!a4)
      return result;
  }
  if (a2 <= v26)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_26;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v26;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_39;
  if (v34 < v32)
    v23 = ((v23 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v100;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_26:
  if (v23 < 0x400000)
    goto LABEL_39;
  v35 = v24 >> 32;
  v36 = v30 >> 32;
  v37 = v4 + SHIDWORD(v24) * (uint64_t)v6;
  v38 = v37 + 8 * v36;
  v39 = *(unsigned __int16 **)(result + 32);
  if (v13 >= v38)
    v40 = (unsigned __int16 *)(v37 + 8 * v36);
  else
    v40 = (unsigned __int16 *)v13;
  if (v40 < v39)
    v40 = *(unsigned __int16 **)(result + 32);
  if (v5)
  {
    v41 = v5 + (int)v35 * (uint64_t)v107 + 2 * v36;
    v42 = *(unsigned __int16 **)(result + 40);
    if (v12 >= v41)
      v43 = (unsigned __int16 *)v41;
    else
      v43 = (unsigned __int16 *)v12;
    if (v43 >= v42)
      v42 = v43;
    v44 = bswap32(*v42) >> 16;
  }
  else
  {
    v41 = 0;
    v44 = 0xFFFF;
  }
  v45 = ((unint64_t)(bswap32(v40[2]) >> 16) << 32) | ((unint64_t)(bswap32(v40[3]) >> 16) << 48) | bswap32(v40[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v40) >> 16);
  if (!v7)
    goto LABEL_101;
  v46 = *(_DWORD *)(v7 + (v31 | v22));
LABEL_45:
  v47 = v46 & 0xF;
  v48 = HIBYTE(v46) & 3;
  switch(v47)
  {
    case 1:
      v76 = (unsigned __int16 *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      if (v13 < (unint64_t)v76)
        v76 = (unsigned __int16 *)v13;
      if (v76 < v39)
        v76 = v39;
      v77 = ((unint64_t)(bswap32(v76[2]) >> 16) << 32) | ((unint64_t)(bswap32(v76[3]) >> 16) << 48) | bswap32(v76[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v76) >> 16);
      LOWORD(v78) = -1;
      if (v5)
      {
        v79 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v107);
        if (v12 < (unint64_t)v79)
          v79 = (unsigned __int16 *)v12;
        if ((unint64_t)v79 < *(_QWORD *)(result + 40))
          v79 = *(unsigned __int16 **)(result + 40);
        v78 = bswap32(*v79) >> 16;
      }
      v80 = (char *)&interpolate_cmyk64 + 16 * v48;
      v45 = v45
          - ((*(_QWORD *)v80 & v45) >> (v48 + 1))
          + ((*(_QWORD *)v80 & v77) >> (v48 + 1));
      v81 = v44 - ((*((_WORD *)v80 + 4) & v44) >> (v48 + 1)) + ((*((_WORD *)v80 + 4) & v78) >> (v48 + 1));
LABEL_100:
      BYTE1(v44) = BYTE1(v81);
      break;
    case 2:
      v82 = (unint64_t)HIWORD(v46) << 56;
      v83 = (unsigned __int16 *)(v38 + (v82 >> 53));
      if (v13 < (unint64_t)v83)
        v83 = (unsigned __int16 *)v13;
      if (v83 < v39)
        v83 = v39;
      v84 = ((unint64_t)(bswap32(v83[2]) >> 16) << 32) | ((unint64_t)(bswap32(v83[3]) >> 16) << 48) | bswap32(v83[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v83) >> 16);
      v85 = 0xFFFF;
      if (v5)
      {
        v86 = (unsigned __int16 *)(v41 + (v82 >> 55));
        if (v12 < (unint64_t)v86)
          v86 = (unsigned __int16 *)v12;
        if ((unint64_t)v86 < *(_QWORD *)(result + 40))
          v86 = *(unsigned __int16 **)(result + 40);
        v85 = bswap32(*v86) >> 16;
      }
      v87 = (v46 >> 28) & 3;
      v88 = (char *)&interpolate_cmyk64 + 16 * v87;
      v89 = *(_QWORD *)v88;
      LOBYTE(v87) = v87 + 1;
      v90 = v45 - ((*(_QWORD *)v88 & v45) >> v87);
      LODWORD(v88) = *((unsigned __int16 *)v88 + 4);
      v74 = v44 - ((v88 & v44) >> v87);
      v91 = (v89 & v84) >> v87;
      v75 = (v88 & v85) >> v87;
      v45 = v90 + v91;
LABEL_99:
      LOWORD(v81) = v74 + v75;
      goto LABEL_100;
    case 3:
      v49 = (unint64_t)HIWORD(v46) << 56;
      v50 = (unsigned __int16 *)(v38 + (v49 >> 53));
      if (v13 < (unint64_t)v50)
        v50 = (unsigned __int16 *)v13;
      if (v50 < v39)
        v50 = v39;
      v51 = ((unint64_t)(bswap32(v50[2]) >> 16) << 32) | ((unint64_t)(bswap32(v50[3]) >> 16) << 48) | bswap32(v50[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v50) >> 16);
      v52 = v38 + SBYTE1(v46) * (uint64_t)v6;
      if (v13 >= v52)
        v53 = (unsigned __int16 *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      else
        v53 = (unsigned __int16 *)v13;
      if (v53 < v39)
        v53 = v39;
      v99 = ((unint64_t)(bswap32(v53[2]) >> 16) << 32) | ((unint64_t)(bswap32(v53[3]) >> 16) << 48) | bswap32(v53[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v53) >> 16);
      v54 = (unsigned __int16 *)(v52 + (v49 >> 53));
      if (v13 < (unint64_t)v54)
        v54 = (unsigned __int16 *)v13;
      if (v54 < v39)
        v54 = v39;
      v55 = ((unint64_t)(bswap32(v54[2]) >> 16) << 32) | ((unint64_t)(bswap32(v54[3]) >> 16) << 48) | bswap32(v54[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v54) >> 16);
      v56 = 0xFFFF;
      v57 = 0xFFFF;
      v58 = 0xFFFF;
      if (v5)
      {
        v59 = (unsigned __int16 *)(v41 + (v49 >> 55));
        v60 = *(_QWORD *)(result + 40);
        if (v12 < (unint64_t)v59)
          v59 = (unsigned __int16 *)v12;
        if ((unint64_t)v59 < v60)
          v59 = *(unsigned __int16 **)(result + 40);
        v56 = bswap32(*v59) >> 16;
        v61 = v41 + SBYTE1(v46) * (uint64_t)v107;
        if (v12 >= v61)
          v62 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v107);
        else
          v62 = (unsigned __int16 *)v12;
        if ((unint64_t)v62 < v60)
          v62 = *(unsigned __int16 **)(result + 40);
        v57 = bswap32(*v62) >> 16;
        v63 = (unsigned __int16 *)(v61 + (v49 >> 55));
        if (v12 < (unint64_t)v63)
          v63 = (unsigned __int16 *)v12;
        if ((unint64_t)v63 < v60)
          v63 = *(unsigned __int16 **)(result + 40);
        v58 = bswap32(*v63) >> 16;
      }
      v64 = (char *)&interpolate_cmyk64 + 16 * v48;
      v65 = *(_QWORD *)v64;
      v66 = v48 + 1;
      v67 = v45 - ((*(_QWORD *)v64 & v45) >> v66);
      LODWORD(v64) = *((unsigned __int16 *)v64 + 4);
      v68 = v67 + ((v65 & v99) >> v66);
      v69 = v44 - ((v64 & v44) >> v66) + ((v64 & v57) >> v66);
      v70 = v51 - ((v65 & v51) >> v66) + ((v65 & v55) >> v66);
      LODWORD(v64) = v56 - ((v64 & v56) >> v66) + ((v64 & v58) >> v66);
      LODWORD(v65) = (v46 >> 28) & 3;
      v71 = (char *)&interpolate_cmyk64 + 16 * v65;
      v72 = *(_QWORD *)v71;
      LOBYTE(v65) = v65 + 1;
      v73 = v68 - ((v68 & *(_QWORD *)v71) >> v65);
      LODWORD(v71) = *((unsigned __int16 *)v71 + 4);
      v74 = v69 - ((v69 & v71) >> v65);
      v75 = (v64 & v71) >> v65;
      v45 = v73 + ((v70 & v72) >> v65);
      goto LABEL_99;
  }
LABEL_101:
  v92 = 0;
  v93 = 0;
  a3 += v8;
  v94 = v103 - a3;
  a2 += v9;
  v95 = v104 - a2;
  while (1)
  {
    *(_QWORD *)(v106 + 8 + 8 * v93) = HIBYTE(v45) & 0xFFFFFF0000FFFFFFLL | ((unint64_t)BYTE1(v44) << 32) | (v45 >> 8) & 0xFF0000 | ((unint64_t)BYTE1(v45) << 24) | HIDWORD(v45) & 0xFF00;
    *(_BYTE *)(v105 + 1 + v93) = v23 >> 22;
    if (a4 - 1 == (_DWORD)v93)
      return result;
    if ((v94 | v95 | (a3 - v102) | (a2 - v101)) < 0)
    {
      v105 += v93 + 1;
      v106 = v106 - v92 + 8;
      a4 += ~(_DWORD)v93;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32);
    v39 = *(unsigned __int16 **)(result + 32);
    if (v13 >= v38)
      v96 = (unsigned __int16 *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32));
    else
      v96 = (unsigned __int16 *)v13;
    if (v96 < v39)
      v96 = *(unsigned __int16 **)(result + 32);
    if (v5)
    {
      v41 = v5 + SHIDWORD(a3) * (uint64_t)v107 + 2 * (a2 >> 32);
      v97 = *(unsigned __int16 **)(result + 40);
      if (v12 >= v41)
        v98 = v5 + SHIDWORD(a3) * (uint64_t)v107 + 2 * (a2 >> 32);
      else
        v98 = v12;
      if (v98 >= (unint64_t)v97)
        v97 = (unsigned __int16 *)v98;
      v44 = bswap32(*v97) >> 16;
    }
    else
    {
      v44 = 0xFFFF;
    }
    v45 = ((unint64_t)(bswap32(v96[2]) >> 16) << 32) | ((unint64_t)(bswap32(v96[3]) >> 16) << 48) | bswap32(v96[1]) & 0xFFFF0000 | (unint64_t)(bswap32(*v96) >> 16);
    if (v7)
    {
      v46 = *(_DWORD *)(v7 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v105 += v93 + 1;
        v106 = v106 - v92 + 8;
        a4 += ~(_DWORD)v93;
        v23 = -1;
        goto LABEL_45;
      }
    }
    ++v93;
    v92 -= 8;
    a3 += v8;
    v94 -= v8;
    a2 += v9;
    v95 -= v9;
    v23 = -1;
  }
}

uint64_t cmyk32_sample_cmyk64(uint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t *v39;
  unint64_t *v40;
  unint64_t v41;
  unsigned __int16 *v42;
  unsigned __int16 *v43;
  int v44;
  unint64_t v45;
  unsigned int v46;
  int v47;
  unsigned int v48;
  int64_t v49;
  unint64_t *v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t *v53;
  unint64_t *v54;
  unint64_t v55;
  int v56;
  int v57;
  int v58;
  unsigned __int16 *v59;
  unint64_t v60;
  unint64_t v61;
  unsigned __int16 *v62;
  unsigned __int16 *v63;
  char *v64;
  uint64_t v65;
  char v66;
  unint64_t v67;
  unint64_t v68;
  unsigned int v69;
  unint64_t v70;
  unsigned int v71;
  unsigned int v72;
  char *v73;
  unint64_t v74;
  unint64_t v75;
  unsigned int v76;
  unsigned int v77;
  unint64_t *v78;
  unint64_t v79;
  int v80;
  unsigned __int16 *v81;
  char *v82;
  uint64_t v83;
  char v84;
  unint64_t v85;
  unint64_t v86;
  int v87;
  int64_t v88;
  unint64_t *v89;
  unint64_t v90;
  __int16 v91;
  __int16 *v92;
  unsigned int v93;
  char *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t *v99;
  unsigned __int16 *v100;
  unint64_t v101;
  unint64_t v102;
  int v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;

  v4 = *(_QWORD *)(result + 32);
  v5 = *(_QWORD *)(result + 40);
  v6 = *(_DWORD *)(result + 24);
  v7 = *(_DWORD *)(result + 28);
  v8 = *(_QWORD *)(result + 176);
  v105 = *(_QWORD *)(result + 80);
  v10 = *(_QWORD *)(result + 112);
  v9 = *(_QWORD *)(result + 120);
  v109 = *(_QWORD *)(result + 152) - 8;
  v107 = *(_QWORD *)(result + 88);
  v108 = *(_QWORD *)(result + 144) - 1;
  v11 = *(_DWORD *)(result + 260) - 1;
  v12 = *(unsigned int *)(result + 256);
  v103 = *(_DWORD *)(result + 188);
  v13 = v5 + (v11 * v7) + 2 * (v12 - 1);
  v14 = v4 + (v11 * v6) + 8 * v12 - 16;
  v106 = *(_QWORD *)(result + 72);
  v104 = *(_QWORD *)(result + 64);
  while (1)
  {
LABEL_2:
    if (a3 >= v106)
    {
      if (a3 <= v107)
      {
        v23 = ((unint64_t)a3 >> 22) & 0x3C0;
        v24 = 0x3FFFFFFF;
        v25 = a3;
        v26 = v104;
      }
      else
      {
        v19 = *(_QWORD *)(result + 216);
        v20 = *(_QWORD *)(result + 224) + v107;
        v21 = v20 - a3 + (v19 >> 1);
        if (v21 < 1)
          goto LABEL_39;
        if (v21 >= v19)
          LODWORD(v22) = 0x3FFFFFFF;
        else
          v22 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
        v26 = v104;
        v24 = v103 | v22;
        v25 = v20 - 0x1000000;
        v23 = 448;
      }
    }
    else
    {
      v15 = *(_QWORD *)(result + 216);
      v16 = v106 - *(_QWORD *)(result + 224);
      v17 = a3 - v16 + (v15 >> 1);
      if (v17 < 1)
        goto LABEL_39;
      if (v17 >= v15)
        LODWORD(v18) = 0x3FFFFFFF;
      else
        v18 = (unint64_t)(*(_QWORD *)(result + 232) * v17) >> 32;
      v26 = v104;
      v24 = v103 | v18;
      v25 = v16 + 0x1000000;
      v23 = 512;
    }
    if (a2 >= v26)
      break;
    v27 = *(_QWORD *)(result + 192);
    v28 = v26 - *(_QWORD *)(result + 200);
    v29 = a2 - v28 + (v27 >> 1);
    if (v29 >= 1)
    {
      if (v29 < v27)
        v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v29) >> 32) >> 15)) | v103;
      v30 = v28 + 0x1000000;
      v31 = 32;
      goto LABEL_26;
    }
LABEL_39:
    --a4;
    a2 += v10;
    a3 += v9;
    *(_BYTE *)++v108 = 0;
    v109 += 8;
    if (!a4)
      return result;
  }
  if (a2 <= v105)
  {
    v31 = ((unint64_t)a2 >> 26) & 0x3C;
    v30 = a2;
    goto LABEL_26;
  }
  v32 = *(_QWORD *)(result + 192);
  v33 = *(_QWORD *)(result + 200) + v105;
  v34 = v33 - a2 + (v32 >> 1);
  if (v34 < 1)
    goto LABEL_39;
  if (v34 < v32)
    v24 = ((v24 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v34) >> 32) >> 15)) | v103;
  v30 = v33 - 0x1000000;
  v31 = 28;
LABEL_26:
  if (v24 < 0x400000)
    goto LABEL_39;
  v35 = v25 >> 32;
  v36 = v30 >> 32;
  v37 = v4 + SHIDWORD(v25) * (uint64_t)v6;
  v38 = v37 + 8 * v36;
  v39 = *(unint64_t **)(result + 32);
  if (v14 >= v38)
    v40 = (unint64_t *)(v37 + 8 * v36);
  else
    v40 = (unint64_t *)v14;
  if (v40 < v39)
    v40 = *(unint64_t **)(result + 32);
  if (v5)
  {
    v41 = v5 + (int)v35 * (uint64_t)v7 + 2 * v36;
    v42 = *(unsigned __int16 **)(result + 40);
    if (v13 >= v41)
      v43 = (unsigned __int16 *)v41;
    else
      v43 = (unsigned __int16 *)v13;
    if (v43 >= v42)
      v42 = v43;
    v44 = *v42;
  }
  else
  {
    v41 = 0;
    v44 = 0xFFFF;
  }
  v45 = *v40;
  if (!v8)
    goto LABEL_101;
  v46 = *(_DWORD *)(v8 + (v31 | v23));
LABEL_45:
  v47 = v46 & 0xF;
  v48 = HIBYTE(v46) & 3;
  switch(v47)
  {
    case 1:
      v78 = (unint64_t *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      if (v14 < (unint64_t)v78)
        v78 = (unint64_t *)v14;
      if (v78 < v39)
        v78 = v39;
      v79 = *v78;
      v80 = 0xFFFF;
      if (v5)
      {
        v81 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v7);
        if (v13 < (unint64_t)v81)
          v81 = (unsigned __int16 *)v13;
        if ((unint64_t)v81 < *(_QWORD *)(result + 40))
          v81 = *(unsigned __int16 **)(result + 40);
        v80 = *v81;
      }
      v82 = (char *)&interpolate_cmyk64 + 16 * v48;
      v83 = *(_QWORD *)v82;
      v84 = v48 + 1;
      v85 = v45 - ((*(_QWORD *)v82 & v45) >> v84);
      LODWORD(v82) = *((unsigned __int16 *)v82 + 4);
      v76 = v44 - ((v82 & v44) >> v84);
      v86 = (v83 & v79) >> v84;
      v77 = (v82 & v80) >> v84;
      v45 = v85 + v86;
LABEL_88:
      LOWORD(v87) = v76 + v77;
      goto LABEL_100;
    case 2:
      v88 = (unint64_t)HIWORD(v46) << 56;
      v89 = (unint64_t *)(v38 + (v88 >> 53));
      if (v14 < (unint64_t)v89)
        v89 = (unint64_t *)v14;
      if (v89 < v39)
        v89 = v39;
      v90 = *v89;
      v91 = -1;
      if (v5)
      {
        v92 = (__int16 *)(v41 + (v88 >> 55));
        if (v13 < (unint64_t)v92)
          v92 = (__int16 *)v13;
        if ((unint64_t)v92 < *(_QWORD *)(result + 40))
          v92 = *(__int16 **)(result + 40);
        v91 = *v92;
      }
      v93 = (v46 >> 28) & 3;
      v94 = (char *)&interpolate_cmyk64 + 16 * v93;
      LOBYTE(v93) = v93 + 1;
      v45 = v45 - ((*(_QWORD *)v94 & v45) >> v93) + ((*(_QWORD *)v94 & v90) >> v93);
      v87 = v44
          - ((unsigned __int16)(*((_WORD *)v94 + 4) & v44) >> v93)
          + ((unsigned __int16)(*((_WORD *)v94 + 4) & v91) >> v93);
LABEL_100:
      BYTE1(v44) = BYTE1(v87);
      break;
    case 3:
      v49 = (unint64_t)HIWORD(v46) << 56;
      v50 = (unint64_t *)(v38 + (v49 >> 53));
      if (v14 < (unint64_t)v50)
        v50 = (unint64_t *)v14;
      if (v50 < v39)
        v50 = v39;
      v51 = *v50;
      v52 = v38 + SBYTE1(v46) * (uint64_t)v6;
      if (v14 >= v52)
        v53 = (unint64_t *)(v38 + SBYTE1(v46) * (uint64_t)v6);
      else
        v53 = (unint64_t *)v14;
      if (v53 < v39)
        v53 = v39;
      v102 = *v53;
      v54 = (unint64_t *)(v52 + (v49 >> 53));
      if (v14 < (unint64_t)v54)
        v54 = (unint64_t *)v14;
      if (v54 < v39)
        v54 = v39;
      v55 = *v54;
      v56 = 0xFFFF;
      v57 = 0xFFFF;
      v58 = 0xFFFF;
      if (v5)
      {
        v59 = (unsigned __int16 *)(v41 + (v49 >> 55));
        v60 = *(_QWORD *)(result + 40);
        if (v13 < (unint64_t)v59)
          v59 = (unsigned __int16 *)v13;
        if ((unint64_t)v59 < v60)
          v59 = *(unsigned __int16 **)(result + 40);
        v56 = *v59;
        v61 = v41 + SBYTE1(v46) * (uint64_t)v7;
        if (v13 >= v61)
          v62 = (unsigned __int16 *)(v41 + SBYTE1(v46) * (uint64_t)v7);
        else
          v62 = (unsigned __int16 *)v13;
        if ((unint64_t)v62 < v60)
          v62 = *(unsigned __int16 **)(result + 40);
        v57 = *v62;
        v63 = (unsigned __int16 *)(v61 + (v49 >> 55));
        if (v13 < (unint64_t)v63)
          v63 = (unsigned __int16 *)v13;
        if ((unint64_t)v63 < v60)
          v63 = *(unsigned __int16 **)(result + 40);
        v58 = *v63;
      }
      v64 = (char *)&interpolate_cmyk64 + 16 * v48;
      v65 = *(_QWORD *)v64;
      v66 = v48 + 1;
      v67 = v45 - ((*(_QWORD *)v64 & v45) >> v66);
      LODWORD(v64) = *((unsigned __int16 *)v64 + 4);
      v68 = v67 + ((v65 & v102) >> v66);
      v69 = v44 - ((v64 & v44) >> v66) + ((v64 & v57) >> v66);
      v70 = v51 - ((v65 & v51) >> v66) + ((v65 & v55) >> v66);
      v71 = v56 - ((v64 & v56) >> v66) + ((v64 & v58) >> v66);
      v72 = (v46 >> 28) & 3;
      v73 = (char *)&interpolate_cmyk64 + 16 * v72;
      v74 = *(_QWORD *)v73;
      LOBYTE(v72) = v72 + 1;
      v75 = v68 - ((v68 & *(_QWORD *)v73) >> v72);
      LODWORD(v73) = *((unsigned __int16 *)v73 + 4);
      v76 = v69 - ((v69 & v73) >> v72);
      v77 = (v71 & v73) >> v72;
      v45 = v75 + ((v70 & v74) >> v72);
      goto LABEL_88;
  }
LABEL_101:
  v95 = 0;
  v96 = 0;
  a3 += v9;
  v97 = v107 - a3;
  a2 += v10;
  v98 = v105 - a2;
  while (1)
  {
    *(_QWORD *)(v109 + 8 + 8 * v95) = (v45 >> 8) & 0xFF0000 | HIBYTE(v45) | (BYTE1(v45) << 24) | HIDWORD(v45) & 0xFF00 | ((unint64_t)BYTE1(v44) << 32);
    *(_BYTE *)(v108 + 1 + v95) = v24 >> 22;
    if (a4 - 1 == (_DWORD)v95)
      return result;
    if ((v97 | v98 | (a3 - v106) | (a2 - v104)) < 0)
    {
      v108 += v95 + 1;
      v109 = v109 - v96 + 8;
      a4 += ~(_DWORD)v95;
      if (a4)
        goto LABEL_2;
      return result;
    }
    v38 = v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32);
    v39 = *(unint64_t **)(result + 32);
    if (v14 >= v38)
      v99 = (unint64_t *)(v4 + SHIDWORD(a3) * (uint64_t)v6 + 8 * (a2 >> 32));
    else
      v99 = (unint64_t *)v14;
    if (v99 < v39)
      v99 = *(unint64_t **)(result + 32);
    if (v5)
    {
      v41 = v5 + SHIDWORD(a3) * (uint64_t)v7 + 2 * (a2 >> 32);
      v100 = *(unsigned __int16 **)(result + 40);
      if (v13 >= v41)
        v101 = v5 + SHIDWORD(a3) * (uint64_t)v7 + 2 * (a2 >> 32);
      else
        v101 = v13;
      if (v101 >= (unint64_t)v100)
        v100 = (unsigned __int16 *)v101;
      v44 = *v100;
    }
    else
    {
      v44 = 0xFFFF;
    }
    v45 = *v99;
    if (v8)
    {
      v46 = *(_DWORD *)(v8 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v46 & 0xF) != 0)
      {
        v108 += v95 + 1;
        v109 = v109 - v96 + 8;
        a4 += ~(_DWORD)v95;
        v24 = -1;
        goto LABEL_45;
      }
    }
    v96 -= 8;
    ++v95;
    a3 += v9;
    v97 -= v9;
    a2 += v10;
    v98 -= v10;
    v24 = -1;
  }
}

uint64_t cmyk32_sample_CMYKF(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  int8x16_t *v44;
  int8x16_t *v45;
  unint64_t v46;
  unsigned int *v47;
  unsigned int *v48;
  float v49;
  int v50;
  float32x4_t v51;
  unsigned int v52;
  int v53;
  int v54;
  int64_t v55;
  int8x16_t *v56;
  int8x16_t *v57;
  int8x16_t *v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  unint64_t v63;
  unint64_t v64;
  unsigned int *v65;
  unsigned int *v66;
  float32x4_t v67;
  int8x16_t *v68;
  float32x4_t v69;
  float v70;
  unsigned int *v71;
  _DWORD *v72;
  int64_t v73;
  int8x16_t *v74;
  unsigned int *v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  int8x16_t *v80;
  unint64_t v81;
  unint64_t v82;
  unsigned int *v83;
  unsigned int *v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  float32x4_t v102;
  float v103;

  v14 = *(_QWORD *)(result + 40);
  v15 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v90 = *(_QWORD *)(result + 88);
  v100 = *(_QWORD *)(result + 120);
  v101 = *(_QWORD *)(result + 112);
  v16 = (unint64_t *)(*(_QWORD *)(result + 152) - 8);
  v91 = *(_QWORD *)(result + 144) - 1;
  v17 = *(_DWORD *)(result + 260) - 1;
  v98 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v18 = *(_DWORD *)(result + 256);
  v93 = *(_DWORD *)(result + 28);
  v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  v86 = *(_DWORD *)(result + 188);
  v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  v88 = *(_QWORD *)(result + 72);
  v89 = *(_QWORD *)(result + 64);
  v96 = v14;
  v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      v23 = v90;
      if (a3 <= v90)
      {
        v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        v31 = 0x3FFFFFFF;
        v32 = a3;
        v22 = a4;
        v24 = v89;
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = *(_QWORD *)(result + 224) + v90;
        v28 = v27 - a3 + (v26 >> 1);
        v22 = a4;
        v24 = v89;
        if (v28 < 1)
          goto LABEL_37;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v31 = v86 | v29;
        v32 = v27 - 0x1000000;
        v30 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v88 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      v24 = v89;
      v23 = v90;
      if (v21 < 1)
        goto LABEL_37;
      if (v21 >= v19)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v31 = v86 | v25;
      v32 = v20 + 0x1000000;
      v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        v37 = ((unint64_t)a2 >> 26) & 0x3C;
        v36 = a2;
      }
      else
      {
        v38 = *(_QWORD *)(result + 192);
        v39 = *(_QWORD *)(result + 200) + v87;
        v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1)
          goto LABEL_37;
        if (v40 < v38)
          v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v86;
        v36 = v39 - 0x1000000;
        v37 = 28;
      }
    }
    else
    {
      v33 = *(_QWORD *)(result + 192);
      v34 = v24 - *(_QWORD *)(result + 200);
      v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1)
        goto LABEL_37;
      if (v35 < v33)
        v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v86;
      v36 = v34 + 0x1000000;
      v37 = 32;
    }
    if (v31 >= 0x400000)
      break;
LABEL_37:
    v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    ++v16;
    *(_BYTE *)++v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50)
      return result;
  }
  v41 = v32 >> 32;
  v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  v44 = *(int8x16_t **)(result + 32);
  v45 = (int8x16_t *)v99;
  if (v99 >= v43)
    v45 = (int8x16_t *)v43;
  if (v45 < v44)
    v45 = *(int8x16_t **)(result + 32);
  if (v14)
  {
    v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    v47 = *(unsigned int **)(result + 40);
    v48 = (unsigned int *)v94;
    v92 = v46;
    if (v94 >= v46)
      v48 = (unsigned int *)v46;
    if (v48 >= v47)
      v47 = v48;
    v49 = COERCE_FLOAT(bswap32(*v47));
  }
  else
  {
    v92 = 0;
    v49 = 1.0;
  }
  v51 = (float32x4_t)vrev32q_s8(*v45);
  if (v15)
  {
    v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    v53 = v52 & 0xF;
    v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      v68 = (int8x16_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68)
        v68 = (int8x16_t *)v99;
      if (v68 >= v44)
        v44 = v68;
      v69 = (float32x4_t)vrev32q_s8(*v44);
      v70 = 1.0;
      if (v14)
      {
        v71 = (unsigned int *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71)
          v71 = (unsigned int *)v94;
        if ((unint64_t)v71 < *(_QWORD *)(result + 40))
          v71 = *(unsigned int **)(result + 40);
        v70 = COERCE_FLOAT(bswap32(*v71));
      }
      v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          v55 = (unint64_t)HIWORD(v52) << 56;
          v56 = (int8x16_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56)
            v57 = v56;
          else
            v57 = (int8x16_t *)v99;
          if (v57 < v44)
            v57 = v44;
          v58 = (int8x16_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58)
            v58 = (int8x16_t *)v99;
          if (v58 >= v44)
            v44 = v58;
          v59 = (float32x4_t)vrev32q_s8(*v57);
          v60 = (float32x4_t)vrev32q_s8(*v44);
          v61 = 1.0;
          v62 = 1.0;
          if (v14)
          {
            v63 = v92 + (v55 >> 54);
            v64 = *(_QWORD *)(result + 40);
            if (v94 >= v63)
              v65 = (unsigned int *)(v92 + (v55 >> 54));
            else
              v65 = (unsigned int *)v94;
            if ((unint64_t)v65 < v64)
              v65 = *(unsigned int **)(result + 40);
            v61 = COERCE_FLOAT(bswap32(*v65));
            v66 = (unsigned int *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66)
              v66 = (unsigned int *)v94;
            if ((unint64_t)v66 < v64)
              v66 = *(unsigned int **)(result + 40);
            v62 = COERCE_FLOAT(bswap32(*v66));
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      v73 = (unint64_t)HIWORD(v52) << 56;
      v74 = (int8x16_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74)
        v74 = (int8x16_t *)v99;
      if (v74 >= v44)
        v44 = v74;
      v69 = (float32x4_t)vrev32q_s8(*v44);
      v70 = 1.0;
      if (v14)
      {
        v75 = (unsigned int *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75)
          v75 = (unsigned int *)v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(unsigned int **)(result + 40);
        v70 = COERCE_FLOAT(bswap32(*v75));
      }
      v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  v76 = 0;
  ++v16;
  v85 = v22;
  v77 = v22 - 1;
  a3 += v100;
  v78 = v23 - a3;
  a2 += v101;
  v79 = v87 - a2;
  while (1)
  {
    v102 = v51;
    v103 = v49;
    CMYKF(v16, v102.f32);
    *(_BYTE *)(v91 + 1 + v76) = v31 >> 22;
    v14 = v96;
    result = v97;
    if (v77 == (_DWORD)v76)
      return result;
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      v50 = ~(_DWORD)v76 + v85;
      goto LABEL_38;
    }
    v80 = (int8x16_t *)v99;
    v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    v44 = *(int8x16_t **)(v97 + 32);
    if (v99 >= v43)
      v80 = (int8x16_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    if (v80 < v44)
      v80 = *(int8x16_t **)(v97 + 32);
    if (v96)
    {
      v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      v83 = *(unsigned int **)(v97 + 40);
      v84 = (unsigned int *)v94;
      v92 = v82;
      if (v94 >= v82)
        v84 = (unsigned int *)v82;
      if (v84 >= v83)
        v83 = v84;
      v49 = COERCE_FLOAT(bswap32(*v83));
    }
    else
    {
      v49 = 1.0;
    }
    v51 = (float32x4_t)vrev32q_s8(*v80);
    if (v15)
    {
      v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        v23 = v90;
        v91 += v76 + 1;
        v22 = ~(_DWORD)v76 + v85;
        v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    ++v16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    v31 = -1;
  }
}

uint64_t cmyk32_sample_CMYKf(uint64_t result, uint64_t a2, uint64_t a3, int a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11, double a12)
{
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  unint64_t v43;
  float32x4_t *v44;
  float32x4_t *v45;
  unint64_t v46;
  float *v47;
  float *v48;
  float v49;
  int v50;
  float32x4_t v51;
  unsigned int v52;
  int v53;
  int v54;
  int64_t v55;
  float32x4_t *v56;
  float32x4_t *v57;
  float32x4_t *v58;
  float32x4_t v59;
  float32x4_t v60;
  float v61;
  float v62;
  unint64_t v63;
  unint64_t v64;
  float *v65;
  float *v66;
  float32x4_t v67;
  float32x4_t *v68;
  float32x4_t v69;
  float v70;
  float *v71;
  _DWORD *v72;
  int64_t v73;
  float32x4_t *v74;
  float *v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  float32x4_t *v80;
  unint64_t v81;
  unint64_t v82;
  float *v83;
  float *v84;
  int v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  unint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  int v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  float32x4_t v102;
  float v103;

  v14 = *(_QWORD *)(result + 40);
  v15 = *(_QWORD *)(result + 176);
  v87 = *(_QWORD *)(result + 80);
  v90 = *(_QWORD *)(result + 88);
  v100 = *(_QWORD *)(result + 120);
  v101 = *(_QWORD *)(result + 112);
  v16 = (unint64_t *)(*(_QWORD *)(result + 152) - 8);
  v91 = *(_QWORD *)(result + 144) - 1;
  v17 = *(_DWORD *)(result + 260) - 1;
  v98 = *(_DWORD *)(result + 24);
  v95 = *(_QWORD *)(result + 32);
  v18 = *(_DWORD *)(result + 256);
  v93 = *(_DWORD *)(result + 28);
  v94 = v14 + (v17 * v93) + 4 * (v18 - 1);
  v86 = *(_DWORD *)(result + 188);
  v99 = v95 + (v17 * v98) + 4 * (4 * v18) - 16;
  v88 = *(_QWORD *)(result + 72);
  v89 = *(_QWORD *)(result + 64);
  v96 = v14;
  v97 = result;
  while (1)
  {
    if (a3 >= v88)
    {
      v23 = v90;
      if (a3 <= v90)
      {
        v30 = ((unint64_t)a3 >> 22) & 0x3C0;
        v31 = 0x3FFFFFFF;
        v32 = a3;
        v22 = a4;
        v24 = v89;
      }
      else
      {
        v26 = *(_QWORD *)(result + 216);
        v27 = *(_QWORD *)(result + 224) + v90;
        v28 = v27 - a3 + (v26 >> 1);
        v22 = a4;
        v24 = v89;
        if (v28 < 1)
          goto LABEL_37;
        if (v28 >= v26)
          LODWORD(v29) = 0x3FFFFFFF;
        else
          v29 = (unint64_t)(*(_QWORD *)(result + 232) * v28) >> 32;
        v31 = v86 | v29;
        v32 = v27 - 0x1000000;
        v30 = 448;
      }
    }
    else
    {
      v19 = *(_QWORD *)(result + 216);
      v20 = v88 - *(_QWORD *)(result + 224);
      v21 = a3 - v20 + (v19 >> 1);
      v22 = a4;
      v24 = v89;
      v23 = v90;
      if (v21 < 1)
        goto LABEL_37;
      if (v21 >= v19)
        LODWORD(v25) = 0x3FFFFFFF;
      else
        v25 = (unint64_t)(*(_QWORD *)(result + 232) * v21) >> 32;
      v31 = v86 | v25;
      v32 = v20 + 0x1000000;
      v30 = 512;
    }
    if (a2 >= v24)
    {
      if (a2 <= v87)
      {
        v37 = ((unint64_t)a2 >> 26) & 0x3C;
        v36 = a2;
      }
      else
      {
        v38 = *(_QWORD *)(result + 192);
        v39 = *(_QWORD *)(result + 200) + v87;
        v40 = v39 - a2 + (v38 >> 1);
        if (v40 < 1)
          goto LABEL_37;
        if (v40 < v38)
          v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v40) >> 32) >> 15)) | v86;
        v36 = v39 - 0x1000000;
        v37 = 28;
      }
    }
    else
    {
      v33 = *(_QWORD *)(result + 192);
      v34 = v24 - *(_QWORD *)(result + 200);
      v35 = a2 - v34 + (v33 >> 1);
      if (v35 < 1)
        goto LABEL_37;
      if (v35 < v33)
        v31 = ((v31 >> 15) * (((unint64_t)(*(_QWORD *)(result + 208) * v35) >> 32) >> 15)) | v86;
      v36 = v34 + 0x1000000;
      v37 = 32;
    }
    if (v31 >= 0x400000)
      break;
LABEL_37:
    v50 = v22 - 1;
    a2 += v101;
    a3 += v100;
    ++v16;
    *(_BYTE *)++v91 = 0;
LABEL_38:
    a4 = v50;
    if (!v50)
      return result;
  }
  v41 = v32 >> 32;
  v42 = (v36 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
  v43 = v95 + SHIDWORD(v32) * (uint64_t)v98 + 4 * v42;
  v44 = *(float32x4_t **)(result + 32);
  v45 = (float32x4_t *)v99;
  if (v99 >= v43)
    v45 = (float32x4_t *)v43;
  if (v45 < v44)
    v45 = *(float32x4_t **)(result + 32);
  if (v14)
  {
    v46 = v14 + (int)v41 * (uint64_t)v93 + v42;
    v47 = *(float **)(result + 40);
    v48 = (float *)v94;
    v92 = v46;
    if (v94 >= v46)
      v48 = (float *)v46;
    if (v48 >= v47)
      v47 = v48;
    v49 = *v47;
  }
  else
  {
    v92 = 0;
    v49 = 1.0;
  }
  v51 = *v45;
  if (v15)
  {
    v52 = *(_DWORD *)(v15 + (v37 | v30));
LABEL_44:
    v53 = v52 & 0xF;
    v54 = HIBYTE(v52) & 3;
    if (v53 == 1)
    {
      v68 = (float32x4_t *)(v43 + SBYTE1(v52) * (uint64_t)v98);
      if (v99 < (unint64_t)v68)
        v68 = (float32x4_t *)v99;
      if (v68 >= v44)
        v44 = v68;
      v69 = *v44;
      v70 = 1.0;
      if (v14)
      {
        v71 = (float *)(v92 + SBYTE1(v52) * (uint64_t)v93);
        if (v94 < (unint64_t)v71)
          v71 = (float *)v94;
        if ((unint64_t)v71 < *(_QWORD *)(result + 40))
          v71 = *(float **)(result + 40);
        v70 = *v71;
      }
      v72 = &interpolate_cmykaf[5 * v54];
    }
    else
    {
      if (v53 != 2)
      {
        if (v53 == 3)
        {
          v55 = (unint64_t)HIWORD(v52) << 56;
          v56 = (float32x4_t *)(v43 + (v55 >> 52));
          if (v99 >= (unint64_t)v56)
            v57 = v56;
          else
            v57 = (float32x4_t *)v99;
          if (v57 < v44)
            v57 = v44;
          v58 = (float32x4_t *)((char *)v56 + SBYTE1(v52) * (uint64_t)v98);
          if (v99 < (unint64_t)v58)
            v58 = (float32x4_t *)v99;
          if (v58 >= v44)
            v44 = v58;
          v59 = *v57;
          v60 = *v44;
          v61 = 1.0;
          v62 = 1.0;
          if (v14)
          {
            v63 = v92 + (v55 >> 54);
            v64 = *(_QWORD *)(result + 40);
            if (v94 >= v63)
              v65 = (float *)(v92 + (v55 >> 54));
            else
              v65 = (float *)v94;
            if ((unint64_t)v65 < v64)
              v65 = *(float **)(result + 40);
            v61 = *v65;
            v66 = (float *)(v63 + SBYTE1(v52) * (uint64_t)v93);
            if (v94 < (unint64_t)v66)
              v66 = (float *)v94;
            if ((unint64_t)v66 < v64)
              v66 = *(float **)(result + 40);
            v62 = *v66;
          }
          LODWORD(a11) = interpolate_cmykaf[5 * v54 + 4];
          LODWORD(a12) = interpolate_cmykaf[5 * ((v52 >> 28) & 3) + 4];
          v67 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a11, 0), v59, *(float *)&a11);
          v51 = vmlaq_n_f32(vmlsq_lane_f32(v67, v67, *(float32x2_t *)&a12, 0), vmlaq_n_f32(vmlsq_lane_f32(v59, v59, *(float32x2_t *)&a11, 0), v60, *(float *)&a11), *(float *)&a12);
          v49 = (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                      - (float)((float)((float)(v49 - (float)(v49 * *(float *)&a11)) + (float)(v61 * *(float *)&a11))
                              * *(float *)&a12))
              + (float)((float)((float)(v61 - (float)(v61 * *(float *)&a11)) + (float)(v62 * *(float *)&a11))
                      * *(float *)&a12);
        }
        goto LABEL_91;
      }
      v73 = (unint64_t)HIWORD(v52) << 56;
      v74 = (float32x4_t *)(v43 + (v73 >> 52));
      if (v99 < (unint64_t)v74)
        v74 = (float32x4_t *)v99;
      if (v74 >= v44)
        v44 = v74;
      v69 = *v44;
      v70 = 1.0;
      if (v14)
      {
        v75 = (float *)(v92 + (v73 >> 54));
        if (v94 < (unint64_t)v75)
          v75 = (float *)v94;
        if ((unint64_t)v75 < *(_QWORD *)(result + 40))
          v75 = *(float **)(result + 40);
        v70 = *v75;
      }
      v72 = &interpolate_cmykaf[5 * ((v52 >> 28) & 3)];
    }
    LODWORD(a9) = v72[4];
    v51 = vmlaq_n_f32(vmlsq_lane_f32(v51, v51, *(float32x2_t *)&a9, 0), v69, *(float *)&a9);
    v49 = (float)(v49 - (float)(v49 * *(float *)&a9)) + (float)(v70 * *(float *)&a9);
  }
LABEL_91:
  v76 = 0;
  ++v16;
  v85 = v22;
  v77 = v22 - 1;
  a3 += v100;
  v78 = v23 - a3;
  a2 += v101;
  v79 = v87 - a2;
  while (1)
  {
    v102 = v51;
    v103 = v49;
    CMYKF(v16, v102.f32);
    *(_BYTE *)(v91 + 1 + v76) = v31 >> 22;
    v14 = v96;
    result = v97;
    if (v77 == (_DWORD)v76)
      return result;
    if ((v78 | v79 | (a3 - v88) | (a2 - v89)) < 0)
    {
      v91 += v76 + 1;
      v50 = ~(_DWORD)v76 + v85;
      goto LABEL_38;
    }
    v80 = (float32x4_t *)v99;
    v81 = (a2 >> 30) & 0xFFFFFFFFFFFFFFFCLL;
    v43 = v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81;
    v44 = *(float32x4_t **)(v97 + 32);
    if (v99 >= v43)
      v80 = (float32x4_t *)(v95 + SHIDWORD(a3) * (uint64_t)v98 + 4 * v81);
    if (v80 < v44)
      v80 = *(float32x4_t **)(v97 + 32);
    if (v96)
    {
      v82 = v96 + SHIDWORD(a3) * (uint64_t)v93 + v81;
      v83 = *(float **)(v97 + 40);
      v84 = (float *)v94;
      v92 = v82;
      if (v94 >= v82)
        v84 = (float *)v82;
      if (v84 >= v83)
        v83 = v84;
      v49 = *v83;
    }
    else
    {
      v49 = 1.0;
    }
    v51 = *v80;
    if (v15)
    {
      v52 = *(_DWORD *)(v15 + (((unint64_t)a2 >> 26) & 0x3C | ((unint64_t)a3 >> 22) & 0x3C0));
      if ((v52 & 0xF) != 0)
      {
        v23 = v90;
        v91 += v76 + 1;
        v22 = ~(_DWORD)v76 + v85;
        v31 = -1;
        goto LABEL_44;
      }
    }
    ++v76;
    ++v16;
    a3 += v100;
    v78 -= v100;
    a2 += v101;
    v79 -= v101;
    v31 = -1;
  }
}

unint64_t *CMYKF(unint64_t *result, float *a2)
{
  float v2;
  float v3;
  float v4;
  uint64_t v5;
  float v6;
  float v7;
  int v8;
  int v9;
  int v10;
  int v11;
  unint64_t v12;

  v2 = a2[4];
  if (v2 <= 0.0)
  {
    v12 = 0;
  }
  else
  {
    v3 = *a2;
    v4 = a2[1];
    LODWORD(v5) = (int)(float)((float)(v2 * 255.0) + 0.5);
    v6 = a2[2];
    v7 = a2[3];
    if (v2 <= 1.0)
      v5 = v5;
    else
      v5 = 255;
    if (v2 > 1.0)
      v2 = 1.0;
    v8 = (int)(float)((float)(v3 * 255.0) + 0.5);
    if (v3 < 0.0)
      v8 = 0;
    if (v3 > v2)
      v8 = v5;
    v9 = (int)(float)((float)(v4 * 255.0) + 0.5);
    if (v4 < 0.0)
      v9 = 0;
    if (v4 > v2)
      v9 = v5;
    v10 = (int)(float)((float)(v6 * 255.0) + 0.5);
    if (v6 < 0.0)
      v10 = 0;
    if (v6 > v2)
      v10 = v5;
    v11 = (int)(float)((float)(v7 * 255.0) + 0.5);
    if (v7 < 0.0)
      v11 = 0;
    if (v7 > v2)
      v11 = v5;
    v12 = (v9 << 16) | (v8 << 24) | (v10 << 8) | v11 | (unint64_t)(v5 << 32);
  }
  *result = v12;
  return result;
}

unint64_t *ARGB32(unint64_t *result, int a2)
{
  unsigned int v2;
  unint64_t v3;
  unsigned int v4;

  HIDWORD(v3) = a2;
  LODWORD(v3) = a2;
  v2 = v3 >> 24;
  v4 = HIBYTE(v2);
  if (HIBYTE(v2) <= BYTE2(v2))
    v4 = BYTE2(v2);
  if (v4 <= BYTE1(v2))
    v4 = BYTE1(v2);
  *result = (int)((v2 - v4) | ((v4 - BYTE2(v2)) << 16) | ((v4 - HIBYTE(v2)) << 24) | ((v4 - BYTE1(v2)) << 8)) | ((unint64_t)v2 << 32);
  return result;
}

unint64_t *RGB555(unint64_t *result, unsigned int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;

  v2 = (a2 << 14) & 0xF80000 | ((a2 >> 10) << 27) | ((a2 & 0x1F) << 11);
  v3 = (v2 >> 5) & 0x3F3F3F3F | HIBYTE(a2) | v2;
  v4 = HIBYTE(v3);
  if (HIBYTE(v3) <= BYTE2(v3))
    v4 = BYTE2(v3);
  if (v4 <= BYTE1(v3))
    v4 = BYTE1(v3);
  *result = (int)((HIBYTE(a2) - v4) | ((v4 - BYTE2(v3)) << 16) | ((v4 - HIBYTE(v3)) << 24) | ((v4 - BYTE1(v3)) << 8)) | ((unint64_t)HIBYTE(a2) << 32);
  return result;
}

_DWORD *cmyk32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11;

  v11 = PIXELCONSTANT(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6, a7, a8, a9);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004CD0;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    a2[12] = v11;
    *((_QWORD *)a2 + 4) = a2 + 12;
    if (BYTE4(v11) == 255)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = 16843009 * BYTE4(v11);
      *((_QWORD *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t cmyk32_mark(uint64_t a1, __n128 a2)
{
  uint64_t v2;
  unint64_t v3;
  double v4;
  int8x16_t v5;
  double v6;
  double v7;
  double v8;
  int8x16_t v9;
  int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  int v13;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint16x4_t *v20;
  int v21;
  int v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  int v28;
  int v29;
  unsigned int v30;
  size_t v31;
  _BYTE *v32;
  _BYTE *v33;
  unsigned int v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  int v38;
  int v39;
  unint64_t v40;
  uint64_t v41;
  int v42;
  unsigned __int8 v43;
  uint32x4_t *v44;
  uint64_t v45;
  char *v46;
  unint64_t v47;
  unint64_t v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  void *v54;
  int *v55;
  unint64_t v56;
  int v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  char *v62;
  unsigned __int8 *v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  unint64_t v67;
  int v68;
  unsigned int *v69;
  unsigned __int8 *v70;
  uint64_t v71;
  int v72;
  int v73;
  char *v74;
  uint64_t v75;
  uint64_t v76;
  int v77;
  unsigned int v78;
  int v79;
  uint64_t v80;
  int v81;
  int *v82;
  int v83;
  int v84;
  int *v85;
  uint64_t v86;
  int v87;
  _BYTE *v88;
  unsigned int v89;
  __int32 *v90;
  unsigned int v91;
  int v92;
  unsigned int v93;
  unsigned int *v94;
  unsigned int v95;
  unint64_t v96;
  int v97;
  int v98;
  unint64_t v99;
  unint64_t v100;
  int v101;
  unint64_t v102;
  unint64_t v103;
  int v104;
  int v105;
  unsigned int *v106;
  unsigned int v107;
  int v108;
  int v109;
  unint64_t v110;
  int v111;
  unint64_t v112;
  int v113;
  int v114;
  unsigned int *v115;
  unsigned int v116;
  int v117;
  int v118;
  unsigned int *v119;
  unsigned int v120;
  int v121;
  int v122;
  int *v123;
  int v124;
  int v125;
  int v126;
  int v127;
  unsigned int v128;
  unsigned int v129;
  int v130;
  unint64_t v131;
  int v132;
  unint64_t v133;
  int v134;
  unint64_t v135;
  int v136;
  unint64_t v137;
  int v138;
  unint64_t v139;
  int v140;
  unint64_t v141;
  int v142;
  unint64_t v143;
  int v144;
  unint64_t v145;
  int v146;
  unint64_t v147;
  int v148;
  unint64_t v149;
  int v150;
  unint64_t v151;
  int v152;
  unint64_t v153;
  int v154;
  unint64_t v155;
  int v156;
  unint64_t v157;
  int v158;
  unint64_t v159;
  int v160;
  unint64_t v161;
  int v162;
  unint64_t v163;
  int v164;
  unint64_t v165;
  int v166;
  unint64_t v167;
  int32x4_t v168;
  int32x4_t v169;
  int32x4_t v170;
  int v171;
  unsigned int v172;
  int32x4_t v173;
  int32x4_t v174;
  int32x4_t v175;
  unsigned int v176;
  int v177;
  unsigned int v178;
  int v179;
  unsigned int v180;
  unint64_t v181;
  int v182;
  int v183;
  int *v184;
  int v185;
  uint64_t v186;
  int v187;
  unsigned int v188;
  uint64_t v189;
  unsigned int *v190;
  unsigned int v191;
  uint64_t v192;
  char *v193;
  uint64_t v194;
  unsigned __int8 *v195;
  uint64_t v196;
  uint64_t v197;
  int v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  int v204;
  int v205;
  uint64_t v206;
  unint64_t v207;
  int *v208;
  uint64_t v209;
  int *v210;
  BOOL v211;
  uint64_t v212;
  int *v213;
  unint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  int v219;
  int v220;
  unint64_t v221;
  unint64_t v222;
  uint64_t v223;
  unint64_t v224;
  int *v225;
  uint64_t v226;
  int *v227;
  BOOL v228;
  uint64_t v229;
  int *v230;
  unint64_t v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  int v235;
  unint64_t v236;
  int v237;
  unint64_t v238;
  int *v239;
  uint64_t v240;
  int *v241;
  BOOL v242;
  uint64_t v243;
  int *v244;
  unint64_t v245;
  uint64_t v246;
  uint64_t v247;
  int v248;
  int v249;
  int *v250;
  uint64_t v251;
  int *v252;
  BOOL v253;
  uint64_t v254;
  int *v255;
  unint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  char v261;
  int v262;
  int *v263;
  uint64_t v264;
  int *v265;
  BOOL v266;
  uint64_t v267;
  int *v268;
  unint64_t v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  uint64_t v273;
  uint64_t v274;
  int v275;
  int v276;
  unint64_t v277;
  unint64_t v278;
  uint64_t v279;
  unint64_t v280;
  int *v281;
  uint64_t v282;
  int *v283;
  BOOL v284;
  uint64_t v285;
  int *v286;
  unint64_t v287;
  uint64_t v288;
  uint64_t v289;
  uint64_t v290;
  uint64_t v291;
  int v292;
  unint64_t v293;
  unint64_t v294;
  unint64_t v295;
  int *v296;
  uint64_t v297;
  int *v298;
  BOOL v299;
  uint64_t v300;
  int *v301;
  unint64_t v302;
  uint64_t v303;
  uint64_t v304;
  int v305;
  int v306;
  int v307;
  unint64_t v308;
  int *v309;
  uint64_t v310;
  int *v311;
  BOOL v312;
  uint64_t v313;
  int *v314;
  unint64_t v315;
  uint64_t v316;
  uint64_t v317;
  int v318;
  uint64_t v319;
  int v320;
  int v321;
  int *v322;
  unsigned int v323;
  unsigned int v324;
  unsigned int *v325;
  char *v326;
  char *v327;
  unsigned int *v328;
  int *v329;
  uint64_t v330;
  unint64_t v331;
  uint64_t v332;
  int *v333;
  BOOL v334;
  uint64_t v335;
  int *v336;
  unint64_t v337;
  uint64_t v338;
  uint64_t v339;
  uint64_t v340;
  int v341;
  int v342;
  unint64_t v343;
  int v344;
  int *v345;
  uint64_t v346;
  int *v347;
  BOOL v348;
  uint64_t v349;
  int *v350;
  unint64_t v351;
  uint64_t v352;
  int v353;
  int v354;
  int v355;
  unsigned int v356;
  unsigned int v357;
  unsigned int v358;
  int *v359;
  uint64_t v360;
  int *v361;
  BOOL v362;
  uint64_t v363;
  int *v364;
  unint64_t v365;
  uint64_t v366;
  uint64_t v367;
  int v368;
  unint64_t v369;
  int v370;
  unint64_t v371;
  unsigned int v372;
  int *v373;
  uint64_t v374;
  int *v375;
  BOOL v376;
  uint64_t v377;
  int *v378;
  unint64_t v379;
  uint64_t v380;
  uint64_t v381;
  int v382;
  unint64_t v383;
  unsigned int v384;
  unint64_t v385;
  unsigned int v386;
  int *v387;
  uint64_t v388;
  int *v389;
  BOOL v390;
  uint64_t v391;
  int *v392;
  unint64_t v393;
  uint64_t v394;
  uint64_t v395;
  int v396;
  unint64_t v397;
  int v398;
  unint64_t v399;
  unsigned int v400;
  int *v401;
  uint64_t v402;
  int *v403;
  BOOL v404;
  uint64_t v405;
  int *v406;
  unint64_t v407;
  uint64_t v408;
  uint64_t v409;
  int v410;
  unint64_t v411;
  unsigned int v412;
  unint64_t v413;
  unsigned int v414;
  int *v415;
  uint64_t v416;
  int *v417;
  BOOL v418;
  uint64_t v419;
  int *v420;
  unint64_t v421;
  uint64_t v422;
  uint64_t v423;
  int v424;
  unint64_t v425;
  unsigned int v426;
  unint64_t v427;
  unsigned int v428;
  int *v429;
  uint64_t v430;
  int *v431;
  BOOL v432;
  uint64_t v433;
  int *v434;
  unint64_t v435;
  uint64_t v436;
  uint64_t v437;
  int v438;
  unint64_t v439;
  int v440;
  unint64_t v441;
  unsigned int v442;
  int *v443;
  uint64_t v444;
  int *v445;
  BOOL v446;
  uint64_t v447;
  int *v448;
  unint64_t v449;
  uint64_t v450;
  uint64_t v451;
  int v452;
  unint64_t v453;
  int v454;
  unint64_t v455;
  unsigned int v456;
  int *v457;
  uint64_t v458;
  int *v459;
  BOOL v460;
  uint64_t v461;
  int *v462;
  unint64_t v463;
  uint64_t v464;
  uint64_t v465;
  int v466;
  unint64_t v467;
  int v468;
  unint64_t v469;
  unsigned int v470;
  int *v471;
  uint64_t v472;
  int *v473;
  BOOL v474;
  uint64_t v475;
  int *v476;
  unint64_t v477;
  uint64_t v478;
  uint64_t v479;
  int v480;
  unint64_t v481;
  signed int v482;
  unint64_t v483;
  unsigned int v484;
  int *v485;
  uint64_t v486;
  int *v487;
  BOOL v488;
  uint64_t v489;
  int *v490;
  unint64_t v491;
  uint64_t v492;
  uint64_t v493;
  int v494;
  unint64_t v495;
  unsigned int v496;
  unint64_t v497;
  unsigned int v498;
  int *v499;
  uint64_t v500;
  int *v501;
  BOOL v502;
  uint64_t v503;
  int *v504;
  unint64_t v505;
  uint64_t v506;
  uint64_t v507;
  int v508;
  unint64_t v509;
  signed int v510;
  unint64_t v511;
  unsigned int v512;
  int *v513;
  uint64_t v514;
  int *v515;
  BOOL v516;
  uint64_t v517;
  int *v518;
  unint64_t v519;
  uint64_t v520;
  uint64_t v521;
  int v522;
  unint64_t v523;
  signed int v524;
  unint64_t v525;
  unsigned int v526;
  int *v527;
  uint64_t v528;
  int *v529;
  BOOL v530;
  uint64_t v531;
  int *v532;
  unint64_t v533;
  uint64_t v534;
  uint64_t v535;
  int v536;
  unint64_t v537;
  signed int v538;
  unint64_t v539;
  unsigned int v540;
  int *v541;
  uint64_t v542;
  int *v543;
  BOOL v544;
  uint64_t v545;
  int *v546;
  unint64_t v547;
  uint64_t v548;
  uint64_t v549;
  int v550;
  unint64_t v551;
  signed int v552;
  unsigned int v553;
  unint64_t v554;
  unsigned int v555;
  int *v556;
  uint64_t v557;
  int *v558;
  BOOL v559;
  uint64_t v560;
  int *v561;
  unint64_t v562;
  uint64_t v563;
  uint64_t v564;
  int v565;
  unint64_t v566;
  signed int v567;
  unint64_t v568;
  unsigned int v569;
  int *v570;
  uint64_t v571;
  int *v572;
  BOOL v573;
  uint64_t v574;
  int *v575;
  unint64_t v576;
  uint64_t v577;
  uint64_t v578;
  int v579;
  unint64_t v580;
  signed int v581;
  unint64_t v582;
  unsigned int v583;
  int *v584;
  uint64_t v585;
  int *v586;
  BOOL v587;
  uint64_t v588;
  int *v589;
  unint64_t v590;
  uint64_t v591;
  uint64_t v592;
  int v593;
  unint64_t v594;
  signed int v595;
  unint64_t v596;
  unsigned int v597;
  int *v598;
  uint64_t v599;
  int *v600;
  BOOL v601;
  uint64_t v602;
  int *v603;
  unint64_t v604;
  uint64_t v605;
  uint64_t v606;
  int v607;
  unint64_t v608;
  signed int v609;
  unsigned __int32 v610;
  unint64_t v611;
  unsigned int v612;
  int *v613;
  uint64_t v614;
  int *v615;
  BOOL v616;
  uint64_t v617;
  int *v618;
  unint64_t v619;
  uint64_t v620;
  uint64_t v621;
  int v622;
  unint64_t v623;
  signed int v624;
  unint64_t v625;
  unsigned int v626;
  int *v627;
  uint64_t v628;
  int *v629;
  BOOL v630;
  uint64_t v631;
  int *v632;
  unint64_t v633;
  uint64_t v634;
  int v635;
  int v636;
  unint64_t v637;
  int *v638;
  uint64_t v639;
  unsigned __int8 *v640;
  uint64_t v641;
  uint64_t v642;
  int v643;
  int v644;
  unsigned int v645;
  int *v646;
  uint64_t v647;
  int *v648;
  BOOL v649;
  uint64_t v650;
  int *v651;
  unint64_t v652;
  uint64_t v653;
  int v654;
  unsigned int v655;
  int *v656;
  uint64_t v657;
  int *v658;
  BOOL v659;
  uint64_t v660;
  int *v661;
  unint64_t v662;
  uint64_t v663;
  int v664;
  unsigned int v665;
  int *v666;
  uint64_t v667;
  int *v668;
  BOOL v669;
  uint64_t v670;
  int *v671;
  unint64_t v672;
  uint64_t v673;
  int v674;
  unsigned int v675;
  int *v676;
  uint64_t v677;
  int *v678;
  BOOL v679;
  uint64_t v680;
  int *v681;
  unint64_t v682;
  uint64_t v683;
  uint64_t v684;
  int v685;
  int v686;
  unint64_t v687;
  int v688;
  int *v689;
  uint64_t v690;
  int *v691;
  BOOL v692;
  uint64_t v693;
  int *v694;
  unint64_t v695;
  uint64_t v696;
  int v697;
  int v698;
  unsigned int v699;
  int *v700;
  uint64_t v701;
  int *v702;
  BOOL v703;
  uint64_t v704;
  int *v705;
  unint64_t v706;
  uint64_t v707;
  uint8x8_t v708;
  int v709;
  unsigned int v710;
  uint64_t v711;
  int v712;
  int *v713;
  uint64_t v714;
  int *v715;
  BOOL v716;
  uint64_t v717;
  int *v718;
  unint64_t v719;
  uint64_t v720;
  int v721;
  int *v722;
  uint64_t v723;
  int *v724;
  BOOL v725;
  uint64_t v726;
  int *v727;
  unint64_t v728;
  uint64_t v729;
  int v730;
  int *v731;
  uint64_t v732;
  int *v733;
  BOOL v734;
  uint64_t v735;
  int *v736;
  unint64_t v737;
  uint64_t v738;
  uint64_t v739;
  char *v740;
  unint64_t v741;
  uint64_t v742;
  int v743;
  uint64_t v744;
  unsigned __int8 *v745;
  uint64_t v746;
  unsigned __int8 *v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  unsigned __int8 *v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  uint64_t v782;
  uint64_t v783;
  uint64_t v784;
  int v785;
  int v786;
  unint64_t v787;
  uint64_t v788;
  unint64_t v789;
  uint64_t v790;
  char *v791;
  int v792;
  int v793;
  unsigned __int8 *v794;
  unint64_t v795;
  int v796;
  int v797;
  uint64_t v798;
  unint64_t v799;
  uint64_t v800;
  unsigned int v801;
  unint64_t v802;
  int v803;
  int v804;
  int v805[2];
  int v806[2];
  int v807[2];
  int v808[2];
  int v809[2];
  int v810[2];
  int v811[2];
  int v812[2];
  int v813[2];
  int v814[2];
  int v815[2];
  int v816[2];
  int v817[2];
  int v818[2];
  int v819[2];
  int v820[2];
  int v821[2];
  int v822[2];
  int v823[2];
  int v824[2];
  int v825[2];
  int v826;
  int v827;
  int v828;
  int v829;
  uint64_t v830;
  unsigned int v831;
  uint64_t v832;
  uint32x4_t *v833;
  unint64_t v834;
  char *v835;
  unint64_t v836;
  uint64_t v837;
  int *v838;
  uint64_t v839;
  uint64_t v840;
  int v841;
  void *v842;
  unint64_t v843;
  unint64_t v844;
  unint64_t v845;
  unint64_t v846;
  unsigned __int8 *v847;
  unint64_t v848;
  int v849;
  uint64_t v850;
  unint64_t v851;
  uint64_t v852;
  uint64_t v853;
  int v854;
  uint64_t v855;
  int v856[4];
  __int128 v857;
  __int128 v858;
  __int128 v859;
  __int128 v860;
  __int128 v861;
  __int128 v862;
  __int128 v863;
  __int128 v864;
  __int128 v865;
  _DWORD v866[1024];
  uint64_t v867;

  v2 = MEMORY[0x1E0C80A78](a1, a2);
  v867 = *MEMORY[0x1E0C80C00];
  v10 = *(_DWORD *)v3;
  v11 = *(unsigned __int8 **)(v3 + 96);
  v12 = *(_QWORD *)(v3 + 48);
  v13 = *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v2 + 56)
                  + 16 * *(_DWORD *)v3
                  + 8 * (v11 == 0)
                  + 4 * (v12 == 0));
  if (v13 > 27)
    return 0xFFFFFFFFLL;
  v15 = v3;
  v16 = *(unsigned int *)(v3 + 4);
  v17 = v16 - 1;
  if ((int)v16 < 1)
    return 0;
  v18 = *(_DWORD *)(v15 + 8);
  v19 = (v18 - 1);
  if (v18 < 1)
    return 0;
  if (v13 >= 24 && **(_DWORD **)v2 == 134759428)
    v13 += 4;
  v20 = *(uint16x4_t **)(v15 + 136);
  if ((v10 & 0xFF0000) == 0x50000 || !v20)
  {
    v22 = v10 & 0xFF00;
    v792 = v13;
    v787 = v15;
    if (v22 == 1024)
    {
      v866[0] = v16;
      v856[0] = v18;
      if (v11)
        v23 = *v11;
      else
        v23 = 255;
      v34 = **(_DWORD **)(v15 + 88);
      v36 = *(int *)(v15 + 12);
      v35 = *(int *)(v15 + 16);
      v37 = (unint64_t)*(int *)(v15 + 28) >> 2;
      if (v12)
      {
        v837 = *(int *)(v15 + 32);
        v835 = (char *)(v12 + v36 + (int)v837 * (uint64_t)(int)v35);
        v831 = 1;
      }
      else
      {
        v835 = 0;
        v837 = 0;
        v831 = 0;
      }
      v43 = ~(_BYTE)v23;
      v44 = (uint32x4_t *)(*(_QWORD *)(v15 + 40) + 4 * (v36 + v35 * v37));
      v833 = v44;
      v799 = (unint64_t)*(int *)(v15 + 28) >> 2;
      if (!v20)
      {
        v842 = 0;
        if (v12)
          v47 = v16;
        else
          v47 = 0;
        v46 = v835;
        v853 = v837 - v47;
        v48 = v16;
        goto LABEL_69;
      }
      shape_enum_clip_alloc(v2, v16, (int *)v20, 1, 1, 1, *(_DWORD *)(v15 + 104), *(_DWORD *)(v15 + 108), v16, v18);
      v46 = v835;
      v853 = v837;
      if (!v45)
        return 1;
      while (1)
      {
        v842 = (void *)v45;
        if (!shape_enum_clip_next(v45, (int *)&v855 + 1, &v855, v866, v856))
          break;
        v44 = (uint32x4_t *)((char *)v44 + 4 * v37 * (int)v855 + 4 * SHIDWORD(v855));
        v48 = v866[0];
        if (v12)
          v46 = &v835[(int)v837 * (uint64_t)(int)v855 + SHIDWORD(v855)];
        v186 = v853;
        if (v12)
          v186 = v837 - v866[0];
        v853 = v186;
        LODWORD(v16) = v866[0];
LABEL_69:
        v851 = v37 - v48;
        v804 = v16;
        switch(v13)
        {
          case 0:
            v71 = v851 + (int)v16;
            v72 = v16;
            v73 = v856[0];
            v852 = v856[0] - 1;
            v74 = &v44->i8[4 * ((v71 * v852) & (v71 >> 63))];
            if (v71 < 0)
              v71 = -v71;
            CGBlt_fillBytes(4 * v16, v856[0], 0, v74, 4 * v71);
            if (v12)
            {
              v75 = v853 + v72;
              v46 += (v75 * v852) & (v75 >> 63);
              if (v75 >= 0)
                v76 = v853 + v72;
              else
                v76 = -v75;
              v77 = v72;
              v78 = v73;
              v79 = 0;
              goto LABEL_88;
            }
            break;
          case 1:
            v840 = (int)v16;
            v80 = v851 + (int)v16;
            if (v80 < 0)
            {
              v44 = (uint32x4_t *)((char *)v44 + 4 * v80 * (v856[0] - 1));
              v80 = -v80;
            }
            v81 = 0;
            v82 = *(int **)(v787 + 88);
            if (v82)
              v81 = *v82;
            v83 = v16;
            v84 = v856[0];
            CGBlt_fillBytes(4 * v16, v856[0], v81, v44->i8, 4 * v80);
            if (v12)
            {
              v78 = v84;
              v85 = *(int **)(v787 + 96);
              if (!v85)
                v85 = (int *)&PIXELALPHAPLANARCONSTANT_15938;
              v46 += ((v853 + v840) * (v84 - 1)) & ((v853 + v840) >> 63);
              if (v853 + v840 >= 0)
                v76 = v853 + v840;
              else
                v76 = -(v853 + v840);
              v79 = *v85;
              v77 = v83;
LABEL_88:
              v853 = v76;
              CGBlt_fillBytes(v77, v78, v79, v46, v76);
            }
            break;
          case 2:
            v86 = 4 * v831;
            if (v12)
            {
              v826 = v16 & 3;
              v87 = v856[0];
              v801 = (v16 >> 2) + 1;
              do
              {
                v841 = v87;
                if ((int)v16 < 4)
                {
                  v92 = v16;
                }
                else
                {
                  v88 = v46 + 3;
                  v89 = v801;
                  do
                  {
                    DAplusDAM(v44, v88 - 3, v34, v23, v44->i32[0], *(v88 - 3), ~(_BYTE)v23);
                    DAplusDAM(&v44->i32[1], v88 - 2, v34, v23, v44->u32[1], *(v88 - 2), ~(_BYTE)v23);
                    DAplusDAM(&v44->i32[2], v88 - 1, v34, v23, v44->u32[2], *(v88 - 1), ~(_BYTE)v23);
                    v91 = v44->u32[3];
                    v90 = &v44->i32[3];
                    DAplusDAM(v90, v88, v34, v23, v91, *v88, ~(_BYTE)v23);
                    v44 = (uint32x4_t *)(v90 + 1);
                    v88 += v86;
                    --v89;
                  }
                  while (v89 > 1);
                  v46 = v88 - 3;
                  v92 = v826;
                }
                if (v92 < 1)
                {
                  v94 = (unsigned int *)v44;
                }
                else
                {
                  v93 = v92 + 1;
                  v94 = (unsigned int *)v44;
                  do
                  {
                    v95 = *v94++;
                    DAplusDAM(v44, v46, v34, v23, v95, *v46, ~(_BYTE)v23);
                    v46 += v831;
                    --v93;
                    v44 = (uint32x4_t *)v94;
                  }
                  while (v93 > 1);
                }
                v44 = (uint32x4_t *)&v94[v851];
                v46 += v853;
                v87 = v841 - 1;
                v856[0] = v841 - 1;
                LODWORD(v16) = v804;
              }
              while (v841 != 1);
              goto LABEL_404;
            }
            v168 = vdupq_n_s32(~(_BYTE)v23);
            v169 = vdupq_n_s32(v34);
            v170.i64[0] = 0x1000100010001;
            v170.i64[1] = 0x1000100010001;
            do
            {
              v171 = v866[0];
              if (v866[0] >= 4)
              {
                v172 = (v866[0] >> 2) + 1;
                do
                {
                  v173.i16[0] = v44->u8[0];
                  v173.i16[1] = BYTE2(v44->u32[0]);
                  v173.i16[2] = BYTE4(v44->i64[0]);
                  v173.i16[3] = BYTE6(v44->i64[0]);
                  v173.i16[4] = v44->i64[1];
                  v173.i16[5] = BYTE2(v44->i64[1]);
                  v173.i16[6] = BYTE12(*(unsigned __int128 *)v44);
                  v173.i16[7] = BYTE14(*(unsigned __int128 *)v44);
                  v174 = vmulq_s32((int32x4_t)(*(_OWORD *)&vshrq_n_u32(*v44, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)), v168);
                  v175 = vmulq_s32(v173, v168);
                  *(int32x4_t *)v44++ = vaddq_s32(vaddq_s32((int32x4_t)(*(_OWORD *)&vaddq_s32(vaddq_s32(v174, v170), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v174, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))) & __PAIR128__(0xFF00FF00FF00FF00, 0xFF00FF00FF00FF00)), v169), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)vaddq_s32(vaddq_s32(v175, v170), (int32x4_t)(*(_OWORD *)&vshrq_n_u32((uint32x4_t)v175, 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL))), 8uLL) & __PAIR128__(0xFFFF00FFFFFF00FFLL, 0xFFFF00FFFFFF00FFLL)));
                  v46 += v86;
                  --v172;
                }
                while (v172 > 1);
                v171 &= 3u;
              }
              if (v171 >= 1)
              {
                v176 = v171 + 1;
                do
                {
                  v44->i32[0] = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43
                                + 65537
                                + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                              + v34
                              + ((((v44->i32[0] & 0xFF00FF) * v43
                                 + 65537
                                 + ((((v44->i32[0] & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v176;
                }
                while (v176 > 1);
                v46 += v171 * v831;
              }
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            v13 = v792;
            break;
          case 3:
            v96 = v37;
            do
            {
              v97 = v866[0];
              do
              {
                v98 = *v46;
                if (v98 == 255)
                {
                  v44->i32[0] = v34;
                  LOBYTE(v99) = v23;
                }
                else if (*v46)
                {
                  v100 = PDAM_5205(v34, v23, v98);
                  v44->i32[0] = v100;
                  v99 = HIDWORD(v100);
                }
                else
                {
                  LOBYTE(v99) = 0;
                  v44->i32[0] = 0;
                }
                *v46 = v99;
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v97;
              }
              while (v97);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 4:
            v96 = v37;
            do
            {
              v101 = v866[0];
              do
              {
                if (~*v46 == 255)
                {
                  v44->i32[0] = v34;
                  LOBYTE(v102) = v23;
                }
                else if (*v46 == -1)
                {
                  LOBYTE(v102) = 0;
                  v44->i32[0] = 0;
                }
                else
                {
                  v103 = PDAM_5205(v34, v23, ~*v46);
                  v44->i32[0] = v103;
                  v102 = HIDWORD(v103);
                }
                *v46 = v102;
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v101;
              }
              while (v101);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_136;
          case 5:
            v104 = v856[0];
            do
            {
              v105 = v16;
              v106 = (unsigned int *)v44;
              do
              {
                v107 = *v106++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46, v107, *v46, ~(_BYTE)v23);
                v46 += v831;
                v44 = (uint32x4_t *)v106;
                --v105;
              }
              while (v105);
              v44 = (uint32x4_t *)&v106[v851];
              v46 += v853;
              v856[0] = --v104;
              LODWORD(v16) = v804;
            }
            while (v104);
            goto LABEL_404;
          case 6:
            v96 = v37;
            do
            {
              v108 = v866[0];
              do
              {
                if (*v46 != -1)
                {
                  if (~*v46 == 255)
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                  else
                  {
                    DAplusDAM(v44, v46, v44->i32[0], *v46, v34, v23, ~*v46);
                  }
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v108;
              }
              while (v108);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
LABEL_136:
            v13 = v792;
            goto LABEL_380;
          case 7:
            if (v12)
            {
              v96 = v37;
              do
              {
                v109 = v866[0];
                do
                {
                  v110 = PDAM_5205(v44->i32[0], *v46, v23);
                  v44->i32[0] = v110;
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  *v46 = BYTE4(v110);
                  v46 += v831;
                  --v109;
                }
                while (v109);
                v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_380;
            }
            do
            {
              v177 = v866[0];
              v178 = v866[0] - 1;
              do
              {
                v44->i32[0] = (((v44->i32[0] & 0xFF00FF) * v23
                              + 65537
                              + ((((v44->i32[0] & 0xFF00FFu) * v23) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | ((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v23 + 65537 + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v23) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                v44 = (uint32x4_t *)((char *)v44 + 4);
                --v177;
              }
              while (v177);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853 + v831 + v831 * (unint64_t)v178;
              --v856[0];
            }
            while (v856[0]);
            break;
          case 8:
            if (v12)
            {
              v96 = v37;
              do
              {
                v111 = v866[0];
                do
                {
                  v112 = PDAM_5205(v44->i32[0], *v46, ~(_BYTE)v23);
                  v44->i32[0] = v112;
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  *v46 = BYTE4(v112);
                  v46 += v831;
                  --v111;
                }
                while (v111);
                v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
LABEL_380:
              v37 = v96;
            }
            else
            {
              do
              {
                v179 = v866[0];
                v180 = v866[0] - 1;
                do
                {
                  v44->i32[0] = (((v44->i32[0] & 0xFF00FF) * v43
                                + 65537
                                + ((((v44->i32[0] & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | ((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43 + 65537 + ((((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) * v43) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v179;
                }
                while (v179);
                v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853 + v831 + v831 * (unint64_t)v180;
                --v856[0];
              }
              while (v856[0]);
            }
            break;
          case 9:
            v113 = v856[0];
            do
            {
              v114 = v16;
              v115 = (unsigned int *)v44;
              do
              {
                v116 = *v115++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46 ^ 0xFF, v116, *v46, v23);
                v46 += v831;
                v44 = (uint32x4_t *)v115;
                --v114;
              }
              while (v114);
              v44 = (uint32x4_t *)&v115[v851];
              v46 += v853;
              v856[0] = --v113;
              LODWORD(v16) = v804;
            }
            while (v113);
            goto LABEL_404;
          case 10:
            v117 = v856[0];
            do
            {
              v118 = v16;
              v119 = (unsigned int *)v44;
              do
              {
                v120 = *v119++;
                DAMplusDAM((unsigned int *)v44, v46, v34, v23, *v46 ^ 0xFF, v120, *v46, ~(_BYTE)v23);
                v46 += v831;
                v44 = (uint32x4_t *)v119;
                --v118;
              }
              while (v118);
              v44 = (uint32x4_t *)&v119[v851];
              v46 += v853;
              v856[0] = --v117;
              LODWORD(v16) = v804;
            }
            while (v117);
            goto LABEL_404;
          case 11:
            if (v12)
            {
              v121 = v856[0];
              do
              {
                v122 = v16;
                v123 = (int *)v44;
                do
                {
                  v124 = *v123++;
                  DAplusdDA(v44, v46, v124, *v46, v34, v23);
                  v46 += v831;
                  v44 = (uint32x4_t *)v123;
                  --v122;
                }
                while (v122);
                v44 = (uint32x4_t *)&v123[v851];
                v46 += v853;
                v856[0] = --v121;
                LODWORD(v16) = v804;
              }
              while (v121);
            }
            else
            {
              v181 = v831 + v831 * (unint64_t)(v16 - 1);
              v182 = v856[0];
              do
              {
                v183 = v16;
                v184 = (int *)v44;
                do
                {
                  v185 = *v184++;
                  DplusdDA((unsigned int *)v44, v185, v34, v23);
                  v44 = (uint32x4_t *)v184;
                  --v183;
                }
                while (v183);
                v44 = (uint32x4_t *)&v184[v851];
                v46 += v181 + v853;
                v856[0] = --v182;
                LODWORD(v16) = v804;
              }
              while (v182);
            }
LABEL_404:
            v13 = v792;
            v37 = v799;
            break;
          case 12:
            v125 = (v34 >> 8) & 0xFF00FF;
            v126 = v34 & 0xFF00FF;
            if (v12)
            {
              do
              {
                v127 = v866[0];
                do
                {
                  v128 = *v46 + v23;
                  v129 = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) << 8) & 0xFF00FF00 | ((v44->i32[0] & 0xFF00FF) + v126) & 0xFF00FF | (15 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001)) | (240 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001));
                  if (v128 >= 0xFF)
                    LOBYTE(v128) = -1;
                  *v46 = v128;
                  v44->i32[0] = v129;
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  v46 += v831;
                  --v127;
                }
                while (v127);
                v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853;
                --v856[0];
              }
              while (v856[0]);
            }
            else
            {
              do
              {
                v187 = v866[0];
                v188 = v866[0] - 1;
                do
                {
                  v44->i32[0] = (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) << 8) & 0xFF00FF00 | ((v44->i32[0] & 0xFF00FF) + v126) & 0xFF00FF | (15 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001)) | (240 * (((((unsigned __int32)v44->i32[0] >> 8) & 0xFF00FF) + v125) & 0x1000100 | (((v44->i32[0] & 0xFF00FFu) + v126) >> 8) & 0x10001));
                  v44 = (uint32x4_t *)((char *)v44 + 4);
                  --v187;
                }
                while (v187);
                v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
                v46 += v853 + v831 + v831 * (unint64_t)v188;
                --v856[0];
              }
              while (v856[0]);
            }
            break;
          case 13:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v130 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v131 = PDAmultiplyPDA_5206(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v131;
                    *v46 = BYTE4(v131);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAmultiplyPDA_5206(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v130;
              }
              while (v130);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 14:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v132 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v133 = PDAscreenPDA_5207(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v133;
                    *v46 = BYTE4(v133);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAscreenPDA_5207(v44->i32[0], 0xFFu, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v132;
              }
              while (v132);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 15:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v134 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v135 = PDAoverlayPDA_5208(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v135;
                    *v46 = BYTE4(v135);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAoverlayPDA_5208(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v134;
              }
              while (v134);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 16:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v136 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v137 = PDAdarkenPDA_5210(v44->i32[0], *v46, v34, v23, v4, v5, v6, v7, v8, v9);
                    v44->i32[0] = v137;
                    *v46 = BYTE4(v137);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAdarkenPDA_5210(v44->i32[0], 0xFFu, v34, v23, v4, v5, v6, v7, v8, v9);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v136;
              }
              while (v136);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 17:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v138 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v139 = PDAlightenPDA_5209(v44->i32[0], *v46, v34, v23, v4, v5, v6, v7, v8, v9);
                    v44->i32[0] = v139;
                    *v46 = BYTE4(v139);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAlightenPDA_5209(v44->i32[0], 0xFFu, v34, v23, v4, v5, v6, v7, v8, v9);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v138;
              }
              while (v138);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 18:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v140 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v141 = PDAcolordodgePDA_5211(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v141;
                    *v46 = BYTE4(v141);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAcolordodgePDA_5211(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v140;
              }
              while (v140);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 19:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v142 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v143 = PDAcolorburnPDA_5212(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v143;
                    *v46 = BYTE4(v143);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAcolorburnPDA_5212(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v142;
              }
              while (v142);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 20:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v144 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v145 = PDAsoftlightPDA_5214(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v145;
                    *v46 = BYTE4(v145);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAsoftlightPDA_5214(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v144;
              }
              while (v144);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 21:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v146 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v147 = PDAhardlightPDA_5213(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v147;
                    *v46 = BYTE4(v147);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAhardlightPDA_5213(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v146;
              }
              while (v146);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 22:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v148 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v149 = PDAdifferencePDA_5215(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v149;
                    *v46 = BYTE4(v149);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAdifferencePDA_5215(v44->i32[0], 0xFFu, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v148;
              }
              while (v148);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 23:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v150 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v151 = PDAexclusionPDA_5216(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v151;
                    *v46 = BYTE4(v151);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAexclusionPDA_5216(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v150;
              }
              while (v150);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 24:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v152 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v153 = PDAhuePDA_5217(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v153;
                    *v46 = BYTE4(v153);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAhuePDA_5217(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v152;
              }
              while (v152);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 25:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v154 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v155 = PDAsaturationPDA_5218(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v155;
                    *v46 = BYTE4(v155);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAsaturationPDA_5218(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v154;
              }
              while (v154);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 26:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v156 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v157 = PDAluminosityPDA_5219(v34, v23, v44->i32[0], *v46);
                    v44->i32[0] = v157;
                    *v46 = BYTE4(v157);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAluminosityPDA_5219(v34, v23, v44->i32[0], 255);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v156;
              }
              while (v156);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 27:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v158 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v159 = PDAluminosityPDA_5219(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v159;
                    *v46 = BYTE4(v159);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAluminosityPDA_5219(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v158;
              }
              while (v158);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 28:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v160 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v161 = PDAtranspose_huePDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v161;
                    *v46 = BYTE4(v161);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_huePDA(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v160;
              }
              while (v160);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 29:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v162 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v163 = PDAtranspose_saturationPDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v163;
                    *v46 = BYTE4(v163);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_saturationPDA(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v162;
              }
              while (v162);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 30:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v164 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v165 = PDAtranspose_luminosityPDA(v34, v23, v44->i32[0], *v46);
                    v44->i32[0] = v165;
                    *v46 = BYTE4(v165);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_luminosityPDA(v34, v23, v44->i32[0], 255);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v164;
              }
              while (v164);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          case 31:
            if (!v23)
              break;
            v96 = v37;
            do
            {
              v166 = v866[0];
              do
              {
                if (v12)
                {
                  if (*v46)
                  {
                    v167 = PDAtranspose_luminosityPDA(v44->i32[0], *v46, v34, v23);
                    v44->i32[0] = v167;
                    *v46 = BYTE4(v167);
                  }
                  else
                  {
                    v44->i32[0] = v34;
                    *v46 = v23;
                  }
                }
                else
                {
                  v44->i32[0] = PDAtranspose_luminosityPDA(v44->i32[0], 255, v34, v23);
                }
                v44 = (uint32x4_t *)((char *)v44 + 4);
                v46 += v831;
                --v166;
              }
              while (v166);
              v44 = (uint32x4_t *)((char *)v44 + 4 * v851);
              v46 += v853;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_380;
          default:
            break;
        }
        v44 = v833;
        v45 = (uint64_t)v842;
        if (!v842)
          return 1;
        v855 = 0;
      }
      v54 = v842;
      goto LABEL_1120;
    }
    v866[0] = v16;
    v856[0] = v18;
    v24 = *(_QWORD *)(v15 + 88);
    v26 = *(int *)(v15 + 12);
    v25 = *(int *)(v15 + 16);
    v27 = (unint64_t)*(int *)(v15 + 28) >> 2;
    if (v12)
    {
      v790 = *(int *)(v15 + 32);
      v791 = (char *)(v12 + v26 + (int)v790 * (uint64_t)(int)v25);
      v850 = 0xFFFFFFFFLL;
    }
    else
    {
      v790 = 0;
      v791 = 0;
      v850 = 0;
    }
    v789 = *(_QWORD *)(v15 + 40) + 4 * (v26 + v25 * v27);
    v38 = *(_DWORD *)(v15 + 56);
    v39 = *(_DWORD *)(v15 + 60);
    v40 = (unint64_t)*(int *)(v15 + 76) >> 2;
    if (v22 != 256)
    {
      v797 = *(_DWORD *)(v15 + 64);
      v796 = *(_DWORD *)(v15 + 68);
      if (v11)
      {
        v41 = *(int *)(v15 + 80);
        v42 = 1;
      }
      else
      {
        v41 = 0;
        v42 = 0;
      }
      v58 = v24 + 4 * v40 * v796;
      v59 = v850 & 1;
      if (v20)
      {
        v836 = (unint64_t)*(int *)(v15 + 76) >> 2;
        v838 = *(int **)(v15 + 88);
        v785 = *(_DWORD *)(v15 + 60);
        v786 = *(_DWORD *)(v15 + 56);
        v850 &= 1u;
        v854 = v42;
        v57 = 1;
        v55 = v838;
        goto LABEL_57;
      }
      v832 = v790 - (v59 * v16);
      if (v24)
      {
        v803 = v16;
        v834 = v24 + 4 * v40 * v796;
        v836 = (unint64_t)*(int *)(v15 + 76) >> 2;
        v66 = v39 % v796;
        v785 = v39 % v796;
        v788 = *(_QWORD *)(v15 + 88);
        v67 = v24 + 4 * v40 * v66;
        v68 = v38 % v797;
        v55 = (int *)(v67 + 4 * v68);
        v65 = v67 + 4 * v797;
        v786 = v68;
        v798 = 0;
        if (v11)
        {
          v793 = 1;
          v42 = 1;
          v69 = (unsigned int *)v789;
          v62 = v791;
          v838 = (int *)(v67 + 4 * v68);
          v839 = (uint64_t)&v11[(int)v41 * (uint64_t)(int)v66 + v68];
          v63 = (unsigned __int8 *)v839;
        }
        else
        {
          v63 = 0;
          v838 = (int *)(v67 + 4 * v68);
          v839 = 0;
          v793 = 1;
          v69 = (unsigned int *)v789;
          v62 = v791;
        }
        v64 = v16;
        goto LABEL_418;
      }
      v785 = *(_DWORD *)(v15 + 60);
      v786 = *(_DWORD *)(v15 + 56);
      v55 = 0;
      v65 = 0;
      v793 = 1;
      v64 = v16;
LABEL_65:
      v798 = 0;
      v838 = 0;
      v839 = (uint64_t)v11;
      v834 = 0;
      v836 = v40 - v64;
      v803 = v16;
      v41 -= v42 * (int)v16;
      v788 = (uint64_t)v55;
      v69 = (unsigned int *)v789;
      v62 = v791;
      v63 = v11;
      goto LABEL_418;
    }
    if (v11)
    {
      v41 = *(int *)(v15 + 80);
      v11 += v38 + (int)v41 * (uint64_t)v39;
      v42 = -1;
    }
    else
    {
      v41 = 0;
      v42 = 0;
    }
    v55 = (int *)(v24 + 4 * (v38 + v39 * v40));
    if (v40 == v27 && (uint64_t)(v789 - (_QWORD)v55) >= 1)
    {
      if (v16 >= (v789 - (unint64_t)v55) >> 2)
      {
        v789 += 4 * v17;
        v791 += v850 & v17;
        v11 += v42 & v17;
        v57 = -1;
        v40 = (unint64_t)*(int *)(v15 + 28) >> 2;
        v55 += v17;
        goto LABEL_52;
      }
      v56 = v27 * v19;
      if (v789 <= (unint64_t)&v55[v27 * v19 + v17])
      {
        v40 = -(uint64_t)v27;
        v70 = (unsigned __int8 *)&v791[v790 * v19];
        v790 = -v790;
        v791 = (char *)v70;
        v850 &= 1u;
        v11 += v41 * v19;
        v41 = -v41;
        v42 &= 1u;
        v57 = 1;
        v55 += v27 * v19;
        v27 = -(uint64_t)v27;
        v789 += 4 * v56;
        goto LABEL_52;
      }
    }
    v850 &= 1u;
    v42 &= 1u;
    v57 = 1;
LABEL_52:
    v785 = *(_DWORD *)(v15 + 60);
    v786 = *(_DWORD *)(v15 + 56);
    if (v20)
    {
      v854 = v42;
      v58 = 0;
      v836 = v40;
      v838 = 0;
      v24 = -1;
      v796 = v41;
      v797 = v40;
LABEL_57:
      v843 = v24;
      v793 = v57;
      shape_enum_clip_alloc(v24, v16, (int *)v20, v57, v27, 1, *(_DWORD *)(v15 + 104), *(_DWORD *)(v15 + 108), v16, v18);
      v788 = (uint64_t)v55;
      v61 = v60;
      v62 = v791;
      v63 = v11;
      v839 = (uint64_t)v11;
      v832 = v790;
      if (!v60)
        return 1;
      while (2)
      {
        if (!shape_enum_clip_next(v61, (int *)&v855 + 1, &v855, v866, v856))
        {
          v54 = (void *)v61;
LABEL_1120:
          free(v54);
          return 1;
        }
        v798 = v61;
        if (v58)
        {
          v834 = v58;
          v69 = (unsigned int *)(v789 + 4 * v27 * (int)v855 + 4 * SHIDWORD(v855));
          v635 = ((int)v855 + *(_DWORD *)(v15 + 60)) % v796;
          v64 = v866[0];
          v636 = (HIDWORD(v855) + *(_DWORD *)(v15 + 56)) % v797;
          v637 = v788 + 4 * v836 * v635;
          v638 = (int *)(v637 + 4 * v636);
          v65 = v637 + 4 * v797;
          v59 = v850;
          if ((_DWORD)v850)
            v62 = &v791[v790 * (int)v855 + SHIDWORD(v855)];
          v639 = v832;
          if ((_DWORD)v850)
            v639 = v790 - v866[0];
          v832 = v639;
          if (v854)
            v42 = v854;
          else
            v42 = 0;
          if (v854)
            v63 = &v11[v41 * v635 + v636];
          v640 = (unsigned __int8 *)v839;
          if (v854)
            v640 = &v11[v41 * v635 + v636];
          v838 = v638;
          v839 = (uint64_t)v640;
          v803 = v866[0];
          v55 = v638;
          v785 = ((int)v855 + *(_DWORD *)(v15 + 60)) % v796;
          v786 = (HIDWORD(v855) + *(_DWORD *)(v15 + 56)) % v797;
        }
        else
        {
          v641 = SHIDWORD(v855) * (uint64_t)v793;
          v803 = v866[0];
          v69 = (unsigned int *)(v789 + 4 * v27 * (int)v855 + 4 * v641);
          v64 = v866[0] * v793;
          v55 = (int *)(v788 + 4 * (int)v855 * v797 + 4 * v641);
          v836 = v797 - v866[0] * v793;
          v59 = v850;
          if ((_DWORD)v850)
            v62 = &v791[v790 * (int)v855 + SHIDWORD(v855) * (uint64_t)v793];
          v642 = v832;
          if ((_DWORD)v850)
            v642 = v790 - v866[0] * v793;
          v832 = v642;
          if (v854)
            v42 = v854;
          else
            v42 = 0;
          v834 = 0;
          if (v854)
          {
            v63 = &v11[(int)v855 * v796 + v641];
            v41 = v796 - (int)v64;
          }
          v65 = v843;
        }
LABEL_418:
        v850 = v59;
        v854 = v42;
        v800 = v41;
        v802 = v27 - v64;
        v795 = v27;
        switch(v13)
        {
          case 0:
            v843 = v65;
            v189 = v802 - v803;
            v190 = &v69[-v803 + 1];
            if (v793 >= 0)
            {
              v190 = v69;
              v189 = v802 + v803;
            }
            v191 = v856[0];
            v192 = v856[0] - 1;
            v193 = (char *)&v190[(v189 * v192) & (v189 >> 63)];
            if (v189 < 0)
              v189 = -v189;
            CGBlt_fillBytes(4 * v803, v856[0], 0, v193, 4 * v189);
            if ((_DWORD)v850)
            {
              v194 = v832 - v803;
              v195 = (unsigned __int8 *)&v62[-v803 + 1];
              if (v793 >= 0)
              {
                v195 = (unsigned __int8 *)v62;
                v194 = v832 + v803;
              }
              v196 = (v194 * v192) & (v194 >> 63);
              if (v194 >= 0)
                v197 = v194;
              else
                v197 = -v194;
              v62 = (char *)&v195[v196];
              v832 = v197;
              CGBlt_fillBytes(v803, v191, 0, (char *)&v195[v196], v197);
            }
            goto LABEL_430;
          case 1:
            v198 = *(unsigned __int8 *)(v15 + 1);
            if (v198 == 2)
            {
              if (v803 < 8
                || (4 * v797) > 0x40
                || (LODWORD(v4) = 4 * v797,
                    v708 = (uint8x8_t)vcnt_s8(*(int8x8_t *)&v4),
                    v708.i16[0] = vaddlv_u8(v708),
                    v708.i32[0] > 1u))
              {
LABEL_1243:
                if ((_DWORD)v59)
                {
                  v711 = (int)v59;
                  if (v42)
                  {
                    do
                    {
                      v712 = v866[0];
                      do
                      {
                        *v69 = *v55;
                        *v62 = *v63;
                        v62 += v711;
                        v713 = &v55[v793];
                        if ((unint64_t)v713 >= v65)
                          v714 = -(uint64_t)v797;
                        else
                          v714 = 0;
                        v55 = &v713[v714];
                        v63 += v42 + v714;
                        v69 += v793;
                        --v712;
                      }
                      while (v712);
                      if (v834)
                      {
                        v715 = &v838[v836];
                        v716 = (unint64_t)v715 >= v834;
                        if ((unint64_t)v715 >= v834)
                          v717 = -(uint64_t)(v836 * v796);
                        else
                          v717 = 0;
                        v718 = &v715[v717];
                        v719 = v65 + 4 * v717;
                        if (v716)
                          v720 = -(v41 * v796);
                        else
                          v720 = 0;
                        v65 = v719 + 4 * v836;
                        v55 = v718;
                        v838 = v718;
                        v839 += v41 + v720;
                        v63 = (unsigned __int8 *)v839;
                      }
                      else
                      {
                        v55 += v836;
                        v63 += v41;
                      }
                      v69 += v802;
                      v62 += v832;
                      --v856[0];
                    }
                    while (v856[0]);
                  }
                  else
                  {
                    do
                    {
                      v730 = v866[0];
                      do
                      {
                        *v69 = *v55;
                        *v62 = -1;
                        v62 += v711;
                        v731 = &v55[v793];
                        if ((unint64_t)v731 >= v65)
                          v732 = -(uint64_t)v797;
                        else
                          v732 = 0;
                        v55 = &v731[v732];
                        v63 += v732;
                        v69 += v793;
                        --v730;
                      }
                      while (v730);
                      if (v834)
                      {
                        v733 = &v838[v836];
                        v734 = (unint64_t)v733 >= v834;
                        if ((unint64_t)v733 >= v834)
                          v735 = -(uint64_t)(v836 * v796);
                        else
                          v735 = 0;
                        v736 = &v733[v735];
                        v737 = v65 + 4 * v735;
                        if (v734)
                          v738 = -(v41 * v796);
                        else
                          v738 = 0;
                        v65 = v737 + 4 * v836;
                        v55 = v736;
                        v838 = v736;
                        v839 += v41 + v738;
                        v63 = (unsigned __int8 *)v839;
                      }
                      else
                      {
                        v55 += v836;
                        v63 += v41;
                      }
                      v69 += v802;
                      v62 += v832;
                      --v856[0];
                    }
                    while (v856[0]);
                  }
                }
                else
                {
                  do
                  {
                    v721 = v866[0];
                    do
                    {
                      *v69 = *v55;
                      v722 = &v55[v793];
                      if ((unint64_t)v722 >= v65)
                        v723 = -(uint64_t)v797;
                      else
                        v723 = 0;
                      v55 = &v722[v723];
                      v63 += v42 + v723;
                      v69 += v793;
                      --v721;
                    }
                    while (v721);
                    if (v834)
                    {
                      v724 = &v838[v836];
                      v725 = (unint64_t)v724 >= v834;
                      if ((unint64_t)v724 >= v834)
                        v726 = -(uint64_t)(v836 * v796);
                      else
                        v726 = 0;
                      v727 = &v724[v726];
                      v728 = v65 + 4 * v726;
                      if (v725)
                        v729 = -(v41 * v796);
                      else
                        v729 = 0;
                      v65 = v728 + 4 * v836;
                      v55 = v727;
                      v838 = v727;
                      v839 += v41 + v729;
                      v63 = (unsigned __int8 *)v839;
                    }
                    else
                    {
                      v55 += v836;
                      v63 += v41;
                    }
                    v69 += v802;
                    v62 += v832;
                    --v856[0];
                  }
                  while (v856[0]);
                }
LABEL_1292:
                v843 = v65;
                goto LABEL_1092;
              }
              v843 = v65;
              v709 = v856[0];
              CGSFillDRAM64(v69, 4 * (v803 + v802), 4 * v803, v856[0], v788, 4 * v836, 4 * v797, v796, 4 * v786, v785);
              if (!(_DWORD)v850)
                goto LABEL_1092;
              v710 = v709;
              v58 = v834;
              v61 = v798;
              if (v42)
                CGSFillDRAM64(v62, v803 + v832, v803, v710, (uint64_t)v11, v41, v797, v796, v786, v785);
              else
                CGBlt_fillBytes(v803, v710, -1, v62, v803 + v832);
            }
            else
            {
              if (v198 != 1)
                goto LABEL_1243;
              v843 = v65;
              if (v793 < 0)
              {
                v199 = v836 - v803;
                v55 += -v803 + 1;
                v200 = v802 - v803;
                v69 += -v803 + 1;
              }
              else
              {
                v199 = v836 + v803;
                v200 = v802 + v803;
              }
              v739 = v856[0] - 1;
              v740 = (char *)&v55[(v199 * v739) & (v199 >> 63)];
              if (v199 >= 0)
                v741 = v199;
              else
                v741 = -v199;
              if (v200 >= 0)
                LODWORD(v742) = v200;
              else
                v742 = -v200;
              v836 = v741;
              v743 = v856[0];
              CGBlt_copyBytes(4 * v803, v856[0], v740, (char *)&v69[(v200 * v739) & (v200 >> 63)], 4 * v741, 4 * v742);
              if (!(_DWORD)v850)
              {
LABEL_430:
                v27 = v795;
                v41 = v800;
                goto LABEL_1092;
              }
              v58 = v834;
              v61 = v798;
              if (v42)
              {
                v744 = v800 - v803;
                v745 = &v63[-v803 + 1];
                v746 = v832 - v803;
                v747 = (unsigned __int8 *)&v62[-v803 + 1];
                if (v793 >= 0)
                {
                  v747 = (unsigned __int8 *)v62;
                  v745 = v63;
                  v744 = v800 + v803;
                  v746 = v832 + v803;
                }
                v748 = (v744 * v739) & (v744 >> 63);
                if (v744 >= 0)
                  v749 = v744;
                else
                  v749 = -v744;
                v750 = (v746 * v739) & (v746 >> 63);
                if (v746 >= 0)
                  v751 = v746;
                else
                  v751 = -v746;
                v63 = &v745[v748];
                v62 = (char *)&v747[v750];
                v832 = v751;
                CGBlt_copyBytes(v803, v743, (char *)&v745[v748], (char *)&v747[v750], v749, v751);
                v27 = v795;
                v41 = v749;
              }
              else
              {
                v752 = v832 - v803;
                v753 = (unsigned __int8 *)&v62[-v803 + 1];
                if (v793 >= 0)
                {
                  v753 = (unsigned __int8 *)v62;
                  v752 = v832 + v803;
                }
                v754 = (v752 * v739) & (v752 >> 63);
                if (v752 >= 0)
                  v755 = v752;
                else
                  v755 = -v752;
                v62 = (char *)&v753[v754];
                v832 = v755;
                CGBlt_fillBytes(v803, v743, -1, (char *)&v753[v754], v755);
                v27 = v795;
                v41 = v800;
              }
            }
            goto LABEL_1093;
          case 2:
            v201 = v793;
            v202 = 4 * v793;
            if ((_DWORD)v59)
            {
              v794 = v11;
              v203 = (int)v59;
              v783 = -(v41 * v796);
              do
              {
                v204 = v866[0];
                do
                {
                  v205 = *v63;
                  if (*v63)
                  {
                    if (v205 == 255)
                    {
                      *v69 = *v55;
                      *v62 = *v63;
                    }
                    else
                    {
                      v206 = v202;
                      v207 = v65;
                      DAplusDAM(v69, v62, *v55, v205, *v69, *v62, v205 ^ 0xFF);
                      v202 = v206;
                      v201 = v793;
                      v65 = v207;
                    }
                  }
                  v62 += v203;
                  v208 = &v55[v201];
                  if ((unint64_t)v208 >= v65)
                    v209 = -(uint64_t)v797;
                  else
                    v209 = 0;
                  v55 = &v208[v209];
                  v63 += v42 + v209;
                  v69 = (unsigned int *)((char *)v69 + v202);
                  --v204;
                }
                while (v204);
                if (v834)
                {
                  v210 = &v838[v836];
                  v41 = v800;
                  v211 = (unint64_t)v210 >= v834;
                  v212 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v210 < v834)
                    v212 = 0;
                  v213 = &v210[v212];
                  v214 = v65 + 4 * v212;
                  v215 = v783;
                  if (!v211)
                    v215 = 0;
                  v65 = v214 + 4 * v836;
                  v55 = v213;
                  v838 = v213;
                  v839 += v800 + v215;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
            do
            {
              v643 = v866[0];
              do
              {
                v644 = *v63;
                if (*v63)
                {
                  if (v644 == 255)
                    v645 = *v55;
                  else
                    v645 = ((((*v69 >> 8) & 0xFF00FF) * (v644 ^ 0xFF)
                           + 65537
                           + (((((*v69 >> 8) & 0xFF00FF) * (v644 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                         + *v55
                         + ((((*v69 & 0xFF00FF) * (v644 ^ 0xFF)
                            + 65537
                            + ((((*v69 & 0xFF00FF) * (v644 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  *v69 = v645;
                }
                v646 = &v55[v793];
                if ((unint64_t)v646 >= v65)
                  v647 = -(uint64_t)v797;
                else
                  v647 = 0;
                v55 = &v646[v647];
                v63 += v42 + v647;
                v69 = (unsigned int *)((char *)v69 + v202);
                --v643;
              }
              while (v643);
              if (v834)
              {
                v648 = &v838[v836];
                v649 = (unint64_t)v648 >= v834;
                if ((unint64_t)v648 >= v834)
                  v650 = -(uint64_t)(v836 * v796);
                else
                  v650 = 0;
                v651 = &v648[v650];
                v652 = v65 + 4 * v650;
                if (v649)
                  v653 = -(v41 * v796);
                else
                  v653 = 0;
                v65 = v652 + 4 * v836;
                v55 = v651;
                v838 = v651;
                v839 += v41 + v653;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v63 += v41;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1202;
          case 3:
            v216 = v793;
            v217 = (int)v59;
            v218 = 4 * v793;
            if (v42)
            {
              v794 = v11;
              v784 = -(v41 * v796);
              do
              {
                v219 = v866[0];
                do
                {
                  v220 = *v62;
                  if (v220 == 255)
                  {
                    *v69 = *v55;
                    LOBYTE(v221) = *v63;
                  }
                  else if (*v62)
                  {
                    v222 = v65;
                    v223 = v218;
                    v224 = PDAM_5205(*v55, *v63, v220);
                    v218 = v223;
                    v216 = v793;
                    v65 = v222;
                    *v69 = v224;
                    v221 = HIDWORD(v224);
                  }
                  else
                  {
                    LOBYTE(v221) = 0;
                    *v69 = 0;
                  }
                  *v62 = v221;
                  v62 += v217;
                  v225 = &v55[v216];
                  if ((unint64_t)v225 >= v65)
                    v226 = -(uint64_t)v797;
                  else
                    v226 = 0;
                  v55 = &v225[v226];
                  v63 += v42 + v226;
                  v69 = (unsigned int *)((char *)v69 + v218);
                  --v219;
                }
                while (v219);
                if (v834)
                {
                  v227 = &v838[v836];
                  v41 = v800;
                  v228 = (unint64_t)v227 >= v834;
                  v229 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v227 < v834)
                    v229 = 0;
                  v230 = &v227[v229];
                  v231 = v65 + 4 * v229;
                  v232 = v784;
                  if (!v228)
                    v232 = 0;
                  v65 = v231 + 4 * v836;
                  v55 = v230;
                  v838 = v230;
                  v839 += v800 + v232;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
            do
            {
              v654 = v866[0];
              do
              {
                v655 = *v62;
                if (*v62)
                {
                  if (v655 == 255)
                    v655 = *v55;
                  else
                    v655 = (((*v55 & 0xFF00FF) * v655 + 65537 + ((((*v55 & 0xFF00FF) * v655) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v55 >> 8) & 0xFF00FF) * v655 + 65537 + (((((*v55 >> 8) & 0xFF00FF) * v655) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                }
                *v69 = v655;
                v62 += v217;
                v656 = &v55[v793];
                if ((unint64_t)v656 >= v65)
                  v657 = -(uint64_t)v797;
                else
                  v657 = 0;
                v55 = &v656[v657];
                v63 += v657;
                v69 = (unsigned int *)((char *)v69 + v218);
                --v654;
              }
              while (v654);
              if (v834)
              {
                v658 = &v838[v836];
                v659 = (unint64_t)v658 >= v834;
                if ((unint64_t)v658 >= v834)
                  v660 = -(uint64_t)(v836 * v796);
                else
                  v660 = 0;
                v661 = &v658[v660];
                v662 = v65 + 4 * v660;
                if (v659)
                  v663 = -(v41 * v796);
                else
                  v663 = 0;
                v65 = v662 + 4 * v836;
                v55 = v661;
                v838 = v661;
                v839 += v41 + v663;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v63 += v41;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            v843 = v65;
            v13 = v792;
            goto LABEL_1091;
          case 4:
            v794 = v11;
            v233 = (int)v59;
            v234 = v42;
            *(_QWORD *)v805 = -(v41 * v796);
            do
            {
              v235 = v866[0];
              v844 = v65;
              do
              {
                if (~*v62 == 255)
                {
                  if (v42)
                    LOBYTE(v236) = *v63;
                  else
                    LOBYTE(v236) = -1;
                }
                else if (*v62 == -1)
                {
                  LOBYTE(v236) = 0;
                  *v69 = 0;
                }
                else
                {
                  if (v42)
                    v237 = *v63;
                  else
                    v237 = 255;
                  v238 = PDAM_5205(*v55, v237, ~*v62);
                  *v69 = v238;
                  v236 = HIDWORD(v238);
                  v42 = v854;
                  v65 = v844;
                }
                *v62 = v236;
                v62 += v233;
                v239 = &v55[v793];
                if ((unint64_t)v239 >= v65)
                  v240 = -(uint64_t)v797;
                else
                  v240 = 0;
                v55 = &v239[v240];
                v63 += v234 + v240;
                v69 += v793;
                --v235;
              }
              while (v235);
              if (v834)
              {
                v241 = &v838[v836];
                v41 = v800;
                v242 = (unint64_t)v241 >= v834;
                v243 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v241 < v834)
                  v243 = 0;
                v244 = &v241[v243];
                v245 = v65 + 4 * v243;
                v246 = *(_QWORD *)v805;
                if (!v242)
                  v246 = 0;
                v65 = v245 + 4 * v836;
                v55 = v244;
                v838 = v244;
                v839 += v800 + v246;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1089;
          case 5:
            v794 = v11;
            v247 = (int)v59;
            v757 = -(v41 * v796);
            v248 = v856[0];
            do
            {
              v827 = v248;
              v249 = v803;
              v845 = v65;
              do
              {
                DAMplusDAM(v69, v62, *v55, *v63, *v62, *v69, *v62, *v63 ^ 0xFF);
                v65 = v845;
                v62 += v247;
                v250 = &v55[v793];
                if ((unint64_t)v250 >= v845)
                  v251 = -(uint64_t)v797;
                else
                  v251 = 0;
                v55 = &v250[v251];
                v63 += v42 + v251;
                v69 += v793;
                --v249;
              }
              while (v249);
              if (v834)
              {
                v252 = &v838[v836];
                v41 = v800;
                v253 = (unint64_t)v252 >= v834;
                v254 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v252 < v834)
                  v254 = 0;
                v255 = &v252[v254];
                v256 = v845 + 4 * v254;
                v257 = v757;
                if (!v253)
                  v257 = 0;
                v65 = v256 + 4 * v836;
                v55 = v255;
                v838 = v255;
                v839 += v800 + v257;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              v248 = v827 - 1;
              v856[0] = v827 - 1;
            }
            while (v827 != 1);
            goto LABEL_1089;
          case 6:
            v794 = v11;
            v258 = (int)v59;
            v259 = v42;
            *(_QWORD *)v806 = -(v41 * v796);
            do
            {
              v260 = v866[0];
              v846 = v65;
              do
              {
                if (*v62 != -1)
                {
                  if (~*v62 == 255)
                  {
                    if (v42)
                      v261 = *v63;
                    else
                      v261 = -1;
                    *v69 = *v55;
                    *v62 = v261;
                  }
                  else
                  {
                    if (v42)
                      v262 = *v63;
                    else
                      v262 = 255;
                    DAplusDAM(v69, v62, *v69, *v62, *v55, v262, ~*v62);
                    v42 = v854;
                    v65 = v846;
                  }
                }
                v62 += v258;
                v263 = &v55[v793];
                if ((unint64_t)v263 >= v65)
                  v264 = -(uint64_t)v797;
                else
                  v264 = 0;
                v55 = &v263[v264];
                v63 += v259 + v264;
                v69 += v793;
                --v260;
              }
              while (v260);
              if (v834)
              {
                v265 = &v838[v836];
                v41 = v800;
                v266 = (unint64_t)v265 >= v834;
                v267 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v265 < v834)
                  v267 = 0;
                v268 = &v265[v267];
                v269 = v65 + 4 * v267;
                v270 = *(_QWORD *)v806;
                if (!v266)
                  v270 = 0;
                v65 = v269 + 4 * v836;
                v55 = v268;
                v838 = v268;
                v839 += v800 + v270;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
            goto LABEL_1089;
          case 7:
            v271 = v793;
            v272 = 4 * v793;
            if ((_DWORD)v59)
            {
              v794 = v11;
              v273 = (int)v59;
              v274 = -(uint64_t)v797;
              v758 = -(v41 * v796);
              do
              {
                v275 = v866[0];
                do
                {
                  v276 = *v63;
                  if (v276 != 255)
                  {
                    if (*v63)
                    {
                      v278 = v65;
                      v279 = v272;
                      v280 = PDAM_5205(*v69, *v62, v276);
                      v271 = v793;
                      v274 = -(uint64_t)v797;
                      v272 = v279;
                      v65 = v278;
                      *v69 = v280;
                      v277 = HIDWORD(v280);
                    }
                    else
                    {
                      LOBYTE(v277) = 0;
                      *v69 = 0;
                    }
                    *v62 = v277;
                  }
                  v62 += v273;
                  v281 = &v55[v271];
                  if ((unint64_t)v281 >= v65)
                    v282 = v274;
                  else
                    v282 = 0;
                  v55 = &v281[v282];
                  v63 += v42 + v282;
                  v69 = (unsigned int *)((char *)v69 + v272);
                  --v275;
                }
                while (v275);
                if (v834)
                {
                  v283 = &v838[v836];
                  v41 = v800;
                  v284 = (unint64_t)v283 >= v834;
                  v285 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v283 < v834)
                    v285 = 0;
                  v286 = &v283[v285];
                  v287 = v65 + 4 * v285;
                  v288 = v758;
                  if (!v284)
                    v288 = 0;
                  v65 = v287 + 4 * v836;
                  v55 = v286;
                  v838 = v286;
                  v839 += v800 + v288;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
              goto LABEL_1089;
            }
LABEL_1163:
            v664 = v866[0];
            while (1)
            {
              v665 = *v63;
              if (!*v63)
                goto LABEL_1167;
              if (v665 != 255)
                break;
LABEL_1168:
              v666 = &v55[v793];
              if ((unint64_t)v666 >= v65)
                v667 = -(uint64_t)v797;
              else
                v667 = 0;
              v55 = &v666[v667];
              v63 += v42 + v667;
              v69 = (unsigned int *)((char *)v69 + v272);
              if (!--v664)
              {
                if (v834)
                {
                  v668 = &v838[v836];
                  v669 = (unint64_t)v668 >= v834;
                  if ((unint64_t)v668 >= v834)
                    v670 = -(uint64_t)(v836 * v796);
                  else
                    v670 = 0;
                  v671 = &v668[v670];
                  v672 = v65 + 4 * v670;
                  if (v669)
                    v673 = -(v41 * v796);
                  else
                    v673 = 0;
                  v65 = v672 + 4 * v836;
                  v55 = v671;
                  v838 = v671;
                  v839 += v41 + v673;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                if (!--v856[0])
                  goto LABEL_1202;
                goto LABEL_1163;
              }
            }
            v665 = (((*v69 & 0xFF00FF) * v665 + 65537 + ((((*v69 & 0xFF00FF) * v665) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v69 >> 8) & 0xFF00FF) * v665 + 65537 + (((((*v69 >> 8) & 0xFF00FF) * v665) >> 8) & 0xFF00FF)) & 0xFF00FF00;
LABEL_1167:
            *v69 = v665;
            goto LABEL_1168;
          case 8:
            v289 = v793;
            v290 = 4 * v793;
            if (!(_DWORD)v59)
            {
              while (1)
              {
                v674 = v866[0];
                do
                {
                  v675 = *v63 ^ 0xFF;
                  if (v675)
                  {
                    if (v675 == 255)
                      goto LABEL_1188;
                    v675 = (((*v69 & 0xFF00FF) * v675 + 65537 + ((((*v69 & 0xFF00FF) * v675) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v69 >> 8) & 0xFF00FF) * v675 + 65537 + (((((*v69 >> 8) & 0xFF00FF) * v675) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  *v69 = v675;
LABEL_1188:
                  v676 = &v55[v793];
                  if ((unint64_t)v676 >= v65)
                    v677 = -(uint64_t)v797;
                  else
                    v677 = 0;
                  v55 = &v676[v677];
                  v63 += v42 + v677;
                  v69 = (unsigned int *)((char *)v69 + v290);
                  --v674;
                }
                while (v674);
                if (v834)
                {
                  v678 = &v838[v836];
                  v679 = (unint64_t)v678 >= v834;
                  if ((unint64_t)v678 >= v834)
                    v680 = -(uint64_t)(v836 * v796);
                  else
                    v680 = 0;
                  v681 = &v678[v680];
                  v682 = v65 + 4 * v680;
                  if (v679)
                    v683 = -(v41 * v796);
                  else
                    v683 = 0;
                  v65 = v682 + 4 * v836;
                  v55 = v681;
                  v838 = v681;
                  v839 += v41 + v683;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                if (!--v856[0])
                {
LABEL_1202:
                  v843 = v65;
                  goto LABEL_1091;
                }
              }
            }
            v794 = v11;
            v291 = (int)v59;
            v759 = -(v41 * v796);
            do
            {
              v292 = v866[0];
              do
              {
                if (~*v63 != 255)
                {
                  if (*v63 == 0xFF)
                  {
                    LOBYTE(v293) = 0;
                    *v69 = 0;
                  }
                  else
                  {
                    v294 = v65;
                    v295 = PDAM_5205(*v69, *v62, ~*v63);
                    v290 = 4 * v793;
                    v289 = v793;
                    v65 = v294;
                    *v69 = v295;
                    v293 = HIDWORD(v295);
                  }
                  *v62 = v293;
                }
                v62 += v291;
                v296 = &v55[v289];
                if ((unint64_t)v296 >= v65)
                  v297 = -(uint64_t)v797;
                else
                  v297 = 0;
                v55 = &v296[v297];
                v63 += v42 + v297;
                v69 = (unsigned int *)((char *)v69 + v290);
                --v292;
              }
              while (v292);
              if (v834)
              {
                v298 = &v838[v836];
                v41 = v800;
                v299 = (unint64_t)v298 >= v834;
                v300 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v298 < v834)
                  v300 = 0;
                v301 = &v298[v300];
                v302 = v65 + 4 * v300;
                v303 = v759;
                if (!v299)
                  v303 = 0;
                v65 = v302 + 4 * v836;
                v55 = v301;
                v838 = v301;
                v839 += v800 + v303;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              --v856[0];
            }
            while (v856[0]);
LABEL_1089:
            v843 = v65;
LABEL_1090:
            v13 = v792;
            v15 = v787;
            v11 = v794;
LABEL_1091:
            v27 = v795;
LABEL_1092:
            v58 = v834;
            v61 = v798;
LABEL_1093:
            if (!v61)
              return 1;
            v855 = 0;
            continue;
          case 9:
            v794 = v11;
            v304 = (int)v59;
            v760 = -(v41 * v796);
            v305 = v856[0];
            do
            {
              v828 = v305;
              v306 = v803;
              do
              {
                v847 = v63;
                v307 = *v63;
                v308 = v65;
                DAMplusDAM(v69, v62, *v55, v307, *v62 ^ 0xFF, *v69, *v62, v307);
                v65 = v308;
                v62 += v304;
                v309 = &v55[v793];
                if ((unint64_t)v309 >= v308)
                  v310 = -(uint64_t)v797;
                else
                  v310 = 0;
                v55 = &v309[v310];
                v63 = &v847[v42 + v310];
                v69 += v793;
                --v306;
              }
              while (v306);
              if (v834)
              {
                v311 = &v838[v836];
                v41 = v800;
                v312 = (unint64_t)v311 >= v834;
                v313 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v311 < v834)
                  v313 = 0;
                v314 = &v311[v313];
                v315 = v65 + 4 * v313;
                v316 = v760;
                if (!v312)
                  v316 = 0;
                v65 = v315 + 4 * v836;
                v55 = v314;
                v838 = v314;
                v839 += v800 + v316;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              v305 = v828 - 1;
              v856[0] = v828 - 1;
            }
            while (v828 != 1);
            goto LABEL_1089;
          case 10:
            v794 = v11;
            v317 = (int)v59;
            v761 = -(v41 * v796);
            v318 = v856[0];
            v319 = -(uint64_t)v797;
            do
            {
              v829 = v318;
              v320 = v803;
              v848 = v65;
              do
              {
                v321 = *v62;
                v322 = v55;
                v323 = *v55;
                v324 = *v69;
                v325 = v69;
                v326 = v62;
                v327 = v62;
                v328 = v69;
                v329 = v322;
                v330 = v319;
                DAMplusDAM(v325, v326, v323, *v63, v321 ^ 0xFF, v324, v321, *v63 ^ 0xFF);
                v319 = v330;
                v65 = v848;
                v62 = &v327[v317];
                v331 = (unint64_t)&v329[v793];
                if (v331 >= v848)
                  v332 = v319;
                else
                  v332 = 0;
                v55 = (int *)(v331 + 4 * v332);
                v63 += v42 + v332;
                v69 = &v328[v793];
                --v320;
              }
              while (v320);
              if (v834)
              {
                v333 = &v838[v836];
                v41 = v800;
                v334 = (unint64_t)v333 >= v834;
                v335 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v333 < v834)
                  v335 = 0;
                v336 = &v333[v335];
                v337 = v848 + 4 * v335;
                v338 = v761;
                if (!v334)
                  v338 = 0;
                v65 = v337 + 4 * v836;
                v55 = v336;
                v838 = v336;
                v839 += v800 + v338;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              v318 = v829 - 1;
              v856[0] = v829 - 1;
            }
            while (v829 != 1);
            goto LABEL_1089;
          case 11:
            v794 = v11;
            v830 = 4 * v793;
            if ((_DWORD)v59)
            {
              v339 = (int)v59;
              v340 = v42;
              v762 = -(v41 * v796);
              v341 = v856[0];
              do
              {
                v849 = v341;
                v342 = v803;
                v343 = v65;
                do
                {
                  if (v42)
                    v344 = *v63;
                  else
                    v344 = 255;
                  DAplusdDA(v69, v62, *v69, *v62, *v55, v344);
                  v62 += v339;
                  v345 = &v55[v793];
                  if ((unint64_t)v345 >= v343)
                    v346 = -(uint64_t)v797;
                  else
                    v346 = 0;
                  v55 = &v345[v346];
                  v63 += v340 + v346;
                  v69 = (unsigned int *)((char *)v69 + v830);
                  --v342;
                  v42 = v854;
                }
                while (v342);
                v65 = v343;
                if (v834)
                {
                  v347 = &v838[v836];
                  v41 = v800;
                  v348 = (unint64_t)v347 >= v834;
                  v349 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v347 < v834)
                    v349 = 0;
                  v350 = &v347[v349];
                  v351 = v343 + 4 * v349;
                  v352 = v762;
                  if (!v348)
                    v352 = 0;
                  v65 = v351 + 4 * v836;
                  v55 = v350;
                  v838 = v350;
                  v839 += v800 + v352;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v41 = v800;
                  v63 += v800;
                }
                v69 += v802;
                v62 += v832;
                v341 = v849 - 1;
                v856[0] = v849 - 1;
              }
              while (v849 != 1);
              goto LABEL_1089;
            }
            v684 = v42;
            v782 = -(v41 * v796);
            v685 = v856[0];
            v756 = v832 + v832 * (v856[0] - 1);
            do
            {
              v686 = v803;
              v687 = v65;
              do
              {
                if (v42)
                  v688 = *v63;
                else
                  v688 = 255;
                DplusdDA(v69, *v69, *v55, v688);
                v689 = &v55[v793];
                if ((unint64_t)v689 >= v687)
                  v690 = -(uint64_t)v797;
                else
                  v690 = 0;
                v55 = &v689[v690];
                v63 += v684 + v690;
                v69 = (unsigned int *)((char *)v69 + v830);
                --v686;
                v42 = v854;
              }
              while (v686);
              v65 = v687;
              if (v834)
              {
                v691 = &v838[v836];
                v41 = v800;
                v692 = (unint64_t)v691 >= v834;
                v693 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v691 < v834)
                  v693 = 0;
                v694 = &v691[v693];
                v695 = v687 + 4 * v693;
                v696 = v782;
                if (!v692)
                  v696 = 0;
                v65 = v695 + 4 * v836;
                v55 = v694;
                v838 = v694;
                v839 += v800 + v696;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v856[0] = --v685;
            }
            while (v685);
            v843 = v65;
            v62 += v756;
            goto LABEL_1090;
          case 12:
            if ((_DWORD)v59)
            {
              do
              {
                v353 = v866[0];
                do
                {
                  if (v42)
                    v354 = *v63;
                  else
                    v354 = 255;
                  v355 = ((*v55 >> 8) & 0xFF00FF) + ((*v69 >> 8) & 0xFF00FF);
                  v356 = (*v55 & 0xFF00FF) + (*v69 & 0xFF00FF);
                  v357 = v354 + *v62;
                  v358 = (v355 << 8) & 0xFF00FF00 | v356 & 0xFF00FF | (15 * (v355 & 0x1000100 | (v356 >> 8) & 0x10001)) | (240 * (v355 & 0x1000100 | (v356 >> 8) & 0x10001));
                  if (v357 >= 0xFF)
                    LOBYTE(v357) = -1;
                  *v62 = v357;
                  *v69 = v358;
                  v62 += (int)v59;
                  v359 = &v55[v793];
                  if ((unint64_t)v359 >= v65)
                    v360 = -(uint64_t)v797;
                  else
                    v360 = 0;
                  v55 = &v359[v360];
                  v63 += v42 + v360;
                  v69 += v793;
                  --v353;
                }
                while (v353);
                if (v834)
                {
                  v361 = &v838[v836];
                  v362 = (unint64_t)v361 >= v834;
                  v363 = -(uint64_t)(v836 * v796);
                  if ((unint64_t)v361 < v834)
                    v363 = 0;
                  v364 = &v361[v363];
                  v365 = v65 + 4 * v363;
                  if (v362)
                    v366 = -(v41 * v796);
                  else
                    v366 = 0;
                  v65 = v365 + 4 * v836;
                  v55 = v364;
                  v838 = v364;
                  v839 += v41 + v366;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
            }
            else
            {
              do
              {
                v697 = v866[0];
                do
                {
                  v698 = ((*v55 >> 8) & 0xFF00FF) + ((*v69 >> 8) & 0xFF00FF);
                  v699 = (*v55 & 0xFF00FF) + (*v69 & 0xFF00FF);
                  *v69 = (v698 << 8) & 0xFF00FF00 | v699 & 0xFF00FF | (15 * (v698 & 0x1000100 | (v699 >> 8) & 0x10001)) | (240 * (v698 & 0x1000100 | (v699 >> 8) & 0x10001));
                  v700 = &v55[v793];
                  if ((unint64_t)v700 >= v65)
                    v701 = -(uint64_t)v797;
                  else
                    v701 = 0;
                  v55 = &v700[v701];
                  v63 += v42 + v701;
                  v69 += v793;
                  --v697;
                }
                while (v697);
                if (v834)
                {
                  v702 = &v838[v836];
                  v703 = (unint64_t)v702 >= v834;
                  if ((unint64_t)v702 >= v834)
                    v704 = -(uint64_t)(v836 * v796);
                  else
                    v704 = 0;
                  v705 = &v702[v704];
                  v706 = v65 + 4 * v704;
                  if (v703)
                    v707 = -(v41 * v796);
                  else
                    v707 = 0;
                  v65 = v706 + 4 * v836;
                  v55 = v705;
                  v838 = v705;
                  v839 += v41 + v707;
                  v63 = (unsigned __int8 *)v839;
                }
                else
                {
                  v55 += v836;
                  v63 += v41;
                }
                v69 += v802;
                v62 += v832;
                --v856[0];
              }
              while (v856[0]);
            }
            goto LABEL_1292;
          case 13:
            v794 = v11;
            *(_QWORD *)v807 = (int)v59;
            v367 = v42;
            v763 = -(v41 * v796);
            while (1)
            {
              v368 = v866[0];
              v369 = v65;
              do
              {
                if (v42)
                {
                  v370 = *v63;
                  if (!*v63)
                    goto LABEL_663;
                  if ((_DWORD)v59)
                    goto LABEL_658;
                }
                else
                {
                  v370 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_658:
                    if (*v62)
                    {
                      v371 = PDAmultiplyPDA_5206(*v69, *v62, *v55, v370);
                      v65 = v369;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v371;
                      *v62 = BYTE4(v371);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v370;
                    }
                    goto LABEL_663;
                  }
                }
                v372 = PDAmultiplyPDA_5206(*v69, 255, *v55, v370);
                v65 = v369;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v372;
LABEL_663:
                v62 += *(_QWORD *)v807;
                v373 = &v55[v793];
                if ((unint64_t)v373 >= v65)
                  v374 = -(uint64_t)v797;
                else
                  v374 = 0;
                v55 = &v373[v374];
                v63 += v367 + v374;
                v69 += v793;
                --v368;
              }
              while (v368);
              if (v834)
              {
                v375 = &v838[v836];
                v41 = v800;
                v376 = (unint64_t)v375 >= v834;
                v377 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v375 < v834)
                  v377 = 0;
                v378 = &v375[v377];
                v379 = v65 + 4 * v377;
                v380 = v763;
                if (!v376)
                  v380 = 0;
                v65 = v379 + 4 * v836;
                v55 = v378;
                v838 = v378;
                v839 += v800 + v380;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 14:
            v794 = v11;
            *(_QWORD *)v808 = (int)v59;
            v381 = v42;
            v764 = -(v41 * v796);
            while (1)
            {
              v382 = v866[0];
              v383 = v65;
              do
              {
                if (v42)
                {
                  v384 = *v63;
                  if (!*v63)
                    goto LABEL_686;
                  if ((_DWORD)v59)
                    goto LABEL_681;
                }
                else
                {
                  v384 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_681:
                    if (*v62)
                    {
                      v385 = PDAscreenPDA_5207(*v69, *v62, *v55, v384);
                      v65 = v383;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v385;
                      *v62 = BYTE4(v385);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v384;
                    }
                    goto LABEL_686;
                  }
                }
                v386 = PDAscreenPDA_5207(*v69, 0xFFu, *v55, v384);
                v65 = v383;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v386;
LABEL_686:
                v62 += *(_QWORD *)v808;
                v387 = &v55[v793];
                if ((unint64_t)v387 >= v65)
                  v388 = -(uint64_t)v797;
                else
                  v388 = 0;
                v55 = &v387[v388];
                v63 += v381 + v388;
                v69 += v793;
                --v382;
              }
              while (v382);
              if (v834)
              {
                v389 = &v838[v836];
                v41 = v800;
                v390 = (unint64_t)v389 >= v834;
                v391 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v389 < v834)
                  v391 = 0;
                v392 = &v389[v391];
                v393 = v65 + 4 * v391;
                v394 = v764;
                if (!v390)
                  v394 = 0;
                v65 = v393 + 4 * v836;
                v55 = v392;
                v838 = v392;
                v839 += v800 + v394;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 15:
            v794 = v11;
            *(_QWORD *)v809 = (int)v59;
            v395 = v42;
            v765 = -(v41 * v796);
            while (1)
            {
              v396 = v866[0];
              v397 = v65;
              do
              {
                if (v42)
                {
                  v398 = *v63;
                  if (!*v63)
                    goto LABEL_709;
                  if ((_DWORD)v59)
                    goto LABEL_704;
                }
                else
                {
                  v398 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_704:
                    if (*v62)
                    {
                      v399 = PDAoverlayPDA_5208(*v69, *v62, *v55, v398);
                      v65 = v397;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v399;
                      *v62 = BYTE4(v399);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v398;
                    }
                    goto LABEL_709;
                  }
                }
                v400 = PDAoverlayPDA_5208(*v69, 255, *v55, v398);
                v65 = v397;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v400;
LABEL_709:
                v62 += *(_QWORD *)v809;
                v401 = &v55[v793];
                if ((unint64_t)v401 >= v65)
                  v402 = -(uint64_t)v797;
                else
                  v402 = 0;
                v55 = &v401[v402];
                v63 += v395 + v402;
                v69 += v793;
                --v396;
              }
              while (v396);
              if (v834)
              {
                v403 = &v838[v836];
                v41 = v800;
                v404 = (unint64_t)v403 >= v834;
                v405 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v403 < v834)
                  v405 = 0;
                v406 = &v403[v405];
                v407 = v65 + 4 * v405;
                v408 = v765;
                if (!v404)
                  v408 = 0;
                v65 = v407 + 4 * v836;
                v55 = v406;
                v838 = v406;
                v839 += v800 + v408;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 16:
            v794 = v11;
            *(_QWORD *)v810 = (int)v59;
            v409 = v42;
            v766 = -(v41 * v796);
            while (1)
            {
              v410 = v866[0];
              v411 = v65;
              do
              {
                if (v42)
                {
                  v412 = *v63;
                  if (!*v63)
                    goto LABEL_732;
                  if ((_DWORD)v59)
                    goto LABEL_727;
                }
                else
                {
                  v412 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_727:
                    if (*v62)
                    {
                      v413 = PDAdarkenPDA_5210(*v69, *v62, *v55, v412, v4, v5, v6, v7, v8, v9);
                      v65 = v411;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v413;
                      *v62 = BYTE4(v413);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v412;
                    }
                    goto LABEL_732;
                  }
                }
                v414 = PDAdarkenPDA_5210(*v69, 0xFFu, *v55, v412, v4, v5, v6, v7, v8, v9);
                v65 = v411;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v414;
LABEL_732:
                v62 += *(_QWORD *)v810;
                v415 = &v55[v793];
                if ((unint64_t)v415 >= v65)
                  v416 = -(uint64_t)v797;
                else
                  v416 = 0;
                v55 = &v415[v416];
                v63 += v409 + v416;
                v69 += v793;
                --v410;
              }
              while (v410);
              if (v834)
              {
                v417 = &v838[v836];
                v41 = v800;
                v418 = (unint64_t)v417 >= v834;
                v419 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v417 < v834)
                  v419 = 0;
                v420 = &v417[v419];
                v421 = v65 + 4 * v419;
                v422 = v766;
                if (!v418)
                  v422 = 0;
                v65 = v421 + 4 * v836;
                v55 = v420;
                v838 = v420;
                v839 += v800 + v422;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 17:
            v794 = v11;
            *(_QWORD *)v811 = (int)v59;
            v423 = v42;
            v767 = -(v41 * v796);
            while (1)
            {
              v424 = v866[0];
              v425 = v65;
              do
              {
                if (v42)
                {
                  v426 = *v63;
                  if (!*v63)
                    goto LABEL_755;
                  if ((_DWORD)v59)
                    goto LABEL_750;
                }
                else
                {
                  v426 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_750:
                    if (*v62)
                    {
                      v427 = PDAlightenPDA_5209(*v69, *v62, *v55, v426, v4, v5, v6, v7, v8, v9);
                      v65 = v425;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v427;
                      *v62 = BYTE4(v427);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v426;
                    }
                    goto LABEL_755;
                  }
                }
                v428 = PDAlightenPDA_5209(*v69, 0xFFu, *v55, v426, v4, v5, v6, v7, v8, v9);
                v65 = v425;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v428;
LABEL_755:
                v62 += *(_QWORD *)v811;
                v429 = &v55[v793];
                if ((unint64_t)v429 >= v65)
                  v430 = -(uint64_t)v797;
                else
                  v430 = 0;
                v55 = &v429[v430];
                v63 += v423 + v430;
                v69 += v793;
                --v424;
              }
              while (v424);
              if (v834)
              {
                v431 = &v838[v836];
                v41 = v800;
                v432 = (unint64_t)v431 >= v834;
                v433 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v431 < v834)
                  v433 = 0;
                v434 = &v431[v433];
                v435 = v65 + 4 * v433;
                v436 = v767;
                if (!v432)
                  v436 = 0;
                v65 = v435 + 4 * v836;
                v55 = v434;
                v838 = v434;
                v839 += v800 + v436;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 18:
            v794 = v11;
            *(_QWORD *)v812 = (int)v59;
            v437 = v42;
            v768 = -(v41 * v796);
            while (1)
            {
              v438 = v866[0];
              v439 = v65;
              do
              {
                if (v42)
                {
                  v440 = *v63;
                  if (!*v63)
                    goto LABEL_778;
                  if ((_DWORD)v59)
                    goto LABEL_773;
                }
                else
                {
                  v440 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_773:
                    if (*v62)
                    {
                      v441 = PDAcolordodgePDA_5211(*v69, *v62, *v55, v440);
                      v65 = v439;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v441;
                      *v62 = BYTE4(v441);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v440;
                    }
                    goto LABEL_778;
                  }
                }
                v442 = PDAcolordodgePDA_5211(*v69, 255, *v55, v440);
                v65 = v439;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v442;
LABEL_778:
                v62 += *(_QWORD *)v812;
                v443 = &v55[v793];
                if ((unint64_t)v443 >= v65)
                  v444 = -(uint64_t)v797;
                else
                  v444 = 0;
                v55 = &v443[v444];
                v63 += v437 + v444;
                v69 += v793;
                --v438;
              }
              while (v438);
              if (v834)
              {
                v445 = &v838[v836];
                v41 = v800;
                v446 = (unint64_t)v445 >= v834;
                v447 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v445 < v834)
                  v447 = 0;
                v448 = &v445[v447];
                v449 = v65 + 4 * v447;
                v450 = v768;
                if (!v446)
                  v450 = 0;
                v65 = v449 + 4 * v836;
                v55 = v448;
                v838 = v448;
                v839 += v800 + v450;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 19:
            v794 = v11;
            *(_QWORD *)v813 = (int)v59;
            v451 = v42;
            v769 = -(v41 * v796);
            while (1)
            {
              v452 = v866[0];
              v453 = v65;
              do
              {
                if (v42)
                {
                  v454 = *v63;
                  if (!*v63)
                    goto LABEL_801;
                  if ((_DWORD)v59)
                    goto LABEL_796;
                }
                else
                {
                  v454 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_796:
                    if (*v62)
                    {
                      v455 = PDAcolorburnPDA_5212(*v69, *v62, *v55, v454);
                      v65 = v453;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v455;
                      *v62 = BYTE4(v455);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v454;
                    }
                    goto LABEL_801;
                  }
                }
                v456 = PDAcolorburnPDA_5212(*v69, 255, *v55, v454);
                v65 = v453;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v456;
LABEL_801:
                v62 += *(_QWORD *)v813;
                v457 = &v55[v793];
                if ((unint64_t)v457 >= v65)
                  v458 = -(uint64_t)v797;
                else
                  v458 = 0;
                v55 = &v457[v458];
                v63 += v451 + v458;
                v69 += v793;
                --v452;
              }
              while (v452);
              if (v834)
              {
                v459 = &v838[v836];
                v41 = v800;
                v460 = (unint64_t)v459 >= v834;
                v461 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v459 < v834)
                  v461 = 0;
                v462 = &v459[v461];
                v463 = v65 + 4 * v461;
                v464 = v769;
                if (!v460)
                  v464 = 0;
                v65 = v463 + 4 * v836;
                v55 = v462;
                v838 = v462;
                v839 += v800 + v464;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 20:
            v794 = v11;
            *(_QWORD *)v814 = (int)v59;
            v465 = v42;
            v770 = -(v41 * v796);
            while (1)
            {
              v466 = v866[0];
              v467 = v65;
              do
              {
                if (v42)
                {
                  v468 = *v63;
                  if (!*v63)
                    goto LABEL_824;
                  if ((_DWORD)v59)
                    goto LABEL_819;
                }
                else
                {
                  v468 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_819:
                    if (*v62)
                    {
                      v469 = PDAsoftlightPDA_5214(*v69, *v62, *v55, v468);
                      v65 = v467;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v469;
                      *v62 = BYTE4(v469);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v468;
                    }
                    goto LABEL_824;
                  }
                }
                v470 = PDAsoftlightPDA_5214(*v69, 255, *v55, v468);
                v65 = v467;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v470;
LABEL_824:
                v62 += *(_QWORD *)v814;
                v471 = &v55[v793];
                if ((unint64_t)v471 >= v65)
                  v472 = -(uint64_t)v797;
                else
                  v472 = 0;
                v55 = &v471[v472];
                v63 += v465 + v472;
                v69 += v793;
                --v466;
              }
              while (v466);
              if (v834)
              {
                v473 = &v838[v836];
                v41 = v800;
                v474 = (unint64_t)v473 >= v834;
                v475 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v473 < v834)
                  v475 = 0;
                v476 = &v473[v475];
                v477 = v65 + 4 * v475;
                v478 = v770;
                if (!v474)
                  v478 = 0;
                v65 = v477 + 4 * v836;
                v55 = v476;
                v838 = v476;
                v839 += v800 + v478;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 21:
            v794 = v11;
            *(_QWORD *)v815 = (int)v59;
            v479 = v42;
            v771 = -(v41 * v796);
            while (1)
            {
              v480 = v866[0];
              v481 = v65;
              do
              {
                if (v42)
                {
                  v482 = *v63;
                  if (!*v63)
                    goto LABEL_847;
                  if ((_DWORD)v59)
                    goto LABEL_842;
                }
                else
                {
                  v482 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_842:
                    if (*v62)
                    {
                      v483 = PDAhardlightPDA_5213(*v69, *v62, *v55, v482);
                      v65 = v481;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v483;
                      *v62 = BYTE4(v483);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v482;
                    }
                    goto LABEL_847;
                  }
                }
                v484 = PDAhardlightPDA_5213(*v69, 255, *v55, v482);
                v65 = v481;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v484;
LABEL_847:
                v62 += *(_QWORD *)v815;
                v485 = &v55[v793];
                if ((unint64_t)v485 >= v65)
                  v486 = -(uint64_t)v797;
                else
                  v486 = 0;
                v55 = &v485[v486];
                v63 += v479 + v486;
                v69 += v793;
                --v480;
              }
              while (v480);
              if (v834)
              {
                v487 = &v838[v836];
                v41 = v800;
                v488 = (unint64_t)v487 >= v834;
                v489 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v487 < v834)
                  v489 = 0;
                v490 = &v487[v489];
                v491 = v65 + 4 * v489;
                v492 = v771;
                if (!v488)
                  v492 = 0;
                v65 = v491 + 4 * v836;
                v55 = v490;
                v838 = v490;
                v839 += v800 + v492;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 22:
            v794 = v11;
            *(_QWORD *)v816 = (int)v59;
            v493 = v42;
            v772 = -(v41 * v796);
            while (1)
            {
              v494 = v866[0];
              v495 = v65;
              do
              {
                if (v42)
                {
                  v496 = *v63;
                  if (!*v63)
                    goto LABEL_870;
                  if ((_DWORD)v59)
                    goto LABEL_865;
                }
                else
                {
                  v496 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_865:
                    if (*v62)
                    {
                      v497 = PDAdifferencePDA_5215(*v69, *v62, *v55, v496);
                      v65 = v495;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v497;
                      *v62 = BYTE4(v497);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v496;
                    }
                    goto LABEL_870;
                  }
                }
                v498 = PDAdifferencePDA_5215(*v69, 0xFFu, *v55, v496);
                v65 = v495;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v498;
LABEL_870:
                v62 += *(_QWORD *)v816;
                v499 = &v55[v793];
                if ((unint64_t)v499 >= v65)
                  v500 = -(uint64_t)v797;
                else
                  v500 = 0;
                v55 = &v499[v500];
                v63 += v493 + v500;
                v69 += v793;
                --v494;
              }
              while (v494);
              if (v834)
              {
                v501 = &v838[v836];
                v41 = v800;
                v502 = (unint64_t)v501 >= v834;
                v503 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v501 < v834)
                  v503 = 0;
                v504 = &v501[v503];
                v505 = v65 + 4 * v503;
                v506 = v772;
                if (!v502)
                  v506 = 0;
                v65 = v505 + 4 * v836;
                v55 = v504;
                v838 = v504;
                v839 += v800 + v506;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 23:
            v794 = v11;
            *(_QWORD *)v817 = (int)v59;
            v507 = v42;
            v773 = -(v41 * v796);
            while (1)
            {
              v508 = v866[0];
              v509 = v65;
              do
              {
                if (v42)
                {
                  v510 = *v63;
                  if (!*v63)
                    goto LABEL_893;
                  if ((_DWORD)v59)
                    goto LABEL_888;
                }
                else
                {
                  v510 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_888:
                    if (*v62)
                    {
                      v511 = PDAexclusionPDA_5216(*v69, *v62, *v55, v510);
                      v65 = v509;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v511;
                      *v62 = BYTE4(v511);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v510;
                    }
                    goto LABEL_893;
                  }
                }
                v512 = PDAexclusionPDA_5216(*v69, 255, *v55, v510);
                v65 = v509;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v512;
LABEL_893:
                v62 += *(_QWORD *)v817;
                v513 = &v55[v793];
                if ((unint64_t)v513 >= v65)
                  v514 = -(uint64_t)v797;
                else
                  v514 = 0;
                v55 = &v513[v514];
                v63 += v507 + v514;
                v69 += v793;
                --v508;
              }
              while (v508);
              if (v834)
              {
                v515 = &v838[v836];
                v41 = v800;
                v516 = (unint64_t)v515 >= v834;
                v517 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v515 < v834)
                  v517 = 0;
                v518 = &v515[v517];
                v519 = v65 + 4 * v517;
                v520 = v773;
                if (!v516)
                  v520 = 0;
                v65 = v519 + 4 * v836;
                v55 = v518;
                v838 = v518;
                v839 += v800 + v520;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 24:
            v794 = v11;
            *(_QWORD *)v818 = (int)v59;
            v521 = v42;
            v774 = -(v41 * v796);
            while (1)
            {
              v522 = v866[0];
              v523 = v65;
              do
              {
                if (v42)
                {
                  v524 = *v63;
                  if (!*v63)
                    goto LABEL_916;
                  if ((_DWORD)v59)
                    goto LABEL_911;
                }
                else
                {
                  v524 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_911:
                    if (*v62)
                    {
                      v525 = PDAhuePDA_5217(*v69, *v62, *v55, v524);
                      v65 = v523;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v525;
                      *v62 = BYTE4(v525);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v524;
                    }
                    goto LABEL_916;
                  }
                }
                v526 = PDAhuePDA_5217(*v69, 255, *v55, v524);
                v65 = v523;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v526;
LABEL_916:
                v62 += *(_QWORD *)v818;
                v527 = &v55[v793];
                if ((unint64_t)v527 >= v65)
                  v528 = -(uint64_t)v797;
                else
                  v528 = 0;
                v55 = &v527[v528];
                v63 += v521 + v528;
                v69 += v793;
                --v522;
              }
              while (v522);
              if (v834)
              {
                v529 = &v838[v836];
                v41 = v800;
                v530 = (unint64_t)v529 >= v834;
                v531 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v529 < v834)
                  v531 = 0;
                v532 = &v529[v531];
                v533 = v65 + 4 * v531;
                v534 = v774;
                if (!v530)
                  v534 = 0;
                v65 = v533 + 4 * v836;
                v55 = v532;
                v838 = v532;
                v839 += v800 + v534;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 25:
            v794 = v11;
            *(_QWORD *)v819 = (int)v59;
            v535 = v42;
            v775 = -(v41 * v796);
            while (1)
            {
              v536 = v866[0];
              v537 = v65;
              do
              {
                if (v42)
                {
                  v538 = *v63;
                  if (!*v63)
                    goto LABEL_939;
                  if ((_DWORD)v59)
                    goto LABEL_934;
                }
                else
                {
                  v538 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_934:
                    if (*v62)
                    {
                      v539 = PDAsaturationPDA_5218(*v69, *v62, *v55, v538);
                      v65 = v537;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v539;
                      *v62 = BYTE4(v539);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v538;
                    }
                    goto LABEL_939;
                  }
                }
                v540 = PDAsaturationPDA_5218(*v69, 255, *v55, v538);
                v65 = v537;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v540;
LABEL_939:
                v62 += *(_QWORD *)v819;
                v541 = &v55[v793];
                if ((unint64_t)v541 >= v65)
                  v542 = -(uint64_t)v797;
                else
                  v542 = 0;
                v55 = &v541[v542];
                v63 += v535 + v542;
                v69 += v793;
                --v536;
              }
              while (v536);
              if (v834)
              {
                v543 = &v838[v836];
                v41 = v800;
                v544 = (unint64_t)v543 >= v834;
                v545 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v543 < v834)
                  v545 = 0;
                v546 = &v543[v545];
                v547 = v65 + 4 * v545;
                v548 = v775;
                if (!v544)
                  v548 = 0;
                v65 = v547 + 4 * v836;
                v55 = v546;
                v838 = v546;
                v839 += v800 + v548;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 26:
            v794 = v11;
            *(_QWORD *)v820 = (int)v59;
            v549 = v42;
            v776 = -(v41 * v796);
            while (1)
            {
              v550 = v866[0];
              v551 = v65;
              do
              {
                if (v42)
                {
                  v552 = *v63;
                  if (!*v63)
                    goto LABEL_962;
                  if ((_DWORD)v59)
                    goto LABEL_957;
                }
                else
                {
                  v552 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_957:
                    v553 = *v55;
                    if (*v62)
                    {
                      v554 = PDAluminosityPDA_5219(v553, v552, *v69, *v62);
                      v65 = v551;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v554;
                      *v62 = BYTE4(v554);
                    }
                    else
                    {
                      *v69 = v553;
                      *v62 = v552;
                    }
                    goto LABEL_962;
                  }
                }
                v555 = PDAluminosityPDA_5219(*v55, v552, *v69, 255);
                v65 = v551;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v555;
LABEL_962:
                v62 += *(_QWORD *)v820;
                v556 = &v55[v793];
                if ((unint64_t)v556 >= v65)
                  v557 = -(uint64_t)v797;
                else
                  v557 = 0;
                v55 = &v556[v557];
                v63 += v549 + v557;
                v69 += v793;
                --v550;
              }
              while (v550);
              if (v834)
              {
                v558 = &v838[v836];
                v41 = v800;
                v559 = (unint64_t)v558 >= v834;
                v560 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v558 < v834)
                  v560 = 0;
                v561 = &v558[v560];
                v562 = v65 + 4 * v560;
                v563 = v776;
                if (!v559)
                  v563 = 0;
                v65 = v562 + 4 * v836;
                v55 = v561;
                v838 = v561;
                v839 += v800 + v563;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 27:
            v794 = v11;
            *(_QWORD *)v821 = (int)v59;
            v564 = v42;
            v777 = -(v41 * v796);
            while (1)
            {
              v565 = v866[0];
              v566 = v65;
              do
              {
                if (v42)
                {
                  v567 = *v63;
                  if (!*v63)
                    goto LABEL_985;
                  if ((_DWORD)v59)
                    goto LABEL_980;
                }
                else
                {
                  v567 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_980:
                    if (*v62)
                    {
                      v568 = PDAluminosityPDA_5219(*v69, *v62, *v55, v567);
                      v65 = v566;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v568;
                      *v62 = BYTE4(v568);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v567;
                    }
                    goto LABEL_985;
                  }
                }
                v569 = PDAluminosityPDA_5219(*v69, 255, *v55, v567);
                v65 = v566;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v569;
LABEL_985:
                v62 += *(_QWORD *)v821;
                v570 = &v55[v793];
                if ((unint64_t)v570 >= v65)
                  v571 = -(uint64_t)v797;
                else
                  v571 = 0;
                v55 = &v570[v571];
                v63 += v564 + v571;
                v69 += v793;
                --v565;
              }
              while (v565);
              if (v834)
              {
                v572 = &v838[v836];
                v41 = v800;
                v573 = (unint64_t)v572 >= v834;
                v574 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v572 < v834)
                  v574 = 0;
                v575 = &v572[v574];
                v576 = v65 + 4 * v574;
                v577 = v777;
                if (!v573)
                  v577 = 0;
                v65 = v576 + 4 * v836;
                v55 = v575;
                v838 = v575;
                v839 += v800 + v577;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 28:
            v794 = v11;
            *(_QWORD *)v822 = (int)v59;
            v578 = v42;
            v778 = -(v41 * v796);
            while (1)
            {
              v579 = v866[0];
              v580 = v65;
              do
              {
                if (v42)
                {
                  v581 = *v63;
                  if (!*v63)
                    goto LABEL_1008;
                  if ((_DWORD)v59)
                    goto LABEL_1003;
                }
                else
                {
                  v581 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_1003:
                    if (*v62)
                    {
                      v582 = PDAtranspose_huePDA(*v69, *v62, *v55, v581);
                      v65 = v580;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v582;
                      *v62 = BYTE4(v582);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v581;
                    }
                    goto LABEL_1008;
                  }
                }
                v583 = PDAtranspose_huePDA(*v69, 255, *v55, v581);
                v65 = v580;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v583;
LABEL_1008:
                v62 += *(_QWORD *)v822;
                v584 = &v55[v793];
                if ((unint64_t)v584 >= v65)
                  v585 = -(uint64_t)v797;
                else
                  v585 = 0;
                v55 = &v584[v585];
                v63 += v578 + v585;
                v69 += v793;
                --v579;
              }
              while (v579);
              if (v834)
              {
                v586 = &v838[v836];
                v41 = v800;
                v587 = (unint64_t)v586 >= v834;
                v588 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v586 < v834)
                  v588 = 0;
                v589 = &v586[v588];
                v590 = v65 + 4 * v588;
                v591 = v778;
                if (!v587)
                  v591 = 0;
                v65 = v590 + 4 * v836;
                v55 = v589;
                v838 = v589;
                v839 += v800 + v591;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 29:
            v794 = v11;
            *(_QWORD *)v823 = (int)v59;
            v592 = v42;
            v779 = -(v41 * v796);
            while (1)
            {
              v593 = v866[0];
              v594 = v65;
              do
              {
                if (v42)
                {
                  v595 = *v63;
                  if (!*v63)
                    goto LABEL_1031;
                  if ((_DWORD)v59)
                    goto LABEL_1026;
                }
                else
                {
                  v595 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_1026:
                    if (*v62)
                    {
                      v596 = PDAtranspose_saturationPDA(*v69, *v62, *v55, v595);
                      v65 = v594;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v596;
                      *v62 = BYTE4(v596);
                    }
                    else
                    {
                      *v69 = *v55;
                      *v62 = v595;
                    }
                    goto LABEL_1031;
                  }
                }
                v597 = PDAtranspose_saturationPDA(*v69, 255, *v55, v595);
                v65 = v594;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v597;
LABEL_1031:
                v62 += *(_QWORD *)v823;
                v598 = &v55[v793];
                if ((unint64_t)v598 >= v65)
                  v599 = -(uint64_t)v797;
                else
                  v599 = 0;
                v55 = &v598[v599];
                v63 += v592 + v599;
                v69 += v793;
                --v593;
              }
              while (v593);
              if (v834)
              {
                v600 = &v838[v836];
                v41 = v800;
                v601 = (unint64_t)v600 >= v834;
                v602 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v600 < v834)
                  v602 = 0;
                v603 = &v600[v602];
                v604 = v65 + 4 * v602;
                v605 = v779;
                if (!v601)
                  v605 = 0;
                v65 = v604 + 4 * v836;
                v55 = v603;
                v838 = v603;
                v839 += v800 + v605;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 30:
            v794 = v11;
            *(_QWORD *)v824 = (int)v59;
            v606 = v42;
            v780 = -(v41 * v796);
            while (1)
            {
              v607 = v866[0];
              v608 = v65;
              do
              {
                if (v42)
                {
                  v609 = *v63;
                  if (!*v63)
                    goto LABEL_1054;
                  if ((_DWORD)v59)
                    goto LABEL_1049;
                }
                else
                {
                  v609 = 255;
                  if ((_DWORD)v59)
                  {
LABEL_1049:
                    v610 = *v55;
                    if (*v62)
                    {
                      v611 = PDAtranspose_luminosityPDA(v610, v609, *v69, *v62);
                      v65 = v608;
                      LODWORD(v59) = v850;
                      v42 = v854;
                      *v69 = v611;
                      *v62 = BYTE4(v611);
                    }
                    else
                    {
                      *v69 = v610;
                      *v62 = v609;
                    }
                    goto LABEL_1054;
                  }
                }
                v612 = PDAtranspose_luminosityPDA(*v55, v609, *v69, 255);
                v65 = v608;
                LODWORD(v59) = v850;
                v42 = v854;
                *v69 = v612;
LABEL_1054:
                v62 += *(_QWORD *)v824;
                v613 = &v55[v793];
                if ((unint64_t)v613 >= v65)
                  v614 = -(uint64_t)v797;
                else
                  v614 = 0;
                v55 = &v613[v614];
                v63 += v606 + v614;
                v69 += v793;
                --v607;
              }
              while (v607);
              if (v834)
              {
                v615 = &v838[v836];
                v41 = v800;
                v616 = (unint64_t)v615 >= v834;
                v617 = -(uint64_t)(v836 * v796);
                if ((unint64_t)v615 < v834)
                  v617 = 0;
                v618 = &v615[v617];
                v619 = v65 + 4 * v617;
                v620 = v780;
                if (!v616)
                  v620 = 0;
                v65 = v619 + 4 * v836;
                v55 = v618;
                v838 = v618;
                v839 += v800 + v620;
                v63 = (unsigned __int8 *)v839;
              }
              else
              {
                v55 += v836;
                v41 = v800;
                v63 += v800;
              }
              v69 += v802;
              v62 += v832;
              if (!--v856[0])
                goto LABEL_1089;
            }
          case 31:
            v794 = v11;
            *(_QWORD *)v825 = (int)v59;
            v621 = v42;
            v781 = -(v41 * v796);
            break;
          default:
            goto LABEL_1292;
        }
        break;
      }
LABEL_1068:
      v622 = v866[0];
      v623 = v65;
      while (1)
      {
        if (v42)
        {
          v624 = *v63;
          if (!*v63)
            goto LABEL_1077;
          if (!(_DWORD)v59)
            goto LABEL_1075;
        }
        else
        {
          v624 = 255;
          if (!(_DWORD)v59)
          {
LABEL_1075:
            v626 = PDAtranspose_luminosityPDA(*v69, 255, *v55, v624);
            v65 = v623;
            LODWORD(v59) = v850;
            v42 = v854;
            *v69 = v626;
            goto LABEL_1077;
          }
        }
        if (*v62)
        {
          v625 = PDAtranspose_luminosityPDA(*v69, *v62, *v55, v624);
          v65 = v623;
          LODWORD(v59) = v850;
          v42 = v854;
          *v69 = v625;
          *v62 = BYTE4(v625);
        }
        else
        {
          *v69 = *v55;
          *v62 = v624;
        }
LABEL_1077:
        v62 += *(_QWORD *)v825;
        v627 = &v55[v793];
        if ((unint64_t)v627 >= v65)
          v628 = -(uint64_t)v797;
        else
          v628 = 0;
        v55 = &v627[v628];
        v63 += v621 + v628;
        v69 += v793;
        if (!--v622)
        {
          if (v834)
          {
            v629 = &v838[v836];
            v41 = v800;
            v630 = (unint64_t)v629 >= v834;
            v631 = -(uint64_t)(v836 * v796);
            if ((unint64_t)v629 < v834)
              v631 = 0;
            v632 = &v629[v631];
            v633 = v65 + 4 * v631;
            v634 = v781;
            if (!v630)
              v634 = 0;
            v65 = v633 + 4 * v836;
            v55 = v632;
            v838 = v632;
            v839 += v800 + v634;
            v63 = (unsigned __int8 *)v839;
          }
          else
          {
            v55 += v836;
            v41 = v800;
            v63 += v800;
          }
          v69 += v802;
          v62 += v832;
          if (!--v856[0])
            goto LABEL_1089;
          goto LABEL_1068;
        }
      }
    }
    v793 = v57;
    v64 = v57 * (int)v16;
    v59 = v850;
    v832 = v790 - (int)v850 * (int)v16;
    v65 = -1;
    v796 = v41;
    v797 = v40;
    goto LABEL_65;
  }
  v21 = *(_DWORD *)(v15 + 128);
  if ((v21 | 8) == 8)
  {
    if ((v10 & 0xFF00) == 0x400)
      cmyk32_mark_constmask(v15, v13);
    else
      cmyk32_mark_pixelmask(v15, v13);
    return 1;
  }
  v28 = *(_DWORD *)(v15 + 112);
  v29 = *(_DWORD *)(v15 + 116);
  v30 = (v28 + 15) & 0xFFFFFFF0;
  v31 = v30 * v29;
  if ((int)v31 <= 4096)
  {
    v33 = v866;
    goto LABEL_41;
  }
  v32 = malloc_type_malloc(v31, 0x8303D2FuLL);
  if (v32)
  {
    v33 = v32;
    v20 = *(uint16x4_t **)(v15 + 136);
    v21 = *(_DWORD *)(v15 + 128);
LABEL_41:
    CGSConvertBitsToMask(v20, *(_DWORD *)(v15 + 124), v33, v30, v28, v29, v21);
    v49 = *(_OWORD *)(v15 + 112);
    v862 = *(_OWORD *)(v15 + 96);
    v863 = v49;
    v50 = *(_OWORD *)(v15 + 144);
    v864 = *(_OWORD *)(v15 + 128);
    v865 = v50;
    v51 = *(_OWORD *)(v15 + 48);
    v858 = *(_OWORD *)(v15 + 32);
    v859 = v51;
    v52 = *(_OWORD *)(v15 + 80);
    v860 = *(_OWORD *)(v15 + 64);
    v861 = v52;
    v53 = *(_OWORD *)(v15 + 16);
    *(_OWORD *)v856 = *(_OWORD *)v15;
    v857 = v53;
    HIDWORD(v863) = (v28 + 15) & 0xFFFFFFF0;
    *((_QWORD *)&v864 + 1) = v33;
    if (BYTE1(v856[0]) << 8 == 1024)
      cmyk32_mark_constmask((uint64_t)v856, v13);
    else
      cmyk32_mark_pixelmask((unint64_t)v856, v13);
    if (v33 == (_BYTE *)v866)
      return 1;
    v54 = v33;
    goto LABEL_1120;
  }
  return 1;
}

uint64_t cmyk32_image(uint64_t *a1, unsigned __int8 *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL4 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  unsigned int v19;
  unsigned int v20;
  char v21;
  int v22;
  int v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;
  int v27;
  int v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _OWORD v46[64];
  uint64_t v47;

  v47 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v44 = 0u;
  v45 = 0u;
  v42 = 0u;
  v43 = 0u;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v29 = 0u;
  memset(v46, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*(_QWORD *)(v6 + 56) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v29, (uint64_t)v46) < 1)
    return 0xFFFFFFFFLL;
  v18 = 134759444;
  v19 = *(_DWORD *)a3;
  *((_QWORD *)&v29 + 1) = __PAIR64__(*(_DWORD *)v6, *(_DWORD *)a3);
  if (v19 != 134759444)
  {
    v20 = SAMPLEINDEX(v19, v10, v11, v12, v13, v14, v15, v16);
    if (v20)
    {
      if (v20 > 0xB)
      {
LABEL_20:
        v22 = 255;
        v21 = 1;
      }
      else
      {
        v21 = 0;
        v22 = 0;
        switch(v20)
        {
          case 2u:
            if (*((_QWORD *)a2 + 12))
              goto LABEL_20;
            v21 = 0;
            v22 = 16;
            break;
          case 5u:
            v21 = 0;
            v22 = 24;
            break;
          case 6u:
            break;
          case 7u:
            v21 = 0;
            v22 = 32;
            break;
          case 8u:
            v21 = 0;
            v22 = 8;
            break;
          case 9u:
            v21 = 0;
            v22 = 40;
            break;
          default:
            goto LABEL_20;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYK8_image_sample[2 * v20 + 2];
      if ((_QWORD)v29)
      {
LABEL_28:
        DWORD2(v29) = v18;
        if ((v21 & 1) == 0
          && (v8 - 1) <= 1
          && (BYTE4(v30) & 7) == 3
          && (a2[2] == 5 || !a2[2])
          && v20 <= 0xB)
        {
          HIDWORD(v24) = v22;
          LODWORD(v24) = v22;
          switch((v24 >> 3))
          {
            case 0u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_RGB32;
              goto LABEL_51;
            case 1u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_RGB32;
              goto LABEL_53;
            case 2u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_W8;
              goto LABEL_51;
            case 3u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_RGB24;
              goto LABEL_51;
            case 4u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_rgb32;
LABEL_51:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 0;
              break;
            case 5u:
              DWORD2(v29) = *(_DWORD *)a3;
              v25 = cmyk32_image_mark_rgb32;
LABEL_53:
              v26 = (uint64_t)a2;
              v27 = v8;
              v28 = 8;
              break;
            default:
              goto LABEL_29;
          }
          cmyk32_image_mark_image(v26, (uint64_t)&v29, v27, v28, (void (*)(_QWORD, _QWORD))v25);
          return 1;
        }
        goto LABEL_29;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
      {
        *(_QWORD *)&v29 = *(_QWORD *)&CMYK16_image_sample[2 * v20 + 2];
        if ((_QWORD)v29)
        {
          v18 = 269501476;
          v23 = 16;
LABEL_27:
          LODWORD(v30) = v23;
          goto LABEL_28;
        }
      }
      *(_QWORD *)&v29 = *(_QWORD *)&CMYKF_image_sample[2 * v20 + 2];
      if ((_QWORD)v29)
      {
        v18 = 538985509;
        v23 = 20;
        goto LABEL_27;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v40 && (~DWORD1(v30) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v30) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk32_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v29 = cmyk32_sample_cmyk32;
LABEL_29:
  cmyk32_image_mark((uint64_t)a2, (uint64_t)&v29, v8, v17);
  return 1;
}

uint64_t cmyk32_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = cmyk32_shade_radial_CMYK;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = cmyk32_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = cmyk32_shade_axial_CMYK;
    }
    else
    {
      v14 = cmyk32_shade_custom_CMYK;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 384)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_27:
      _blt_shade_samples_16((uint64_t)v16, 2, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_29;
    }
    v16 = malloc_type_malloc(10 * v15 + 32, 0x54320A8DuLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_27;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_29:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void cmyk32_shade_radial_CMYK(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  int8x16_t v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  float v21;
  char *v22;
  int8x16_t *v23;
  uint64_t v24;
  unsigned __int16 *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  uint64_t v32;
  int v33;
  int v34;
  float v35;
  float v36;
  int v37;
  int v38;
  float v39;
  float v40;
  float v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  float v54;
  BOOL v55;
  float v56;
  BOOL v57;
  int v58;
  float v59;
  unsigned __int16 *v60;
  int v61;
  unsigned __int16 v62;
  unsigned __int16 v63;
  int v64;
  int v65;
  unsigned __int16 v66;
  char v67;
  float v68;
  float v69;
  float v70;
  unsigned __int16 *v71;
  int v72;
  float v73;
  float v74;
  float v75;
  float v77;
  float v78;
  float v79;
  int v80;
  int v81;
  uint64_t v83;
  int v84;
  int v85;
  unsigned __int16 v86;
  unsigned __int16 v87;
  unsigned __int16 v88;
  unsigned __int16 *v89;
  unsigned __int16 *v90;
  int v91;
  int v92;
  unsigned __int16 v93;
  unsigned __int16 v94;
  unsigned __int16 v95;
  int v96;
  int v97;
  unsigned __int16 v98;
  __int16 v99;
  int v100;
  int v101;
  int v102;
  unsigned __int16 v103;
  __int16 v104;
  __int16 v105;
  unint64_t v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  unsigned __int16 v111;
  __int16 v112;
  __int16 v113;
  int v114;
  char v115;
  char v116;
  unsigned __int16 *v117;
  int v118;
  unsigned __int16 v119;
  unsigned __int16 v120;
  int v121;
  int v122;
  unsigned __int16 v123;
  uint64_t v124;
  unsigned __int16 *v125;
  unsigned __int16 v126;
  unsigned __int16 v127;
  int v128;
  unsigned __int16 v129;
  int v130;
  unsigned __int16 *v131;
  unsigned __int16 *v132;
  int32x2_t v133;
  int32x2_t v134;
  int32x2_t v135;
  int32x2_t v136;
  int32x2_t v137;
  int v138;
  int32x2_t v139;
  int32x2_t v140;
  int8x8_t v141;
  uint32x2_t v142;
  int32x2_t v143;
  int8x16_t v144;
  int8x16_t v145;
  int8x8_t v146;
  int8x16_t v147;
  int8x8_t v148;
  int8x16_t v149;
  int8x16_t v150;
  int32x2_t v151;
  int8x8_t v152;
  uint32x2_t v153;
  int8x16_t v154;
  int8x16_t v155;
  int8x8_t v156;
  int8x16_t v157;

  v5 = *(float *)(a1 + 280);
  v6 = *(float *)(a1 + 284);
  v7 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v8 = v7 * (float)(uint64_t)a2;
  v9 = v7 * (float)(uint64_t)a3;
  v10 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v9) + (float)(v5 * v8));
  v11 = *(float *)(a1 + 300) + (float)((float)(v9 * *(float *)(a1 + 292)) + (float)(v6 * v8));
  v13 = *(_QWORD *)(a1 + 400);
  v14 = *(float *)(a1 + 336);
  v15 = *(float *)(a1 + 344);
  v16 = *(float *)(a1 + 304);
  v17 = *(float *)(a1 + 308);
  v18 = *(_DWORD *)(a1 + 324);
  v19 = *(float *)(v13 + 8);
  v20 = *(float *)(v13 + 16);
  v4.i32[0] = *(_DWORD *)(v13 + 20);
  v21 = *(float *)(v13 + 28);
  v24 = a1 + 144;
  v22 = *(char **)(a1 + 144);
  v23 = *(int8x16_t **)(v24 + 8);
  v25 = *(unsigned __int16 **)(a1 + 376);
  v26 = *(_QWORD *)(a1 + 360);
  v27 = (a2 >> 8) & 0xF;
  if (v19 != 0.0 || v21 != 0.0 || v6 != 0.0)
  {
    v38 = *(_DWORD *)(a1 + 320);
    v39 = *(float *)(v13 + 12);
    v40 = *(float *)(v13 + 24);
    v41 = *(float *)(v13 + 32);
    v42 = a1 + 368;
    v43 = *(_QWORD *)(a1 + 368);
    v44 = v43 + ((a3 >> 4) & 0xF0);
    v31 = v43 == 0;
    v45 = 15;
    if (v31)
    {
      v45 = 0;
      v27 = 0;
    }
    else
    {
      v42 = v44;
    }
    v46 = -v40;
    v47 = v17 - v16;
    while (1)
    {
      v48 = v46 + (float)((float)(v10 + v10) * v19);
      v49 = (float)((float)(v11 * v11) + (float)(v10 * v10)) - v21;
      if (*(float *)v4.i32 == 0.0)
      {
        v56 = v49 / v48;
      }
      else
      {
        v50 = (float)((float)(*(float *)v4.i32 * -4.0) * v49) + (float)(v48 * v48);
        if (v50 < 0.0)
          goto LABEL_51;
        v51 = sqrtf(v50);
        v52 = v41 * (float)(v48 - v51);
        v53 = v48 + v51;
        v54 = v41 * v53;
        v55 = (float)(v41 * v53) <= v52;
        if ((float)(v41 * v53) <= v52)
          v56 = v41 * v53;
        else
          v56 = v52;
        if (v55)
          v54 = v52;
        if (v54 < 0.0)
        {
          v57 = v54 < v39;
LABEL_37:
          v58 = v38;
          if (v57)
            goto LABEL_51;
LABEL_38:
          if ((v58 & 0x80000000) == 0)
            goto LABEL_50;
          goto LABEL_51;
        }
        if (v54 <= 1.0)
        {
          v59 = v16 + (float)(v54 * v47);
          goto LABEL_49;
        }
        if ((v18 & 0x80000000) == 0)
        {
          v58 = v18;
          if (v54 <= v20)
          {
LABEL_50:
            v60 = (unsigned __int16 *)(v26 + 10 * v58);
            v61 = v60[1];
            v62 = v60[2];
            v63 = v60[3];
            v64 = *(unsigned __int8 *)(v42 + v27);
            v65 = v64 + *v60;
            v66 = v60[4];
            goto LABEL_53;
          }
        }
      }
      if (v56 < 0.0)
      {
        v57 = v56 < v39;
        goto LABEL_37;
      }
      if (v56 > 1.0)
      {
        v58 = v18;
        if (v56 > v20)
          goto LABEL_51;
        goto LABEL_38;
      }
      v59 = v16 + (float)(v56 * v47);
LABEL_49:
      v58 = (int)(float)(v15 * (float)(v59 - v14));
      if ((v58 & 0x80000000) == 0)
        goto LABEL_50;
LABEL_51:
      if (!v25)
      {
        v67 = 0;
        goto LABEL_55;
      }
      v61 = v25[1];
      v62 = v25[2];
      v63 = v25[3];
      v64 = *(unsigned __int8 *)(v42 + v27);
      v65 = v64 + *v25;
      v66 = v25[4];
LABEL_53:
      v23->i64[0] = (v65 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v64 + v66) & 0xFF00) >> 8) << 32) | ((v64 + v61) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v64 + v62) & 0xFF00) | ((unsigned __int16)(v64 + v63) >> 8);
      v67 = -1;
LABEL_55:
      v27 = ((_DWORD)v27 + 1) & v45;
      v10 = v5 + v10;
      v11 = v6 + v11;
      v23 = (int8x16_t *)((char *)v23 + 8);
      *v22++ = v67;
      if (!--a4)
        return;
    }
  }
  v28 = a1 + 368;
  v29 = *(_QWORD *)(a1 + 368);
  LODWORD(v30) = (BYTE1(a2) + 1) & 0xF;
  v31 = v29 == 0;
  if (v29)
    v32 = v29 + ((a3 >> 4) & 0xF0);
  else
    v32 = v28;
  if (v31)
  {
    LODWORD(v30) = 0;
    v33 = 0;
  }
  else
  {
    v33 = (a2 >> 8) & 0xF;
  }
  if (v31)
    v34 = 0;
  else
    v34 = 15;
  v35 = v11 * v11;
  v36 = -*(float *)v4.i32;
  if (v35 <= (float)-*(float *)v4.i32)
  {
    v68 = fabsf(*(float *)(v13 + 32));
    v69 = *(float *)v4.i32 * -4.0;
    v70 = v17 - v16;
    v71 = (unsigned __int16 *)(v26 + 10 * v18);
    v72 = a4 + 2;
    while (1)
    {
      v73 = v35 + (float)(v10 * v10);
      v74 = v5 + v10;
      v75 = v35 + (float)(v74 * v74);
      if (v73 > v36 && v75 > v36)
      {
        if (v18 < 0)
        {
          if (!v25)
          {
            v116 = 0;
            v115 = 0;
            goto LABEL_79;
          }
          v84 = *v25;
          v85 = v25[1];
          v86 = v25[2];
          v87 = v25[3];
          v88 = v25[4];
        }
        else
        {
          v84 = *v71;
          v85 = v71[1];
          v86 = v71[2];
          v87 = v71[3];
          v88 = v71[4];
        }
        v108 = *(unsigned __int8 *)(v32 + v33);
        v109 = v108 + v84;
        v110 = v108 + v85;
        v111 = v108 + v86;
        v112 = v108 + v87;
        v113 = v108 + v88;
        v114 = *(unsigned __int8 *)(v32 + v30);
        v101 = v114 + v84;
        v102 = v114 + v85;
        v103 = v114 + v86;
        v104 = v114 + v87;
        v105 = v114 + v88;
        v106 = (v109 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v113 & 0xFF00) >> 8) << 32) | (v110 << 8) & 0xFF0000 | (unint64_t)(v111 & 0xFF00);
        v107 = HIBYTE(v112);
        goto LABEL_77;
      }
      v77 = sqrtf(v69 * v75);
      v78 = v68 * sqrtf(v69 * v73);
      v79 = v68 * v77;
      v80 = (int)(float)(v15 * (float)((float)(v16 + (float)(v78 * v70)) - v14));
      v81 = (int)(float)(v15 * (float)((float)(v16 + (float)((float)(v68 * v77) * v70)) - v14));
      if (v78 <= 1.0 && v79 <= 1.0)
      {
        v89 = (unsigned __int16 *)(v26 + 10 * v80);
        v90 = (unsigned __int16 *)(v26 + 10 * v81);
        v91 = *v90;
        v92 = v90[1];
        v93 = v90[2];
        v94 = v90[3];
        v95 = v90[4];
        LODWORD(v90) = *(unsigned __int8 *)(v32 + v33);
        v96 = (_DWORD)v90 + *v89;
        v97 = (_DWORD)v90 + v89[1];
        v98 = (_WORD)v90 + v89[2];
        v99 = (_WORD)v90 + v89[3];
        LOWORD(v89) = (_WORD)v90 + v89[4];
        v100 = *(unsigned __int8 *)(v32 + v30);
        v101 = v100 + v91;
        v102 = v100 + v92;
        v103 = v100 + v93;
        v104 = v100 + v94;
        v105 = v100 + v95;
        v106 = (v96 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((unsigned __int16)v89 & 0xFF00) >> 8) << 32) | (v97 << 8) & 0xFF0000 | (unint64_t)(v98 & 0xFF00);
        v107 = HIBYTE(v99);
LABEL_77:
        v23->i64[0] = v106 | v107;
        v115 = -1;
        goto LABEL_78;
      }
      if (v78 <= 1.0)
      {
        if ((v80 & 0x80000000) == 0)
        {
          v83 = 5 * v80;
LABEL_83:
          v117 = (unsigned __int16 *)(v26 + 2 * v83);
          v118 = v117[1];
          v119 = v117[2];
          v120 = v117[3];
          v121 = *(unsigned __int8 *)(v32 + v33);
          v122 = v121 + *v117;
          v123 = v117[4];
          goto LABEL_86;
        }
      }
      else if (v78 <= v20)
      {
        v83 = 5 * v18;
        if ((v18 & 0x80000000) == 0)
          goto LABEL_83;
      }
      if (!v25)
      {
        v115 = 0;
        goto LABEL_87;
      }
      v118 = v25[1];
      v119 = v25[2];
      v120 = v25[3];
      v121 = *(unsigned __int8 *)(v32 + v33);
      v122 = v121 + *v25;
      v123 = v25[4];
LABEL_86:
      v23->i64[0] = (v122 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v121 + v123) & 0xFF00) >> 8) << 32) | ((v121 + v118) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v121 + v119) & 0xFF00) | ((unsigned __int16)(v121 + v120) >> 8);
      v115 = -1;
LABEL_87:
      if (v79 <= 1.0)
      {
        if (v81 < 0)
          goto LABEL_94;
        v124 = 5 * v81;
      }
      else if (v79 > v20 || (v124 = 5 * v18, v18 < 0))
      {
LABEL_94:
        if (!v25)
        {
          v116 = 0;
          goto LABEL_79;
        }
        v130 = *(unsigned __int8 *)(v32 + v30);
        v101 = v130 + *v25;
        v102 = v130 + v25[1];
        v103 = v130 + v25[2];
        v104 = v130 + v25[3];
        v105 = v130 + v25[4];
        goto LABEL_78;
      }
      v125 = (unsigned __int16 *)(v26 + 2 * v124);
      v126 = v125[2];
      v127 = v125[3];
      v128 = *(unsigned __int8 *)(v32 + v30);
      v101 = v128 + *v125;
      v129 = v125[4];
      v102 = v128 + v125[1];
      v103 = v128 + v126;
      v104 = v128 + v127;
      v105 = v128 + v129;
LABEL_78:
      v23->i64[1] = (v101 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v105 & 0xFF00) >> 8) << 32) | (v102 << 8) & 0xFF0000 | (unint64_t)(v103 & 0xFF00) | HIBYTE(v104);
      v116 = -1;
LABEL_79:
      v10 = v5 + v74;
      LOBYTE(v33) = (v33 + 1) & v34;
      LOBYTE(v30) = (v30 + 1) & v34;
      ++v23;
      *v22 = v115;
      v22[1] = v116;
      v22 += 2;
      v72 -= 2;
      if (v72 <= 2)
        return;
    }
  }
  if (v25 || (v18 & 0x80000000) == 0)
  {
    v131 = (unsigned __int16 *)(v26 + 10 * v18);
    if (v18 >= 0)
      v132 = v131;
    else
      v132 = v25;
    v133 = vdup_n_s32(v132[4]);
    v134 = vdup_n_s32(*v132);
    v135 = vdup_n_s32(v132[1]);
    v136 = vdup_n_s32(v132[2]);
    v137 = vdup_n_s32(v132[3]);
    v138 = a4 + 4;
    do
    {
      v4.i8[0] = *(_BYTE *)(v32 + v33);
      v4.i8[4] = *(_BYTE *)(v32 + v30);
      v139 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
      v140 = vadd_s32(v135, v139);
      v141 = (int8x8_t)vadd_s32(v136, v139);
      v142 = (uint32x2_t)vadd_s32(v137, v139);
      v143 = vshl_n_s32(vadd_s32(v134, v139), 0x10uLL);
      v144.i64[0] = v143.i32[0] & 0xFF00FFFF;
      v144.i64[1] = v143.i32[1] & 0xFF00FFFF;
      v145 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v133, v139), (int8x8_t)0xFF000000FF00), 0x18uLL), v144);
      v146 = vand_s8((int8x8_t)vshl_n_s32(v140, 8uLL), (int8x8_t)0xFF000000FF0000);
      v144.i64[0] = v146.u32[0];
      v144.i64[1] = v146.u32[1];
      v147 = v144;
      v148 = vand_s8(v141, (int8x8_t)0xFF000000FF00);
      v144.i64[0] = v148.u32[0];
      v144.i64[1] = v148.u32[1];
      v149 = vorrq_s8(v145, vorrq_s8(v147, v144));
      *(uint32x2_t *)v147.i8 = vshr_n_u32(v142, 8uLL);
      v144.i64[0] = v147.i32[0] & 0xFFFFFEFF;
      v144.i64[1] = v147.i32[1] & 0xFFFFFEFF;
      v150 = vorrq_s8(v149, v144);
      *v23 = v150;
      v30 = ((_DWORD)v30 + 1) & v34;
      v150.i8[0] = *(_BYTE *)(v32 + ((v33 + 1) & v34));
      v150.i8[4] = *(_BYTE *)(v32 + v30);
      *(int8x8_t *)v150.i8 = vand_s8(*(int8x8_t *)v150.i8, (int8x8_t)0xFF000000FFLL);
      v151 = vadd_s32(v135, *(int32x2_t *)v150.i8);
      v152 = (int8x8_t)vadd_s32(v136, *(int32x2_t *)v150.i8);
      v153 = (uint32x2_t)vadd_s32(v137, *(int32x2_t *)v150.i8);
      *(int32x2_t *)v147.i8 = vshl_n_s32(vadd_s32(v134, *(int32x2_t *)v150.i8), 0x10uLL);
      v144.i64[0] = v147.i32[0] & 0xFF00FFFF;
      v144.i64[1] = v147.i32[1] & 0xFF00FFFF;
      v154 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v133, *(int32x2_t *)v150.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v144);
      *(int8x8_t *)v147.i8 = vand_s8((int8x8_t)vshl_n_s32(v151, 8uLL), (int8x8_t)0xFF000000FF0000);
      v144.i64[0] = v147.u32[0];
      v144.i64[1] = v147.u32[1];
      v155 = v144;
      v156 = vand_s8(v152, (int8x8_t)0xFF000000FF00);
      v144.i64[0] = v156.u32[0];
      v144.i64[1] = v156.u32[1];
      v157 = vorrq_s8(v154, vorrq_s8(v155, v144));
      *(uint32x2_t *)v155.i8 = vshr_n_u32(v153, 8uLL);
      v144.i64[0] = v155.i32[0] & 0xFFFFFEFF;
      v144.i64[1] = v155.i32[1] & 0xFFFFFEFF;
      *(_DWORD *)v22 = -1;
      v22 += 4;
      v138 -= 4;
      v4 = vorrq_s8(v157, v144);
      v23[1] = v4;
      v23 += 2;
      v33 = (v33 + 1) & v34;
    }
    while (v138 > 4);
  }
  else
  {
    if (a4 >= 4)
      v37 = 4;
    else
      v37 = a4;
    bzero(v22, ((a4 - v37 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t cmyk32_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v15;
  uint64_t v16;
  unint64_t *v17;
  _BYTE *v18;
  uint64_t v19;
  float v20;
  float v21;
  unsigned int v22;
  float v23;
  float v24;
  unsigned int v25;
  float v26;
  float v27;
  unsigned __int16 *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned __int16 *v33;
  int v34;
  int v35;
  uint64_t result;
  int v37;
  int v38;
  unsigned int v39;
  int v40;
  float v41;
  float v42;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  v9 = *(_QWORD *)(a1 + 368);
  if (v9)
    v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v10 = a1 + 368;
  if (v9)
    v11 = 15;
  else
    v11 = 0;
  v12 = *(float *)(a1 + 284);
  v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  v41 = *(float *)(a1 + 336);
  v42 = *(float *)(a1 + 304);
  v15 = *(float *)(a1 + 344);
  v16 = *(_QWORD *)(a1 + 360);
  v18 = *(_BYTE **)(a1 + 144);
  v17 = *(unint64_t **)(a1 + 152);
  if (v9)
    v19 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v19 = 0;
  v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    v21 = v15 * (float)((float)(v42 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v41);
    v22 = vcvtms_s32_f32(v21);
    v23 = ceilf(v21);
    v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0)
      v22 = v25;
    v26 = ceilf(v21 - v15);
    if (v21 <= v15)
      v27 = v23;
    else
      v27 = v26;
    v28 = (unsigned __int16 *)(v16 + 2 * (int)(5 * v22));
    v29 = *v28;
    v30 = v28[1];
    v31 = v28[2];
    v32 = v28[3];
    v33 = (unsigned __int16 *)(v16 + 10 * (int)v27);
    v34 = 255 - (int)v24;
    v35 = v33[1];
    result = v33[2];
    v37 = v33[3];
    LODWORD(v28) = v33[4] * (int)v24 + v34 * v28[4];
    LODWORD(v33) = (int)v24 * *v33 + v34 * v29;
    v38 = (int)v24 * v35 + v34 * v30;
    v39 = (int)v24 * result + v34 * v31;
    v40 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((v40 + (v33 >> 8)) << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v40 + (v28 >> 8)) & 0xFF00) >> 8) << 32) | (v38 + (v40 << 8)) & 0xFF0000 | (unint64_t)((unsigned __int16)(v40 + (v39 >> 8)) & 0xFF00) | ((unsigned __int16)(v40 + ((v37 * (int)v24 + v34 * v32) >> 8)) >> 8);
    v19 = ((_DWORD)v19 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

unint64_t cmyk32_shade_custom_CMYK(unint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  unsigned __int16 *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t *v26;
  char *v27;
  int v31;
  unsigned __int16 v32;
  unsigned __int16 v33;
  int v34;
  int v35;
  unsigned __int16 v36;
  unsigned __int16 *v37;
  int v38;
  char v39;

  v4 = *(float *)(result + 280);
  v5 = *(float *)(*(_QWORD *)(result + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  v9 = result + 368;
  v10 = *(_QWORD *)(result + 368);
  v11 = 15;
  if (v10)
    v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v11 = 0;
  v12 = *(float *)(result + 284);
  v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  v14 = *(float *)(result + 304);
  v15 = *(float *)(result + 308);
  v16 = *(float *)(result + 312);
  v17 = *(float *)(result + 316);
  v18 = *(float *)(result + 336);
  v19 = *(float *)(result + 348);
  v20 = *(float *)(result + 344);
  v21 = *(float *)(result + 356);
  v22 = *(unsigned __int16 **)(result + 376);
  v23 = *(_QWORD *)(result + 360);
  v24 = 5 * *(_DWORD *)(result + 48);
  if (v10)
    v25 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v25 = 0;
  v27 = *(char **)(result + 144);
  v26 = *(unint64_t **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      v37 = (unsigned __int16 *)(v23
                               + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19))
                               + 10 * (int)(float)(v20 * (float)(v8 - v18)));
      v31 = v37[1];
      v32 = v37[2];
      v33 = v37[3];
      v34 = *(unsigned __int8 *)(v9 + v25);
      v35 = v34 + *v37;
      v36 = v37[4];
      goto LABEL_21;
    }
    if (v22)
    {
      v31 = v22[1];
      v32 = v22[2];
      v33 = v22[3];
      v34 = *(unsigned __int8 *)(v9 + v25);
      v35 = v34 + *v22;
      v36 = v22[4];
LABEL_21:
      v38 = v34 + v31;
      result = (unsigned __int16)(v34 + v32) & 0xFF00;
      *v26 = (v35 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v34 + v36) & 0xFF00) >> 8) << 32) | (v38 << 8) & 0xFF0000 | result | ((unsigned __int16)(v34 + v33) >> 8);
      v39 = -1;
      goto LABEL_22;
    }
    v39 = 0;
LABEL_22:
    v25 = ((_DWORD)v25 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    ++v26;
    *v27++ = v39;
    --a4;
  }
  while (a4);
  return result;
}

void cmyk32_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int8x16_t v4;
  float v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  _DWORD *v20;
  int8x16_t *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned __int16 *v32;
  int v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  int v36;
  int v37;
  unsigned __int16 v38;
  char v39;
  unsigned __int16 *v40;
  unsigned __int16 *v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unint64_t v45;
  unsigned int v46;
  int32x2_t v47;
  int32x2_t v48;
  int v49;
  int32x2_t v50;
  int32x2_t v51;
  int32x2_t v52;
  int32x2_t v53;
  int32x2_t v54;
  int8x8_t v55;
  uint32x2_t v56;
  int32x2_t v57;
  int8x16_t v58;
  int8x16_t v59;
  int8x8_t v60;
  int8x16_t v61;
  int8x8_t v62;
  int8x16_t v63;
  int8x16_t v64;
  int32x2_t v65;
  int8x8_t v66;
  uint32x2_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x8_t v70;
  int8x16_t v71;
  unint64_t v72;
  int v73;

  v5 = *(float *)(a1 + 280);
  v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a2)));
  v7 = a1 + 368;
  v8 = *(_QWORD *)(a1 + 368);
  v9 = ((unint64_t)a3 >> 4) & 0xF0;
  v10 = v8 + v9;
  if (v8)
    v11 = v8 + v9;
  else
    v11 = a1 + 368;
  if (v8)
    v12 = 15;
  else
    v12 = 0;
  v14 = *(float *)(a1 + 336);
  v15 = *(float *)(a1 + 344);
  v16 = *(float *)(a1 + 304);
  v17 = *(float *)(a1 + 308);
  v18 = *(_DWORD *)(a1 + 320);
  v19 = *(_DWORD *)(a1 + 324);
  v22 = a1 + 144;
  v20 = *(_DWORD **)(a1 + 144);
  v21 = *(int8x16_t **)(v22 + 8);
  v23 = *(unsigned __int16 **)(a1 + 376);
  v24 = *(_QWORD *)(a1 + 360);
  if (v5 != 0.0)
  {
    if (v8)
      v30 = (a2 >> 8) & 0xF;
    else
      LOBYTE(v30) = 0;
    while (1)
    {
      v31 = v18;
      if (v6 >= v16)
      {
        v31 = v19;
        if (v6 <= v17)
          v31 = (int)(float)(v15 * (float)(v6 - v14));
      }
      if (v31 < 0)
      {
        if (!v23)
        {
          v39 = 0;
          goto LABEL_40;
        }
        v33 = v23[1];
        v34 = v23[2];
        v35 = v23[3];
        v36 = *(unsigned __int8 *)(v11 + v30);
        v37 = v36 + *v23;
        v38 = v23[4];
      }
      else
      {
        v32 = (unsigned __int16 *)(v24 + 10 * v31);
        v33 = v32[1];
        v34 = v32[2];
        v35 = v32[3];
        v36 = *(unsigned __int8 *)(v11 + v30);
        v37 = v36 + *v32;
        v38 = v32[4];
      }
      v21->i64[0] = (v37 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v36 + v38) & 0xFF00) >> 8) << 32) | ((v36 + v33) << 8) & 0xFF0000 | (unint64_t)((unsigned __int16)(v36 + v34) & 0xFF00) | ((unsigned __int16)(v36 + v35) >> 8);
      v39 = -1;
LABEL_40:
      LOBYTE(v30) = (v30 + 1) & v12;
      v6 = v5 + v6;
      v21 = (int8x16_t *)((char *)v21 + 8);
      *(_BYTE *)v20 = v39;
      v20 = (_DWORD *)((char *)v20 + 1);
      if (!--a4)
        return;
    }
  }
  if (v8)
    v25 = v10;
  else
    v25 = v7;
  if (v8)
    LODWORD(v26) = ((a2 >> 8) + 1) & 0xF;
  else
    LODWORD(v26) = 0;
  if (v8)
    v27 = (a2 >> 8) & 0xF;
  else
    v27 = 0;
  if (v8)
    v28 = 15;
  else
    v28 = 0;
  if (v6 >= v16)
  {
    v18 = v19;
    if (v6 <= v17)
      v18 = (int)(float)(v15 * (float)(v6 - v14));
  }
  if ((v18 & 0x80000000) == 0 || v23)
  {
    v40 = (unsigned __int16 *)(v24 + 10 * v18);
    if (v18 < 0)
      v41 = v23;
    else
      v41 = v40;
    v42 = *v41;
    v43 = v41[1];
    v44 = v41[2];
    v45 = v41[3];
    v46 = v41[4];
    if (v8)
    {
      v47 = vdup_n_s32(v42);
      v48 = vdup_n_s32(v43);
      v49 = a4 + 4;
      v50 = vdup_n_s32(v44);
      v51 = vdup_n_s32(v45);
      v52 = vdup_n_s32(v46);
      do
      {
        v4.i8[0] = *(_BYTE *)(v25 + v27);
        v4.i8[4] = *(_BYTE *)(v25 + v26);
        v53 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
        v54 = vadd_s32(v48, v53);
        v55 = (int8x8_t)vadd_s32(v50, v53);
        v56 = (uint32x2_t)vadd_s32(v51, v53);
        v57 = vshl_n_s32(vadd_s32(v47, v53), 0x10uLL);
        v58.i64[0] = v57.i32[0] & 0xFF00FFFF;
        v58.i64[1] = v57.i32[1] & 0xFF00FFFF;
        v59 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v52, v53), (int8x8_t)0xFF000000FF00), 0x18uLL), v58);
        v60 = vand_s8((int8x8_t)vshl_n_s32(v54, 8uLL), (int8x8_t)0xFF000000FF0000);
        v58.i64[0] = v60.u32[0];
        v58.i64[1] = v60.u32[1];
        v61 = v58;
        v62 = vand_s8(v55, (int8x8_t)0xFF000000FF00);
        v58.i64[0] = v62.u32[0];
        v58.i64[1] = v62.u32[1];
        v63 = vorrq_s8(v59, vorrq_s8(v61, v58));
        *(uint32x2_t *)v61.i8 = vshr_n_u32(v56, 8uLL);
        v58.i64[0] = v61.i32[0] & 0xFFFFFEFF;
        v58.i64[1] = v61.i32[1] & 0xFFFFFEFF;
        v64 = vorrq_s8(v63, v58);
        *v21 = v64;
        v26 = ((_DWORD)v26 + 1) & v28;
        v64.i8[0] = *(_BYTE *)(v25 + ((v27 + 1) & v28));
        v64.i8[4] = *(_BYTE *)(v25 + v26);
        *(int8x8_t *)v64.i8 = vand_s8(*(int8x8_t *)v64.i8, (int8x8_t)0xFF000000FFLL);
        v65 = vadd_s32(v48, *(int32x2_t *)v64.i8);
        v66 = (int8x8_t)vadd_s32(v50, *(int32x2_t *)v64.i8);
        v67 = (uint32x2_t)vadd_s32(v51, *(int32x2_t *)v64.i8);
        *(int32x2_t *)v61.i8 = vshl_n_s32(vadd_s32(v47, *(int32x2_t *)v64.i8), 0x10uLL);
        v58.i64[0] = v61.i32[0] & 0xFF00FFFF;
        v58.i64[1] = v61.i32[1] & 0xFF00FFFF;
        v68 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v52, *(int32x2_t *)v64.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v58);
        *(int8x8_t *)v61.i8 = vand_s8((int8x8_t)vshl_n_s32(v65, 8uLL), (int8x8_t)0xFF000000FF0000);
        v58.i64[0] = v61.u32[0];
        v58.i64[1] = v61.u32[1];
        v69 = v58;
        v70 = vand_s8(v66, (int8x8_t)0xFF000000FF00);
        v58.i64[0] = v70.u32[0];
        v58.i64[1] = v70.u32[1];
        v71 = vorrq_s8(v68, vorrq_s8(v69, v58));
        *(uint32x2_t *)v69.i8 = vshr_n_u32(v67, 8uLL);
        v58.i64[0] = v69.i32[0] & 0xFFFFFEFF;
        v58.i64[1] = v69.i32[1] & 0xFFFFFEFF;
        *v20++ = -1;
        v49 -= 4;
        v4 = vorrq_s8(v71, v58);
        v21[1] = v4;
        v21 += 2;
        v27 = (v27 + 1) & v28;
      }
      while (v49 > 4);
    }
    else
    {
      v72 = (v42 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v46 & 0xFF00) >> 8) << 32) | ((unint64_t)BYTE1(v43) << 16) | (unsigned __int16)v44 & 0xFF00 | (v45 >> 8);
      v73 = a4 + 4;
      do
      {
        v21->i64[0] = v72;
        v21->i64[1] = v72;
        v21[1].i64[0] = v72;
        v21[1].i64[1] = v72;
        v73 -= 4;
        v21 += 2;
        *v20++ = -1;
      }
      while (v73 > 4);
    }
  }
  else
  {
    if (a4 >= 4)
      v29 = 4;
    else
      v29 = a4;
    bzero(v20, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

void cmyk32_image_mark(uint64_t a1, uint64_t a2, int a3, __n128 a4)
{
  unint64_t v4;
  uint64_t v6;
  float v7;
  int *v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  size_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  void *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  uint64_t v32;
  unsigned int *v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  unsigned __int8 *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  int v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  unint64_t *v54;
  unsigned __int8 *v55;
  int v56;
  unsigned int v57;
  int v58;
  _BYTE *v59;
  uint64_t v60;
  int v61;
  unsigned __int8 *v62;
  unsigned int v63;
  unint64_t v64;
  unint64_t v65;
  uint64_t v66;
  int v67;
  uint64_t v68;
  float *v69;
  float v70;
  float v71;
  float v72;
  float v73;
  float v74;
  int v75;
  int v76;
  int v77;
  int v78;
  int v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  float *v85;
  float v86;
  float v87;
  float v88;
  int v89;
  float v90;
  float v91;
  int v92;
  int v93;
  int v94;
  int v95;
  unint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  float *v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  uint64_t v107;
  int v108;
  int v109;
  int v110;
  int v111;
  unint64_t v112;
  uint64_t v113;
  unsigned __int16 *v114;
  const double *v115;
  uint64x2_t v116;
  int8x16_t v117;
  uint64_t v118;
  uint64_t v119;
  float *v120;
  float v121;
  float v122;
  float v123;
  float v124;
  float v125;
  uint64_t v126;
  int v127;
  int v128;
  int v129;
  int v130;
  unint64_t v131;
  uint64_t v132;
  _WORD *v133;
  uint64_t v134;
  unsigned __int8 v135;
  uint64_t v136;
  _BYTE *v137;
  unsigned int *v138;
  unsigned int *v139;
  unsigned int v140;
  unsigned __int8 *v141;
  unint64_t v142;
  uint64_t v143;
  unsigned __int8 v144;
  uint64_t v145;
  _BYTE *v146;
  unsigned int *v147;
  unsigned int *v148;
  unsigned int v149;
  unsigned __int8 *v150;
  unint64_t v151;
  unint64_t v152;
  uint64_t v153;
  unsigned __int8 *v154;
  unsigned int v155;
  unint64_t v156;
  unsigned int v157;
  unint64_t v158;
  int v159;
  unsigned __int8 *v160;
  unsigned int v161;
  unsigned int v162;
  int v163;
  unint64_t v164;
  unsigned int v165;
  unsigned int v166;
  unint64_t v167;
  uint64_t v168;
  unsigned int v169;
  unint64_t v170;
  unsigned int v171;
  unsigned int v172;
  int v173;
  unsigned int v174;
  uint64_t v175;
  unsigned int v176;
  unint64_t v177;
  unsigned int v178;
  unsigned int v179;
  int v180;
  unsigned int v181;
  unsigned __int8 *v182;
  int v183;
  unsigned int v184;
  unsigned int v185;
  int v186;
  unint64_t v187;
  uint64_t v188;
  int v189;
  unsigned int v190;
  unsigned int v191;
  int v192;
  unint64_t v193;
  uint64_t v194;
  uint64_t v195;
  unsigned __int8 *v196;
  unsigned int v197;
  unsigned int v198;
  unint64_t v199;
  uint64_t v200;
  unsigned int v201;
  unsigned int v202;
  unint64_t v203;
  unsigned int v204;
  unsigned int v205;
  unsigned int v206;
  int v207;
  unsigned __int8 *v208;
  int v209;
  unsigned int v210;
  unsigned int v211;
  unint64_t v212;
  unsigned int v213;
  unint64_t v214;
  unint64_t v215;
  int v216;
  int v217;
  unsigned int v218;
  unsigned int v219;
  unint64_t v220;
  unsigned int v221;
  unint64_t v222;
  unint64_t v223;
  int v224;
  int v225;
  unsigned int v226;
  unsigned int v227;
  unint64_t v228;
  unsigned int v229;
  unint64_t v230;
  unint64_t v231;
  int v232;
  int v233;
  unsigned int v234;
  unsigned int v235;
  unint64_t v236;
  double v237;
  int8x16_t v238;
  double v239;
  double v240;
  double v241;
  int8x16_t v242;
  unsigned int v243;
  unint64_t v244;
  unint64_t v245;
  int v246;
  int v247;
  unsigned int v248;
  unsigned int v249;
  unint64_t v250;
  double v251;
  int8x16_t v252;
  double v253;
  double v254;
  double v255;
  int8x16_t v256;
  unsigned int v257;
  unint64_t v258;
  unint64_t v259;
  int v260;
  int v261;
  unsigned int v262;
  unsigned int v263;
  unint64_t v264;
  unsigned int v265;
  unint64_t v266;
  unint64_t v267;
  int v268;
  int v269;
  unsigned int v270;
  unsigned int v271;
  unint64_t v272;
  unsigned int v273;
  unint64_t v274;
  unint64_t v275;
  int v276;
  int v277;
  unsigned int v278;
  unsigned int v279;
  unint64_t v280;
  unsigned int v281;
  unint64_t v282;
  unint64_t v283;
  int v284;
  int v285;
  unsigned int v286;
  unsigned int v287;
  unint64_t v288;
  unsigned int v289;
  unint64_t v290;
  unint64_t v291;
  int v292;
  int v293;
  unsigned int v294;
  unsigned int v295;
  unint64_t v296;
  unsigned int v297;
  unint64_t v298;
  unint64_t v299;
  int v300;
  int v301;
  unsigned int v302;
  unsigned int v303;
  unint64_t v304;
  unsigned int v305;
  unint64_t v306;
  unint64_t v307;
  int v308;
  int v309;
  unsigned int v310;
  unsigned int v311;
  unint64_t v312;
  unsigned int v313;
  unint64_t v314;
  unint64_t v315;
  int v316;
  int v317;
  unsigned int v318;
  unsigned int v319;
  unint64_t v320;
  unsigned int v321;
  unint64_t v322;
  unint64_t v323;
  int v324;
  int v325;
  unsigned int v326;
  unsigned int v327;
  unint64_t v328;
  unint64_t v329;
  int v330;
  int v331;
  unsigned int v332;
  unsigned int v333;
  unint64_t v334;
  unsigned int v335;
  unint64_t v336;
  unint64_t v337;
  int v338;
  int v339;
  unsigned int v340;
  unsigned int v341;
  unint64_t v342;
  unsigned int v343;
  unint64_t v344;
  unint64_t v345;
  int v346;
  int v347;
  unsigned int v348;
  unsigned int v349;
  unint64_t v350;
  unsigned int v351;
  unint64_t v352;
  unint64_t v353;
  int v354;
  int v355;
  unsigned int v356;
  unsigned int v357;
  unint64_t v358;
  unint64_t v359;
  int v360;
  int v361;
  unsigned int v362;
  unsigned int v363;
  unint64_t v364;
  unsigned int v365;
  unint64_t v366;
  unint64_t v367;
  int v368;
  unsigned __int8 *v369;
  int v370;
  unsigned int v371;
  unsigned __int8 *v372;
  int v373;
  unsigned int v374;
  unsigned int *v375;
  unsigned int *v376;
  unsigned __int8 v377;
  unsigned __int8 *v378;
  unsigned int *v379;
  int v380;
  unsigned int v381;
  unint64_t v382;
  unsigned int v383;
  unint64_t v384;
  unsigned int v385;
  unsigned __int8 v386;
  unsigned int v387;
  unsigned int v388;
  unint64_t v389;
  unsigned __int8 *v390;
  int v391;
  int v392;
  unsigned int v393;
  unsigned int v394;
  _BYTE *v395;
  unsigned int *v396;
  unsigned __int8 *v397;
  unint64_t v398;
  _BYTE *v399;
  unsigned int *v400;
  unsigned __int8 *v401;
  unint64_t v402;
  unint64_t v403;
  int v404;
  unsigned int *v405;
  unsigned __int8 v406;
  unsigned int *v407;
  unsigned __int8 *v408;
  int v409;
  unint64_t v410;
  unsigned int v411;
  unint64_t v412;
  unsigned int v413;
  unsigned __int8 v414;
  unint64_t v415;
  uint64_t v416;
  void *v417;
  uint64_t v418;
  unint64_t v419;
  uint64_t v420;
  uint64_t v421;
  uint64_t v422;
  int8x16_t v423;
  int8x16_t v424;
  uint64x2_t v425;
  uint64x2_t v426;
  uint64_t v427;
  uint64_t v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  int v433;
  int v434;
  uint64_t v435;
  void *v436;
  uint64_t v437;
  uint64_t v438;
  int v439;
  uint64_t v440;
  uint64_t v441;

  v433 = a3;
  v441 = *MEMORY[0x1E0C80C00];
  v427 = a1;
  v438 = *(unsigned int *)(a1 + 4);
  v422 = (int)v438;
  v4 = ((int)v438 + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if ((int)v4 > 0x1FFFFFF)
    return;
  v6 = *(_QWORD *)(v427 + 40);
  v428 = *(_QWORD *)(v427 + 48);
  v7 = *(float *)(a2 + 184);
  v8 = *(int **)(v427 + 136);
  v435 = *(_QWORD *)(a2 + 96);
  v418 = *(_QWORD *)(a2 + 104);
  v10 = *(int *)(v427 + 24);
  v9 = *(int *)(v427 + 28);
  v11 = *(int *)(v427 + 16);
  v437 = *(int *)(v427 + 20);
  v12 = *(int *)(v427 + 12);
  v434 = *(_DWORD *)(v427 + 8);
  v13 = *(int *)(a2 + 16);
  v14 = (v13 + 10) * v4;
  if (v14 > 65439)
  {
    v17 = (char *)malloc_type_calloc(1uLL, v14 + 96, 0x3023562EuLL);
    v16 = v17;
    v19 = v17;
    if (!v17)
      return;
  }
  else
  {
    MEMORY[0x1E0C80A78](a1, a4);
    v16 = (char *)&v415 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v16, v15);
    v19 = 0;
  }
  v417 = v19;
  v439 = (int)(float)((float)(v7 * 255.0) + 0.5);
  v20 = (unint64_t)(v16 + 15) & 0xFFFFFFFFFFFFFFF0;
  v21 = v20 + ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  *(_QWORD *)(a2 + 160) = v21;
  if ((_DWORD)v13)
    v22 = 8 * v4;
  else
    v22 = 0;
  v23 = a2;
  v24 = v21 + v22;
  v25 = v6 + (v10 - 1) * v9;
  v26 = v9 >> 2;
  *(_QWORD *)(v23 + 144) = v20;
  *(_QWORD *)(v23 + 152) = v24;
  v430 = v23;
  v27 = v428;
  if (v428)
  {
    v28 = v427;
    v29 = *(int *)(v427 + 32);
    v30 = (char *)(v428 + v12 + (int)v29 * (uint64_t)(int)v11);
    v432 = v29 - v422;
    v31 = v422;
    v440 = 1;
  }
  else
  {
    v30 = 0;
    v432 = 0;
    v440 = 0;
    v28 = v427;
    v31 = v422;
  }
  v32 = v25 + 4 * v437;
  v33 = (unsigned int *)(v6 + 4 * (v12 + v26 * v11));
  v431 = v26 - v31;
  v34 = *(int *)(v28 + 104);
  v35 = *(_DWORD *)(v28 + 108);
  v36 = *(unsigned __int8 *)(v28 + 2);
  if (v36 == 6 || v36 == 1)
  {
    v37 = v430;
    v38 = v435;
    if (!v8)
      goto LABEL_34;
    v415 = v26;
    v39 = 0;
    v40 = 0;
    v41 = *(int *)(v28 + 124);
    v42 = (unsigned __int8 *)v8 + v34 + (int)v41 * (uint64_t)v35;
    v31 = v422;
    v429 = v41 - v422;
    v43 = v438;
    goto LABEL_21;
  }
  v415 = v26;
  if (!v8)
  {
    v42 = 0;
    v39 = 0;
    v429 = 0;
    v40 = 0;
    v37 = v430;
    v43 = v438;
    v38 = v435;
LABEL_21:
    v47 = v418;
LABEL_38:
    LODWORD(v437) = v40;
    v421 = (v43 - 1) + 1;
    v420 = -v31;
    v416 = v32;
    v419 = v32 - 4;
    v426 = (uint64x2_t)xmmword_185004CE0;
    v425 = (uint64x2_t)xmmword_185004CF0;
    v424 = (int8x16_t)xmmword_185004D00;
    v423 = (int8x16_t)xmmword_185004D10;
    v53 = v39;
    while (2)
    {
      v435 = v38;
      v436 = (void *)v53;
      (*(void (**)(uint64_t, uint64_t, uint64_t, uint64_t))v37)(v37, v38, v47, v43);
      v54 = *(unint64_t **)(v37 + 160);
      v55 = *(unsigned __int8 **)(v37 + 144);
      v57 = *(_DWORD *)(v37 + 8);
      v56 = *(_DWORD *)(v37 + 12);
      if (v57 == v56)
      {
        if (v439 == 255)
          goto LABEL_47;
        v58 = v43;
        v59 = *(_BYTE **)(v37 + 144);
        do
        {
          if (*v59)
            *v54 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v439);
          ++v59;
          ++v54;
          --v58;
        }
        while (v58);
        v54 += v420;
        v55 += v421 + v420;
        goto LABEL_46;
      }
      v66 = *(_QWORD *)(v37 + 152);
      v67 = HIWORD(v57) & 0x3F;
      if (v67 == 16)
      {
        if (v56 == 134759428)
        {
          if (v439 != 255)
          {
            v81 = 0;
            v82 = v66 + 8;
            do
            {
              if (v55[v81])
                v54[v81] = PDAM_5205(HIDWORD(*(_QWORD *)(v82 - 8)) & 0xFF000000 | (*(_QWORD *)(v82 - 8) >> 24) & 0xFF0000 | WORD1(*(_QWORD *)(v82 - 8)) & 0xFF00 | BYTE1(*(_QWORD *)(v82 - 8)), *(unsigned __int8 *)(v82 + 1), v439);
              v82 += 16;
              ++v81;
            }
            while ((_DWORD)v43 != (_DWORD)v81);
            goto LABEL_46;
          }
          v113 = 0;
          v114 = (unsigned __int16 *)(v66 + 8);
          do
          {
            if (v55[v113])
            {
              v115 = (const double *)(v114 - 4);
              v116 = (uint64x2_t)vld1q_dup_f64(v115);
              v117 = vorrq_s8(vandq_s8((int8x16_t)vshlq_u64(v116, v426), v423), vandq_s8((int8x16_t)vshlq_u64(v116, v425), v424));
              v54[v113] = *(_QWORD *)&vorr_s8(*(int8x8_t *)v117.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v117, v117, 8uLL)) | ((unint64_t)*v114 << 24) & 0xFF00000000;
            }
            v114 += 8;
            ++v113;
          }
          while ((_DWORD)v43 != (_DWORD)v113);
        }
        else
        {
          if (v439 != 255)
          {
            v97 = 0;
            v98 = v66 + 8;
            do
            {
              if (v55[v97])
                v54[v97] = PDAM_5205((HIBYTE(*(_QWORD *)(v98 - 8)) | (BYTE3(*(_QWORD *)(v98 - 8)) << 16)) & 0xFFFFFF | (BYTE1(*(_QWORD *)(v98 - 8)) << 24) | HIDWORD(*(_QWORD *)(v98 - 8)) & 0xFF00, *(unsigned __int8 *)(v98 + 1), v439);
              v98 += 16;
              ++v97;
            }
            while ((_DWORD)v43 != (_DWORD)v97);
            goto LABEL_46;
          }
          v132 = 0;
          v133 = (_WORD *)(v66 + 8);
          do
          {
            if (v55[v132])
              v54[v132] = (*((_QWORD *)v133 - 1) >> 8) & 0xFF0000 | HIBYTE(*((_QWORD *)v133 - 1)) | (BYTE1(*((_QWORD *)v133 - 1)) << 24) | HIDWORD(*((_QWORD *)v133 - 1)) & 0xFF00 | ((unint64_t)HIBYTE(*v133) << 32);
            v133 += 8;
            ++v132;
          }
          while ((_DWORD)v43 != (_DWORD)v132);
        }
      }
      else if (v67 == 32)
      {
        if (v56 == 134759428)
        {
          if (v439 != 255)
          {
            v68 = 0;
            v69 = (float *)(v66 + 8);
            do
            {
              if (v55[v68])
              {
                v70 = v69[2];
                if (v70 <= 0.0)
                {
                  v80 = 0;
                }
                else
                {
                  v71 = *(v69 - 2);
                  v72 = *(v69 - 1);
                  v73 = *v69;
                  v74 = v69[1];
                  v75 = (int)(float)((float)(v70 * 255.0) + 0.5);
                  if (v70 > 1.0)
                  {
                    v75 = 255;
                    v70 = 1.0;
                  }
                  v76 = (int)(float)((float)(v71 * 255.0) + 0.5);
                  if (v71 < 0.0)
                    v76 = 0;
                  if (v71 > v70)
                    v76 = v75;
                  v77 = (int)(float)((float)(v72 * 255.0) + 0.5);
                  if (v72 < 0.0)
                    v77 = 0;
                  if (v72 > v70)
                    v77 = v75;
                  v78 = (int)(float)((float)(v73 * 255.0) + 0.5);
                  if (v73 < 0.0)
                    v78 = 0;
                  if (v73 > v70)
                    v78 = v75;
                  v79 = (int)(float)((float)(v74 * 255.0) + 0.5);
                  if (v74 < 0.0)
                    v79 = 0;
                  if (v74 > v70)
                    v79 = v75;
                  v80 = PDAM_5205(v76 | (v77 << 8) | (v78 << 16) | (v79 << 24), v75, v439);
                }
                v54[v68] = v80;
              }
              ++v68;
              v69 += 5;
            }
            while ((_DWORD)v43 != (_DWORD)v68);
LABEL_46:
            v27 = v428;
            goto LABEL_47;
          }
          v100 = 0;
          v101 = (float *)(v66 + 8);
          do
          {
            if (v55[v100])
            {
              v102 = v101[2];
              if (v102 <= 0.0)
              {
                v112 = 0;
              }
              else
              {
                v103 = *(v101 - 2);
                v104 = *(v101 - 1);
                v105 = *v101;
                v106 = v101[1];
                LODWORD(v107) = (int)(float)((float)(v102 * 255.0) + 0.5);
                if (v102 <= 1.0)
                  v107 = v107;
                else
                  v107 = 255;
                if (v102 > 1.0)
                  v102 = 1.0;
                v108 = (int)(float)((float)(v103 * 255.0) + 0.5);
                if (v103 < 0.0)
                  v108 = 0;
                if (v103 > v102)
                  v108 = v107;
                v109 = (int)(float)((float)(v104 * 255.0) + 0.5);
                if (v104 < 0.0)
                  v109 = 0;
                if (v104 > v102)
                  v109 = v107;
                v110 = (int)(float)((float)(v105 * 255.0) + 0.5);
                if (v105 < 0.0)
                  v110 = 0;
                if (v105 > v102)
                  v110 = v107;
                v111 = (int)(float)((float)(v106 * 255.0) + 0.5);
                if (v106 < 0.0)
                  v111 = 0;
                if (v106 > v102)
                  v111 = v107;
                v112 = v108 | (v109 << 8) | (v110 << 16) | (v111 << 24) | (unint64_t)(v107 << 32);
              }
              v54[v100] = v112;
            }
            ++v100;
            v101 += 5;
          }
          while ((_DWORD)v43 != (_DWORD)v100);
        }
        else if (v439 == 255)
        {
          v119 = 0;
          v120 = (float *)(v66 + 8);
          do
          {
            if (v55[v119])
            {
              v121 = v120[2];
              if (v121 <= 0.0)
              {
                v131 = 0;
              }
              else
              {
                v122 = *(v120 - 2);
                v123 = *(v120 - 1);
                v124 = *v120;
                v125 = v120[1];
                LODWORD(v126) = (int)(float)((float)(v121 * 255.0) + 0.5);
                if (v121 <= 1.0)
                {
                  v126 = v126;
                }
                else
                {
                  v121 = 1.0;
                  v126 = 255;
                }
                v127 = (int)(float)((float)(v122 * 255.0) + 0.5);
                if (v122 < 0.0)
                  v127 = 0;
                if (v122 > v121)
                  v127 = v126;
                v128 = (int)(float)((float)(v123 * 255.0) + 0.5);
                if (v123 < 0.0)
                  v128 = 0;
                if (v123 > v121)
                  v128 = v126;
                v129 = (int)(float)((float)(v124 * 255.0) + 0.5);
                if (v124 < 0.0)
                  v129 = 0;
                if (v124 > v121)
                  v129 = v126;
                v130 = (int)(float)((float)(v125 * 255.0) + 0.5);
                if (v125 < 0.0)
                  v130 = 0;
                if (v125 > v121)
                  v130 = v126;
                v131 = (v128 << 16) | (v127 << 24) | (v129 << 8) | v130 | (unint64_t)(v126 << 32);
              }
              v54[v119] = v131;
            }
            ++v119;
            v120 += 5;
          }
          while ((_DWORD)v43 != (_DWORD)v119);
        }
        else
        {
          v84 = 0;
          v85 = (float *)(v66 + 8);
          do
          {
            if (v55[v84])
            {
              v86 = v85[2];
              if (v86 <= 0.0)
              {
                v96 = 0;
              }
              else
              {
                v87 = *(v85 - 2);
                v88 = *(v85 - 1);
                v89 = (int)(float)((float)(v86 * 255.0) + 0.5);
                v90 = *v85;
                v91 = v85[1];
                if (v86 > 1.0)
                {
                  v86 = 1.0;
                  v89 = 255;
                }
                v92 = (int)(float)((float)(v87 * 255.0) + 0.5);
                if (v87 < 0.0)
                  v92 = 0;
                if (v87 > v86)
                  v92 = v89;
                v93 = (int)(float)((float)(v88 * 255.0) + 0.5);
                if (v88 < 0.0)
                  v93 = 0;
                if (v88 > v86)
                  v93 = v89;
                v94 = (int)(float)((float)(v90 * 255.0) + 0.5);
                if (v90 < 0.0)
                  v94 = 0;
                if (v90 > v86)
                  v94 = v89;
                v95 = (int)(float)((float)(v91 * 255.0) + 0.5);
                if (v91 < 0.0)
                  v95 = 0;
                if (v91 > v86)
                  v95 = v89;
                v96 = PDAM_5205((v93 << 16) | (v92 << 24) | (v94 << 8) | v95, v89, v439);
              }
              v54[v84] = v96;
            }
            ++v84;
            v85 += 5;
          }
          while ((_DWORD)v438 != (_DWORD)v84);
          v43 = v438;
        }
      }
      else if (v56 == 134759428)
      {
        if (v439 != 255)
        {
          v83 = 0;
          do
          {
            if (v55[v83])
              v54[v83] = PDAM_5205(bswap32(*(_DWORD *)(v66 + 8 * v83)), *(unsigned __int8 *)(v66 + 8 * v83 + 4), v439);
            ++v83;
          }
          while ((_DWORD)v43 != (_DWORD)v83);
          goto LABEL_46;
        }
        v118 = 0;
        do
        {
          if (v55[v118])
            v54[v118] = *(_QWORD *)(v66 + 8 * v118) & 0xFF00000000 | bswap32(*(_QWORD *)(v66 + 8 * v118));
          ++v118;
        }
        while ((_DWORD)v43 != (_DWORD)v118);
      }
      else
      {
        if (v439 != 255)
        {
          v99 = 0;
          do
          {
            if (v55[v99])
              v54[v99] = PDAM_5205(*(_DWORD *)(v66 + 8 * v99), *(unsigned __int8 *)(v66 + 8 * v99 + 4), v439);
            ++v99;
          }
          while ((_DWORD)v43 != (_DWORD)v99);
          goto LABEL_46;
        }
        v134 = 0;
        do
        {
          if (v55[v134])
            v54[v134] = *(unsigned int *)(v66 + 8 * v134);
          ++v134;
        }
        while ((_DWORD)v43 != (_DWORD)v134);
      }
LABEL_47:
      switch(v433)
      {
        case 0:
          v60 = v42 != 0;
          if (v27)
          {
            v61 = v43;
            v62 = v42;
            do
            {
              v63 = *v55;
              if (*v55)
              {
                if (v42)
                  v63 = (*v62 * v63 + ((*v62 * v63) >> 8) + 1) >> 8;
                if ((_BYTE)v63)
                {
                  if (v63 == 255)
                  {
                    LOBYTE(v64) = 0;
                    *v33 = 0;
                  }
                  else
                  {
                    v65 = PDAM_5205(*v33, *v30, ~(_BYTE)v63);
                    *v33 = v65;
                    v64 = HIDWORD(v65);
                  }
                  *v30 = v64;
                }
              }
              ++v55;
              v62 += v60;
              ++v33;
              ++v30;
              --v61;
            }
            while (v61);
            v42 = &v62[v429];
            v33 += v431;
            v30 += v432;
            goto LABEL_657;
          }
          v368 = v43;
          v369 = v42;
          v188 = v435;
          do
          {
            v370 = *v55;
            if (*v55)
            {
              if (v42)
                v370 = ((unsigned __int16)(*v369 * (_WORD)v370 + ((*v369 * v370) >> 8) + 1) >> 8);
              if (v370)
              {
                if (v370 == 255)
                  v371 = 0;
                else
                  v371 = (((*v33 & 0xFF00FF) * (v370 ^ 0xFF)
                         + 65537
                         + ((((*v33 & 0xFF00FF) * (v370 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v33 >> 8) & 0xFF00FF) * (v370 ^ 0xFF) + 65537 + (((((*v33 >> 8) & 0xFF00FF) * (v370 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                *v33 = v371;
              }
            }
            ++v55;
            v369 += v60;
            ++v33;
            --v368;
          }
          while (v368);
          v42 = &v369[v429];
          v33 += v431;
          v30 += v432;
          goto LABEL_606;
        case 1:
          v135 = *v55;
          if (v27)
          {
            v136 = 0;
            if (v42)
            {
              v137 = v55 + 1;
              v138 = v33;
              do
              {
                v139 = v138;
                if (v135)
                {
                  v140 = v42[v136] * v135 + ((v42[v136] * v135) >> 8) + 1;
                  if (BYTE1(v140))
                  {
                    v141 = (unsigned __int8 *)&v30[v136];
                    if (BYTE1(v140) == 255)
                    {
                      v142 = v54[v136];
                      v33[v136] = v142;
                      *v141 = BYTE4(v142);
                    }
                    else
                    {
                      DAMplusDAM(v138, v141, v54[v136], BYTE4(v54[v136]), BYTE1(v140), v33[v136], *v141, ~(v140 >> 8));
                    }
                  }
                }
                v135 = v137[v136];
                v138 = v139 + 1;
                ++v136;
              }
              while ((_DWORD)v43 != (_DWORD)v136);
              v143 = (uint64_t)&v30[v136 - 1];
              v27 = v428;
              v42 += v136 + v429;
            }
            else
            {
              v395 = v55 + 1;
              v396 = v33;
              do
              {
                if (v135)
                {
                  v397 = (unsigned __int8 *)&v30[v136];
                  if (v135 == 255)
                  {
                    v398 = v54[v136];
                    v33[v136] = v398;
                    *v397 = BYTE4(v398);
                  }
                  else
                  {
                    DAMplusDAM(v396, v397, v54[v136], BYTE4(v54[v136]), v135, v33[v136], *v397, ~v135);
                  }
                }
                v135 = v395[v136];
                ++v396;
                ++v136;
              }
              while ((_DWORD)v43 != (_DWORD)v136);
              v42 = 0;
              v143 = (uint64_t)&v30[v136 - 1];
              v139 = v396 - 1;
            }
            v33 = &v139[v431 + 1];
            v30 = (char *)(v143 + v432 + 1);
            goto LABEL_605;
          }
          v372 = v55 + 1;
          if (v42)
          {
            v373 = v43;
            do
            {
              if (v135)
              {
                v374 = *v42 * v135 + ((*v42 * v135) >> 8) + 1;
                v375 = (unsigned int *)v419;
                if (v419 >= (unint64_t)v33)
                  v375 = v33;
                if ((unint64_t)v375 >= *(_QWORD *)(v427 + 40))
                  v376 = v375;
                else
                  v376 = *(unsigned int **)(v427 + 40);
                if (BYTE1(v374))
                {
                  if (BYTE1(v374) == 255)
                    *v376 = *v54;
                  else
                    DMplusDM(v376, *(_DWORD *)v54, BYTE1(v374), *v376, ~(v374 >> 8));
                }
              }
              else
              {
                v376 = v33;
              }
              v377 = *v372++;
              v135 = v377;
              ++v54;
              ++v42;
              v33 = v376 + 1;
              --v373;
            }
            while (v373);
            v27 = v428;
            v42 += v429;
          }
          else
          {
            v404 = v43;
            do
            {
              v405 = (unsigned int *)v419;
              if (v419 >= (unint64_t)v33)
                v405 = v33;
              if ((unint64_t)v405 >= *(_QWORD *)(v427 + 40))
                v376 = v405;
              else
                v376 = *(unsigned int **)(v427 + 40);
              if (v135)
              {
                if (v135 == 255)
                  *v376 = *v54;
                else
                  DMplusDM(v376, *(_DWORD *)v54, v135, *v376, ~v135);
              }
              v406 = *v372++;
              v135 = v406;
              ++v54;
              v33 = v376 + 1;
              --v404;
            }
            while (v404);
            v42 = 0;
          }
          v407 = &v376[v431];
          goto LABEL_710;
        case 2:
          v144 = *v55;
          if (v27)
          {
            v145 = 0;
            if (v42)
            {
              v146 = v55 + 1;
              v147 = v33;
              while (1)
              {
                v148 = v147;
                if (!v144)
                  goto LABEL_241;
                v149 = v42[v145] * v144 + ((v42[v145] * v144) >> 8) + 1;
                if (!BYTE1(v149))
                  goto LABEL_241;
                v150 = (unsigned __int8 *)&v30[v145];
                if (BYTE1(v149) == 255)
                {
                  v151 = v54[v145];
                  if (BYTE4(v151))
                  {
                    if (BYTE4(v151) != 255)
                      goto LABEL_240;
                    v33[v145] = v151;
                    *v150 = -1;
                  }
                }
                else
                {
                  v152 = PDAM_5205(v54[v145], BYTE4(v54[v145]), BYTE1(v149));
                  if (BYTE4(v152))
                  {
                    v151 = v152;
LABEL_240:
                    DAplusDAM(v148, &v30[v145], v151, SBYTE4(v151), v33[v145], *v150, ~BYTE4(v151));
                  }
                }
LABEL_241:
                v144 = v146[v145];
                v147 = v148 + 1;
                if ((_DWORD)v438 == (_DWORD)++v145)
                {
                  v153 = (uint64_t)&v30[v145 - 1];
                  v37 = v430;
                  v42 += v145 + v429;
LABEL_684:
                  v33 = &v148[v431 + 1];
                  v30 = (char *)(v153 + v432 + 1);
                  goto LABEL_604;
                }
              }
            }
            v399 = v55 + 1;
            v400 = v33;
            while (1)
            {
              if (v144)
              {
                v401 = (unsigned __int8 *)&v30[v145];
                if (v144 == 255)
                {
                  v402 = v54[v145];
                  if (BYTE4(v402))
                  {
                    if (BYTE4(v402) != 255)
                      goto LABEL_681;
                    v33[v145] = v402;
                    *v401 = -1;
                  }
                }
                else
                {
                  v403 = PDAM_5205(v54[v145], BYTE4(v54[v145]), v144);
                  if (BYTE4(v403))
                  {
                    v402 = v403;
LABEL_681:
                    DAplusDAM(v400, &v30[v145], v402, SBYTE4(v402), v33[v145], *v401, ~BYTE4(v402));
                  }
                }
              }
              v144 = v399[v145];
              ++v400;
              if ((_DWORD)v438 == (_DWORD)++v145)
              {
                v42 = 0;
                v153 = (uint64_t)&v30[v145 - 1];
                v148 = v400 - 1;
                goto LABEL_684;
              }
            }
          }
          if (!v42)
          {
            v408 = v55 + 1;
            v379 = v33 - 1;
            v409 = v43;
            while (1)
            {
              if (v144)
              {
                if (v144 == 255)
                {
                  v410 = *v54;
                  if (BYTE4(*v54))
                  {
                    if (BYTE4(*v54) != 255)
                    {
                      v411 = v379[1];
                      LODWORD(v410) = ((((v411 >> 8) & 0xFF00FF) * ~BYTE4(v410)
                                      + 65537
                                      + (((((v411 >> 8) & 0xFF00FF) * ~BYTE4(v410)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                    + v410
                                    + ((((v411 & 0xFF00FF) * ~BYTE4(v410)
                                       + 65537
                                       + ((((v411 & 0xFF00FF) * ~BYTE4(v410)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                    }
                    goto LABEL_706;
                  }
                }
                else
                {
                  v412 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v144);
                  if (BYTE4(v412))
                  {
                    v413 = v379[1];
                    LODWORD(v410) = ((((v413 >> 8) & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)
                                    + 65537
                                    + (((((v413 >> 8) & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                  + v412
                                  + ((((v413 & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)
                                     + 65537
                                     + ((((v413 & 0xFF00FF) * (BYTE4(v412) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
LABEL_706:
                    v379[1] = v410;
                  }
                }
              }
              v414 = *v408++;
              v144 = v414;
              ++v54;
              ++v379;
              if (!--v409)
              {
                v42 = 0;
                goto LABEL_709;
              }
            }
          }
          v378 = v55 + 1;
          v379 = v33 - 1;
          v380 = v43;
          do
          {
            if (v144)
            {
              v381 = *v42 * v144 + ((*v42 * v144) >> 8) + 1;
              if (BYTE1(v381))
              {
                if (BYTE1(v381) == 255)
                {
                  v382 = *v54;
                  if (!BYTE4(*v54))
                    goto LABEL_646;
                  if (BYTE4(*v54) != 255)
                  {
                    v383 = v379[1];
                    LODWORD(v382) = ((((v383 >> 8) & 0xFF00FF) * ~BYTE4(v382)
                                    + 65537
                                    + (((((v383 >> 8) & 0xFF00FF) * ~BYTE4(v382)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                  + v382
                                  + ((((v383 & 0xFF00FF) * ~BYTE4(v382)
                                     + 65537
                                     + ((((v383 & 0xFF00FF) * ~BYTE4(v382)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                  }
                }
                else
                {
                  v384 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), BYTE1(v381));
                  if (!BYTE4(v384))
                    goto LABEL_646;
                  v385 = v379[1];
                  LODWORD(v382) = ((((v385 >> 8) & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)
                                  + 65537
                                  + (((((v385 >> 8) & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                                + v384
                                + ((((v385 & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)
                                   + 65537
                                   + ((((v385 & 0xFF00FF) * (BYTE4(v384) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
                }
                v379[1] = v382;
              }
            }
LABEL_646:
            v386 = *v378++;
            v144 = v386;
            ++v54;
            ++v42;
            ++v379;
            --v380;
          }
          while (v380);
          v42 += v429;
LABEL_709:
          v407 = &v379[v431];
LABEL_710:
          v33 = v407 + 1;
LABEL_711:
          v30 += v432;
LABEL_605:
          v188 = v435;
LABEL_606:
          v52 = v436;
          if (v434 == 1)
            goto LABEL_32;
          --v434;
          v53 = 0;
          LODWORD(v437) = v437 + 1;
          v38 = *(_QWORD *)(v37 + 128) + v188;
          v47 += *(_QWORD *)(v37 + 136);
          if (v436)
          {
            v46 = v422;
            goto LABEL_22;
          }
          continue;
        case 3:
          v154 = v42;
          do
          {
            v155 = *v55;
            if (*v55)
            {
              if (v42)
                v155 = (*v154 * v155 + ((*v154 * v155) >> 8) + 1) >> 8;
              if ((_BYTE)v155)
              {
                if (v155 == 255)
                {
                  v156 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), *v30);
                  *v33 = v156;
                  *v30 = BYTE4(v156);
                }
                else
                {
                  DAMplusDAM(v33, v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)(*v30 * v155+ ((*v30 * v155) >> 8)+ 1) >> 8, *v33, *v30, ~(_BYTE)v155);
                }
              }
            }
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
          }
          while ((_DWORD)v43);
          goto LABEL_355;
        case 4:
          v154 = v42;
          do
          {
            v157 = *v55;
            if (*v55)
            {
              if (v42)
                v157 = (*v154 * v157 + ((*v154 * v157) >> 8) + 1) >> 8;
              if ((_BYTE)v157)
              {
                if (v157 == 255)
                {
                  v158 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), *v30 ^ 0xFFu);
                  *v33 = v158;
                  *v30 = BYTE4(v158);
                }
                else
                {
                  DAMplusDAM(v33, v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)((*v30 ^ 0xFF) * v157+ (((*v30 ^ 0xFF) * v157) >> 8)+ 1) >> 8, *v33, *v30, ~(_BYTE)v157);
                }
              }
            }
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
          }
          while ((_DWORD)v43);
          goto LABEL_355;
        case 5:
          v159 = v43;
          v160 = v42;
          while (1)
          {
            v161 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_268;
              v162 = *v160 * v161 + ((*v160 * v161) >> 8) + 1;
              if (BYTE1(v162))
                break;
            }
LABEL_269:
            ++v55;
            ++v54;
            v160 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v159)
              goto LABEL_335;
          }
          v161 = v162 >> 8;
LABEL_268:
          v163 = *v30;
          v164 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v161);
          DAMplusDAM(v33, v30, v164, BYTE4(v164), v163, *v33, v163, ~BYTE4(v164));
          goto LABEL_269;
        case 6:
          v154 = v42;
          while (1)
          {
            v165 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_276;
              v166 = *v154 * v165 + ((*v154 * v165) >> 8) + 1;
              if (BYTE1(v166))
                break;
            }
LABEL_280:
            ++v55;
            ++v54;
            v154 += v42 != 0;
            ++v33;
            v30 += v440;
            LODWORD(v43) = v43 - 1;
            if (!(_DWORD)v43)
            {
LABEL_355:
              v42 = &v154[v429];
              goto LABEL_603;
            }
          }
          v165 = v166 >> 8;
LABEL_276:
          if (*v30 != -1)
          {
            if (~*v30 == 255)
            {
              v167 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v165);
              *v33 = v167;
              *v30 = BYTE4(v167);
            }
            else
            {
              DAplusDAM(v33, v30, *v33, *v30, *(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), (unsigned __int16)(~*v30 * v165+ ((~*v30 * v165) >> 8)+ 1) >> 8);
            }
          }
          goto LABEL_280;
        case 7:
          v168 = v42 != 0;
          v154 = v42;
          if (v27)
          {
            do
            {
              v169 = *v55;
              if (*v55)
              {
                if (v42)
                  v169 = (*v154 * v169 + ((*v154 * v169) >> 8) + 1) >> 8;
                if ((_BYTE)v169)
                {
                  if (v169 == 255)
                  {
                    v170 = PDAM_5205(*v33, *v30, *((unsigned __int8 *)v54 + 4));
                    *v33 = v170;
                    *v30 = BYTE4(v170);
                  }
                  else
                  {
                    v171 = *((unsigned __int8 *)v54 + 4) * v169;
                    DAMplusDAM(v33, v30, *v33, *v30, (unsigned __int16)(v171 + (v171 >> 8) + 1) >> 8, *v33, *v30, ~(_BYTE)v169);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v168;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
            }
            while ((_DWORD)v43);
          }
          else
          {
            do
            {
              v172 = *v55;
              if (*v55)
              {
                if (v42)
                  v172 = (*v154 * v172 + ((*v154 * v172) >> 8) + 1) >> 8;
                if ((_BYTE)v172)
                {
                  if (v172 == 255)
                  {
                    v173 = *((unsigned __int8 *)v54 + 4);
                    *v33 = ((v173 * (*v33 & 0xFF00FF) + 65537 + (((v173 * (*v33 & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v173 * ((*v33 >> 8) & 0xFF00FF) + 65537 + (((v173 * ((*v33 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  else
                  {
                    v174 = *((unsigned __int8 *)v54 + 4) * v172;
                    DMplusDM(v33, *v33, (unsigned __int16)(v174 + (v174 >> 8) + 1) >> 8, *v33, ~(_BYTE)v172);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v168;
              ++v33;
              LODWORD(v43) = v43 - 1;
            }
            while ((_DWORD)v43);
          }
          goto LABEL_355;
        case 8:
          v175 = v42 != 0;
          v154 = v42;
          if (v27)
          {
            do
            {
              v176 = *v55;
              if (*v55)
              {
                if (v42)
                  v176 = (*v154 * v176 + ((*v154 * v176) >> 8) + 1) >> 8;
                if ((_BYTE)v176)
                {
                  if (v176 == 255)
                  {
                    v177 = PDAM_5205(*v33, *v30, *((unsigned __int8 *)v54 + 4) ^ 0xFFu);
                    *v33 = v177;
                    *v30 = BYTE4(v177);
                  }
                  else
                  {
                    v178 = (*((unsigned __int8 *)v54 + 4) ^ 0xFF) * v176;
                    DAMplusDAM(v33, v30, *v33, *v30, (unsigned __int16)(v178 + (v178 >> 8) + 1) >> 8, *v33, *v30, ~(_BYTE)v176);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v175;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
            }
            while ((_DWORD)v43);
          }
          else
          {
            do
            {
              v179 = *v55;
              if (*v55)
              {
                if (v42)
                  v179 = (*v154 * v179 + ((*v154 * v179) >> 8) + 1) >> 8;
                if ((_BYTE)v179)
                {
                  if (v179 == 255)
                  {
                    v180 = *((unsigned __int8 *)v54 + 4) ^ 0xFF;
                    *v33 = ((v180 * (*v33 & 0xFF00FF) + 65537 + (((v180 * (*v33 & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v180 * ((*v33 >> 8) & 0xFF00FF) + 65537 + (((v180 * ((*v33 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
                  }
                  else
                  {
                    v181 = (*((unsigned __int8 *)v54 + 4) ^ 0xFF) * v179;
                    DMplusDM(v33, *v33, (unsigned __int16)(v181 + (v181 >> 8) + 1) >> 8, *v33, ~(_BYTE)v179);
                  }
                }
              }
              ++v55;
              ++v54;
              v154 += v175;
              ++v33;
              LODWORD(v43) = v43 - 1;
            }
            while ((_DWORD)v43);
          }
          goto LABEL_355;
        case 9:
          v418 = v47;
          v182 = v42;
          v183 = v43;
          while (1)
          {
            v184 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_325;
              v185 = *v182 * v184 + ((*v182 * v184) >> 8) + 1;
              if (BYTE1(v185))
                break;
            }
LABEL_326:
            ++v55;
            ++v54;
            v182 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v183)
            {
              v27 = v428;
              v42 = &v182[v429];
              v37 = v430;
              v33 += v431;
              v30 += v432;
              v43 = v438;
              v188 = v435;
              v47 = v418;
              goto LABEL_606;
            }
          }
          v184 = v185 >> 8;
LABEL_325:
          v186 = *v30;
          v187 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v184);
          DAMplusDAM(v33, v30, v187, BYTE4(v187), v186 ^ 0xFF, *v33, v186, (BYTE4(v187) + ~(_BYTE)v184));
          goto LABEL_326;
        case 10:
          v160 = v42;
          v189 = v43;
          while (1)
          {
            v190 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_333;
              v191 = *v160 * v190 + ((*v160 * v190) >> 8) + 1;
              if (BYTE1(v191))
                break;
            }
LABEL_334:
            ++v55;
            ++v54;
            v160 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v189)
            {
LABEL_335:
              v42 = &v160[v429];
              v37 = v430;
              v194 = v431;
              goto LABEL_656;
            }
          }
          v190 = v191 >> 8;
LABEL_333:
          v192 = *v30;
          v193 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v190);
          DAMplusDAM(v33, v30, v193, BYTE4(v193), v192 ^ 0xFF, *v33, v192, ~BYTE4(v193));
          goto LABEL_334;
        case 11:
          v195 = v42 != 0;
          if (v27)
          {
            v196 = v42;
            while (1)
            {
              v197 = *v55;
              if (*v55)
              {
                if (!v42)
                  goto LABEL_342;
                v198 = *v196 * v197 + ((*v196 * v197) >> 8) + 1;
                if (BYTE1(v198))
                  break;
              }
LABEL_343:
              ++v55;
              ++v54;
              v196 += v195;
              ++v33;
              ++v30;
              LODWORD(v43) = v43 - 1;
              if (!(_DWORD)v43)
                goto LABEL_655;
            }
            v197 = v198 >> 8;
LABEL_342:
            v199 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v197);
            DAplusdDA(v33, v30, *v33, *v30, v199, BYTE4(v199));
            goto LABEL_343;
          }
          v196 = v42;
          while (1)
          {
            v387 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_653;
              v388 = *v196 * v387 + ((*v196 * v387) >> 8) + 1;
              if (BYTE1(v388))
                break;
            }
LABEL_654:
            ++v55;
            ++v54;
            v196 += v195;
            ++v33;
            LODWORD(v43) = v43 - 1;
            if (!(_DWORD)v43)
            {
LABEL_655:
              v42 = &v196[v429];
              v194 = v431;
LABEL_656:
              v33 += v194;
              v30 += v432;
              v43 = v438;
LABEL_657:
              v27 = v428;
              goto LABEL_605;
            }
          }
          v387 = v388 >> 8;
LABEL_653:
          v389 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v387);
          DplusdDA(v33, *v33, v389, BYTE4(v389));
          goto LABEL_654;
        case 12:
          v200 = v42 != 0;
          if (!v27)
          {
            v390 = v42;
            v391 = v43;
            do
            {
              v392 = *v55;
              if (*v55)
              {
                if (!v42
                  || (v392 = ((unsigned __int16)(*v390 * (_WORD)v392
                                                                + ((*v390 * v392) >> 8)
                                                                + 1) >> 8)) != 0)
                {
                  v393 = (((((*(_DWORD *)v54 >> 8) & 0xFF00FF) * v392
                          + 65537
                          + (((((*(_DWORD *)v54 >> 8) & 0xFF00FFu) * v392) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + ((*v33 >> 8) & 0xFF00FF);
                  v394 = ((((*(_DWORD *)v54 & 0xFF00FF) * v392
                          + 65537
                          + ((((*(_DWORD *)v54 & 0xFF00FFu) * v392) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                       + (*v33 & 0xFF00FF);
                  *v33 = (v393 << 8) & 0xFF00FF00 | v394 & 0xFF00FF | (15 * (v393 & 0x1000100 | (v394 >> 8) & 0x10001)) | (240 * (v393 & 0x1000100 | (v394 >> 8) & 0x10001));
                }
              }
              ++v55;
              ++v54;
              v390 += v200;
              ++v33;
              --v391;
            }
            while (v391);
            v42 = &v390[v429];
            v33 += v431;
            goto LABEL_711;
          }
          v154 = v42;
          while (1)
          {
            v201 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_351;
              v202 = *v154 * v201 + ((*v154 * v201) >> 8) + 1;
              if (BYTE1(v202))
                break;
            }
LABEL_354:
            ++v55;
            ++v54;
            v154 += v200;
            ++v33;
            ++v30;
            LODWORD(v43) = v43 - 1;
            if (!(_DWORD)v43)
              goto LABEL_355;
          }
          v201 = v202 >> 8;
LABEL_351:
          v203 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v201);
          v204 = ((v203 >> 8) & 0xFF00FF) + ((*v33 >> 8) & 0xFF00FF);
          v205 = *v30 + HIDWORD(v203);
          v206 = (v204 << 8) & 0xFF00FF00 | ((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                                * (v204 & 0x1000100 | (((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v204 & 0x1000100 | (((v203 & 0xFF00FF) + (*v33 & 0xFF00FF)) >> 8) & 0x10001));
          if (v205 >= 0xFF)
            LOBYTE(v205) = -1;
          *v30 = v205;
          *v33 = v206;
          goto LABEL_354;
        case 13:
          v207 = v43;
          v208 = v42;
          v209 = v207;
          while (1)
          {
            v210 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_361;
              v211 = *v208 * v210 + ((*v208 * v210) >> 8) + 1;
              if (BYTE1(v211))
                break;
            }
LABEL_367:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v209)
              goto LABEL_602;
          }
          v210 = v211 >> 8;
LABEL_361:
          v212 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v210);
          if (BYTE4(v212))
          {
            v213 = v212;
            v214 = HIDWORD(v212);
            if (v27)
            {
              if (*v30)
              {
                v215 = PDAmultiplyPDA_5206(*v33, *v30, v212, BYTE4(v212));
                v213 = v215;
                v214 = HIDWORD(v215);
              }
              *v33 = v213;
              *v30 = v214;
            }
            else
            {
              *v33 = PDAmultiplyPDA_5206(*v33, 255, v212, BYTE4(v212));
            }
          }
          goto LABEL_367;
        case 14:
          v216 = v43;
          v208 = v42;
          v217 = v216;
          while (1)
          {
            v218 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_374;
              v219 = *v208 * v218 + ((*v208 * v218) >> 8) + 1;
              if (BYTE1(v219))
                break;
            }
LABEL_380:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v217)
              goto LABEL_602;
          }
          v218 = v219 >> 8;
LABEL_374:
          v220 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v218);
          if (BYTE4(v220))
          {
            v221 = v220;
            v222 = HIDWORD(v220);
            if (v27)
            {
              if (*v30)
              {
                v223 = PDAscreenPDA_5207(*v33, *v30, v220, BYTE4(v220));
                v221 = v223;
                v222 = HIDWORD(v223);
              }
              *v33 = v221;
              *v30 = v222;
            }
            else
            {
              *v33 = PDAscreenPDA_5207(*v33, 0xFFu, v220, BYTE4(v220));
            }
          }
          goto LABEL_380;
        case 15:
          v224 = v43;
          v208 = v42;
          v225 = v224;
          while (1)
          {
            v226 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_387;
              v227 = *v208 * v226 + ((*v208 * v226) >> 8) + 1;
              if (BYTE1(v227))
                break;
            }
LABEL_393:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v225)
              goto LABEL_602;
          }
          v226 = v227 >> 8;
LABEL_387:
          v228 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v226);
          if (BYTE4(v228))
          {
            v229 = v228;
            v230 = HIDWORD(v228);
            if (v27)
            {
              if (*v30)
              {
                v231 = PDAoverlayPDA_5208(*v33, *v30, v228, BYTE4(v228));
                v229 = v231;
                v230 = HIDWORD(v231);
              }
              *v33 = v229;
              *v30 = v230;
            }
            else
            {
              *v33 = PDAoverlayPDA_5208(*v33, 255, v228, BYTE4(v228));
            }
          }
          goto LABEL_393;
        case 16:
          v232 = v43;
          v208 = v42;
          v233 = v232;
          while (1)
          {
            v234 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_400;
              v235 = *v208 * v234 + ((*v208 * v234) >> 8) + 1;
              if (BYTE1(v235))
                break;
            }
LABEL_406:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v233)
              goto LABEL_602;
          }
          v234 = v235 >> 8;
LABEL_400:
          v236 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v234);
          if (BYTE4(v236))
          {
            v243 = v236;
            v244 = HIDWORD(v236);
            if (v27)
            {
              if (*v30)
              {
                v245 = PDAdarkenPDA_5210(*v33, *v30, v236, BYTE4(v236), v237, v238, v239, v240, v241, v242);
                v243 = v245;
                v244 = HIDWORD(v245);
              }
              *v33 = v243;
              *v30 = v244;
            }
            else
            {
              *v33 = PDAdarkenPDA_5210(*v33, 0xFFu, v236, BYTE4(v236), v237, v238, v239, v240, v241, v242);
            }
          }
          goto LABEL_406;
        case 17:
          v246 = v43;
          v208 = v42;
          v247 = v246;
          while (1)
          {
            v248 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_413;
              v249 = *v208 * v248 + ((*v208 * v248) >> 8) + 1;
              if (BYTE1(v249))
                break;
            }
LABEL_419:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v247)
              goto LABEL_602;
          }
          v248 = v249 >> 8;
LABEL_413:
          v250 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v248);
          if (BYTE4(v250))
          {
            v257 = v250;
            v258 = HIDWORD(v250);
            if (v27)
            {
              if (*v30)
              {
                v259 = PDAlightenPDA_5209(*v33, *v30, v250, BYTE4(v250), v251, v252, v253, v254, v255, v256);
                v257 = v259;
                v258 = HIDWORD(v259);
              }
              *v33 = v257;
              *v30 = v258;
            }
            else
            {
              *v33 = PDAlightenPDA_5209(*v33, 0xFFu, v250, BYTE4(v250), v251, v252, v253, v254, v255, v256);
            }
          }
          goto LABEL_419;
        case 18:
          v260 = v43;
          v208 = v42;
          v261 = v260;
          while (1)
          {
            v262 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_426;
              v263 = *v208 * v262 + ((*v208 * v262) >> 8) + 1;
              if (BYTE1(v263))
                break;
            }
LABEL_432:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v261)
              goto LABEL_602;
          }
          v262 = v263 >> 8;
LABEL_426:
          v264 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v262);
          if (BYTE4(v264))
          {
            v265 = v264;
            v266 = HIDWORD(v264);
            if (v27)
            {
              if (*v30)
              {
                v267 = PDAcolordodgePDA_5211(*v33, *v30, v264, BYTE4(v264));
                v265 = v267;
                v266 = HIDWORD(v267);
              }
              *v33 = v265;
              *v30 = v266;
            }
            else
            {
              *v33 = PDAcolordodgePDA_5211(*v33, 255, v264, BYTE4(v264));
            }
          }
          goto LABEL_432;
        case 19:
          v268 = v43;
          v208 = v42;
          v269 = v268;
          while (1)
          {
            v270 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_439;
              v271 = *v208 * v270 + ((*v208 * v270) >> 8) + 1;
              if (BYTE1(v271))
                break;
            }
LABEL_445:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v269)
              goto LABEL_602;
          }
          v270 = v271 >> 8;
LABEL_439:
          v272 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v270);
          if (BYTE4(v272))
          {
            v273 = v272;
            v274 = HIDWORD(v272);
            if (v27)
            {
              if (*v30)
              {
                v275 = PDAcolorburnPDA_5212(*v33, *v30, v272, BYTE4(v272));
                v273 = v275;
                v274 = HIDWORD(v275);
              }
              *v33 = v273;
              *v30 = v274;
            }
            else
            {
              *v33 = PDAcolorburnPDA_5212(*v33, 255, v272, BYTE4(v272));
            }
          }
          goto LABEL_445;
        case 20:
          v276 = v43;
          v208 = v42;
          v277 = v276;
          while (1)
          {
            v278 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_452;
              v279 = *v208 * v278 + ((*v208 * v278) >> 8) + 1;
              if (BYTE1(v279))
                break;
            }
LABEL_458:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v277)
              goto LABEL_602;
          }
          v278 = v279 >> 8;
LABEL_452:
          v280 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v278);
          if (BYTE4(v280))
          {
            v281 = v280;
            v282 = HIDWORD(v280);
            if (v27)
            {
              if (*v30)
              {
                v283 = PDAsoftlightPDA_5214(*v33, *v30, v280, BYTE4(v280));
                v281 = v283;
                v282 = HIDWORD(v283);
              }
              *v33 = v281;
              *v30 = v282;
            }
            else
            {
              *v33 = PDAsoftlightPDA_5214(*v33, 255, v280, BYTE4(v280));
            }
          }
          goto LABEL_458;
        case 21:
          v284 = v43;
          v208 = v42;
          v285 = v284;
          while (1)
          {
            v286 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_465;
              v287 = *v208 * v286 + ((*v208 * v286) >> 8) + 1;
              if (BYTE1(v287))
                break;
            }
LABEL_471:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v285)
              goto LABEL_602;
          }
          v286 = v287 >> 8;
LABEL_465:
          v288 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v286);
          if (BYTE4(v288))
          {
            v289 = v288;
            v290 = HIDWORD(v288);
            if (v27)
            {
              if (*v30)
              {
                v291 = PDAhardlightPDA_5213(*v33, *v30, v288, BYTE4(v288));
                v289 = v291;
                v290 = HIDWORD(v291);
              }
              *v33 = v289;
              *v30 = v290;
            }
            else
            {
              *v33 = PDAhardlightPDA_5213(*v33, 255, v288, BYTE4(v288));
            }
          }
          goto LABEL_471;
        case 22:
          v292 = v43;
          v208 = v42;
          v293 = v292;
          while (1)
          {
            v294 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_478;
              v295 = *v208 * v294 + ((*v208 * v294) >> 8) + 1;
              if (BYTE1(v295))
                break;
            }
LABEL_484:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v293)
              goto LABEL_602;
          }
          v294 = v295 >> 8;
LABEL_478:
          v296 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v294);
          if (BYTE4(v296))
          {
            v297 = v296;
            v298 = HIDWORD(v296);
            if (v27)
            {
              if (*v30)
              {
                v299 = PDAdifferencePDA_5215(*v33, *v30, v296, BYTE4(v296));
                v297 = v299;
                v298 = HIDWORD(v299);
              }
              *v33 = v297;
              *v30 = v298;
            }
            else
            {
              *v33 = PDAdifferencePDA_5215(*v33, 0xFFu, v296, BYTE4(v296));
            }
          }
          goto LABEL_484;
        case 23:
          v300 = v43;
          v208 = v42;
          v301 = v300;
          while (1)
          {
            v302 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_491;
              v303 = *v208 * v302 + ((*v208 * v302) >> 8) + 1;
              if (BYTE1(v303))
                break;
            }
LABEL_497:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v301)
              goto LABEL_602;
          }
          v302 = v303 >> 8;
LABEL_491:
          v304 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v302);
          if (BYTE4(v304))
          {
            v305 = v304;
            v306 = HIDWORD(v304);
            if (v27)
            {
              if (*v30)
              {
                v307 = PDAexclusionPDA_5216(*v33, *v30, v304, BYTE4(v304));
                v305 = v307;
                v306 = HIDWORD(v307);
              }
              *v33 = v305;
              *v30 = v306;
            }
            else
            {
              *v33 = PDAexclusionPDA_5216(*v33, 255, v304, BYTE4(v304));
            }
          }
          goto LABEL_497;
        case 24:
          v308 = v43;
          v208 = v42;
          v309 = v308;
          while (1)
          {
            v310 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_504;
              v311 = *v208 * v310 + ((*v208 * v310) >> 8) + 1;
              if (BYTE1(v311))
                break;
            }
LABEL_510:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v309)
              goto LABEL_602;
          }
          v310 = v311 >> 8;
LABEL_504:
          v312 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v310);
          if (BYTE4(v312))
          {
            v313 = v312;
            v314 = HIDWORD(v312);
            if (v27)
            {
              if (*v30)
              {
                v315 = PDAhuePDA_5217(*v33, *v30, v312, BYTE4(v312));
                v313 = v315;
                v314 = HIDWORD(v315);
              }
              *v33 = v313;
              *v30 = v314;
            }
            else
            {
              *v33 = PDAhuePDA_5217(*v33, 255, v312, BYTE4(v312));
            }
          }
          goto LABEL_510;
        case 25:
          v316 = v43;
          v208 = v42;
          v317 = v316;
          while (1)
          {
            v318 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_517;
              v319 = *v208 * v318 + ((*v208 * v318) >> 8) + 1;
              if (BYTE1(v319))
                break;
            }
LABEL_523:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v317)
              goto LABEL_602;
          }
          v318 = v319 >> 8;
LABEL_517:
          v320 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v318);
          if (BYTE4(v320))
          {
            v321 = v320;
            v322 = HIDWORD(v320);
            if (v27)
            {
              if (*v30)
              {
                v323 = PDAsaturationPDA_5218(*v33, *v30, v320, BYTE4(v320));
                v321 = v323;
                v322 = HIDWORD(v323);
              }
              *v33 = v321;
              *v30 = v322;
            }
            else
            {
              *v33 = PDAsaturationPDA_5218(*v33, 255, v320, BYTE4(v320));
            }
          }
          goto LABEL_523;
        case 26:
          v324 = v43;
          v208 = v42;
          v325 = v324;
          while (1)
          {
            v326 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_530;
              v327 = *v208 * v326 + ((*v208 * v326) >> 8) + 1;
              if (BYTE1(v327))
                break;
            }
LABEL_536:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v325)
              goto LABEL_602;
          }
          v326 = v327 >> 8;
LABEL_530:
          v328 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v326);
          if (BYTE4(v328))
          {
            v329 = HIDWORD(v328);
            if (v27)
            {
              if (*v30)
              {
                v328 = PDAluminosityPDA_5219(v328, BYTE4(v328), *v33, *v30);
                v329 = HIDWORD(v328);
              }
              *v33 = v328;
              *v30 = v329;
            }
            else
            {
              *v33 = PDAluminosityPDA_5219(v328, BYTE4(v328), *v33, 255);
            }
          }
          goto LABEL_536;
        case 27:
          v330 = v43;
          v208 = v42;
          v331 = v330;
          while (1)
          {
            v332 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_543;
              v333 = *v208 * v332 + ((*v208 * v332) >> 8) + 1;
              if (BYTE1(v333))
                break;
            }
LABEL_549:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v331)
              goto LABEL_602;
          }
          v332 = v333 >> 8;
LABEL_543:
          v334 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v332);
          if (BYTE4(v334))
          {
            v335 = v334;
            v336 = HIDWORD(v334);
            if (v27)
            {
              if (*v30)
              {
                v337 = PDAluminosityPDA_5219(*v33, *v30, v334, BYTE4(v334));
                v335 = v337;
                v336 = HIDWORD(v337);
              }
              *v33 = v335;
              *v30 = v336;
            }
            else
            {
              *v33 = PDAluminosityPDA_5219(*v33, 255, v334, BYTE4(v334));
            }
          }
          goto LABEL_549;
        case 28:
          v338 = v43;
          v208 = v42;
          v339 = v338;
          while (1)
          {
            v340 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_556;
              v341 = *v208 * v340 + ((*v208 * v340) >> 8) + 1;
              if (BYTE1(v341))
                break;
            }
LABEL_562:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v339)
              goto LABEL_602;
          }
          v340 = v341 >> 8;
LABEL_556:
          v342 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v340);
          if (BYTE4(v342))
          {
            v343 = v342;
            v344 = HIDWORD(v342);
            if (v27)
            {
              if (*v30)
              {
                v345 = PDAtranspose_huePDA(*v33, *v30, v342, BYTE4(v342));
                v343 = v345;
                v344 = HIDWORD(v345);
              }
              *v33 = v343;
              *v30 = v344;
            }
            else
            {
              *v33 = PDAtranspose_huePDA(*v33, 255, v342, BYTE4(v342));
            }
          }
          goto LABEL_562;
        case 29:
          v346 = v43;
          v208 = v42;
          v347 = v346;
          while (1)
          {
            v348 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_569;
              v349 = *v208 * v348 + ((*v208 * v348) >> 8) + 1;
              if (BYTE1(v349))
                break;
            }
LABEL_575:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v347)
              goto LABEL_602;
          }
          v348 = v349 >> 8;
LABEL_569:
          v350 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v348);
          if (BYTE4(v350))
          {
            v351 = v350;
            v352 = HIDWORD(v350);
            if (v27)
            {
              if (*v30)
              {
                v353 = PDAtranspose_saturationPDA(*v33, *v30, v350, BYTE4(v350));
                v351 = v353;
                v352 = HIDWORD(v353);
              }
              *v33 = v351;
              *v30 = v352;
            }
            else
            {
              *v33 = PDAtranspose_saturationPDA(*v33, 255, v350, BYTE4(v350));
            }
          }
          goto LABEL_575;
        case 30:
          v354 = v43;
          v208 = v42;
          v355 = v354;
          while (1)
          {
            v356 = *v55;
            if (*v55)
            {
              if (!v42)
                goto LABEL_582;
              v357 = *v208 * v356 + ((*v208 * v356) >> 8) + 1;
              if (BYTE1(v357))
                break;
            }
LABEL_588:
            ++v55;
            ++v54;
            v208 += v42 != 0;
            ++v33;
            v30 += v440;
            if (!--v355)
              goto LABEL_602;
          }
          v356 = v357 >> 8;
LABEL_582:
          v358 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v356);
          if (BYTE4(v358))
          {
            v359 = HIDWORD(v358);
            if (v27)
            {
              if (*v30)
              {
                v358 = PDAtranspose_luminosityPDA(v358, BYTE4(v358), *v33, *v30);
                v359 = HIDWORD(v358);
              }
              *v33 = v358;
              *v30 = v359;
            }
            else
            {
              *v33 = PDAtranspose_luminosityPDA(v358, BYTE4(v358), *v33, 255);
            }
          }
          goto LABEL_588;
        case 31:
          v360 = v43;
          v208 = v42;
          v361 = v360;
          break;
        default:
          goto LABEL_605;
      }
      break;
    }
    while (1)
    {
      v362 = *v55;
      if (*v55)
      {
        if (!v42)
          goto LABEL_595;
        v363 = *v208 * v362 + ((*v208 * v362) >> 8) + 1;
        if (BYTE1(v363))
          break;
      }
LABEL_601:
      ++v55;
      ++v54;
      v208 += v42 != 0;
      ++v33;
      v30 += v440;
      if (!--v361)
      {
LABEL_602:
        v42 = &v208[v429];
LABEL_603:
        v37 = v430;
        v33 += v431;
        v30 += v432;
LABEL_604:
        v43 = v438;
        goto LABEL_605;
      }
    }
    v362 = v363 >> 8;
LABEL_595:
    v364 = PDAM_5205(*(_DWORD *)v54, *((unsigned __int8 *)v54 + 4), v362);
    if (BYTE4(v364))
    {
      v365 = v364;
      v366 = HIDWORD(v364);
      if (v27)
      {
        if (*v30)
        {
          v367 = PDAtranspose_luminosityPDA(*v33, *v30, v364, BYTE4(v364));
          v365 = v367;
          v366 = HIDWORD(v367);
        }
        *v33 = v365;
        *v30 = v366;
      }
      else
      {
        *v33 = PDAtranspose_luminosityPDA(*v33, 255, v364, BYTE4(v364));
      }
    }
    goto LABEL_601;
  }
  v416 = v32;
  shape_enum_clip_alloc((uint64_t)v17, v18, v8, 1, 1, 1, v34, v35, v438, v434);
  if (!v44)
    goto LABEL_34;
  v436 = (void *)v44;
  LODWORD(v437) = 0;
  v45 = (int)((v13 * v4 + 15) & 0xFFFFFFF0);
  if (!(_DWORD)v13)
    v45 = 8 * v4;
  v46 = v422;
  v429 = -v422;
  v42 = (unsigned __int8 *)(v24 + v45 + 16);
  v37 = v430;
  v43 = v438;
  v38 = v435;
  v47 = v418;
LABEL_22:
  v48 = v432 + v46;
  while (1)
  {
    while (1)
    {
      v49 = *((_DWORD *)v42 - 4);
      v40 = v437;
      v50 = v49 - v437;
      if (v49 > (int)v437)
        break;
      if ((int)v437 < *((_DWORD *)v42 - 3) + v49)
      {
        v31 = v422;
        v32 = v416;
        v39 = (uint64_t)v436;
        goto LABEL_38;
      }
      if (!shape_enum_clip_scan((uint64_t)v436, (_DWORD *)v42 - 4))
        goto LABEL_31;
    }
    v434 -= v50;
    if (v434 < 1)
      break;
    v38 += *(_QWORD *)(v37 + 128) * v50;
    v47 += *(_QWORD *)(v37 + 136) * v50;
    v33 += v415 * v50;
    v51 = v48 * v50;
    if (!v27)
      v51 = 0;
    v30 += v51;
    LODWORD(v437) = v49;
  }
LABEL_31:
  v52 = v436;
LABEL_32:
  if (v52)
    free(v52);
LABEL_34:
  if (v417)
    free(v417);
}

unint64_t PDAM_5205(unsigned int a1, int a2, int a3)
{
  return (((a1 & 0xFF00FF) * a3 + 65537 + ((((a1 & 0xFF00FF) * a3) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((a1 >> 8) & 0xFF00FF) * a3 + 65537 + (((((a1 >> 8) & 0xFF00FF) * a3) >> 8) & 0xFF00FF)) & 0xFF00FF00 | ((unint64_t)((a3 * a2 + ((a3 * a2) >> 8) + 1) >> 8) << 32);
}

unsigned int *DAMplusDAM(unsigned int *result, _BYTE *a2, unsigned int a3, int a4, int a5, unsigned int a6, int a7, int a8)
{
  unsigned int v8;
  unsigned int v9;

  v8 = ((a3 >> 8) & 0xFF00FF) * a5 + ((a6 >> 8) & 0xFF00FF) * a8;
  v9 = (a3 & 0xFF00FF) * a5 + (a6 & 0xFF00FF) * a8;
  *a2 = (unsigned __int16)(a5 * a4 + a8 * a7 + ((a5 * a4 + a8 * a7) >> 8) + 1) >> 8;
  *result = ((v9 + 65537 + ((v9 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v8 + 65537 + ((v8 >> 8) & 0xFF00FF)) & 0xFF00FF00;
  return result;
}

unsigned int *DMplusDM(unsigned int *result, unsigned int a2, int a3, unsigned int a4, int a5)
{
  unsigned int v5;
  unsigned int v6;

  v5 = ((a2 >> 8) & 0xFF00FF) * a3 + ((a4 >> 8) & 0xFF00FF) * a5;
  v6 = (a2 & 0xFF00FF) * a3 + (a4 & 0xFF00FF) * a5;
  *result = ((v6 + 65537 + ((v6 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v5 + 65537 + ((v5 >> 8) & 0xFF00FF)) & 0xFF00FF00;
  return result;
}

_DWORD *DAplusDAM(_DWORD *result, _BYTE *a2, int a3, char a4, unsigned int a5, int a6, int a7)
{
  *a2 = a4 + ((unsigned __int16)(a7 * a6 + ((a7 * a6) >> 8) + 1) >> 8);
  *result = ((((a5 >> 8) & 0xFF00FF) * a7 + 65537 + (((((a5 >> 8) & 0xFF00FF) * a7) >> 8) & 0xFF00FF)) & 0xFF00FF00)
          + a3
          + ((((a5 & 0xFF00FF) * a7 + 65537 + ((((a5 & 0xFF00FF) * a7) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
  return result;
}

_DWORD *DAplusdDA(_DWORD *result, _BYTE *a2, int a3, int a4, int a5, int a6)
{
  unsigned int v6;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  unint64_t v14;

  v6 = ((a4 << 16) | (a4 << 24) | (((a4 << 16) | (a4 << 24)) >> 16)) - a3;
  v7 = ((a6 << 16) | (a6 << 24) | (((a6 << 16) | (a6 << 24)) >> 16)) - a5;
  v8 = ((v7 >> 8) & 0xFF00FF) + ((v6 >> 8) & 0xFF00FF);
  v9 = (v7 & 0xFF00FF) + (v6 & 0xFF00FF);
  v10 = v8 & 0x1000100 | (v9 >> 8) & 0x10001;
  v11 = a6 + a4;
  v12 = 15 * v10;
  v13 = 240 * v10;
  if ((a6 + a4) > 0xFF)
    v11 = -1;
  HIDWORD(v14) = v11;
  LODWORD(v14) = v11 << 24;
  *a2 = v11;
  *result = ((v14 >> 8) | ((v14 >> 8) >> 16)) - ((v8 << 8) & 0xFF00FF00 | v9 & 0xFF00FF | v12 | v13);
  return result;
}

unsigned int *DplusdDA(unsigned int *result, int a2, int a3, int a4)
{
  unsigned int v4;
  unsigned int v5;

  v4 = ((a4 << 16) | (a4 << 24) | (((a4 << 16) | (a4 << 24)) >> 16)) - a3;
  v5 = ((v4 >> 8) & 0xFF00FF) + ((~a2 >> 8) & 0xFF00FF);
  *result = ~((v5 << 8) & 0xFF00FF00 | ((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) & 0xFF00FF | (15
                                                                                        * (v5 & 0x1000100 | (((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v5 & 0x1000100 | (((v4 & 0xFF00FF) + (~a2 & 0xFF00FF)) >> 8) & 0x10001)));
  return result;
}

unint64_t PDAmultiplyPDA_5206(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;

  v4 = a2 - HIBYTE(a1);
  v5 = a2 - BYTE2(a1);
  v6 = a2 - BYTE1(a1);
  v7 = a2 - a1;
  v8 = a4 - HIBYTE(a3);
  v9 = a4 - BYTE2(a3);
  v10 = a4 - BYTE1(a3);
  v11 = a4 - a3;
  v12 = v8 + (a4 ^ 0xFF);
  v13 = v9 + (a4 ^ 0xFF);
  v14 = v10 + (a4 ^ 0xFF);
  v15 = v11 + (a4 ^ 0xFF);
  if (a4 == 255)
  {
    v12 = v8;
    v13 = v9;
    v14 = v10;
    v15 = v11;
  }
  v16 = v15 * v7;
  v17 = v14 * v6;
  v18 = v13 * v5;
  v19 = v12 * v4;
  v20 = v19 + v8 * (a2 ^ 0xFF);
  v21 = v18 + v9 * (a2 ^ 0xFF);
  v22 = v17 + v10 * (a2 ^ 0xFF);
  v23 = v16 + v11 * (a2 ^ 0xFF);
  if (a2 != 255)
  {
    v19 = v20;
    v18 = v21;
    v17 = v22;
    v16 = v23;
  }
  v24 = 255 * (a4 + a2) - a4 * a2;
  if (v19 >= 65152)
    v25 = 65152;
  else
    v25 = v19 + 128;
  v26 = v25 + (v25 >> 8);
  if (v18 >= 65152)
    v27 = 65152;
  else
    v27 = v18 + 128;
  v28 = v27 + (v27 >> 8);
  if (v17 >= 65152)
    v29 = 65152;
  else
    v29 = v17 + 128;
  v30 = v29 + (v29 >> 8);
  if (v16 >= 65152)
    v31 = 65152;
  else
    v31 = v16 + 128;
  v32 = v31 + (v31 >> 8);
  if (v24 >= 65152)
    v33 = 65152;
  else
    v33 = v24 + 128;
  v34 = (v33 + (v33 >> 8)) >> 8;
  return ((v34 - (v26 >> 8)) << 24) | ((v34 - BYTE1(v28)) << 16) | ((v34 - BYTE1(v30)) << 8) | (v34 - BYTE1(v32)) | ((unint64_t)v34 << 32);
}

unint64_t PDAscreenPDA_5207(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int32x2_t v4;
  int8x8_t v5;
  int v6;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  uint32x2_t v18;
  int8x8_t v19;

  v4 = (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
  v5 = (int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0);
  v6 = HIBYTE(a1) - a2 + (a4 - HIBYTE(a3)) * (255 - (a2 - HIBYTE(a1))) + ((a2 - HIBYTE(a1)) << 8);
  v7 = a1
     - a2
     + (a4 - a3) * (255 - (a2 - a1))
     + ((a2 - a1) << 8);
  v8 = 255 * (a4 + a2) - a4 * a2;
  if (v6 >= 65152)
    v9 = 65152;
  else
    v9 = v6 + 128;
  v10 = v9 + (v9 >> 8);
  if (v7 >= 65152)
    v11 = 65152;
  else
    v11 = v7 + 128;
  v12 = v11 + (v11 >> 8);
  if (v8 >= 65152)
    v13 = 65152;
  else
    v13 = v8 + 128;
  v14 = (v13 + (v13 >> 8)) >> 8;
  v15 = vsub_s32(vdup_n_s32(a2), v4);
  v16 = vmla_s32(vmul_s32(v15, (int32x2_t)0xFF000000FFLL), vsub_s32(vdup_n_s32(a4), (int32x2_t)vand_s8(v5, (int8x8_t)0xFF000000FFLL)), vsub_s32((int32x2_t)0xFF000000FFLL, v15));
  v17 = vdup_n_s32(0xFE80u);
  v18 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v17, v16), (int8x8_t)vadd_s32(v16, (int32x2_t)0x8000000080), (int8x8_t)v17);
  v19 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v14), (int32x2_t)vshr_n_u32(vsra_n_u32(v18, v18, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v19.i32[0] | ((v14 - (v10 >> 8)) << 24) | (v14 - BYTE1(v12)) | v19.i32[1] | ((unint64_t)v14 << 32);
}

unint64_t PDAoverlayPDA_5208(unsigned int a1, signed int a2, unsigned int a3, int a4)
{
  signed int v4;
  signed int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  signed int v10;
  int v11;
  int v12;
  signed int v13;
  int v14;
  int v15;
  signed int v16;
  int v17;
  int v18;
  signed int v19;
  int v20;
  int v21;
  signed int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  unsigned int v35;
  unsigned int v36;
  int8x8_t v37;
  int32x2_t v38;
  int8x8_t v39;
  unsigned int v40;
  unsigned int v41;
  int v42;
  unsigned int v43;
  uint32x2_t v44;
  int8x8_t v45;

  v4 = a2 - BYTE1(a1);
  v5 = a2 - a1;
  v6 = a4 - BYTE2(a3);
  v7 = a4 - BYTE1(a3);
  v8 = a4 - a3;
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v9 = a4;
  else
    v9 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v10 = a2;
  else
    v10 = a2 - HIBYTE(a1);
  v11 = 2 * v10 * v9;
  if (v6 >= a4)
    v12 = a4;
  else
    v12 = v6;
  if (a2 - BYTE2(a1) >= a2)
    v13 = a2;
  else
    v13 = a2 - BYTE2(a1);
  v14 = 2 * v13 * v12;
  if (v7 >= a4)
    v15 = a4;
  else
    v15 = v7;
  if (v4 >= a2)
    v16 = a2;
  else
    v16 = v4;
  v17 = 2 * v16 * v15;
  if (v8 >= a4)
    v18 = a4;
  else
    v18 = v8;
  if (v5 >= a2)
    v19 = a2;
  else
    v19 = v5;
  v20 = 2 * v19 * v18;
  v21 = a4 * a2;
  v22 = (a2 + 1) >> 1;
  if (v10 >= v22)
    v23 = v9 * (a2 + 255) + (a4 + 255) * v10 - (v21 + v11);
  else
    v23 = (a4 ^ 0xFF) * v10 + v9 * (a2 ^ 0xFF) + v11;
  v24 = a4 + 255;
  v25 = a2 + 255;
  v26 = v12 * (a2 + 255) + (a4 + 255) * v13 - (v21 + v14);
  v27 = a4 ^ 0xFF;
  v28 = a2 ^ 0xFF;
  v29 = (a4 ^ 0xFF) * v13 + v12 * (a2 ^ 0xFF) + v14;
  if (v13 >= v22)
    v29 = v26;
  v30 = v15 * v25 + v24 * v16 - (v21 + v17);
  v31 = v27 * v16 + v15 * v28 + v17;
  if (v16 >= v22)
    v31 = v30;
  v32 = v18 * v25 + v24 * v19 - (v21 + v20);
  v33 = v27 * v19 + v18 * v28 + v20;
  if (v19 >= v22)
    v33 = v32;
  v34 = 255 * (a4 + a2) - v21;
  v35 = v23 + 128;
  if (v23 >= 65152)
    v35 = 65152;
  v36 = v35 + (v35 >> 8);
  v37 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v29, v31), (int32x2_t)0x8000000080);
  v38 = vdup_n_s32(0xFE80u);
  v39 = (int8x8_t)vcgt_s32(v38, (int32x2_t)__PAIR64__(v29, v31));
  if (v33 >= 65152)
    v40 = 65152;
  else
    v40 = v33 + 128;
  v41 = v40 + (v40 >> 8);
  if (v34 >= 65152)
    v42 = 65152;
  else
    v42 = v34 + 128;
  v43 = (v42 + (v42 >> 8)) >> 8;
  v44 = (uint32x2_t)vbsl_s8(v39, v37, (int8x8_t)v38);
  v45 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v43), (int32x2_t)vshr_n_u32(vsra_n_u32(v44, v44, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v43 - BYTE1(v41)) | v45.i32[0] | v45.i32[1] | ((v43 - (v36 >> 8)) << 24) | ((unint64_t)v43 << 32);
}

unint64_t PDAlightenPDA_5209(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, double a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  int8x16_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int32x2_t v26;
  uint32x2_t v27;
  int8x8_t v28;

  a6.i32[0] = a1;
  a6.i32[1] = a1 >> 8;
  a6.i32[2] = HIWORD(a1);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  v11 = (int32x4_t)vandq_s8(a6, v10);
  v11.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_185004D20).i32[3];
  v12 = vdupq_n_s32(a2);
  v13 = vsubq_s32(v12, v11);
  a10.i32[0] = a3;
  a10.i32[1] = a3 >> 8;
  a10.i32[2] = HIWORD(a3);
  v14 = (int32x4_t)vandq_s8(a10, v10);
  v14.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a3), (uint32x4_t)xmmword_185004D20).i32[3];
  v15 = vdupq_n_s32(a4);
  v16 = vminq_s32(vsubq_s32(v15, v14), v15);
  v17 = vminq_s32(v13, v12);
  v18 = vmaxq_s32(vmulq_s32(v16, v12), vmulq_s32(v17, v15));
  if (a4 != 255)
    v18 = vmlaq_s32(v18, vdupq_n_s32(a4 ^ 0xFF), v17);
  if (a2 != 255)
    v18 = vmlaq_s32(v18, v16, vdupq_n_s32(a2 ^ 0xFF));
  v19 = 255 * (a4 + a2) - a4 * a2;
  if (v18.i32[3] >= 65152)
    v20 = 65152;
  else
    v20 = v18.i32[3] + 128;
  v21 = v20 + (v20 >> 8);
  if (v18.i32[0] >= 65152)
    v22 = 65152;
  else
    v22 = v18.i32[0] + 128;
  v23 = v22 + (v22 >> 8);
  if (v19 >= 65152)
    v24 = 65152;
  else
    v24 = v19 + 128;
  v25 = (v24 + (v24 >> 8)) >> 8;
  v18.i32[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL).u32[0];
  v26 = vdup_n_s32(0xFE80u);
  v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, *(int32x2_t *)v18.i8), (int8x8_t)vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x8000000080), (int8x8_t)v26);
  v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v25), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v25 - (v21 >> 8)) << 24) | (v25 - BYTE1(v23)) | v28.i32[1] | ((unint64_t)v25 << 32);
}

unint64_t PDAdarkenPDA_5210(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4, double a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  int8x16_t v10;
  int32x4_t v11;
  int32x4_t v12;
  int32x4_t v13;
  int32x4_t v14;
  int32x4_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x4_t v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  int v24;
  unsigned int v25;
  int32x2_t v26;
  uint32x2_t v27;
  int8x8_t v28;

  a6.i32[0] = a1;
  a6.i32[1] = a1 >> 8;
  a6.i32[2] = HIWORD(a1);
  v10.i64[0] = 0xFF000000FFLL;
  v10.i64[1] = 0xFF000000FFLL;
  v11 = (int32x4_t)vandq_s8(a6, v10);
  v11.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a1), (uint32x4_t)xmmword_185004D20).i32[3];
  v12 = vdupq_n_s32(a2);
  v13 = vsubq_s32(v12, v11);
  a10.i32[0] = a3;
  a10.i32[1] = a3 >> 8;
  a10.i32[2] = HIWORD(a3);
  v14 = (int32x4_t)vandq_s8(a10, v10);
  v14.i32[3] = vshlq_u32((uint32x4_t)vdupq_n_s32(a3), (uint32x4_t)xmmword_185004D20).i32[3];
  v15 = vdupq_n_s32(a4);
  v16 = vminq_s32(vsubq_s32(v15, v14), v15);
  v17 = vminq_s32(v13, v12);
  v18 = vminq_s32(vmulq_s32(v16, v12), vmulq_s32(v17, v15));
  if (a4 != 255)
    v18 = vmlaq_s32(v18, vdupq_n_s32(a4 ^ 0xFF), v17);
  if (a2 != 255)
    v18 = vmlaq_s32(v18, v16, vdupq_n_s32(a2 ^ 0xFF));
  v19 = 255 * (a4 + a2) - a4 * a2;
  if (v18.i32[3] >= 65152)
    v20 = 65152;
  else
    v20 = v18.i32[3] + 128;
  v21 = v20 + (v20 >> 8);
  if (v18.i32[0] >= 65152)
    v22 = 65152;
  else
    v22 = v18.i32[0] + 128;
  v23 = v22 + (v22 >> 8);
  if (v19 >= 65152)
    v24 = 65152;
  else
    v24 = v19 + 128;
  v25 = (v24 + (v24 >> 8)) >> 8;
  v18.i32[0] = vextq_s8((int8x16_t)v18, (int8x16_t)v18, 8uLL).u32[0];
  v26 = vdup_n_s32(0xFE80u);
  v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, *(int32x2_t *)v18.i8), (int8x8_t)vadd_s32(*(int32x2_t *)v18.i8, (int32x2_t)0x8000000080), (int8x8_t)v26);
  v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v25), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v25 - (v21 >> 8)) << 24) | (v25 - BYTE1(v23)) | v28.i32[1] | ((unint64_t)v25 << 32);
}

unint64_t PDAcolordodgePDA_5211(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;

  v4 = a2 - HIBYTE(a1);
  v5 = a2 - BYTE2(a1);
  v6 = a4 * a4;
  if (v4 >= a2)
    v4 = a2;
  if (v4)
  {
    if (HIBYTE(a3))
      v7 = v6 * v4 / (int)HIBYTE(a3);
    else
      v7 = 65025;
  }
  else
  {
    v7 = 0;
  }
  v8 = a2 - BYTE1(a1);
  if (v5 >= a2)
    v5 = a2;
  if (v5)
  {
    if (BYTE2(a3))
      v9 = v6 * v5 / BYTE2(a3);
    else
      v9 = 65025;
  }
  else
  {
    v9 = 0;
  }
  v10 = a2 - a1;
  if (v8 >= a2)
    v8 = a2;
  if (v8)
  {
    if (BYTE1(a3))
      v11 = v6 * v8 / BYTE1(a3);
    else
      v11 = 65025;
  }
  else
  {
    v11 = 0;
  }
  if (v10 >= a2)
    v12 = a2;
  else
    v12 = v10;
  if (v12)
  {
    if ((_BYTE)a3)
      v13 = v6 * v12 / a3;
    else
      v13 = 65025;
  }
  else
  {
    v13 = 0;
  }
  v14 = v7 + (a4 ^ 0xFF) * v4;
  v15 = v9 + (a4 ^ 0xFF) * v5;
  v16 = v11 + (a4 ^ 0xFF) * v8;
  if (a4 == 255)
    v16 = v11;
  else
    v13 += (a4 ^ 0xFF) * v12;
  if (a4 == 255)
  {
    v15 = v9;
    v14 = v7;
  }
  v17 = v13 + (a4 - a3) * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v17 = v13;
    v18 = v16;
  }
  else
  {
    v18 = v16 + (a4 - BYTE1(a3)) * (a2 ^ 0xFF);
  }
  if (a2 != 255)
  {
    v15 += (a4 - BYTE2(a3)) * (a2 ^ 0xFF);
    v14 += (a4 - HIBYTE(a3)) * (a2 ^ 0xFF);
  }
  v19 = 255 * (a4 + a2) - a4 * a2;
  if (v14 >= v19)
    v14 = 255 * (a4 + a2) - a4 * a2;
  if (v15 >= v19)
    v15 = 255 * (a4 + a2) - a4 * a2;
  if (v18 >= v19)
    v18 = 255 * (a4 + a2) - a4 * a2;
  if (v17 >= v19)
    v17 = 255 * (a4 + a2) - a4 * a2;
  if (v18 >= 65152)
    v20 = 65152;
  else
    v20 = v18 + 128;
  v21 = v20 + (v20 >> 8);
  if (v15 >= 65152)
    v22 = 65152;
  else
    v22 = v15 + 128;
  v23 = v22 + (v22 >> 8);
  if (v14 >= 65152)
    v24 = 65152;
  else
    v24 = v14 + 128;
  v25 = v24 + (v24 >> 8);
  if (v17 >= 65152)
    v26 = 65152;
  else
    v26 = v17 + 128;
  v27 = v26 + (v26 >> 8);
  if (v19 >= 65152)
    v28 = 65152;
  else
    v28 = v19 + 128;
  v29 = (v28 + (v28 >> 8)) >> 8;
  return ((v29 - BYTE1(v23)) << 16) | ((v29 - (v25 >> 8)) << 24) | ((v29 - BYTE1(v21)) << 8) | (v29 - BYTE1(v27)) | ((unint64_t)v29 << 32);
}

unint64_t PDAcolorburnPDA_5212(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  unsigned int v30;
  unsigned int v31;
  int8x8_t v32;
  int32x2_t v33;
  int8x8_t v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  unsigned int v38;
  uint32x2_t v39;
  int8x8_t v40;

  v4 = a4 - BYTE2(a3);
  v5 = a4 - BYTE1(a3);
  v6 = a4 - a3;
  v7 = a4 * a2;
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v8 = a4;
  else
    v8 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v9 = a2;
  else
    v9 = a2 - HIBYTE(a1);
  if (v4 >= a4)
    v10 = a4;
  else
    v10 = v4;
  if (a2 - BYTE2(a1) >= a2)
    v11 = a2;
  else
    v11 = a2 - BYTE2(a1);
  if (v5 >= a4)
    v12 = a4;
  else
    v12 = v5;
  if (a2 - BYTE1(a1) >= a2)
    v13 = a2;
  else
    v13 = a2 - BYTE1(a1);
  if (v6 >= a4)
    v14 = a4;
  else
    v14 = v6;
  if (a2 - a1 >= a2)
    v15 = a2;
  else
    v15 = a2 - a1;
  v16 = v7 + (a4 ^ 0xFF) * v13;
  v17 = v7 + (a4 ^ 0xFF) * v15;
  if (a4 == 255)
  {
    v17 = a4 * a2;
    v16 = 255 * a2;
    v18 = 255 * a2;
  }
  else
  {
    v18 = v7 + (a4 ^ 0xFF) * v11;
  }
  if (a4 == 255)
    v19 = 255 * a2;
  else
    v19 = v7 + (a4 ^ 0xFF) * v9;
  if (a2 == 255)
    v20 = v17;
  else
    v20 = v17 + v14 * (a2 ^ 0xFF);
  if (a2 == 255)
    v21 = v16;
  else
    v21 = v16 + v12 * (a2 ^ 0xFF);
  if (a2 == 255)
    v22 = v18;
  else
    v22 = v18 + v10 * (a2 ^ 0xFF);
  if (a2 == 255)
    v23 = v19;
  else
    v23 = v19 + v8 * (a2 ^ 0xFF);
  v24 = a2 - v9;
  v25 = a4 * a4;
  v26 = (v23 - v25 * v24 / v8) & ~((v23 - v25 * v24 / v8) >> 31);
  if (v8)
    v27 = v26;
  else
    v27 = 0;
  if (HIBYTE(a1))
    v23 = v27;
  if (BYTE2(a1))
  {
    if (v10)
      v22 = (v22 - v25 * (a2 - v11) / v10) & ~((v22 - v25 * (a2 - v11) / v10) >> 31);
    else
      v22 = 0;
  }
  if (BYTE1(a1))
  {
    if (v12)
      v21 = (v21 - v25 * (a2 - v13) / v12) & ~((v21 - v25 * (a2 - v13) / v12) >> 31);
    else
      v21 = 0;
  }
  if (v14)
    v28 = (v20 - v25 * (a2 - v15) / v14) & ~((v20 - v25 * (a2 - v15) / v14) >> 31);
  else
    v28 = 0;
  if (!(_BYTE)a1)
    v28 = v20;
  v29 = 255 * (a4 + a2) - v7;
  v30 = v23 + 128;
  if (v23 >= 65152)
    v30 = 65152;
  v31 = v30 + (v30 >> 8);
  v32 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v22, v21), (int32x2_t)0x8000000080);
  v33 = vdup_n_s32(0xFE80u);
  v34 = (int8x8_t)vcgt_s32(v33, (int32x2_t)__PAIR64__(v22, v21));
  if (v28 >= 65152)
    v35 = 65152;
  else
    v35 = v28 + 128;
  v36 = v35 + (v35 >> 8);
  if (v29 >= 65152)
    v37 = 65152;
  else
    v37 = v29 + 128;
  v38 = (v37 + (v37 >> 8)) >> 8;
  v39 = (uint32x2_t)vbsl_s8(v34, v32, (int8x8_t)v33);
  v40 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v38), (int32x2_t)vshr_n_u32(vsra_n_u32(v39, v39, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v38 - BYTE1(v36)) | v40.i32[0] | v40.i32[1] | ((v38 - (v31 >> 8)) << 24) | ((unint64_t)v38 << 32);
}

unint64_t PDAhardlightPDA_5213(unsigned int a1, int a2, unsigned int a3, signed int a4)
{
  int v4;
  int v5;
  signed int v6;
  signed int v7;
  signed int v8;
  signed int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  signed int v14;
  int v15;
  int v16;
  signed int v17;
  int v18;
  int v19;
  int v20;
  signed int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  unsigned int v37;
  unsigned int v38;
  int8x8_t v39;
  int32x2_t v40;
  int8x8_t v41;
  unsigned int v42;
  unsigned int v43;
  int v44;
  unsigned int v45;
  uint32x2_t v46;
  int8x8_t v47;

  v4 = a2 - BYTE1(a1);
  v5 = a2 - a1;
  v6 = a4 - BYTE2(a3);
  v7 = a4 - BYTE1(a3);
  v8 = a4 - a3;
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v9 = a4;
  else
    v9 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v10 = a2;
  else
    v10 = a2 - HIBYTE(a1);
  v11 = 2 * v10 * v9;
  if (v6 >= a4)
    v6 = a4;
  if (a2 - BYTE2(a1) >= a2)
    v12 = a2;
  else
    v12 = a2 - BYTE2(a1);
  v13 = 2 * v12 * v6;
  if (v7 >= a4)
    v14 = a4;
  else
    v14 = v7;
  if (v4 >= a2)
    v15 = a2;
  else
    v15 = v4;
  v16 = 2 * v15 * v14;
  if (v8 >= a4)
    v17 = a4;
  else
    v17 = v8;
  if (v5 >= a2)
    v18 = a2;
  else
    v18 = v5;
  v19 = 2 * v18 * v17;
  v20 = a4 * a2;
  v21 = (a4 + 1) >> 1;
  if (v9 <= v21)
    v22 = (a4 ^ 0xFF) * v10 + v9 * (a2 ^ 0xFF) + v11;
  else
    v22 = v9 * (a2 + 255) + (a4 + 255) * v10 - (v20 + v11);
  v23 = a4 ^ 0xFF;
  v24 = a2 ^ 0xFF;
  v25 = (a4 ^ 0xFF) * v12 + v6 * (a2 ^ 0xFF) + v13;
  v26 = a4 + 255;
  v27 = a2 + 255;
  v28 = v6 * (a2 + 255) + (a4 + 255) * v12 - (v20 + v13);
  if (v6 > v21)
    v29 = v28;
  else
    v29 = v25;
  v30 = v23 * v15 + v14 * v24 + v16;
  v31 = v14 * v27 + v26 * v15 - (v20 + v16);
  if (v14 > v21)
    v32 = v31;
  else
    v32 = v30;
  v33 = v23 * v18 + v17 * v24 + v19;
  v34 = v17 * v27 + v26 * v18 - (v20 + v19);
  if (v17 > v21)
    v35 = v34;
  else
    v35 = v33;
  v36 = 255 * (a4 + a2) - v20;
  v37 = v22 + 128;
  if (v22 >= 65152)
    v37 = 65152;
  v38 = v37 + (v37 >> 8);
  v39 = (int8x8_t)vadd_s32((int32x2_t)__PAIR64__(v29, v32), (int32x2_t)0x8000000080);
  v40 = vdup_n_s32(0xFE80u);
  v41 = (int8x8_t)vcgt_s32(v40, (int32x2_t)__PAIR64__(v29, v32));
  if (v35 >= 65152)
    v42 = 65152;
  else
    v42 = v35 + 128;
  v43 = v42 + (v42 >> 8);
  if (v36 >= 65152)
    v44 = 65152;
  else
    v44 = v36 + 128;
  v45 = (v44 + (v44 >> 8)) >> 8;
  v46 = (uint32x2_t)vbsl_s8(v41, v39, (int8x8_t)v40);
  v47 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v45), (int32x2_t)vshr_n_u32(vsra_n_u32(v46, v46, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return (v45 - BYTE1(v43)) | v47.i32[0] | v47.i32[1] | ((v45 - (v38 >> 8)) << 24) | ((unint64_t)v45 << 32);
}

unint64_t PDAsoftlightPDA_5214(unsigned int a1, int a2, unsigned int a3, int a4)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  int v37;
  int v38;

  v4 = a2 - HIBYTE(a1);
  v5 = a4 - HIBYTE(a3);
  if (v5 >= a4)
    v5 = a4;
  if (v4 >= a2)
    v4 = a2;
  v6 = a4 - a3;
  v7 = a4 - BYTE1(a3);
  v8 = a4 - BYTE2(a3);
  v9 = a2 - a1;
  v10 = a2 - BYTE1(a1);
  v11 = a2 - BYTE2(a1);
  v12 = v4 * v4 * (2 * v5 - a4) / a2;
  v13 = (2 * v4 * v5 - v12) & ~((2 * v4 * v5 - v12) >> 31);
  if (v8 >= a4)
    v8 = a4;
  if (v11 >= a2)
    v11 = a2;
  v14 = v11 * v11 * (2 * v8 - a4) / a2;
  v15 = (2 * v11 * v8 - v14) & ~((2 * v11 * v8 - v14) >> 31);
  if (v7 >= a4)
    v7 = a4;
  if (v10 >= a2)
    v10 = a2;
  v16 = v10 * v10 * (2 * v7 - a4) / a2;
  v17 = (2 * v10 * v7 - v16) & ~((2 * v10 * v7 - v16) >> 31);
  if (v6 >= a4)
    v6 = a4;
  if (v9 >= a2)
    v9 = a2;
  v18 = 2 * v9 * v6 - v9 * v9 * (2 * v6 - a4) / a2;
  v19 = v18 & ~(v18 >> 31);
  v20 = v13 + (a4 ^ 0xFF) * v4;
  v21 = v15 + v11 * (a4 ^ 0xFF);
  v22 = v17 + v10 * (a4 ^ 0xFF);
  v23 = v19 + v9 * (a4 ^ 0xFF);
  if (a4 == 255)
  {
    v23 = v19;
    v22 = v17;
    v21 = v15;
    v20 = v13;
  }
  v24 = v20 + v5 * (a2 ^ 0xFF);
  v25 = v21 + v8 * (a2 ^ 0xFF);
  v26 = v22 + v7 * (a2 ^ 0xFF);
  v27 = v23 + v6 * (a2 ^ 0xFF);
  if (a2 == 255)
  {
    v27 = v23;
    v26 = v22;
    v25 = v21;
    v24 = v20;
  }
  v28 = 255 * (a4 + a2) - a4 * a2;
  if (v24 >= 65152)
    v29 = 65152;
  else
    v29 = v24 + 128;
  v30 = v29 + (v29 >> 8);
  if (v25 >= 65152)
    v31 = 65152;
  else
    v31 = v25 + 128;
  v32 = v31 + (v31 >> 8);
  if (v26 >= 65152)
    v33 = 65152;
  else
    v33 = v26 + 128;
  v34 = v33 + (v33 >> 8);
  if (v27 >= 65152)
    v35 = 65152;
  else
    v35 = v27 + 128;
  v36 = v35 + (v35 >> 8);
  if (v28 >= 65152)
    v37 = 65152;
  else
    v37 = v28 + 128;
  v38 = (v37 + (v37 >> 8)) >> 8;
  return ((v38 - BYTE1(v32)) << 16) | ((v38 - (v30 >> 8)) << 24) | ((v38 - BYTE1(v34)) << 8) | (v38 - BYTE1(v36)) | ((unint64_t)v38 << 32);
}

unint64_t PDAdifferencePDA_5215(unsigned int a1, unsigned int a2, unsigned int a3, unsigned int a4)
{
  int32x2_t v4;
  uint32x2_t v5;
  int32x2_t v6;
  uint32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  int32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int v21;
  int32x2_t v22;
  int32x2_t v23;
  unsigned int v24;
  int32x2_t v25;
  int32x2_t v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int32x2_t v32;
  int32x2_t v33;
  int32x2_t v34;
  int32x2_t v35;
  uint32x2_t v36;
  int8x8_t v37;

  v4 = vdup_n_s32(a4);
  v5 = (uint32x2_t)vdup_n_s32(a1);
  v6.i32[0] = a1;
  v6.i32[1] = vshl_u32(v5, (uint32x2_t)0xFFFFFFE8FFFFFF01).i32[1];
  v7 = (uint32x2_t)vdup_n_s32(a3);
  v8.i32[0] = a3;
  v8.i32[1] = vshl_u32(v7, (uint32x2_t)0xFFFFFFE8FFFFFF01).i32[1];
  v9 = vmin_s32(vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32(v7, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v4);
  v10 = vdup_n_s32(a2);
  v11 = vmin_s32(vsub_s32(v10, (int32x2_t)vand_s8((int8x8_t)vshl_u32(v5, (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL)), v10);
  v12 = vmin_s32(vsub_s32(v4, v8), v4);
  v13 = vmin_s32(vsub_s32(v10, v6), v10);
  v4.i32[0] = v13.i32[0];
  v4.i32[1] = v12.i32[1];
  v14 = vmul_s32(v4, (int32x2_t)__PAIR64__(a2, a4));
  v15 = vrev64_s32((int32x2_t)__PAIR64__(a2, a4));
  v16 = vadd_s32(v9, v11);
  v17 = (int32x2_t)__PAIR64__(v11.u32[1], v9.u32[0]);
  v11.i32[1] = v9.i32[1];
  v18 = vmul_s32(v11, (int32x2_t)__PAIR64__(a2, a4));
  v19 = vadd_s32(v12, v13);
  v12.i32[1] = v13.i32[1];
  v20 = vmul_s32(v12, v15);
  v13.i32[0] = v20.i32[0];
  v13.i32[1] = v14.i32[1];
  v21 = 255 * (a4 + a2) - a4 * a2;
  v22 = vneg_s32(v14);
  v14.i32[1] = v20.i32[1];
  v23 = vaba_s32(vsub_s32(vmla_s32(v22, v19, (int32x2_t)0xFF000000FFLL), v20), v14, v13);
  v24 = v23.i32[1] + 128;
  v25 = vdup_n_s32(0xFE80u);
  v26 = vcgt_s32(v25, v23);
  if ((v26.i8[4] & 1) == 0)
    v24 = 65152;
  v27 = v24 + (v24 >> 8);
  v28 = v23.i32[0] + 128;
  if ((v26.i8[0] & 1) == 0)
    v28 = 65152;
  v29 = v28 + (v28 >> 8);
  if (v21 >= 65152)
    v30 = 65152;
  else
    v30 = v21 + 128;
  v31 = (v30 + (v30 >> 8)) >> 8;
  v32 = vmul_s32(v17, v15);
  v33 = (int32x2_t)__PAIR64__(v18.u32[1], v32.u32[0]);
  v34 = vneg_s32(v18);
  v18.i32[1] = v32.i32[1];
  v35 = vaba_s32(vsub_s32(vmla_s32(v34, v16, (int32x2_t)0xFF000000FFLL), v32), v18, v33);
  v36 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v25, v35), (int8x8_t)vadd_s32(v35, (int32x2_t)0x8000000080), (int8x8_t)v25);
  v37 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v31), (int32x2_t)vshr_n_u32(vsra_n_u32(v36, v36, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v37.i32[0] | ((v31 - (v27 >> 8)) << 24) | v37.i32[1] | (v31 - BYTE1(v29)) | ((unint64_t)v31 << 32);
}

unint64_t PDAexclusionPDA_5216(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  signed int v4;
  int32x2_t v5;
  int32x2_t v6;
  signed int v7;
  signed int v8;
  int32x2_t v9;
  int32x2_t v10;
  int v11;
  signed int v12;
  int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  int32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  uint32x2_t v27;
  int8x8_t v28;

  v4 = a2 - HIBYTE(a1);
  v5 = vdup_n_s32(a2);
  v6 = vsub_s32(v5, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  v7 = a2 - a1;
  v8 = a4 - HIBYTE(a3);
  v9 = vdup_n_s32(a4);
  v10 = vsub_s32(v9, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if (v8 >= a4)
    v8 = a4;
  if (v4 >= a2)
    v4 = a2;
  v11 = 255 * (v8 + v4) - 2 * v4 * v8;
  if (a4 - a3 >= a4)
    v12 = a4;
  else
    v12 = a4 - a3;
  if (v7 >= a2)
    v7 = a2;
  v13 = 255 * (v12 + v7) - 2 * v7 * v12;
  v14 = 255 * (a4 + a2) - a4 * a2;
  if (v11 >= 65152)
    v15 = 65152;
  else
    v15 = v11 + 128;
  v16 = v15 + (v15 >> 8);
  if (v13 >= 65152)
    v17 = 65152;
  else
    v17 = v13 + 128;
  v18 = v17 + (v17 >> 8);
  if (v14 >= 65152)
    v19 = 65152;
  else
    v19 = v14 + 128;
  v20 = (v19 + (v19 >> 8)) >> 8;
  v21 = vmin_s32(v10, v9);
  v22 = vmin_s32(v6, v5);
  v23 = vmul_s32(vadd_s32(v21, v22), (int32x2_t)0xFF000000FFLL);
  v24 = vmul_s32(v22, v21);
  v25 = vsub_s32(v23, vadd_s32(v24, v24));
  v26 = vdup_n_s32(0xFE80u);
  v27 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v26, v25), (int8x8_t)vadd_s32(v25, (int32x2_t)0x8000000080), (int8x8_t)v26);
  v28 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v20), (int32x2_t)vshr_n_u32(vsra_n_u32(v27, v27, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v28.i32[0] | ((v20 - (v16 >> 8)) << 24) | (v20 - BYTE1(v18)) | v28.i32[1] | ((unint64_t)v20 << 32);
}

unint64_t PDAhuePDA_5217(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int v8;
  int v9;
  int32x2_t v10;
  int32x2_t v11;
  signed int v12;
  int v13;
  int v14;
  double v15;
  int32x2_t v16;
  int v17;
  double v18;
  int32x2_t v19;
  double v20;
  int v21;
  int v22;
  int32x2_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  int v31;
  int v32;
  int v33;
  __int32 v34;
  int v35;
  int32x2_t v36;
  signed int v37;
  int v38;
  __int32 v39;
  int32x2_t v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  signed int v45;
  int v46;
  unsigned int v47;
  int32x2_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int32x2_t v52;
  uint32x2_t v53;
  int8x8_t v54;
  __int32 v56;
  int32x2_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = vdup_n_s32(a2);
  v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  v6 = vdup_n_s32(a4);
  v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v8 = a4;
  else
    v8 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v9 = a2;
  else
    v9 = a2 - HIBYTE(a1);
  v10 = vmin_s32(v7, v6);
  v11 = vmin_s32(v5, v4);
  if (a4 - a3 >= a4)
    v12 = a4;
  else
    v12 = a4 - a3;
  if (a2 - a1 >= a2)
    v13 = a2;
  else
    v13 = a2 - a1;
  if (a4 == 255)
  {
    v17 = 0;
    v14 = 0;
    v15 = 0.0;
  }
  else
  {
    v14 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17 = (a4 ^ 0xFF) * v13;
    v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, v10, vdup_n_s32(a2 ^ 0xFFu)));
  v19 = vmla_s32((int32x2_t)0x8000000080, v10, v4);
  v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    v22 = v14;
  }
  else
  {
    v17 = v21;
    v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    *(double *)&v23 = v15;
  }
  else
  {
    v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    *(double *)&v10 = v20;
    *(double *)&v23 = v18;
  }
  v56 = v8;
  v57 = v10;
  v24 = v8 < v10.i32[0];
  v25 = v8 >= v10.i32[0];
  if (v10.i32[1] >= *(&v56 + v25))
  {
    v27 = *(&v56 + v24);
    v26 = v25;
    if (v10.i32[1] <= v27)
      v25 = 2;
    else
      v25 = v24;
    if (v10.i32[1] > v27)
      v24 = 2;
  }
  else
  {
    v26 = 2;
  }
  v28 = *(&v56 + v24);
  v29 = *(&v56 + v26);
  v30 = __OFSUB__(v28, v29);
  v31 = v28 - v29;
  if ((v31 < 0) ^ v30 | (v31 == 0))
  {
    *(&v56 + v24) = 0;
    *(&v56 + v25) = 0;
  }
  else
  {
    v32 = v11.i32[0];
    if (v9 >= v11.i32[0])
      v33 = v11.i32[0];
    else
      v33 = v9;
    if (v9 > v11.i32[0])
      v32 = v9;
    if (v11.i32[1] <= v32)
      v34 = v32;
    else
      v34 = v11.i32[1];
    if (v11.i32[1] >= v33)
      v32 = v34;
    else
      v33 = v11.i32[1];
    v35 = v32 - v33;
    *(&v56 + v24) = v35;
    *(&v56 + v25) = ((*(&v56 + v25) - *(&v56 + v26)) * ((v35 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v56 + v26) = 0;
  v36 = vmul_s32(vsub_s32(v11, v57), (int32x2_t)0x1C00000097);
  v37 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v38 = v36.i32[0] + 77 * (v9 - v56) + v36.i32[1];
  v39 = v56 + ((v38 + 128) >> 8);
  v40 = vadd_s32(vdup_n_s32((v38 + 128) >> 8), v57);
  if (v38 != (char)v38)
  {
    v41 = v56 >= v57.i32[0] ? v40.i32[0] : v56 + ((v38 + 128) >> 8);
    v42 = v56 >= v57.i32[0] ? v56 + ((v38 + 128) >> 8) : v40.i32[0];
    v43 = v40.i32[1] <= v42 ? v42 : v40.i32[1];
    if (v40.i32[1] >= v41)
      v42 = v43;
    else
      v41 = v40.i32[1];
    if (v42 > v37 || v41 < 0)
    {
      v44 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      if (v38 > -129)
      {
        v45 = v42 - v44;
        if (v42 == v44)
          goto LABEL_64;
        v46 = v37 - v44;
      }
      else
      {
        v45 = v44 - v41;
        if (v44 == v41)
          goto LABEL_64;
        v46 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      }
      v47 = (v46 << 16) / v45;
      v39 = v44 + ((int)(v47 * (v39 - v44) + 0x8000) >> 16);
      v48 = vdup_n_s32(v44);
      v40 = vsra_n_s32(v48, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v47), vsub_s32(v40, v48)), 0x10uLL);
    }
  }
LABEL_64:
  if (v17 >= 65152)
    v49 = 65152;
  else
    v49 = v17 + 128;
  if (v22 >= 65152)
    v50 = 65152;
  else
    v50 = v22 + 128;
  v51 = a4 + a2 - v37;
  v52 = vdup_n_s32(0xFE80u);
  v53 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v52, v23), (int8x8_t)vadd_s32(v23, (int32x2_t)0x8000000080), (int8x8_t)v52);
  v54 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v51), (int32x2_t)vsra_n_u32((uint32x2_t)v40, vsra_n_u32(v53, v53, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v54.i32[0] | ((v51 - (v39 + ((v50 + (v50 >> 8)) >> 8))) << 24) | (v51
                                                                                          - (v13
                                                                                           + ((unsigned __int16)(v49 + (v49 >> 8)) >> 8))) | v54.i32[1] | ((unint64_t)v51 << 32);
}

unint64_t PDAsaturationPDA_5218(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  signed int v8;
  int v9;
  double v10;
  int32x2_t v11;
  signed int v12;
  int v13;
  int v14;
  double v15;
  int32x2_t v16;
  int v17;
  double v18;
  int32x2_t v19;
  double v20;
  int v21;
  int v22;
  int v23;
  int32x2_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  BOOL v31;
  int v32;
  int v33;
  int v34;
  int v35;
  __int32 v36;
  int32x2_t v37;
  signed int v38;
  int v39;
  __int32 v40;
  int32x2_t v41;
  int v42;
  int v43;
  int v44;
  unsigned int v45;
  signed int v46;
  int v47;
  unsigned int v48;
  int32x2_t v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  int32x2_t v53;
  uint32x2_t v54;
  int8x8_t v55;
  __int32 v57;
  int32x2_t v58;
  uint64_t v59;

  v59 = *MEMORY[0x1E0C80C00];
  v4 = vdup_n_s32(a2);
  v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  v6 = vdup_n_s32(a4);
  v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v8 = a4;
  else
    v8 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v9 = a2;
  else
    v9 = a2 - HIBYTE(a1);
  v10 = COERCE_DOUBLE(vmin_s32(v7, v6));
  v11 = vmin_s32(v5, v4);
  if (a4 - a3 >= a4)
    v12 = a4;
  else
    v12 = a4 - a3;
  if (a2 - a1 >= a2)
    v13 = a2;
  else
    v13 = a2 - a1;
  if (a4 == 255)
  {
    v17 = 0;
    v14 = 0;
    v15 = 0.0;
  }
  else
  {
    v14 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17 = (a4 ^ 0xFF) * v13;
    v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  v18 = COERCE_DOUBLE(vadd_s32(vrev64_s32(vmul_s32(*(int32x2_t *)&v10, vdup_n_s32(a2 ^ 0xFFu))), *(int32x2_t *)&v15));
  v19 = vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v10, v4);
  v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    v22 = v14;
  }
  else
  {
    v17 = v21;
    v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
    v23 = v8;
  else
    v23 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    *(double *)&v24 = v15;
  }
  else
  {
    v10 = v20;
    *(double *)&v24 = v18;
  }
  v57 = v9;
  v58 = v11;
  v25 = v9 < v11.i32[0];
  v26 = v9 >= v11.i32[0];
  if (v11.i32[1] >= *(&v57 + v26))
  {
    v28 = *(&v57 + v25);
    v27 = v9 >= v11.i32[0];
    if (v11.i32[1] <= v28)
      v26 = 2;
    else
      v26 = v9 < v11.i32[0];
    if (v11.i32[1] > v28)
      v25 = 2;
  }
  else
  {
    v27 = 2;
  }
  v29 = *(&v57 + v25);
  v30 = *(&v57 + v27);
  v31 = __OFSUB__(v29, v30);
  v32 = v29 - v30;
  if ((v32 < 0) ^ v31 | (v32 == 0))
  {
    *(&v57 + v25) = 0;
    *(&v57 + v26) = 0;
  }
  else
  {
    if (v23 >= SHIDWORD(v10))
      v33 = HIDWORD(v10);
    else
      v33 = v23;
    if (v23 <= SHIDWORD(v10))
      v23 = HIDWORD(v10);
    v34 = LODWORD(v10);
    if (SLODWORD(v10) <= v23)
      v35 = v23;
    else
      v35 = LODWORD(v10);
    if (SLODWORD(v10) >= v33)
    {
      v34 = v33;
      v23 = v35;
    }
    v36 = v23 - v34;
    *(&v57 + v25) = v36;
    *(&v57 + v26) = ((*(&v57 + v26) - *(&v57 + v27)) * ((v36 << 16) / v32) + 0x8000) >> 16;
  }
  *(&v57 + v27) = 0;
  v37 = vmul_s32(vsub_s32(v11, v58), (int32x2_t)0x1C00000097);
  v38 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v39 = v37.i32[0] + 77 * (v9 - v57) + v37.i32[1];
  v40 = v57 + ((v39 + 128) >> 8);
  v41 = vadd_s32(vdup_n_s32((v39 + 128) >> 8), v58);
  if (v39 != (char)v39)
  {
    v42 = v57 >= v58.i32[0] ? v41.i32[0] : v57 + ((v39 + 128) >> 8);
    v43 = v57 >= v58.i32[0] ? v57 + ((v39 + 128) >> 8) : v41.i32[0];
    v44 = v41.i32[1] <= v43 ? v43 : v41.i32[1];
    if (v41.i32[1] >= v42)
      v43 = v44;
    else
      v42 = v41.i32[1];
    if (v43 > v38 || v42 < 0)
    {
      v45 = (77 * v40 + 151 * v41.i32[0] + 28 * v41.i32[1] + 128) >> 8;
      if (v39 > -129)
      {
        v46 = v43 - v45;
        if (v43 == v45)
          goto LABEL_66;
        v47 = v38 - v45;
      }
      else
      {
        v46 = v45 - v42;
        if (v45 == v42)
          goto LABEL_66;
        v47 = (77 * v40 + 151 * v41.i32[0] + 28 * v41.i32[1] + 128) >> 8;
      }
      v48 = (v47 << 16) / v46;
      v40 = v45 + ((int)(v48 * (v40 - v45) + 0x8000) >> 16);
      v49 = vdup_n_s32(v45);
      v41 = vsra_n_s32(v49, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v48), vsub_s32(v41, v49)), 0x10uLL);
    }
  }
LABEL_66:
  if (v17 >= 65152)
    v50 = 65152;
  else
    v50 = v17 + 128;
  if (v22 >= 65152)
    v51 = 65152;
  else
    v51 = v22 + 128;
  v52 = a4 + a2 - v38;
  v53 = vdup_n_s32(0xFE80u);
  v54 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v53, v24), (int8x8_t)vadd_s32(v24, (int32x2_t)0x8000000080), (int8x8_t)v53);
  v55 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v52), (int32x2_t)vsra_n_u32((uint32x2_t)v41, vsra_n_u32(v54, v54, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v55.i32[0] | ((v52 - (v40 + ((v51 + (v51 >> 8)) >> 8))) << 24) | (v52
                                                                                          - (v13
                                                                                           + ((unsigned __int16)(v50 + (v50 >> 8)) >> 8))) | v55.i32[1] | ((unint64_t)v52 << 32);
}

unint64_t PDAluminosityPDA_5219(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int v8;
  int v9;
  int32x2_t v10;
  int v11;
  signed int v12;
  int v13;
  int32x2_t v14;
  int32x2_t v15;
  int v16;
  int32x2_t v17;
  int32x2_t v18;
  signed int v19;
  int32x2_t v20;
  signed __int32 v21;
  signed __int32 v22;
  int32x2_t v23;
  int v24;
  int v25;
  int v26;
  unsigned int v27;
  signed int v28;
  int v29;
  unsigned int v30;
  int32x2_t v31;
  unsigned int v32;
  unsigned int v33;
  int32x2_t v34;
  int8x8_t v35;
  int8x8_t v36;
  unsigned int v37;
  uint32x2_t v38;
  int8x8_t v39;

  v4 = vdup_n_s32(a2);
  v5 = vdup_n_s32(a4);
  v6 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  v7 = vsub_s32(v5, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v8 = a4;
  else
    v8 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v9 = a2;
  else
    v9 = a2 - HIBYTE(a1);
  v10 = vmin_s32(v6, v4);
  if (a4 - a3 >= a4)
    v11 = a4;
  else
    v11 = a4 - a3;
  if (a4 == 255)
  {
    v16 = 0;
    v13 = 0;
    v14 = 0;
  }
  else
  {
    if (a2 - a1 >= a2)
      v12 = a2;
    else
      v12 = a2 - a1;
    v13 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    v14 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v10);
    v15 = vmla_s32((int32x2_t)0x8000000080, v10, v5);
    v10 = vshr_n_s32(vsra_n_s32(v15, v15, 8uLL), 8uLL);
    v16 = (a4 ^ 0xFF) * v12;
  }
  v17 = vmin_s32(v7, v5);
  if (a2 != 255)
  {
    v13 += v8 * (a2 ^ 0xFF);
    v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    v14 = vmla_s32(v14, v17, vdup_n_s32(a2 ^ 0xFFu));
    v18 = vmla_s32((int32x2_t)0x8000000080, v17, v4);
    v17 = vshr_n_s32(vsra_n_s32(v18, v18, 8uLL), 8uLL);
    v16 += v11 * (a2 ^ 0xFF);
    v11 = (v11 * a2 + 128 + ((v11 * a2 + 128) >> 8)) >> 8;
  }
  v19 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v20 = vmul_s32(vsub_s32(v17, v10), (int32x2_t)0x1C00000097);
  v21 = vadd_s32(v20, vdup_lane_s32(v20, 1)).u32[0] + 77 * (v8 - v9);
  v22 = v9 + ((v21 + 128) >> 8);
  v23 = vadd_s32(vdup_n_s32((v21 + 128) >> 8), v10);
  if (v21 != (char)v21)
  {
    v24 = v9 >= v10.i32[0] ? v23.i32[0] : v9 + ((v21 + 128) >> 8);
    v25 = v9 >= v10.i32[0] ? v9 + ((v21 + 128) >> 8) : v23.i32[0];
    v26 = v23.i32[1] <= v25 ? v25 : v23.i32[1];
    if (v23.i32[1] >= v24)
      v25 = v26;
    else
      v24 = v23.i32[1];
    if (v25 > v19 || v24 < 0)
    {
      v27 = (77 * v22 + 151 * v23.i32[0] + 28 * v23.i32[1] + 128) >> 8;
      if (v21 > -129)
      {
        v28 = v25 - v27;
        if (v25 == v27)
          goto LABEL_39;
        v29 = v19 - v27;
      }
      else
      {
        v28 = v27 - v24;
        if (v27 == v24)
          goto LABEL_39;
        v29 = (77 * v22 + 151 * v23.i32[0] + 28 * v23.i32[1] + 128) >> 8;
      }
      v30 = (v29 << 16) / v28;
      v22 = v27 + ((int)(v30 * (v22 - v27) + 0x8000) >> 16);
      v31 = vdup_n_s32(v27);
      v23 = vsra_n_s32(v31, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v30), vsub_s32(v23, v31)), 0x10uLL);
    }
  }
LABEL_39:
  if (v16 >= 65152)
    v32 = 65152;
  else
    v32 = v16 + 128;
  v33 = v32 + (v32 >> 8);
  v34 = vdup_n_s32(0xFE80u);
  v35 = (int8x8_t)vcgt_s32(v34, v14);
  v36 = (int8x8_t)vadd_s32(v14, (int32x2_t)0x8000000080);
  if (v13 >= 65152)
    v37 = 65152;
  else
    v37 = v13 + 128;
  v38 = (uint32x2_t)vbsl_s8(v35, v36, (int8x8_t)v34);
  v39 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(a4 + a2 - v19), (int32x2_t)vsra_n_u32((uint32x2_t)v23, vsra_n_u32(v38, v38, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v39.i32[0] | ((a4 + a2 - v19 - (v22 + ((v37 + (v37 >> 8)) >> 8))) << 24) | (a4 + a2 - v19 - (v11 + BYTE1(v33))) | v39.i32[1] | ((unint64_t)(a4 + a2 - v19) << 32);
}

unint64_t PDAtranspose_huePDA(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  int v8;
  int v9;
  int32x2_t v10;
  int32x2_t v11;
  signed int v12;
  int v13;
  int v14;
  double v15;
  int32x2_t v16;
  int v17;
  double v18;
  int32x2_t v19;
  double v20;
  int v21;
  int v22;
  int32x2_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  int v29;
  BOOL v30;
  int v31;
  int v32;
  int v33;
  __int32 v34;
  int v35;
  int32x2_t v36;
  signed int v37;
  int v38;
  __int32 v39;
  int32x2_t v40;
  int v41;
  int v42;
  int v43;
  unsigned int v44;
  signed int v45;
  int v46;
  unsigned int v47;
  int32x2_t v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int32x2_t v52;
  uint32x2_t v53;
  int8x8_t v54;
  __int32 v56;
  int32x2_t v57;
  uint64_t v58;

  v58 = *MEMORY[0x1E0C80C00];
  v4 = vdup_n_s32(a2);
  v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  v6 = vdup_n_s32(a4);
  v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  if (a4 - a3 >= a4)
    v8 = a4;
  else
    v8 = a4 - a3;
  if (a2 - a1 >= a2)
    v9 = a2;
  else
    v9 = a2 - a1;
  v10 = vmin_s32(v7, v6);
  v11 = vmin_s32(v5, v4);
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v12 = a4;
  else
    v12 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v13 = a2;
  else
    v13 = a2 - HIBYTE(a1);
  if (a4 == 255)
  {
    v17 = 0;
    v14 = 0;
    v15 = 0.0;
  }
  else
  {
    v14 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    v15 = COERCE_DOUBLE(vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11));
    v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17 = (a4 ^ 0xFF) * v13;
    v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
  }
  v18 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v15, v10, vdup_n_s32(a2 ^ 0xFFu)));
  v19 = vmla_s32((int32x2_t)0x8000000080, v10, v4);
  v20 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v19, v19, 8uLL), 8uLL));
  v21 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    v22 = v14;
  }
  else
  {
    v17 = v21;
    v22 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
  {
    *(double *)&v23 = v15;
  }
  else
  {
    v8 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
    *(double *)&v10 = v20;
    *(double *)&v23 = v18;
  }
  v56 = v8;
  v57 = v10;
  v24 = v8 < v10.i32[0];
  v25 = v8 >= v10.i32[0];
  if (v10.i32[1] >= *(&v56 + v25))
  {
    v27 = *(&v56 + v24);
    v26 = v25;
    if (v10.i32[1] <= v27)
      v25 = 2;
    else
      v25 = v24;
    if (v10.i32[1] > v27)
      v24 = 2;
  }
  else
  {
    v26 = 2;
  }
  v28 = *(&v56 + v24);
  v29 = *(&v56 + v26);
  v30 = __OFSUB__(v28, v29);
  v31 = v28 - v29;
  if ((v31 < 0) ^ v30 | (v31 == 0))
  {
    *(&v56 + v24) = 0;
    *(&v56 + v25) = 0;
  }
  else
  {
    v32 = v11.i32[0];
    if (v9 >= v11.i32[0])
      v33 = v11.i32[0];
    else
      v33 = v9;
    if (v9 > v11.i32[0])
      v32 = v9;
    if (v11.i32[1] <= v32)
      v34 = v32;
    else
      v34 = v11.i32[1];
    if (v11.i32[1] >= v33)
      v32 = v34;
    else
      v33 = v11.i32[1];
    v35 = v32 - v33;
    *(&v56 + v24) = v35;
    *(&v56 + v25) = ((*(&v56 + v25) - *(&v56 + v26)) * ((v35 << 16) / v31) + 0x8000) >> 16;
  }
  *(&v56 + v26) = 0;
  v36 = vmul_s32(vsub_s32(v11, v57), (int32x2_t)0x1C00000097);
  v37 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v38 = v36.i32[0] + 77 * (v9 - v56) + v36.i32[1];
  v39 = v56 + ((v38 + 128) >> 8);
  v40 = vadd_s32(vdup_n_s32((v38 + 128) >> 8), v57);
  if (v38 != (char)v38)
  {
    v41 = v56 >= v57.i32[0] ? v40.i32[0] : v56 + ((v38 + 128) >> 8);
    v42 = v56 >= v57.i32[0] ? v56 + ((v38 + 128) >> 8) : v40.i32[0];
    v43 = v40.i32[1] <= v42 ? v42 : v40.i32[1];
    if (v40.i32[1] >= v41)
      v42 = v43;
    else
      v41 = v40.i32[1];
    if (v42 > v37 || v41 < 0)
    {
      v44 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      if (v38 > -129)
      {
        v45 = v42 - v44;
        if (v42 == v44)
          goto LABEL_64;
        v46 = v37 - v44;
      }
      else
      {
        v45 = v44 - v41;
        if (v44 == v41)
          goto LABEL_64;
        v46 = (77 * v39 + 151 * v40.i32[0] + 28 * v40.i32[1] + 128) >> 8;
      }
      v47 = (v46 << 16) / v45;
      v39 = v44 + ((int)(v47 * (v39 - v44) + 0x8000) >> 16);
      v48 = vdup_n_s32(v44);
      v40 = vsra_n_s32(v48, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v47), vsub_s32(v40, v48)), 0x10uLL);
    }
  }
LABEL_64:
  if (v17 >= 65152)
    v49 = 65152;
  else
    v49 = v17 + 128;
  if (v22 >= 65152)
    v50 = 65152;
  else
    v50 = v22 + 128;
  v51 = a4 + a2 - v37;
  v52 = vdup_n_s32(0xFE80u);
  v53 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v52, v23), (int8x8_t)vadd_s32(v23, (int32x2_t)0x8000000080), (int8x8_t)v52);
  v54 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v51), (int32x2_t)vsra_n_u32((uint32x2_t)v40, vsra_n_u32(v53, v53, 8uLL), 8uLL)), (uint32x2_t)0x1000000008), (int8x8_t)0xFF00000000FF00);
  return v54.i32[1] | ((v51 - (v13 + ((v49 + (v49 >> 8)) >> 8))) << 24) | v54.i32[0] | (v51 - (v39 + ((unsigned __int16)(v50 + (v50 >> 8)) >> 8))) | ((unint64_t)v51 << 32);
}

unint64_t PDAtranspose_saturationPDA(unsigned int a1, signed int a2, unsigned int a3, signed int a4)
{
  int32x2_t v4;
  int32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  signed int v8;
  int v9;
  double v10;
  int32x2_t v11;
  signed int v12;
  int v13;
  int v14;
  int32x2_t v15;
  int32x2_t v16;
  int v17;
  double v18;
  double v19;
  int32x2_t v20;
  double v21;
  int v22;
  int v23;
  int v24;
  int32x2_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  int v31;
  BOOL v32;
  int v33;
  int v34;
  int v35;
  int v36;
  __int32 v37;
  int32x2_t v38;
  signed int v39;
  int v40;
  __int32 v41;
  int32x2_t v42;
  int32x2_t v43;
  int v44;
  int v45;
  int v46;
  unsigned int v47;
  signed int v48;
  int v49;
  unsigned int v50;
  int32x2_t v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  int32x2_t v55;
  uint32x2_t v56;
  int8x8_t v57;
  __int32 v59;
  int32x2_t v60;
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v4 = vdup_n_s32(a2);
  v5 = vsub_s32(v4, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a1), (uint32x2_t)0xFFFFFFF0FFFFFFF8), (int8x8_t)0xFF000000FFLL));
  v6 = vdup_n_s32(a4);
  v7 = vsub_s32(v6, (int32x2_t)vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(a3), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL));
  if (a4 - a3 >= a4)
    v8 = a4;
  else
    v8 = a4 - a3;
  if (a2 - a1 >= a2)
    v9 = a2;
  else
    v9 = a2 - a1;
  v10 = COERCE_DOUBLE(vmin_s32(v7, v6));
  v11 = vmin_s32(v5, v4);
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v12 = a4;
  else
    v12 = a4 - HIBYTE(a3);
  if ((int)(a2 - HIBYTE(a1)) >= a2)
    v13 = a2;
  else
    v13 = a2 - HIBYTE(a1);
  if (a4 == 255)
  {
    v17 = 0;
    v14 = 0;
    v18 = 0.0;
  }
  else
  {
    v14 = (a4 ^ 0xFF) * v9;
    v9 = (v9 * a4 + 128 + ((v9 * a4 + 128) >> 8)) >> 8;
    v15 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v11);
    v16 = vmla_s32((int32x2_t)0x8000000080, v11, v6);
    v11 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17 = (a4 ^ 0xFF) * v13;
    v13 = (v13 * a4 + 128 + ((v13 * a4 + 128) >> 8)) >> 8;
    v18 = COERCE_DOUBLE(vrev64_s32(v15));
  }
  v19 = COERCE_DOUBLE(vmla_s32(*(int32x2_t *)&v18, *(int32x2_t *)&v10, vdup_n_s32(a2 ^ 0xFFu)));
  v20 = vmla_s32((int32x2_t)0x8000000080, *(int32x2_t *)&v10, v4);
  v21 = COERCE_DOUBLE(vshr_n_s32(vsra_n_s32(v20, v20, 8uLL), 8uLL));
  v22 = v17 + (a2 ^ 0xFF) * v12;
  if (a2 == 255)
  {
    v23 = v14;
  }
  else
  {
    v17 = v22;
    v23 = v14 + v8 * (a2 ^ 0xFF);
  }
  if (a2 == 255)
    v24 = v8;
  else
    v24 = (v8 * a2 + 128 + ((v8 * a2 + 128) >> 8)) >> 8;
  if (a2 == 255)
  {
    *(double *)&v25 = v18;
  }
  else
  {
    v10 = v21;
    *(double *)&v25 = v19;
  }
  v59 = v9;
  v60 = v11;
  v26 = v9 < v11.i32[0];
  v27 = v9 >= v11.i32[0];
  if (v11.i32[1] >= *(&v59 + v27))
  {
    v29 = *(&v59 + v26);
    v28 = v9 >= v11.i32[0];
    if (v11.i32[1] <= v29)
      v27 = 2;
    else
      v27 = v9 < v11.i32[0];
    if (v11.i32[1] > v29)
      v26 = 2;
  }
  else
  {
    v28 = 2;
  }
  v30 = *(&v59 + v26);
  v31 = *(&v59 + v28);
  v32 = __OFSUB__(v30, v31);
  v33 = v30 - v31;
  if ((v33 < 0) ^ v32 | (v33 == 0))
  {
    *(&v59 + v26) = 0;
    *(&v59 + v27) = 0;
  }
  else
  {
    if (v24 >= SHIDWORD(v10))
      v34 = HIDWORD(v10);
    else
      v34 = v24;
    if (v24 <= SHIDWORD(v10))
      v24 = HIDWORD(v10);
    v35 = LODWORD(v10);
    if (SLODWORD(v10) <= v24)
      v36 = v24;
    else
      v36 = LODWORD(v10);
    if (SLODWORD(v10) >= v34)
    {
      v35 = v34;
      v24 = v36;
    }
    v37 = v24 - v35;
    *(&v59 + v26) = v37;
    *(&v59 + v27) = ((*(&v59 + v27) - *(&v59 + v28)) * ((v37 << 16) / v33) + 0x8000) >> 16;
  }
  *(&v59 + v28) = 0;
  v38 = vmul_s32(vsub_s32(v11, v60), (int32x2_t)0x1C00000097);
  v39 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v40 = v38.i32[0] + 77 * (v9 - v59) + v38.i32[1];
  v41 = v59 + ((v40 + 128) >> 8);
  v42 = vadd_s32(vdup_n_s32((v40 + 128) >> 8), v60);
  v43 = vrev64_s32(v42);
  if (v40 != (char)v40)
  {
    v44 = v59 >= v60.i32[0] ? v42.i32[0] : v59 + ((v40 + 128) >> 8);
    v45 = v59 >= v60.i32[0] ? v59 + ((v40 + 128) >> 8) : v42.i32[0];
    v46 = v42.i32[1] <= v45 ? v45 : v42.i32[1];
    if (v42.i32[1] >= v44)
      v45 = v46;
    else
      v44 = v42.i32[1];
    if (v45 > v39 || v44 < 0)
    {
      v47 = (77 * v41 + 151 * v42.i32[0] + 28 * v42.i32[1] + 128) >> 8;
      if (v40 > -129)
      {
        v48 = v45 - v47;
        if (v45 == v47)
          goto LABEL_66;
        v49 = v39 - v47;
      }
      else
      {
        v48 = v47 - v44;
        if (v47 == v44)
          goto LABEL_66;
        v49 = (77 * v41 + 151 * v42.i32[0] + 28 * v42.i32[1] + 128) >> 8;
      }
      v50 = (v49 << 16) / v48;
      v41 = v47 + ((int)(v50 * (v41 - v47) + 0x8000) >> 16);
      v51 = vdup_n_s32(v47);
      v43 = vsra_n_s32(v51, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v50), vsub_s32(v43, v51)), 0x10uLL);
    }
  }
LABEL_66:
  if (v17 >= 65152)
    v52 = 65152;
  else
    v52 = v17 + 128;
  if (v23 >= 65152)
    v53 = 65152;
  else
    v53 = v23 + 128;
  v54 = a4 + a2 - v39;
  v55 = vdup_n_s32(0xFE80u);
  v56 = (uint32x2_t)vbsl_s8((int8x8_t)vcgt_s32(v55, v25), (int8x8_t)vadd_s32(v25, (int32x2_t)0x8000000080), (int8x8_t)v55);
  v57 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(v54), (int32x2_t)vsra_n_u32((uint32x2_t)v43, vsra_n_u32(v56, v56, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v57.i32[0] | ((v54 - (v13 + ((v52 + (v52 >> 8)) >> 8))) << 24) | (v54
                                                                                          - (v41
                                                                                           + ((unsigned __int16)(v53 + (v53 >> 8)) >> 8))) | v57.i32[1] | ((unint64_t)v54 << 32);
}

unint64_t PDAtranspose_luminosityPDA(unsigned __int32 a1, signed int a2, unsigned __int32 a3, signed int a4)
{
  int8x8_t v4;
  int32x2_t v5;
  int8x8_t v6;
  int32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  int32x2_t v10;
  int v11;
  int v12;
  int v13;
  signed int v14;
  int v15;
  int32x2_t v16;
  int32x2_t v17;
  int32x2_t v18;
  int32x2_t v19;
  int v20;
  int32x2_t v21;
  int32x2_t v22;
  int32x2_t v23;
  signed int v24;
  int32x2_t v25;
  int v26;
  int v27;
  int32x2_t v28;
  int32x2_t v29;
  int v30;
  int v31;
  int v32;
  unsigned int v33;
  signed int v34;
  int v35;
  unsigned int v36;
  int32x2_t v37;
  unsigned int v38;
  unsigned int v39;
  int32x2_t v40;
  int8x8_t v41;
  int8x8_t v42;
  unsigned int v43;
  uint32x2_t v44;
  int8x8_t v45;

  v4.i32[0] = a1 >> 8;
  v4.i32[1] = a1;
  v5 = vdup_n_s32(a2);
  v6.i32[0] = a3 >> 8;
  v6.i32[1] = a3;
  v7 = (int32x2_t)vand_s8(v6, (int8x8_t)0xFF000000FFLL);
  v8 = vdup_n_s32(a4);
  v9 = vsub_s32(v8, v7);
  v10 = vmin_s32(vsub_s32(v5, (int32x2_t)vand_s8(v4, (int8x8_t)0xFF000000FFLL)), v5);
  if (a4 - BYTE2(a3) >= a4)
    v11 = a4;
  else
    v11 = a4 - BYTE2(a3);
  if (a2 - BYTE2(a1) >= a2)
    v12 = a2;
  else
    v12 = a2 - BYTE2(a1);
  if ((int)(a4 - HIBYTE(a3)) >= a4)
    v13 = a4;
  else
    v13 = a4 - HIBYTE(a3);
  if (a4 == 255)
  {
    v20 = 0;
    v15 = 0;
    v19 = 0;
  }
  else
  {
    if ((int)(a2 - HIBYTE(a1)) >= a2)
      v14 = a2;
    else
      v14 = a2 - HIBYTE(a1);
    v15 = (a4 ^ 0xFF) * v10.i32[1];
    v16 = vmla_s32((int32x2_t)0x8000000080, v10, v8);
    v17 = vdup_lane_s32(v10, 0);
    v18 = vshr_n_s32(vsra_n_s32(v16, v16, 8uLL), 8uLL);
    v17.i32[0] = v12;
    v19 = vmul_s32(vdup_n_s32(a4 ^ 0xFFu), v17);
    v12 = (v12 * a4 + 128 + ((v12 * a4 + 128) >> 8)) >> 8;
    v20 = (a4 ^ 0xFF) * v14;
    v10 = v18;
  }
  v21 = vmin_s32(v9, v8);
  if (a2 != 255)
  {
    v15 += v21.i32[1] * (a2 ^ 0xFF);
    v22 = vmla_s32((int32x2_t)0x8000000080, v21, v5);
    v23 = vdup_lane_s32(v21, 0);
    v23.i32[0] = v11;
    v21 = vshr_n_s32(vsra_n_s32(v22, v22, 8uLL), 8uLL);
    v19 = vmla_s32(v19, v23, vdup_n_s32(a2 ^ 0xFFu));
    v11 = (v11 * a2 + 128 + ((v11 * a2 + 128) >> 8)) >> 8;
    v20 += v13 * (a2 ^ 0xFF);
    v13 = (v13 * a2 + 128 + ((v13 * a2 + 128) >> 8)) >> 8;
  }
  v24 = (a4 * a2 + 128 + ((a4 * a2 + 128) >> 8)) >> 8;
  v25 = vmul_s32(vsub_s32(v21, v10), (int32x2_t)0x4D00000097);
  v26 = v25.i32[0] + 28 * (v11 - v12) + v25.i32[1];
  v27 = v10.i32[1] + ((v26 + 128) >> 8);
  v28 = vdup_lane_s32(v10, 0);
  v28.i32[0] = v12;
  v29 = vadd_s32(vdup_n_s32((v26 + 128) >> 8), v28);
  if (v26 != (char)v26)
  {
    v30 = v10.i32[1] >= v10.i32[0] ? v29.i32[1] : v10.i32[1] + ((v26 + 128) >> 8);
    v31 = v10.i32[1] >= v10.i32[0] ? v10.i32[1] + ((v26 + 128) >> 8) : v29.i32[1];
    v32 = v29.i32[0] <= v31 ? v31 : v29.i32[0];
    if (v29.i32[0] >= v30)
      v31 = v32;
    else
      v30 = v29.i32[0];
    if (v31 > v24 || v30 < 0)
    {
      v33 = (77 * v27 + 151 * v29.i32[1] + 28 * v29.i32[0] + 128) >> 8;
      if (v26 > -129)
      {
        v34 = v31 - v33;
        if (v31 == v33)
          goto LABEL_39;
        v35 = v24 - v33;
      }
      else
      {
        v34 = v33 - v30;
        if (v33 == v30)
          goto LABEL_39;
        v35 = (77 * v27 + 151 * v29.i32[1] + 28 * v29.i32[0] + 128) >> 8;
      }
      v36 = (v35 << 16) / v34;
      v27 = v33 + ((int)(v36 * (v27 - v33) + 0x8000) >> 16);
      v37 = vdup_n_s32(v33);
      v29 = vsra_n_s32(v37, vmla_s32((int32x2_t)0x800000008000, vdup_n_s32(v36), vsub_s32(v29, v37)), 0x10uLL);
    }
  }
LABEL_39:
  if (v20 >= 65152)
    v38 = 65152;
  else
    v38 = v20 + 128;
  v39 = v38 + (v38 >> 8);
  v40 = vdup_n_s32(0xFE80u);
  v41 = (int8x8_t)vcgt_s32(v40, v19);
  v42 = (int8x8_t)vadd_s32(v19, (int32x2_t)0x8000000080);
  if (v15 >= 65152)
    v43 = 65152;
  else
    v43 = v15 + 128;
  v44 = (uint32x2_t)vbsl_s8(v41, v42, (int8x8_t)v40);
  v45 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vsub_s32(vdup_n_s32(a4 + a2 - v24), (int32x2_t)vsra_n_u32((uint32x2_t)v29, vsra_n_u32(v44, v44, 8uLL), 8uLL)), (uint32x2_t)0x800000010), (int8x8_t)0xFF0000FF0000);
  return v45.i32[0] | ((a4 + a2 - v24 - (v13 + (v39 >> 8))) << 24) | (a4
                                                                                     + a2
                                                                                     - v24
                                                                                     - (v27
                                                                                      + ((unsigned __int16)(v43 + (v43 >> 8)) >> 8))) | v45.i32[1] | ((unint64_t)(a4 + a2 - v24) << 32);
}

_DWORD *cmyk32_image_mark_W8(_DWORD *result, int *a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  int v8;
  unsigned int *v9;
  unsigned __int8 *v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  uint64_t v18;
  int v19;
  uint64_t v20;

  v8 = *((unsigned __int8 *)a2 + 8);
  v9 = (unsigned int *)*((_QWORD *)a2 + 2);
  v10 = (unsigned __int8 *)*((_QWORD *)a2 + 4);
  if (v10)
    v20 = *((_QWORD *)a2 + 5) - a5;
  else
    v20 = 0;
  v19 = *a2;
  v18 = *((_QWORD *)a2 + 3) - a5;
  v11 = v10 != 0;
  if (v8 == 255)
    v12 = 0xFF000000FELL;
  else
    v12 = ((unsigned __int16)(254 * v8 + ((254 * v8) >> 8) + 1) >> 8) | ((unint64_t)((255 * v8 + ((255 * v8) >> 8) + 1) >> 8) << 32);
  v13 = ~BYTE4(v12);
  if (*((_QWORD *)result + 22))
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          v14 = a5;
          do
          {
            *v9 = v12;
            if (v10)
              *v10 = BYTE4(v12);
            ++v9;
            v10 += v11;
            --v14;
          }
          while (v14);
        }
      }
      else
      {
        v15 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (BYTE4(v12))
              {
                if (BYTE4(v12) == 255)
                {
                  *v9 = v12;
                  *v10 = -1;
                }
                else
                {
                  result = DAplusDAM(v9, v10, v12, SBYTE4(v12), *v9, *v10, ~BYTE4(v12));
                }
              }
            }
            else if (BYTE4(v12))
            {
              if (BYTE4(v12) == 255)
                *v9 = v12;
              else
                *v9 = ((((*v9 >> 8) & 0xFF00FF) * v13 + 65537 + (((((*v9 >> 8) & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) & 0xFF00FF00 | v12)
                    + ((((*v9 & 0xFF00FF) * v13 + 65537 + ((((*v9 & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            ++v9;
            v10 += v11;
            --v15;
          }
          while (v15);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  else
  {
    do
    {
      if (v19 == 1)
      {
        if (a5 >= 1)
        {
          v16 = a5;
          do
          {
            *v9 = v12;
            if (v10)
              *v10 = BYTE4(v12);
            ++v9;
            v10 += v11;
            --v16;
          }
          while (v16);
        }
      }
      else
      {
        v17 = a5;
        if (a5 >= 1)
        {
          do
          {
            if (v10)
            {
              if (BYTE4(v12))
              {
                if (BYTE4(v12) == 255)
                {
                  *v9 = v12;
                  *v10 = -1;
                }
                else
                {
                  result = DAplusDAM(v9, v10, v12, SBYTE4(v12), *v9, *v10, ~BYTE4(v12));
                }
              }
            }
            else if (BYTE4(v12))
            {
              if (BYTE4(v12) == 255)
                *v9 = v12;
              else
                *v9 = ((((*v9 >> 8) & 0xFF00FF) * v13 + 65537 + (((((*v9 >> 8) & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) & 0xFF00FF00 | v12)
                    + ((((*v9 & 0xFF00FF) * v13 + 65537 + ((((*v9 & 0xFF00FF) * v13) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            ++v9;
            v10 += v11;
            --v17;
          }
          while (v17);
        }
      }
      v9 += v18;
      v10 += v20;
      --a6;
    }
    while (a6);
  }
  return result;
}

void cmyk32_image_mark_image(uint64_t a1, uint64_t a2, int a3, int a4, void (*a5)(_QWORD, _QWORD))
{
  __n128 v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  uint64_t v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char v44;
  unint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  char *v48;
  int v49;
  int v50;
  int *v51;
  int v52;
  void *v53;
  void *v54;
  int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  void (*v64)(_QWORD, _QWORD);
  char *v65;
  uint64_t *v66;
  _DWORD v67[2];
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  int v77;
  int v78;
  _QWORD v79[3];

  v79[1] = *MEMORY[0x1E0C80C00];
  v8.n128_u32[1] = 0;
  v8.n128_u64[1] = 0;
  v68 = 0u;
  v69 = 0u;
  v75 = 0u;
  v76 = 0u;
  v73 = 0u;
  v74 = 0u;
  v71 = 0u;
  v72 = 0u;
  v70 = 0u;
  v8.n128_f32[0] = (float)(*(float *)(a2 + 184) * 255.0) + 0.5;
  v67[0] = a3;
  v67[1] = a4;
  LOBYTE(v68) = (int)v8.n128_f32[0];
  v9 = (unint64_t)*(int *)(a1 + 28) >> 2;
  *(_QWORD *)&v69 = v9;
  if (*(_QWORD *)(a1 + 48))
    v10 = *(int *)(a1 + 32);
  else
    v10 = 0;
  *(_QWORD *)&v70 = v10;
  v11 = *(_QWORD *)(a2 + 120);
  v12 = *(_DWORD *)(a2 + 20);
  v13 = HIBYTE(v12);
  v14 = BYTE2(v12);
  if (v11)
  {
    v15 = *(int *)(a2 + 24);
    v16 = (uint64_t *)(a2 + 104);
    v17 = (uint64_t *)(a2 + 72);
    v18 = (uint64_t *)(a2 + 88);
    v19 = v13;
  }
  else
  {
    v15 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v16 = (uint64_t *)(a2 + 96);
    v17 = (uint64_t *)(a2 + 64);
    v18 = (uint64_t *)(a2 + 80);
    v11 = *(_QWORD *)(a2 + 112);
    v19 = v14;
  }
  v20 = *v18;
  v21 = *v17;
  v22 = *v16;
  v23 = v19;
  *((_QWORD *)&v71 + 1) = v19;
  *((_QWORD *)&v70 + 1) = v22;
  *((_QWORD *)&v75 + 1) = v15;
  *((_QWORD *)&v74 + 1) = v20;
  *((_QWORD *)&v73 + 1) = v21;
  *((_QWORD *)&v72 + 1) = v11;
  v24 = *(_QWORD *)(a2 + 128);
  if (v24)
  {
    v25 = (unint64_t)*(unsigned int *)(a2 + 8) >> 25;
    v26 = (uint64_t *)(a2 + 96);
    v27 = (uint64_t *)(a2 + 64);
    v28 = (uint64_t *)(a2 + 80);
    v13 = v14;
  }
  else
  {
    v25 = *(int *)(a2 + 24);
    v26 = (uint64_t *)(a2 + 104);
    v27 = (uint64_t *)(a2 + 72);
    v28 = (uint64_t *)(a2 + 88);
    v24 = *(_QWORD *)(a2 + 136);
  }
  v66 = &v62;
  v29 = *v28;
  v30 = *v27;
  v31 = *v26;
  *(_QWORD *)&v72 = v13;
  *(_QWORD *)&v71 = v31;
  *(_QWORD *)&v76 = v25;
  *(_QWORD *)&v75 = v29;
  *(_QWORD *)&v74 = v30;
  *(_QWORD *)&v73 = v24;
  v32 = *(int *)(a1 + 4);
  MEMORY[0x1E0C80A78](a1, v8);
  v65 = (char *)&v62 - v34 - 15;
  if (v35 <= 0xFFFFFFFFFFFFFFELL)
    v37 = (char *)&v62 - v34 - 15;
  else
    v37 = 0;
  if (v35 - 0xFFFFFFFFFFFFFFFLL >= 0xF000000000000402)
  {
    v63 = v33;
    v64 = a5;
    v38 = v36;
    v37 = (char *)malloc_type_malloc(16 * v32, 0x1B1F656EuLL);
    v33 = v63;
    v36 = v38;
    a5 = v64;
  }
  *((_QWORD *)&v76 + 1) = v37;
  if (v37)
  {
    v39 = v32;
    if (*(_QWORD *)(a2 + 176))
    {
      if ((int)v32 >= 1)
      {
        v40 = (uint64_t *)(v37 + 8);
        v41 = -v33;
        v42 = v36 - v22;
        do
        {
          if (((v41 + v22) | v42) < 0)
          {
            v45 = 0;
            v46 = 0;
          }
          else
          {
            v43 = ((v22 & (unint64_t)~(-1 << v23)) >> (v23 - 4)) & 0xF;
            v44 = weights_19497[v43];
            if (v43 - 7 >= 9)
              v45 = -(uint64_t)v15;
            else
              v45 = v15;
            v46 = v44 & 0xF;
          }
          v33 = v15 * (v22 >> v23);
          *(v40 - 1) = v33;
          *v40 = v46 | (16 * v45);
          v40 += 2;
          v22 += v11;
          v42 -= v11;
          --v39;
        }
        while (v39);
      }
    }
    else if ((int)v32 >= 1)
    {
      v47 = v37 + 8;
      do
      {
        *(v47 - 1) = v15 * (v22 >> v23);
        *v47 = 0;
        v47 += 2;
        v22 += v11;
        --v39;
      }
      while (v39);
    }
    v48 = v37;
    v49 = *(_DWORD *)(a1 + 4);
    v50 = *(_DWORD *)(a1 + 8);
    v77 = v50;
    v78 = v49;
    v51 = *(int **)(a1 + 136);
    if (v51)
    {
      v52 = *(_DWORD *)(a1 + 104);
      LODWORD(v79[0]) = *(_DWORD *)(a1 + 108);
      HIDWORD(v79[0]) = v52;
      shape_enum_clip_alloc((uint64_t)v37, v33, v51, 1, 1, 1, v52, v79[0], v49, v50);
      v54 = v53;
      if (v53)
        goto LABEL_36;
    }
    v55 = 0;
    v56 = 0;
    v54 = 0;
    v79[0] = 0;
    while (1)
    {
      v57 = *(int *)(a1 + 16) + (uint64_t)v56;
      v58 = *(_QWORD *)(a1 + 48);
      v59 = *(int *)(a1 + 12) + (uint64_t)v55;
      v60 = *(_QWORD *)(a1 + 40) + 4 * v9 * v57 + 4 * v59;
      v61 = v58 + v10 * v57 + v59;
      if (!v58)
        v61 = 0;
      *((_QWORD *)&v68 + 1) = v60;
      *((_QWORD *)&v69 + 1) = v61;
      a5(a2, v67);
      if (!v54)
        break;
LABEL_36:
      if (!shape_enum_clip_next((uint64_t)v54, (int *)v79 + 1, v79, &v78, &v77))
      {
        free(v54);
        break;
      }
      v56 = v79[0];
      v55 = HIDWORD(v79[0]);
      v9 = v69;
      v10 = v70;
    }
    if (v48 != v65)
      free(v48);
  }
}

unint64_t cmyk32_image_mark_RGB24(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  unsigned int *v7;
  unsigned __int8 *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  unsigned __int8 *v15;
  unsigned __int8 *v16;
  uint64_t v17;
  char v18;
  BOOL v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t *v23;
  uint64_t i;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned __int8 *v28;
  unsigned int v29;
  char v30;
  unsigned __int8 *v31;
  int v32;
  unsigned __int8 *v33;
  unsigned __int8 *v34;
  int v35;
  unsigned __int8 *v36;
  unsigned int v37;
  int v38;
  unsigned int v39;
  unsigned int v40;
  unsigned __int8 *v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned __int8 *v50;
  unsigned int v51;
  char v52;
  unsigned __int8 *v53;
  int v54;
  unsigned __int8 *v55;
  unsigned __int8 *v56;
  int v57;
  unsigned __int8 *v58;
  unsigned int v59;
  int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned __int8 *v63;
  unsigned int v64;
  unsigned int v65;
  uint64_t v66;
  int v67;
  unsigned __int8 *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t j;
  uint64_t v73;
  unsigned __int8 *v74;
  unsigned int v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  uint64_t v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  unsigned __int8 *v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  uint64_t v88;
  int v89;
  uint64_t v90;
  uint64_t v91;
  char v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v98;
  char v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  uint64_t v103;
  uint64_t v104;
  int v105;
  int v106;
  uint64_t v107;
  uint64_t *v108;
  unint64_t v109;

  v109 = result;
  v6 = *((unsigned __int8 *)a2 + 8);
  v7 = (unsigned int *)*((_QWORD *)a2 + 2);
  v8 = (unsigned __int8 *)*((_QWORD *)a2 + 4);
  if (v8)
    v103 = *((_QWORD *)a2 + 5) - a5;
  else
    v103 = 0;
  v102 = *a2;
  v101 = *((_QWORD *)a2 + 3) - a5;
  v9 = v8 != 0;
  v11 = *((_QWORD *)a2 + 17);
  v10 = *((_QWORD *)a2 + 18);
  v12 = *((_QWORD *)a2 + 9);
  v98 = *((_QWORD *)a2 + 11);
  v13 = *((_QWORD *)a2 + 7) + v98 * a4;
  v14 = *(unsigned __int8 **)(result + 32);
  v15 = &v14[(*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
           + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3)];
  v96 = a5;
  v99 = v12;
  v100 = v11;
  if (*(_QWORD *)(result + 176))
  {
    v95 = *((_QWORD *)a2 + 13);
    v93 = ~(-1 << v12);
    v94 = *((_QWORD *)a2 + 15);
    v92 = v12 - 4;
    v16 = v15 - 3;
    v90 = v10 + 16 * a3 + 8;
    v91 = -v11;
    while (1)
    {
      if (((v94 - v13) | (v13 - v95)) < 0)
      {
        v21 = 0;
        v107 = 0;
      }
      else
      {
        v17 = ((v13 & (unint64_t)v93) >> v92) & 0xF;
        v18 = weights_19497[v17];
        v19 = (unint64_t)(v17 - 7) >= 9;
        v20 = v91;
        if (!v19)
          v20 = v11;
        v107 = v20;
        v21 = v18 & 0xF;
      }
      v22 = *(_QWORD *)(v109 + 32) + (v13 >> v12) * v11;
      v105 = a6;
      v104 = v13;
      if (v102 != 1)
        break;
      if (a5 >= 1)
      {
        v23 = (uint64_t *)v90;
        for (i = v96; i; --i)
        {
          v25 = *(v23 - 1);
          v26 = *v23;
          v27 = v22 + v25;
          if ((unint64_t)v16 >= v22 + v25)
            v28 = (unsigned __int8 *)(v22 + v25);
          else
            v28 = v16;
          if (v28 < v14)
            v28 = v14;
          v29 = (*v28 << 24) | (v28[1] << 16) | (v28[2] << 8);
          v30 = v26 & 0xF;
          if ((v26 & 0xF) != 0)
          {
            v31 = (unsigned __int8 *)(v27 + (v26 >> 4));
            if (v16 < v31)
              v31 = v16;
            if (v31 < v14)
              v31 = v14;
            v32 = (*v31 << 24) | (v31[1] << 16) | (v31[2] << 8);
            if (v21)
            {
              v33 = (unsigned __int8 *)(v27 + v107);
              if (v16 >= v33)
                v34 = v33;
              else
                v34 = v16;
              if (v34 < v14)
                v34 = v14;
              v35 = (*v34 << 24) | (v34[1] << 16) | (v34[2] << 8);
              v36 = &v33[v26 >> 4];
              if (v16 < v36)
                v36 = v16;
              if (v36 < v14)
                v36 = v14;
              v37 = BLEND8_19499[v21];
              v29 = v29 - ((v37 & v29) >> v21) + ((v37 & v35) >> v21);
              v32 = v32 - ((v37 & v32) >> v21) + ((((*v36 << 24) | (v36[1] << 16) | (v36[2] << 8)) & v37) >> v21);
            }
            v38 = BLEND8_19499[*v23 & 0xF];
            v39 = v29 - ((v38 & v29) >> v30);
            v40 = (v38 & v32) >> v30;
          }
          else
          {
            if (!v21)
              goto LABEL_43;
            v41 = (unsigned __int8 *)(v27 + v107);
            if ((unint64_t)v16 < v27 + v107)
              v41 = v16;
            if (v41 < v14)
              v41 = v14;
            v42 = BLEND8_19499[v21];
            v39 = v29 - ((v42 & v29) >> v21);
            v40 = (((*v41 << 24) | (v41[1] << 16) | (v41[2] << 8)) & v42) >> v21;
          }
          v29 = v39 + v40;
LABEL_43:
          v43 = HIBYTE(v29);
          if (HIBYTE(v29) <= BYTE2(v29))
            v43 = BYTE2(v29);
          if (v43 <= BYTE1(v29))
            v43 = BYTE1(v29);
          v44 = (((v43 - HIBYTE(v29)) << 24) | ((v43 - BYTE2(v29)) << 16) | ((v43 - BYTE1(v29)) << 8) | v43) ^ 0xFF;
          if (v6 == 255)
          {
            result = v44 | 0xFF00000000;
            if (!v8)
            {
LABEL_51:
              *v7 = result;
              goto LABEL_52;
            }
          }
          else
          {
            result = PDAM_5205(v44, 255, v6);
            if (!v8)
              goto LABEL_51;
          }
          *v7 = result;
          *v8 = BYTE4(result);
LABEL_52:
          v23 += 2;
          ++v7;
          v8 += v9;
        }
      }
LABEL_102:
      v11 = v100;
      v7 += v101;
      v8 += v103;
      LOBYTE(v12) = v99;
      v13 = v104 + v98;
      a6 = v105 - 1;
      if (v105 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_102;
    v45 = (uint64_t *)v90;
    v46 = v96;
    while (1)
    {
      v47 = *(v45 - 1);
      v48 = *v45;
      v49 = v22 + v47;
      if ((unint64_t)v16 >= v22 + v47)
        v50 = (unsigned __int8 *)(v22 + v47);
      else
        v50 = v16;
      if (v50 < v14)
        v50 = v14;
      v51 = (*v50 << 24) | (v50[1] << 16) | (v50[2] << 8);
      v52 = v48 & 0xF;
      if ((v48 & 0xF) != 0)
        break;
      if (v21)
      {
        v63 = (unsigned __int8 *)(v49 + v107);
        if ((unint64_t)v16 < v49 + v107)
          v63 = v16;
        if (v63 < v14)
          v63 = v14;
        v64 = BLEND8_19499[v21];
        v61 = v51 - ((v64 & v51) >> v21);
        v62 = (((*v63 << 24) | (v63[1] << 16) | (v63[2] << 8)) & v64) >> v21;
        goto LABEL_84;
      }
LABEL_85:
      v65 = HIBYTE(v51);
      if (HIBYTE(v51) <= BYTE2(v51))
        v65 = BYTE2(v51);
      if (v65 <= BYTE1(v51))
        v65 = BYTE1(v51);
      result = (((v65 - HIBYTE(v51)) << 24) | ((v65 - BYTE2(v51)) << 16) | ((v65 - BYTE1(v51)) << 8) | v65) ^ 0xFF;
      if (v6 == 255)
      {
        v66 = result | 0xFF00000000;
      }
      else
      {
        result = PDAM_5205(result, 255, v6);
        v66 = result;
      }
      if (v8)
      {
        if (BYTE4(v66))
        {
          if (BYTE4(v66) == 255)
          {
            *v7 = v66;
            *v8 = -1;
          }
          else
          {
            result = (unint64_t)DAplusDAM(v7, v8, v66, SBYTE4(v66), *v7, *v8, ~BYTE4(v66));
          }
        }
      }
      else if (BYTE4(v66))
      {
        if (BYTE4(v66) == 255)
        {
          *v7 = v66;
        }
        else
        {
          v67 = ~BYTE4(v66);
          *v7 = ((((*v7 >> 8) & 0xFF00FF) * v67 + 65537 + (((((*v7 >> 8) & 0xFF00FF) * v67) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v66
              + ((((*v7 & 0xFF00FF) * v67 + 65537 + ((((*v7 & 0xFF00FF) * v67) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v45 += 2;
      ++v7;
      v8 += v9;
      if (!--v46)
        goto LABEL_102;
    }
    v53 = (unsigned __int8 *)(v49 + (v48 >> 4));
    if (v16 < v53)
      v53 = v16;
    if (v53 < v14)
      v53 = v14;
    v54 = (*v53 << 24) | (v53[1] << 16) | (v53[2] << 8);
    if (v21)
    {
      v55 = (unsigned __int8 *)(v49 + v107);
      if (v16 >= v55)
        v56 = v55;
      else
        v56 = v16;
      if (v56 < v14)
        v56 = v14;
      v57 = (*v56 << 24) | (v56[1] << 16) | (v56[2] << 8);
      v58 = &v55[v48 >> 4];
      if (v16 < v58)
        v58 = v16;
      if (v58 < v14)
        v58 = v14;
      v59 = BLEND8_19499[v21];
      v51 = v51 - ((v59 & v51) >> v21) + ((v59 & v57) >> v21);
      v54 = v54 - ((v59 & v54) >> v21) + ((((*v58 << 24) | (v58[1] << 16) | (v58[2] << 8)) & v59) >> v21);
    }
    v60 = BLEND8_19499[*v45 & 0xF];
    v61 = v51 - ((v60 & v51) >> v52);
    v62 = (v60 & v54) >> v52;
LABEL_84:
    v51 = v61 + v62;
    goto LABEL_85;
  }
  v108 = (uint64_t *)(v10 + 16 * a3);
  v68 = v15 - 3;
  do
  {
    v106 = a6;
    v69 = v13;
    v70 = *(_QWORD *)(v109 + 32) + (v13 >> v12) * v11;
    if (v102 == 1)
    {
      if (a5 >= 1)
      {
        v71 = v108;
        for (j = v96; j; --j)
        {
          v73 = *v71;
          v71 += 2;
          v74 = (unsigned __int8 *)(v70 + v73);
          if ((unint64_t)v68 < v70 + v73)
            v74 = v68;
          if ((unint64_t)v74 < *(_QWORD *)(v109 + 32))
            v74 = *(unsigned __int8 **)(v109 + 32);
          v75 = *v74;
          v76 = v74[1];
          v77 = v74[2];
          if (v75 <= v76)
            v78 = v76;
          else
            v78 = v75;
          if (v78 <= v77)
            v78 = v77;
          v79 = (((v78 - v75) << 24) | ((v78 - v76) << 16) | ((v78 - v77) << 8) | v78) ^ 0xFF;
          if (v6 == 255)
          {
            result = v79 | 0xFF00000000;
            if (!v8)
            {
LABEL_121:
              *v7 = result;
              goto LABEL_122;
            }
          }
          else
          {
            result = PDAM_5205(v79, 255, v6);
            if (!v8)
              goto LABEL_121;
          }
          *v7 = result;
          *v8 = BYTE4(result);
LABEL_122:
          ++v7;
          v8 += v9;
        }
      }
    }
    else
    {
      v80 = v108;
      v81 = v96;
      if (a5 >= 1)
      {
        do
        {
          v82 = *v80;
          v80 += 2;
          v83 = (unsigned __int8 *)(v70 + v82);
          if ((unint64_t)v68 < v70 + v82)
            v83 = v68;
          if ((unint64_t)v83 < *(_QWORD *)(v109 + 32))
            v83 = *(unsigned __int8 **)(v109 + 32);
          v84 = *v83;
          v85 = v83[1];
          v86 = v83[2];
          if (v84 <= v85)
            v87 = v85;
          else
            v87 = v84;
          if (v87 <= v86)
            v87 = v86;
          result = (((v87 - v84) << 24) | ((v87 - v85) << 16) | ((v87 - v86) << 8) | v87) ^ 0xFF;
          if (v6 == 255)
          {
            v88 = result | 0xFF00000000;
          }
          else
          {
            result = PDAM_5205(result, 255, v6);
            v88 = result;
          }
          if (v8)
          {
            if (BYTE4(v88))
            {
              if (BYTE4(v88) == 255)
              {
                *v7 = v88;
                *v8 = -1;
              }
              else
              {
                result = (unint64_t)DAplusDAM(v7, v8, v88, SBYTE4(v88), *v7, *v8, ~BYTE4(v88));
              }
            }
          }
          else if (BYTE4(v88))
          {
            if (BYTE4(v88) == 255)
            {
              *v7 = v88;
            }
            else
            {
              v89 = ~BYTE4(v88);
              *v7 = ((((*v7 >> 8) & 0xFF00FF) * v89 + 65537 + (((((*v7 >> 8) & 0xFF00FF) * v89) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v88
                  + ((((*v7 & 0xFF00FF) * v89 + 65537 + ((((*v7 & 0xFF00FF) * v89) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v7;
          v8 += v9;
          --v81;
        }
        while (v81);
      }
    }
    v11 = v100;
    v7 += v101;
    v8 += v103;
    LOBYTE(v12) = v99;
    v13 = v69 + v98;
    a6 = v106 - 1;
  }
  while (v106 != 1);
  return result;
}

unint64_t cmyk32_image_mark_RGB32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  int v7;
  unsigned int *v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  unsigned int *v17;
  char v18;
  uint64_t v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  signed int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  char v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int *v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  unint64_t v72;
  int v73;
  unsigned int *v74;
  char v75;
  char v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  unsigned int *v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  uint64_t v85;
  signed int v86;
  uint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int *v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  uint64_t v94;
  unint64_t v95;
  int v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  char v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  int v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  int v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  char v118;
  uint64_t *v119;
  uint64_t v120;
  int v121;

  v6 = *((unsigned __int8 *)a2 + 8);
  v117 = result;
  if (*(_QWORD *)(result + 40))
    v7 = 0;
  else
    v7 = 255;
  v121 = v7;
  v8 = (unsigned int *)*((_QWORD *)a2 + 2);
  v9 = (unsigned __int8 *)*((_QWORD *)a2 + 4);
  if (v9)
    v110 = *((_QWORD *)a2 + 5) - a5;
  else
    v110 = 0;
  v10 = a2[1];
  v109 = *a2;
  v108 = *((_QWORD *)a2 + 3) - a5;
  v120 = v9 != 0;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v105 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v105 * a4;
  v15 = *(unsigned int **)(result + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v106 = v13;
  v107 = v12;
  if (*(_QWORD *)(result + 176))
  {
    v101 = ~(-1 << v13);
    v102 = *((_QWORD *)a2 + 15);
    v103 = *((_QWORD *)a2 + 13);
    v100 = v13 - 4;
    v99 = -v12;
    v17 = (unsigned int *)(v16 - 4);
    v18 = a2[1];
    v118 = 32 - v10;
    v97 = v11 + 16 * a3 + 8;
    v98 = a5;
    while (1)
    {
      if (((v102 - v14) | (v14 - v103)) < 0)
      {
        v23 = 0;
        v115 = 0;
      }
      else
      {
        v19 = ((v14 & (unint64_t)v101) >> v100) & 0xF;
        v20 = weights_19497[v19];
        v21 = (unint64_t)(v19 - 7) >= 9;
        v22 = v99;
        if (!v21)
          v22 = v12;
        v115 = v22;
        v23 = v20 & 0xF;
      }
      v24 = *(_QWORD *)(v117 + 32) + (v14 >> v13) * v12;
      v113 = a6;
      v111 = v14;
      if (v109 != 1)
        break;
      if (a5 >= 1)
      {
        v26 = (uint64_t *)v97;
        v25 = v98;
        while (1)
        {
          v27 = *(v26 - 1);
          v28 = *v26;
          v29 = v24 + v27;
          if ((unint64_t)v17 >= v24 + v27)
            v30 = (unsigned int *)(v24 + v27);
          else
            v30 = v17;
          if (v30 < v15)
            v30 = v15;
          v31 = bswap32(*v30);
          v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)(v29 + v115);
            if ((unint64_t)v17 < v29 + v115)
              v43 = v17;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (bswap32(*v43) & v44) >> v23;
            goto LABEL_45;
          }
LABEL_46:
          v45 = (v31 << v18) | (v31 >> v118);
          v46 = HIBYTE(v45);
          if (HIBYTE(v45) <= BYTE2(v45))
            v46 = BYTE2(v45);
          if (v46 <= BYTE1(v45))
            v46 = BYTE1(v45);
          v47 = v45 | v121;
          v48 = (v47 - v46) | ((v46 - BYTE2(v45)) << 16) | ((v46 - HIBYTE(v45)) << 24) | ((v46 - BYTE1(v45)) << 8);
          result = v48 | (unint64_t)(v47 << 32);
          if (v6 != 255)
            result = PDAM_5205(v48, BYTE4(result), v6);
          *v8 = result;
          if (v9)
            *v9 = BYTE4(result);
          v26 += 2;
          ++v8;
          v9 += v120;
          if (!--v25)
            goto LABEL_103;
        }
        v33 = (unsigned int *)(v29 + (v28 >> 4));
        if (v17 < v33)
          v33 = v17;
        if (v33 < v15)
          v33 = v15;
        v34 = bswap32(*v33);
        if (v23)
        {
          v35 = (unsigned int *)(v29 + v115);
          if (v17 >= v35)
            v36 = v35;
          else
            v36 = v17;
          if (v36 < v15)
            v36 = v15;
          v37 = bswap32(*v36);
          v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v17 < v38)
            v38 = v17;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((bswap32(*v38) & v39) >> v23);
        }
        v40 = BLEND8_19499[*v26 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_45:
        v31 = v41 + v42;
        goto LABEL_46;
      }
LABEL_103:
      v12 = v107;
      v8 += v108;
      v9 += v110;
      LOBYTE(v13) = v106;
      v14 = v111 + v105;
      a6 = v113 - 1;
      if (v113 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_103;
    v50 = (uint64_t *)v97;
    v49 = v98;
    while (1)
    {
      v51 = *(v50 - 1);
      v52 = *v50;
      v53 = v24 + v51;
      if ((unint64_t)v17 >= v24 + v51)
        v54 = (unsigned int *)(v24 + v51);
      else
        v54 = v17;
      if (v54 < v15)
        v54 = v15;
      v55 = bswap32(*v54);
      v56 = v52 & 0xF;
      if ((v52 & 0xF) != 0)
        break;
      if (v23)
      {
        v67 = (unsigned int *)(v53 + v115);
        if ((unint64_t)v17 < v53 + v115)
          v67 = v17;
        if (v67 < v15)
          v67 = v15;
        v68 = BLEND8_19499[v23];
        v65 = v55 - ((v68 & v55) >> v23);
        v66 = (bswap32(*v67) & v68) >> v23;
        goto LABEL_86;
      }
LABEL_87:
      v69 = (v55 << v18) | (v55 >> v118);
      v70 = HIBYTE(v69);
      if (HIBYTE(v69) <= BYTE2(v69))
        v70 = BYTE2(v69);
      if (v70 <= BYTE1(v69))
        v70 = BYTE1(v69);
      v71 = v69 | v121;
      result = ((_DWORD)v71 - v70) | ((v70 - BYTE2(v69)) << 16) | ((v70 - HIBYTE(v69)) << 24) | ((v70 - BYTE1(v69)) << 8);
      v72 = (int)result | (unint64_t)(v71 << 32);
      if (v6 != 255)
      {
        result = PDAM_5205(result, BYTE4(v72), v6);
        v72 = result;
      }
      if (v9)
      {
        if (BYTE4(v72))
        {
          if (BYTE4(v72) == 255)
          {
            *v8 = v72;
            *v9 = -1;
          }
          else
          {
            result = (unint64_t)DAplusDAM(v8, v9, v72, SBYTE4(v72), *v8, *v9, ~BYTE4(v72));
          }
        }
      }
      else if (BYTE4(v72))
      {
        if (BYTE4(v72) == 255)
        {
          *v8 = v72;
        }
        else
        {
          v73 = ~BYTE4(v72);
          *v8 = ((((*v8 >> 8) & 0xFF00FF) * v73 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v72
              + ((((*v8 & 0xFF00FF) * v73 + 65537 + ((((*v8 & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v50 += 2;
      ++v8;
      v9 += v120;
      if (!--v49)
        goto LABEL_103;
    }
    v57 = (unsigned int *)(v53 + (v52 >> 4));
    if (v17 < v57)
      v57 = v17;
    if (v57 < v15)
      v57 = v15;
    v58 = bswap32(*v57);
    if (v23)
    {
      v59 = (unsigned int *)(v53 + v115);
      if (v17 >= v59)
        v60 = v59;
      else
        v60 = v17;
      if (v60 < v15)
        v60 = v15;
      v61 = bswap32(*v60);
      v62 = (unsigned int *)((char *)v59 + (v52 >> 4));
      if (v17 < v62)
        v62 = v17;
      if (v62 < v15)
        v62 = v15;
      v63 = BLEND8_19499[v23];
      v55 = v55 - ((v63 & v55) >> v23) + ((v63 & v61) >> v23);
      v58 = v58 - ((v63 & v58) >> v23) + ((bswap32(*v62) & v63) >> v23);
    }
    v64 = BLEND8_19499[*v50 & 0xF];
    v65 = v55 - ((v64 & v55) >> v56);
    v66 = (v64 & v58) >> v56;
LABEL_86:
    v55 = v65 + v66;
    goto LABEL_87;
  }
  v119 = (uint64_t *)(v11 + 16 * a3);
  v74 = (unsigned int *)(v16 - 4);
  v75 = a2[1];
  v76 = 32 - v10;
  v116 = a5;
  do
  {
    v77 = *(_QWORD *)(v117 + 32) + (v14 >> v13) * v12;
    v114 = a6;
    v112 = v14;
    if (v109 == 1)
    {
      if (a5 >= 1)
      {
        v78 = v119;
        v79 = v116;
        do
        {
          v80 = *v78;
          v78 += 2;
          v81 = (unsigned int *)(v77 + v80);
          if ((unint64_t)v74 < v77 + v80)
            v81 = v74;
          if ((unint64_t)v81 < *(_QWORD *)(v117 + 32))
            v81 = *(unsigned int **)(v117 + 32);
          v82 = bswap32(*v81);
          v83 = (v82 << v75) | (v82 >> v76);
          v84 = HIBYTE(v83);
          if (HIBYTE(v83) <= BYTE2(v83))
            v84 = BYTE2(v83);
          if (v84 <= BYTE1(v83))
            v84 = BYTE1(v83);
          v85 = v83 | v121;
          v86 = (v85 - v84) | ((v84 - BYTE2(v83)) << 16) | ((v84 - HIBYTE(v83)) << 24) | ((v84 - BYTE1(v83)) << 8);
          result = v86 | (unint64_t)(v85 << 32);
          if (v6 != 255)
            result = PDAM_5205(v86, BYTE4(result), v6);
          *v8 = result;
          if (v9)
            *v9 = BYTE4(result);
          ++v8;
          v9 += v120;
          --v79;
        }
        while (v79);
      }
    }
    else
    {
      v87 = v119;
      v88 = v116;
      if (a5 >= 1)
      {
        do
        {
          v89 = *v87;
          v87 += 2;
          v90 = (unsigned int *)(v77 + v89);
          if ((unint64_t)v74 < v77 + v89)
            v90 = v74;
          if ((unint64_t)v90 < *(_QWORD *)(v117 + 32))
            v90 = *(unsigned int **)(v117 + 32);
          v91 = bswap32(*v90);
          v92 = (v91 << v75) | (v91 >> v76);
          v93 = HIBYTE(v92);
          if (HIBYTE(v92) <= BYTE2(v92))
            v93 = BYTE2(v92);
          if (v93 <= BYTE1(v92))
            v93 = BYTE1(v92);
          v94 = v92 | v121;
          result = ((_DWORD)v94 - v93) | ((v93 - BYTE2(v92)) << 16) | ((v93 - HIBYTE(v92)) << 24) | ((v93 - BYTE1(v92)) << 8);
          v95 = (int)result | (unint64_t)(v94 << 32);
          if (v6 != 255)
          {
            result = PDAM_5205(result, BYTE4(v95), v6);
            v95 = result;
          }
          if (v9)
          {
            if (BYTE4(v95))
            {
              if (BYTE4(v95) == 255)
              {
                *v8 = v95;
                *v9 = -1;
              }
              else
              {
                result = (unint64_t)DAplusDAM(v8, v9, v95, SBYTE4(v95), *v8, *v9, ~BYTE4(v95));
              }
            }
          }
          else if (BYTE4(v95))
          {
            if (BYTE4(v95) == 255)
            {
              *v8 = v95;
            }
            else
            {
              v96 = ~BYTE4(v95);
              *v8 = ((((*v8 >> 8) & 0xFF00FF) * v96 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v96) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v95
                  + ((((*v8 & 0xFF00FF) * v96 + 65537 + ((((*v8 & 0xFF00FF) * v96) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v8;
          v9 += v120;
          --v88;
        }
        while (v88);
      }
    }
    v12 = v107;
    v8 += v108;
    v9 += v110;
    LOBYTE(v13) = v106;
    v14 = v112 + v105;
    a6 = v114 - 1;
  }
  while (v114 != 1);
  return result;
}

unint64_t cmyk32_image_mark_rgb32(unint64_t result, int *a2, int a3, int a4, int a5, int a6)
{
  int v6;
  int v7;
  unsigned int *v8;
  unsigned __int8 *v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  char *v16;
  unsigned int *v17;
  char v18;
  uint64_t v19;
  char v20;
  BOOL v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  char v32;
  unsigned int *v33;
  unsigned int v34;
  unsigned int *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int *v38;
  int v39;
  int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  signed int v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unsigned int *v54;
  unsigned int v55;
  char v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int *v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int *v62;
  int v63;
  int v64;
  unsigned int v65;
  unsigned int v66;
  unsigned int *v67;
  int v68;
  unsigned int v69;
  unsigned int v70;
  uint64_t v71;
  unint64_t v72;
  int v73;
  char *v74;
  char v75;
  char v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t v79;
  uint64_t v80;
  char *v81;
  unsigned int v82;
  unsigned int v83;
  uint64_t v84;
  signed int v85;
  uint64_t *v86;
  uint64_t v87;
  uint64_t v88;
  char *v89;
  unsigned int v90;
  unsigned int v91;
  uint64_t v92;
  unint64_t v93;
  int v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  char v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v103;
  char v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  int v111;
  int v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t v115;
  char v116;
  uint64_t *v117;
  uint64_t v118;
  int v119;

  v6 = *((unsigned __int8 *)a2 + 8);
  v115 = result;
  if (*(_QWORD *)(result + 40))
    v7 = 0;
  else
    v7 = 255;
  v119 = v7;
  v8 = (unsigned int *)*((_QWORD *)a2 + 2);
  v9 = (unsigned __int8 *)*((_QWORD *)a2 + 4);
  if (v9)
    v108 = *((_QWORD *)a2 + 5) - a5;
  else
    v108 = 0;
  v10 = a2[1];
  v107 = *a2;
  v106 = *((_QWORD *)a2 + 3) - a5;
  v118 = v9 != 0;
  v12 = *((_QWORD *)a2 + 17);
  v11 = *((_QWORD *)a2 + 18);
  v13 = *((_QWORD *)a2 + 9);
  v103 = *((_QWORD *)a2 + 11);
  v14 = *((_QWORD *)a2 + 7) + v103 * a4;
  v15 = *(unsigned int **)(result + 32);
  v16 = (char *)v15
      + (*(_DWORD *)(result + 260) - 1) * *(_DWORD *)(result + 24)
      + (((*(_DWORD *)(result + 8) >> 22) * *(_DWORD *)(result + 256)) >> 3);
  v104 = v13;
  v105 = v12;
  if (*(_QWORD *)(result + 176))
  {
    v99 = ~(-1 << v13);
    v100 = *((_QWORD *)a2 + 15);
    v101 = *((_QWORD *)a2 + 13);
    v98 = v13 - 4;
    v97 = -v12;
    v17 = (unsigned int *)(v16 - 4);
    v18 = a2[1];
    v116 = 32 - v10;
    v95 = v11 + 16 * a3 + 8;
    v96 = a5;
    while (1)
    {
      if (((v100 - v14) | (v14 - v101)) < 0)
      {
        v23 = 0;
        v113 = 0;
      }
      else
      {
        v19 = ((v14 & (unint64_t)v99) >> v98) & 0xF;
        v20 = weights_19497[v19];
        v21 = (unint64_t)(v19 - 7) >= 9;
        v22 = v97;
        if (!v21)
          v22 = v12;
        v113 = v22;
        v23 = v20 & 0xF;
      }
      v24 = *(_QWORD *)(v115 + 32) + (v14 >> v13) * v12;
      v111 = a6;
      v109 = v14;
      if (v107 != 1)
        break;
      if (a5 >= 1)
      {
        v26 = (uint64_t *)v95;
        v25 = v96;
        while (1)
        {
          v27 = *(v26 - 1);
          v28 = *v26;
          v29 = v24 + v27;
          if ((unint64_t)v17 >= v24 + v27)
            v30 = (unsigned int *)(v24 + v27);
          else
            v30 = v17;
          if (v30 < v15)
            v30 = v15;
          v31 = *v30;
          v32 = v28 & 0xF;
          if ((v28 & 0xF) != 0)
            break;
          if (v23)
          {
            v43 = (unsigned int *)(v29 + v113);
            if ((unint64_t)v17 < v29 + v113)
              v43 = v17;
            if (v43 < v15)
              v43 = v15;
            v44 = BLEND8_19499[v23];
            v41 = v31 - ((v44 & v31) >> v23);
            v42 = (v44 & *v43) >> v23;
            goto LABEL_45;
          }
LABEL_46:
          v45 = (v31 << v18) | (v31 >> v116);
          v46 = HIBYTE(v45);
          if (HIBYTE(v45) <= BYTE2(v45))
            v46 = BYTE2(v45);
          if (v46 <= BYTE1(v45))
            v46 = BYTE1(v45);
          v47 = v45 | v119;
          v48 = (v47 - v46) | ((v46 - BYTE2(v45)) << 16) | ((v46 - HIBYTE(v45)) << 24) | ((v46 - BYTE1(v45)) << 8);
          result = v48 | (unint64_t)(v47 << 32);
          if (v6 != 255)
            result = PDAM_5205(v48, BYTE4(result), v6);
          *v8 = result;
          if (v9)
            *v9 = BYTE4(result);
          v26 += 2;
          ++v8;
          v9 += v118;
          if (!--v25)
            goto LABEL_103;
        }
        v33 = (unsigned int *)(v29 + (v28 >> 4));
        if (v17 < v33)
          v33 = v17;
        if (v33 < v15)
          v33 = v15;
        v34 = *v33;
        if (v23)
        {
          v35 = (unsigned int *)(v29 + v113);
          if (v17 >= v35)
            v36 = v35;
          else
            v36 = v17;
          if (v36 < v15)
            v36 = v15;
          v37 = *v36;
          v38 = (unsigned int *)((char *)v35 + (v28 >> 4));
          if (v17 < v38)
            v38 = v17;
          if (v38 < v15)
            v38 = v15;
          v39 = BLEND8_19499[v23];
          v31 = v31 - ((v39 & v31) >> v23) + ((v39 & v37) >> v23);
          v34 = v34 - ((v39 & v34) >> v23) + ((v39 & *v38) >> v23);
        }
        v40 = BLEND8_19499[*v26 & 0xF];
        v41 = v31 - ((v40 & v31) >> v32);
        v42 = (v40 & v34) >> v32;
LABEL_45:
        v31 = v41 + v42;
        goto LABEL_46;
      }
LABEL_103:
      v12 = v105;
      v8 += v106;
      v9 += v108;
      LOBYTE(v13) = v104;
      v14 = v109 + v103;
      a6 = v111 - 1;
      if (v111 == 1)
        return result;
    }
    if (a5 < 1)
      goto LABEL_103;
    v50 = (uint64_t *)v95;
    v49 = v96;
    while (1)
    {
      v51 = *(v50 - 1);
      v52 = *v50;
      v53 = v24 + v51;
      if ((unint64_t)v17 >= v24 + v51)
        v54 = (unsigned int *)(v24 + v51);
      else
        v54 = v17;
      if (v54 < v15)
        v54 = v15;
      v55 = *v54;
      v56 = v52 & 0xF;
      if ((v52 & 0xF) != 0)
        break;
      if (v23)
      {
        v67 = (unsigned int *)(v53 + v113);
        if ((unint64_t)v17 < v53 + v113)
          v67 = v17;
        if (v67 < v15)
          v67 = v15;
        v68 = BLEND8_19499[v23];
        v65 = v55 - ((v68 & v55) >> v23);
        v66 = (v68 & *v67) >> v23;
        goto LABEL_86;
      }
LABEL_87:
      v69 = (v55 << v18) | (v55 >> v116);
      v70 = HIBYTE(v69);
      if (HIBYTE(v69) <= BYTE2(v69))
        v70 = BYTE2(v69);
      if (v70 <= BYTE1(v69))
        v70 = BYTE1(v69);
      v71 = v69 | v119;
      result = ((_DWORD)v71 - v70) | ((v70 - BYTE2(v69)) << 16) | ((v70 - HIBYTE(v69)) << 24) | ((v70 - BYTE1(v69)) << 8);
      v72 = (int)result | (unint64_t)(v71 << 32);
      if (v6 != 255)
      {
        result = PDAM_5205(result, BYTE4(v72), v6);
        v72 = result;
      }
      if (v9)
      {
        if (BYTE4(v72))
        {
          if (BYTE4(v72) == 255)
          {
            *v8 = v72;
            *v9 = -1;
          }
          else
          {
            result = (unint64_t)DAplusDAM(v8, v9, v72, SBYTE4(v72), *v8, *v9, ~BYTE4(v72));
          }
        }
      }
      else if (BYTE4(v72))
      {
        if (BYTE4(v72) == 255)
        {
          *v8 = v72;
        }
        else
        {
          v73 = ~BYTE4(v72);
          *v8 = ((((*v8 >> 8) & 0xFF00FF) * v73 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) & 0xFF00FF00)
              + v72
              + ((((*v8 & 0xFF00FF) * v73 + 65537 + ((((*v8 & 0xFF00FF) * v73) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        }
      }
      v50 += 2;
      ++v8;
      v9 += v118;
      if (!--v49)
        goto LABEL_103;
    }
    v57 = (unsigned int *)(v53 + (v52 >> 4));
    if (v17 < v57)
      v57 = v17;
    if (v57 < v15)
      v57 = v15;
    v58 = *v57;
    if (v23)
    {
      v59 = (unsigned int *)(v53 + v113);
      if (v17 >= v59)
        v60 = v59;
      else
        v60 = v17;
      if (v60 < v15)
        v60 = v15;
      v61 = *v60;
      v62 = (unsigned int *)((char *)v59 + (v52 >> 4));
      if (v17 < v62)
        v62 = v17;
      if (v62 < v15)
        v62 = v15;
      v63 = BLEND8_19499[v23];
      v55 = v55 - ((v63 & v55) >> v23) + ((v63 & v61) >> v23);
      v58 = v58 - ((v63 & v58) >> v23) + ((v63 & *v62) >> v23);
    }
    v64 = BLEND8_19499[*v50 & 0xF];
    v65 = v55 - ((v64 & v55) >> v56);
    v66 = (v64 & v58) >> v56;
LABEL_86:
    v55 = v65 + v66;
    goto LABEL_87;
  }
  v117 = (uint64_t *)(v11 + 16 * a3);
  v74 = v16 - 4;
  v75 = a2[1];
  v76 = 32 - v10;
  v114 = a5;
  do
  {
    v77 = *(_QWORD *)(v115 + 32) + (v14 >> v13) * v12;
    v112 = a6;
    v110 = v14;
    if (v107 == 1)
    {
      if (a5 >= 1)
      {
        v78 = v117;
        v79 = v114;
        do
        {
          v80 = *v78;
          v78 += 2;
          v81 = (char *)(v77 + v80);
          if ((unint64_t)v74 < v77 + v80)
            v81 = v74;
          if ((unint64_t)v81 < *(_QWORD *)(v115 + 32))
            v81 = *(char **)(v115 + 32);
          v82 = (*(_DWORD *)v81 << v75) | (*(_DWORD *)v81 >> v76);
          v83 = HIBYTE(v82);
          if (HIBYTE(v82) <= BYTE2(v82))
            v83 = BYTE2(v82);
          if (v83 <= BYTE1(v82))
            v83 = BYTE1(v82);
          v84 = v82 | v119;
          v85 = (v84 - v83) | ((v83 - BYTE2(v82)) << 16) | ((v83 - HIBYTE(v82)) << 24) | ((v83 - BYTE1(v82)) << 8);
          result = v85 | (unint64_t)(v84 << 32);
          if (v6 != 255)
            result = PDAM_5205(v85, BYTE4(result), v6);
          *v8 = result;
          if (v9)
            *v9 = BYTE4(result);
          ++v8;
          v9 += v118;
          --v79;
        }
        while (v79);
      }
    }
    else
    {
      v86 = v117;
      v87 = v114;
      if (a5 >= 1)
      {
        do
        {
          v88 = *v86;
          v86 += 2;
          v89 = (char *)(v77 + v88);
          if ((unint64_t)v74 < v77 + v88)
            v89 = v74;
          if ((unint64_t)v89 < *(_QWORD *)(v115 + 32))
            v89 = *(char **)(v115 + 32);
          v90 = (*(_DWORD *)v89 << v75) | (*(_DWORD *)v89 >> v76);
          v91 = HIBYTE(v90);
          if (HIBYTE(v90) <= BYTE2(v90))
            v91 = BYTE2(v90);
          if (v91 <= BYTE1(v90))
            v91 = BYTE1(v90);
          v92 = v90 | v119;
          result = ((_DWORD)v92 - v91) | ((v91 - BYTE2(v90)) << 16) | ((v91 - HIBYTE(v90)) << 24) | ((v91 - BYTE1(v90)) << 8);
          v93 = (int)result | (unint64_t)(v92 << 32);
          if (v6 != 255)
          {
            result = PDAM_5205(result, BYTE4(v93), v6);
            v93 = result;
          }
          if (v9)
          {
            if (BYTE4(v93))
            {
              if (BYTE4(v93) == 255)
              {
                *v8 = v93;
                *v9 = -1;
              }
              else
              {
                result = (unint64_t)DAplusDAM(v8, v9, v93, SBYTE4(v93), *v8, *v9, ~BYTE4(v93));
              }
            }
          }
          else if (BYTE4(v93))
          {
            if (BYTE4(v93) == 255)
            {
              *v8 = v93;
            }
            else
            {
              v94 = ~BYTE4(v93);
              *v8 = ((((*v8 >> 8) & 0xFF00FF) * v94 + 65537 + (((((*v8 >> 8) & 0xFF00FF) * v94) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                  + v93
                  + ((((*v8 & 0xFF00FF) * v94 + 65537 + ((((*v8 & 0xFF00FF) * v94) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
          }
          ++v8;
          v9 += v118;
          --v87;
        }
        while (v87);
      }
    }
    v12 = v105;
    v8 += v106;
    v9 += v108;
    LOBYTE(v13) = v104;
    v14 = v110 + v103;
    a6 = v112 - 1;
  }
  while (v112 != 1);
  return result;
}

unint64_t cmyk32_mark_constmask(uint64_t a1, int a2)
{
  uint64_t v4;
  unsigned __int8 *v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t result;
  double v12;
  int8x16_t v13;
  double v14;
  double v15;
  double v16;
  int8x16_t v17;
  _QWORD *v18;
  char *v19;
  char *v20;
  char *v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned __int8 *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  unint64_t v41;
  int v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  int v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  int v52;
  int v53;
  unint64_t v54;
  unint64_t v55;
  int v56;
  unint64_t v57;
  unint64_t v58;
  int v59;
  unint64_t v60;
  unint64_t v61;
  int v62;
  unint64_t v63;
  unint64_t v64;
  int v65;
  unint64_t v66;
  unint64_t v67;
  int v68;
  unint64_t v69;
  unint64_t v70;
  int v71;
  unint64_t v72;
  unint64_t v73;
  int v74;
  unint64_t v75;
  unint64_t v76;
  int v77;
  unint64_t v78;
  unint64_t v79;
  int v80;
  unint64_t v81;
  unint64_t v82;
  int v83;
  unint64_t v84;
  unint64_t v85;
  int v86;
  unint64_t v87;
  unint64_t v88;
  int v89;
  unint64_t v90;
  unint64_t v91;
  int v92;
  unint64_t v93;
  int v94;
  unint64_t v95;
  unint64_t v96;
  int v97;
  unint64_t v98;
  unint64_t v99;
  int v100;
  unint64_t v101;
  unint64_t v102;
  int v103;
  unint64_t v104;
  int v105;
  unint64_t v106;
  unint64_t v107;
  unsigned int v108;
  int v109;
  char v110;
  unsigned int *v111;
  int v112;
  unsigned int v113;
  unsigned int v114;
  unsigned int v115;
  int v116;
  unsigned int *v117;
  unsigned __int8 *v118;
  char v119;
  int v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  int v124;
  uint64_t v125;
  uint64_t v126;
  int v127;
  int v128;
  int v129;
  int v130;
  int v131;
  int v132;
  int v133;
  int v134;
  int v135;
  int v136;
  uint64_t v137;
  int v138;
  unsigned int v139;
  unsigned int v140;
  unsigned int v141;
  unsigned int v142;
  int v143;
  uint64_t v144;
  unsigned int v145;
  int v146;
  int v147;
  unsigned int v148;
  int v149;
  char v150;
  unsigned int *v151;
  int32x4_t *v152;
  int v153;
  int v154;
  unsigned int v155;
  unsigned int v156;
  int v157;
  char v158;
  unsigned int *v159;
  uint32x2_t *v160;
  int v161;
  int v162;
  unsigned int v163;
  unsigned int v164;
  int v165;
  int v166;
  unsigned int v167;
  unsigned int v168;
  int v169;
  int v170;
  int v171;
  int v172;
  unsigned int v173;
  unsigned int v174;
  int v175;
  unsigned int v176;
  int v177;
  unsigned int v178;
  unsigned int *v179;
  unsigned __int8 *v180;
  unsigned int *v181;
  unsigned __int8 *v182;
  unsigned __int8 *v183;
  unsigned int v184;
  int v185;
  unsigned int v186;
  unsigned int v187;
  int v188;
  unsigned int v189;
  _DWORD *v190;
  unsigned int v191;
  _BYTE *v192;
  int v193;
  int v194;
  char v195;
  int v196;
  int *v197;
  int v198;
  int v199;
  int32x4_t v200;
  uint64_t v201;
  unint64_t v202;
  unsigned int v203;
  int v204;
  unsigned int v205;
  __int32 v206;
  int v207;
  __int32 v208;
  unsigned __int32 v209;
  __int32 v210;
  unsigned __int32 v211;
  unsigned int v212;
  unsigned __int32 v213;
  int v214;
  uint64_t v215;
  int32x2_t v216;
  int v217;
  int32x2_t v218;
  unint64_t v219;
  unsigned int v220;
  unsigned int v221;
  int v222;
  int32x2_t v223;
  int32x2_t v224;
  int32x2_t v225;
  unsigned __int32 v226;
  unsigned __int32 v227;
  int v228;
  unsigned int v229;
  unsigned int v230;
  int v231;
  uint64_t v232;
  int v233;
  uint64_t v234;
  int v235;
  uint64_t v236;
  int v237;
  unsigned int v238;
  int *v239;
  unsigned __int32 v240;
  int v241;
  int v242;
  uint64_t v243;
  uint64_t v244;
  int v245;
  int v246;
  uint64_t v247;
  unint64_t v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  int v252;
  unsigned __int8 v253;
  uint64_t v254;
  unint64_t v255;
  unint64_t v256;
  unint64_t v257;
  int v258;
  unsigned int v259;
  unsigned int v260;
  int v261;

  v4 = *(_QWORD *)(a1 + 48);
  v5 = *(unsigned __int8 **)(a1 + 96);
  if (v5)
    v6 = (unint64_t)*v5 << 32;
  else
    v6 = 0xFF00000000;
  v258 = *(_DWORD *)(a1 + 4);
  v261 = *(_DWORD *)(a1 + 8);
  v7 = *(_QWORD *)(a1 + 136);
  v248 = *(int *)(a1 + 28);
  v254 = *(_QWORD *)(a1 + 40);
  v8 = **(unsigned int **)(a1 + 88);
  v9 = v6 | v8;
  pthread_mutex_lock(&cmyk32_cacheColorLock);
  v10 = (_QWORD *)cmyk32_cacheColor;
  if (!cmyk32_cacheColor || *(_QWORD *)(cmyk32_cacheColor + 16) != v9)
  {
    v19 = 0;
    while (1)
    {
      if (!v10)
        goto LABEL_12;
      v20 = v19;
      v19 = (char *)v10;
      if (v10[2] == v9)
        break;
      v10 = (_QWORD *)*v10;
      if (!*(_QWORD *)v19)
      {
        if (cmyk32_cacheColorCount > 6)
        {
          *(_QWORD *)v20 = 0;
        }
        else
        {
LABEL_12:
          v21 = (char *)cmyk32_cacheColorBase;
          if (cmyk32_cacheColorBase)
          {
            v22 = cmyk32_cacheColorCount;
          }
          else
          {
            v21 = (char *)malloc_type_calloc(1uLL, 0x38A8uLL, 0x10200402493A768uLL);
            v22 = 0;
            cmyk32_cacheColorBase = (uint64_t)v21;
          }
          v19 = &v21[24 * v22];
          *((_QWORD *)v19 + 1) = &v21[2048 * (unint64_t)v22 + 168];
          cmyk32_cacheColorCount = v22 + 1;
        }
        v23 = 0;
        *(_QWORD *)v19 = cmyk32_cacheColor;
        cmyk32_cacheColor = (uint64_t)v19;
        *((_QWORD *)v19 + 2) = v9;
        v25 = *((_QWORD *)v19 + 1);
        v18 = v19 + 8;
        v24 = v25;
        v26 = HIDWORD(v6);
        do
        {
          *(_QWORD *)(v24 + 8 * v23) = PDAM_5205(v8, v26, v23);
          ++v23;
        }
        while ((_DWORD)v23 != 256);
        result = pthread_mutex_unlock(&cmyk32_cacheColorLock);
        goto LABEL_23;
      }
    }
    if (v20)
    {
      *(_QWORD *)v20 = *v10;
      *v10 = cmyk32_cacheColor;
      cmyk32_cacheColor = (uint64_t)v10;
    }
  }
  result = pthread_mutex_unlock(&cmyk32_cacheColorLock);
  v18 = v10 + 1;
LABEL_23:
  v28 = *(int *)(a1 + 12);
  v27 = *(int *)(a1 + 16);
  if (v4)
  {
    v29 = *(int *)(a1 + 32);
    v30 = (unsigned __int8 *)(v4 + v28 + (int)v29 * (uint64_t)(int)v27);
    v31 = 1;
    if (!v7)
      return result;
  }
  else
  {
    v30 = 0;
    v29 = 0;
    v31 = 0;
    if (!v7)
      return result;
  }
  v32 = v29 - v258;
  if (v4)
    v29 -= v258;
  v251 = v29;
  v33 = *v18;
  v34 = *(_QWORD *)(*v18 + 2040);
  v35 = (unsigned int *)(v254 + 4 * (v28 + (v248 >> 2) * v27));
  v36 = *(int *)(a1 + 124);
  v37 = v7 + *(int *)(a1 + 104) + *(int *)(a1 + 108) * (uint64_t)(int)v36;
  v38 = v36 - v258;
  v255 = (v248 >> 2) - v258;
  switch(a2)
  {
    case 0:
      if (v4)
      {
        do
        {
          v39 = v258;
          do
          {
            v40 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v40 == 255)
              {
                LOBYTE(v41) = 0;
                *v35 = 0;
              }
              else
              {
                result = PDAM_5205(*v35, *v30, v40 ^ 0xFFu);
                *v35 = result;
                v41 = HIDWORD(result);
              }
              *v30 = v41;
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v39;
          }
          while (v39);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          v146 = v258;
          do
          {
            v147 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v147 == 255)
                v148 = 0;
              else
                v148 = (((*v35 & 0xFF00FF) * (v147 ^ 0xFF)
                       + 65537
                       + ((((*v35 & 0xFF00FF) * (v147 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v35 >> 8) & 0xFF00FF) * (v147 ^ 0xFF) + 65537 + (((((*v35 >> 8) & 0xFF00FF) * (v147 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              *v35 = v148;
            }
            ++v37;
            ++v35;
            --v146;
          }
          while (v146);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 1:
      v108 = v37 & 3;
      if (v4)
      {
        v109 = v108 + v258;
        if ((v37 & 3) != 0)
          v110 = v37 & 0xFC;
        else
          v110 = v37;
        if ((v37 & 3) != 0)
          result = (-1 << (8 * v108));
        else
          result = 0xFFFFFFFFLL;
        if ((v37 & 3) != 0)
          v111 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        else
          v111 = (unsigned int *)v37;
        if ((v37 & 3) != 0)
        {
          v30 -= v37 & 3;
          v35 -= v37 & 3;
        }
        else
        {
          v109 = v258;
        }
        if ((((_BYTE)v109 + v110) & 3) != 0)
        {
          v112 = 4 - (((_BYTE)v109 + v110) & 3);
          v108 += v112;
          v113 = 0xFFFFFFFF >> (8 * v112);
          if (v109 >= 4)
            v114 = 0xFFFFFFFF >> (8 * v112);
          else
            v114 = 0;
          v259 = v114;
          if (v109 >= 4)
            v113 = -1;
          result = v113 & result;
          v252 = result;
        }
        else
        {
          v252 = result;
          v259 = 0;
        }
        v250 = v38 - v108;
        v256 = v255 - v108;
        v246 = v109 >> 2;
        v244 = v32 - v108;
        do
        {
          v176 = *v111 & v252;
          v177 = v246;
          v178 = v259;
          if (!v176)
            goto LABEL_464;
LABEL_446:
          if (v176 == -1)
          {
            *v35 = v34;
            *v30 = BYTE4(v34);
            v35[1] = v34;
            v30[1] = BYTE4(v34);
            v35[2] = v34;
            v30[2] = BYTE4(v34);
            v35[3] = v34;
            v30[3] = BYTE4(v34);
            goto LABEL_464;
          }
          while (1)
          {
            if ((_BYTE)v176)
            {
              if (v176 == 255)
              {
                *v35 = v34;
                *v30 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * v176), *(_BYTE *)(v33 + 8 * v176 + 4), *v35, *v30, ~(_BYTE)v176);
              }
            }
            if (BYTE1(v176))
            {
              v179 = v35 + 1;
              v180 = v30 + 1;
              if (BYTE1(v176) == 255)
              {
                *v179 = v34;
                *v180 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v179, v180, *(_DWORD *)(v33 + 8 * BYTE1(v176)), *(_BYTE *)(v33 + 8 * BYTE1(v176) + 4), *v179, *v180, ~(v176 >> 8));
              }
            }
            if (BYTE2(v176))
            {
              v181 = v35 + 2;
              v182 = v30 + 2;
              if (BYTE2(v176) == 255)
              {
                *v181 = v34;
                *v182 = BYTE4(v34);
              }
              else
              {
                DAplusDAM(v181, v182, *(_DWORD *)(v33 + 8 * BYTE2(v176)), *(_BYTE *)(v33 + 8 * BYTE2(v176) + 4), *v181, *v182, ~HIWORD(v176));
              }
            }
            result = (unint64_t)(v35 + 3);
            v183 = v30 + 3;
            v184 = HIBYTE(v176);
            if (HIBYTE(v176) == 255)
            {
              *(_DWORD *)result = v34;
              *v183 = BYTE4(v34);
            }
            else if (v184)
            {
              result = (unint64_t)DAplusDAM((_DWORD *)result, v183, *(_DWORD *)(v33 + 8 * v184), *(_BYTE *)(v33 + 8 * v184 + 4), *(_DWORD *)result, *v183, ~v176 >> 24);
            }
LABEL_464:
            while (1)
            {
              v185 = v177;
              v35 += 4;
              v30 += 4;
              --v177;
              ++v111;
              if (v185 < 2)
                break;
              v176 = *v111;
              if (*v111)
                goto LABEL_446;
            }
            if (!v178)
              break;
            v178 = 0;
            v176 = *v111 & v259;
          }
          v111 = (unsigned int *)((char *)v111 + v250);
          v35 += v256;
          v30 += v244;
          --v261;
        }
        while (v261);
      }
      else
      {
        v149 = -1 << (8 * v108);
        if ((v37 & 3) != 0)
          v150 = v37 & 0xFC;
        else
          v150 = v37;
        if ((v37 & 3) != 0)
        {
          v151 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v149 = -1;
          v151 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0)
          v152 = (int32x4_t *)&v35[-(v37 & 3)];
        else
          v152 = (int32x4_t *)v35;
        if ((v37 & 3) != 0)
          v153 = v108 + v258;
        else
          v153 = v258;
        if ((((_BYTE)v153 + v150) & 3) != 0)
        {
          v154 = 4 - (((_BYTE)v153 + v150) & 3);
          v108 += v154;
          v155 = 0xFFFFFFFF >> (8 * v154);
          if (v153 >= 4)
            v156 = v155;
          else
            v156 = 0;
          if (v153 >= 4)
            v155 = -1;
          v149 &= v155;
        }
        else
        {
          v156 = 0;
        }
        v199 = v153 >> 2;
        v200 = vdupq_n_s32(v34);
        v201 = v38 - v108;
        v202 = v255 - v108;
        do
        {
          v203 = *v151 & v149;
          v204 = v199;
          v205 = v156;
          if (!v203)
            goto LABEL_513;
LABEL_495:
          if (v203 == -1)
          {
            *v152 = v200;
            goto LABEL_513;
          }
          while (1)
          {
            if ((_BYTE)v203)
            {
              v206 = v34;
              if (v203 != 255)
              {
                v207 = v203 ^ 0xFF;
                v206 = (((((unsigned __int32)v152->i32[0] >> 8) & 0xFF00FF) * v207
                       + 65537
                       + ((((((unsigned __int32)v152->i32[0] >> 8) & 0xFF00FF) * v207) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(_QWORD *)(v33 + 8 * v203)
                     + ((((v152->i32[0] & 0xFF00FF) * v207
                        + 65537
                        + ((((v152->i32[0] & 0xFF00FFu) * v207) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[0] = v206;
            }
            if (BYTE1(v203))
            {
              v208 = v34;
              if (BYTE1(v203) != 255)
              {
                v209 = v152->u32[1];
                v208 = ((((v209 >> 8) & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)
                       + 65537
                       + (((((v209 >> 8) & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(_QWORD *)(v33 + 8 * BYTE1(v203))
                     + ((((v209 & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)
                        + 65537
                        + ((((v209 & 0xFF00FF) * (BYTE1(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[1] = v208;
            }
            if (BYTE2(v203))
            {
              v210 = v34;
              if (BYTE2(v203) != 255)
              {
                v211 = v152->u32[2];
                v210 = ((((v211 >> 8) & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)
                       + 65537
                       + (((((v211 >> 8) & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                     + *(_QWORD *)(v33 + 8 * BYTE2(v203))
                     + ((((v211 & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)
                        + 65537
                        + ((((v211 & 0xFF00FF) * (BYTE2(v203) ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
              }
              v152->i32[2] = v210;
            }
            v212 = HIBYTE(v203);
            if (v212 == 255)
            {
              v152->i32[3] = v34;
            }
            else if (v212)
            {
              v213 = v152->u32[3];
              v152->i32[3] = ((((v213 >> 8) & 0xFF00FF) * (v212 ^ 0xFF)
                             + 65537
                             + (((((v213 >> 8) & 0xFF00FF) * (v212 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + *(_QWORD *)(v33 + 8 * v212)
                           + ((((v213 & 0xFF00FF) * (v212 ^ 0xFF)
                              + 65537
                              + ((((v213 & 0xFF00FF) * (v212 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
LABEL_513:
            while (1)
            {
              v214 = v204;
              ++v152;
              --v204;
              ++v151;
              if (v214 < 2)
                break;
              v203 = *v151;
              if (*v151)
                goto LABEL_495;
            }
            if (!v205)
              break;
            v205 = 0;
            v203 = *v151 & v156;
          }
          v151 = (unsigned int *)((char *)v151 + v201);
          v152 = (int32x4_t *)((char *)v152 + 4 * v202);
          result = --v261;
        }
        while (v261);
      }
      return result;
    case 2:
      v253 = ~BYTE4(v34);
      v115 = v37 & 3;
      if (!v4)
      {
        v157 = -1 << (8 * v115);
        if ((v37 & 3) != 0)
          v158 = v37 & 0xFC;
        else
          v158 = v37;
        if ((v37 & 3) != 0)
        {
          v159 = (unsigned int *)(v37 & 0xFFFFFFFFFFFFFFFCLL);
        }
        else
        {
          v157 = -1;
          v159 = (unsigned int *)v37;
        }
        if ((v37 & 3) != 0)
          v160 = (uint32x2_t *)&v35[-(v37 & 3)];
        else
          v160 = (uint32x2_t *)v35;
        if ((v37 & 3) != 0)
          v161 = v115 + v258;
        else
          v161 = v258;
        if ((((_BYTE)v161 + v158) & 3) != 0)
        {
          v162 = 4 - (((_BYTE)v161 + v158) & 3);
          v115 += v162;
          v163 = 0xFFFFFFFF >> (8 * v162);
          if (v161 >= 4)
            v164 = -1;
          else
            v164 = 0xFFFFFFFF >> (8 * v162);
          v157 &= v164;
          if (v161 < 4)
            v163 = 0;
        }
        else
        {
          v163 = 0;
        }
        v215 = v38 - v115;
        v216 = vdup_n_s32(v253);
        v217 = v161 >> 2;
        v218 = vdup_n_s32(v34);
        result = 255;
        v219 = v255 - v115;
        while (1)
        {
          v220 = *v159 & v157;
          v221 = v163;
          v222 = v217;
          if (!v220)
            goto LABEL_534;
LABEL_523:
          if (v220 == -1)
            break;
          while (1)
          {
            if ((_BYTE)v220)
            {
              v232 = v33 + 8 * v220;
              v233 = *(_DWORD *)v232;
              LODWORD(v232) = ~*(_BYTE *)(v232 + 4);
              v160->i32[0] = ((v232 * (((unsigned __int32)v160->i32[0] >> 8) & 0xFF00FF)
                             + 65537
                             + (((v232 * (((unsigned __int32)v160->i32[0] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + v233
                           + ((((_DWORD)v232 * (v160->i32[0] & 0xFF00FF)
                              + 65537
                              + (((v232 * (v160->i32[0] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            if ((v220 & 0xFF00) != 0)
            {
              v234 = v33 + 8 * BYTE1(v220);
              v235 = *(_DWORD *)v234;
              LODWORD(v234) = ~*(_BYTE *)(v234 + 4);
              v160->i32[1] = ((v234 * (((unsigned __int32)v160->i32[1] >> 8) & 0xFF00FF)
                             + 65537
                             + (((v234 * (((unsigned __int32)v160->i32[1] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                           + v235
                           + ((((_DWORD)v234 * (v160->i32[1] & 0xFF00FF)
                              + 65537
                              + (((v234 * (v160->i32[1] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            if ((v220 & 0xFF0000) != 0)
            {
              v236 = v33 + 8 * BYTE2(v220);
              v237 = *(_DWORD *)v236;
              LODWORD(v236) = ~*(_BYTE *)(v236 + 4);
              v160[1].i32[0] = ((v236 * (((unsigned __int32)v160[1].i32[0] >> 8) & 0xFF00FF)
                               + 65537
                               + (((v236 * (((unsigned __int32)v160[1].i32[0] >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                             + v237
                             + ((((_DWORD)v236 * (v160[1].i32[0] & 0xFF00FF)
                                + 65537
                                + (((v236 * (v160[1].i32[0] & 0xFF00FF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
            }
            v238 = HIBYTE(v220);
            if (v238)
            {
              v239 = (int *)(v33 + 8 * v238);
              v231 = *v239;
              v240 = v160[1].u32[1];
              v241 = ~*((_BYTE *)v239 + 4);
              v229 = v241 * ((v240 >> 8) & 0xFF00FF);
              v230 = v241 * (v240 & 0xFF00FF);
              goto LABEL_533;
            }
LABEL_534:
            while (1)
            {
              v242 = v222;
              v160 += 2;
              --v222;
              ++v159;
              if (v242 < 2)
                break;
              v220 = *v159;
              if (*v159)
                goto LABEL_523;
            }
            if (!v221)
              break;
            v221 = 0;
            v220 = *v159 & v163;
          }
          v159 = (unsigned int *)((char *)v159 + v215);
          v160 = (uint32x2_t *)((char *)v160 + 4 * v219);
          if (!--v261)
            return result;
        }
        v223.i16[0] = v160->u8[0];
        v223.i16[1] = BYTE2(v160->u32[0]);
        v223.i16[2] = BYTE4(*(unint64_t *)v160);
        v223.i16[3] = BYTE6(*(unint64_t *)v160);
        v224 = vmul_s32((int32x2_t)(*(_QWORD *)&vshr_n_u32(*v160, 8uLL) & 0xFFFF00FFFFFF00FFLL), v216);
        v225 = vmul_s32(v223, v216);
        *v160 = (uint32x2_t)vadd_s32(vadd_s32((int32x2_t)(*(_QWORD *)&vadd_s32(vadd_s32(v224, (int32x2_t)0x1000100010001), (int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)v224, 8uLL) & 0xFFFF00FFFFFF00FFLL)) & 0xFF00FF00FF00FF00), v218), (int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)vadd_s32(vadd_s32(v225, (int32x2_t)0x1000100010001), (int32x2_t)(*(_QWORD *)&vshr_n_u32((uint32x2_t)v225, 8uLL) & 0xFFFF00FFFFFF00FFLL)), 8uLL) & 0xFFFF00FFFFFF00FFLL));
        v226 = v160[1].u32[0];
        v227 = v160[1].u32[1];
        v160[1].i32[0] = ((((v226 >> 8) & 0xFF00FF) * v253
                         + 65537
                         + (((((v226 >> 8) & 0xFF00FF) * v253) >> 8) & 0xFF00FF)) & 0xFF00FF00)
                       + v34
                       + ((((v226 & 0xFF00FF) * v253 + 65537 + ((((v226 & 0xFF00FF) * v253) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        v228 = v227 & 0xFF00FF;
        v229 = ((v227 >> 8) & 0xFF00FF) * v253;
        v230 = v228 * v253;
        v231 = v34;
LABEL_533:
        v160[1].i32[1] = ((v229 + 65537 + ((v229 >> 8) & 0xFF00FF)) & 0xFF00FF00)
                       + v231
                       + (((v230 + 65537 + ((v230 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF);
        goto LABEL_534;
      }
      v116 = v115 + v258;
      v117 = &v35[-(v37 & 3)];
      v118 = &v30[-(v37 & 3)];
      if ((v37 & 3) != 0)
        v119 = v37 & 0xFC;
      else
        v119 = v37;
      if ((v37 & 3) != 0)
        result = (-1 << (8 * v115));
      else
        result = 0xFFFFFFFFLL;
      if ((v37 & 3) != 0)
      {
        v37 &= 0xFFFFFFFFFFFFFFFCLL;
        v30 = v118;
        v35 = v117;
      }
      else
      {
        v116 = v258;
      }
      if ((((_BYTE)v116 + v119) & 3) != 0)
      {
        v120 = 4 - (((_BYTE)v116 + v119) & 3);
        v115 += v120;
        v121 = 0xFFFFFFFF >> (8 * v120);
        if (v116 >= 4)
          v122 = 0xFFFFFFFF >> (8 * v120);
        else
          v122 = 0;
        v260 = v122;
        if (v116 >= 4)
          v121 = -1;
        result = v121 & result;
        v249 = result;
      }
      else
      {
        v249 = result;
        v260 = 0;
      }
      v247 = v38 - v115;
      v257 = v255 - v115;
      v245 = v116 >> 2;
      v243 = v32 - v115;
      v186 = v260;
      do
      {
        v187 = *(_DWORD *)v37 & v249;
        v188 = v245;
        v189 = v186;
        if (!v187)
          goto LABEL_485;
LABEL_474:
        if (v187 == -1)
        {
          DAplusDAM(v35, v30, v34, SBYTE4(v34), *v35, *v30, ~BYTE4(v34));
          DAplusDAM(v35 + 1, v30 + 1, v34, SBYTE4(v34), v35[1], v30[1], ~BYTE4(v34));
          DAplusDAM(v35 + 2, v30 + 2, v34, SBYTE4(v34), v35[2], v30[2], ~BYTE4(v34));
          v190 = v35 + 3;
          v191 = v35[3];
          v192 = v30 + 3;
          v193 = v30[3];
          v194 = v34;
          v195 = BYTE4(v34);
          v196 = ~BYTE4(v34);
          v186 = v260;
LABEL_484:
          result = (unint64_t)DAplusDAM(v190, v192, v194, v195, v191, v193, v196);
          goto LABEL_485;
        }
        while (1)
        {
          if ((_BYTE)v187)
            result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * v187), *(_DWORD *)(v33 + 8 * v187 + 4), *v35, *v30, ~*(_BYTE *)(v33 + 8 * v187 + 4));
          if ((v187 & 0xFF00) != 0)
            result = (unint64_t)DAplusDAM(v35 + 1, v30 + 1, *(_DWORD *)(v33 + 8 * BYTE1(v187)), *(_DWORD *)(v33 + 8 * BYTE1(v187) + 4), v35[1], v30[1], ~*(_BYTE *)(v33 + 8 * BYTE1(v187) + 4));
          if ((v187 & 0xFF0000) != 0)
            result = (unint64_t)DAplusDAM(v35 + 2, v30 + 2, *(_DWORD *)(v33 + 8 * BYTE2(v187)), *(_DWORD *)(v33 + 8 * BYTE2(v187) + 4), v35[2], v30[2], ~*(_BYTE *)(v33 + 8 * BYTE2(v187) + 4));
          if (HIBYTE(v187))
          {
            v197 = (int *)(v33 + 8 * HIBYTE(v187));
            v190 = v35 + 3;
            v191 = v35[3];
            v194 = *v197;
            LODWORD(v197) = v197[1];
            v192 = v30 + 3;
            v193 = v30[3];
            v196 = ~(_BYTE)v197;
            v195 = (char)v197;
            goto LABEL_484;
          }
LABEL_485:
          while (1)
          {
            v198 = v188;
            v35 += 4;
            v30 += 4;
            --v188;
            v37 += 4;
            if (v198 < 2)
              break;
            v187 = *(_DWORD *)v37;
            if (*(_DWORD *)v37)
              goto LABEL_474;
          }
          if (!v189)
            break;
          v189 = 0;
          v187 = *(_DWORD *)v37 & v186;
        }
        v37 += v247;
        v35 += v257;
        v30 += v243;
        --v261;
      }
      while (v261);
      return result;
    case 3:
      do
      {
        v42 = v258;
        do
        {
          v43 = *(unsigned __int8 *)v37;
          if (*(_BYTE *)v37)
          {
            if (v43 == 255)
            {
              v44 = *(_QWORD *)(v33 + 8 * *v30);
              *v35 = v44;
              *v30 = BYTE4(v44);
            }
            else
            {
              v45 = *v30;
              v46 = v33 + 8 * ((v45 * v43 + ((v45 * v43) >> 8) + 1) >> 8);
              result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)v46, *(_BYTE *)(v46 + 4), *v35, v45, v43 ^ 0xFFu);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v42;
        }
        while (v42);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 4:
      do
      {
        v47 = v258;
        do
        {
          v48 = *(unsigned __int8 *)v37;
          if (*(_BYTE *)v37)
          {
            if (v48 == 255)
            {
              v49 = *(_QWORD *)(v33 + 8 * ~*v30);
              *v35 = v49;
              *v30 = BYTE4(v49);
            }
            else
            {
              v50 = *v30;
              v51 = v33 + 8 * (((v50 ^ 0xFF) * v48 + (((v50 ^ 0xFFu) * v48) >> 8) + 1) >> 8);
              result = (unint64_t)DAplusDAM(v35, v30, *(_DWORD *)v51, *(_BYTE *)(v51 + 4), *v35, v50, v48 ^ 0xFFu);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v47;
        }
        while (v47);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 5:
      do
      {
        v123 = v258;
        do
        {
          if (*(_BYTE *)v37)
            result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30, *v35, *v30, ~*(_BYTE *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
          ++v37;
          ++v35;
          v30 += v31;
          --v123;
        }
        while (v123);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 6:
      do
      {
        v124 = v258;
        do
        {
          v125 = *(unsigned __int8 *)v37;
          if (*(_BYTE *)v37 && *v30 != 0xFF)
          {
            if (~*v30 == 255)
            {
              v126 = *(_QWORD *)(v33 + 8 * v125);
              *v35 = v126;
              *v30 = BYTE4(v126);
            }
            else
            {
              result = (unint64_t)DAplusDAM(v35, v30, *v35, *v30, *(_DWORD *)(v33 + 8 * v125), *(unsigned __int8 *)(v33 + 8 * v125 + 4), ~*v30);
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v124;
        }
        while (v124);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 7:
      if (v4)
      {
        do
        {
          v127 = v258;
          do
          {
            v128 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v128 == 255)
                v129 = BYTE4(v34);
              else
                v129 = (~(_BYTE)v128
                                       + ((unsigned __int16)(BYTE4(v34) * (_WORD)v128
                                                           + ((BYTE4(v34) * v128) >> 8)
                                                           + 1) >> 8));
              result = PDAM_5205(*v35, *v30, v129);
              *v35 = result;
              *v30 = BYTE4(result);
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v127;
          }
          while (v127);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          v165 = v258;
          do
          {
            v166 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v166 == 255)
              {
                v167 = ((*v35 >> 8) & 0xFF00FF) * BYTE4(v34);
                v168 = (*v35 & 0xFF00FF) * BYTE4(v34);
              }
              else
              {
                v169 = (~(_BYTE)v166
                                       + ((unsigned __int16)(BYTE4(v34) * (_WORD)v166
                                                           + ((BYTE4(v34) * v166) >> 8)
                                                           + 1) >> 8));
                v167 = ((*v35 >> 8) & 0xFF00FF) * v169;
                v168 = (*v35 & 0xFF00FF) * v169;
              }
              *v35 = ((v168 + 65537 + ((v168 >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v167
                                                                                  + 65537
                                                                                  + ((v167 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            ++v37;
            ++v35;
            --v165;
          }
          while (v165);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 8:
      if (v4)
      {
        do
        {
          v130 = v258;
          do
          {
            v131 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v131 == 255)
                v132 = ~BYTE4(v34);
              else
                v132 = ~((BYTE4(v34) * v131 + ((BYTE4(v34) * v131) >> 8) + 1) >> 8);
              result = PDAM_5205(*v35, *v30, v132);
              *v35 = result;
              *v30 = BYTE4(result);
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v130;
          }
          while (v130);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        v170 = ~BYTE4(v34);
        do
        {
          v171 = v258;
          do
          {
            v172 = *(unsigned __int8 *)v37;
            if (*(_BYTE *)v37)
            {
              if (v172 == 255)
              {
                v173 = ((*v35 >> 8) & 0xFF00FF) * v170;
                v174 = (*v35 & 0xFF00FF) * v170;
              }
              else
              {
                v175 = ~((BYTE4(v34) * v172 + ((BYTE4(v34) * v172) >> 8) + 1) >> 8);
                v173 = ((*v35 >> 8) & 0xFF00FF) * v175;
                v174 = (*v35 & 0xFF00FF) * v175;
              }
              result = (v174 >> 8) & 0xFF00FF;
              *v35 = ((v174 + 65537 + result) >> 8) & 0xFF00FF | (v173 + 65537 + ((v173 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            ++v37;
            ++v35;
            --v171;
          }
          while (v171);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 9:
      do
      {
        v52 = v258;
        do
        {
          if (*(_BYTE *)v37)
            result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30 ^ 0xFFu, *v35, *v30, (*(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4)+ ~*(_BYTE *)v37));
          ++v37;
          ++v35;
          v30 += v31;
          --v52;
        }
        while (v52);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 10:
      do
      {
        v133 = v258;
        do
        {
          if (*(_BYTE *)v37)
            result = (unint64_t)DAMplusDAM(v35, v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37 + 4), *v30 ^ 0xFFu, *v35, *v30, ~*(_BYTE *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
          ++v37;
          ++v35;
          v30 += v31;
          --v133;
        }
        while (v133);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 11:
      if (v4)
      {
        do
        {
          v134 = v258;
          do
          {
            if (*(_BYTE *)v37)
              result = (unint64_t)DAplusdDA(v35, v30, *v35, *v30, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(unsigned __int8 *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
            ++v37;
            ++v35;
            v30 += v31;
            --v134;
          }
          while (v134);
          v37 += v38;
          v35 += v255;
          v30 += v251;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          v135 = v258;
          do
          {
            if (*(_BYTE *)v37)
              result = (unint64_t)DplusdDA(v35, *v35, *(_DWORD *)(v33 + 8 * *(unsigned __int8 *)v37), *(unsigned __int8 *)(v33 + 8 * *(unsigned __int8 *)v37 + 4));
            ++v37;
            ++v35;
            --v135;
          }
          while (v135);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 12:
      if (v4)
      {
        do
        {
          v136 = v258;
          do
          {
            if (*(_BYTE *)v37)
            {
              v137 = v33 + 8 * *(unsigned __int8 *)v37;
              v138 = *(unsigned __int8 *)(v137 + 4);
              LODWORD(v137) = *(_DWORD *)v137;
              v139 = ((v137 >> 8) & 0xFF00FF) + ((*v35 >> 8) & 0xFF00FF);
              LODWORD(v137) = (v137 & 0xFF00FF) + (*v35 & 0xFF00FF);
              v140 = v139 & 0x1000100 | (v137 >> 8) & 0x10001;
              v141 = v138 + *v30;
              result = (v139 << 8) & 0xFF00FF00;
              v142 = result | v137 & 0xFF00FF | (15 * v140) | (240 * v140);
              if (v141 >= 0xFF)
                LOBYTE(v141) = -1;
              *v30 = v141;
              *v35 = v142;
            }
            ++v37;
            ++v35;
            v30 += v31;
            --v136;
          }
          while (v136);
          v37 += v38;
          v35 += v255;
          v30 += v29;
          --v261;
        }
        while (v261);
      }
      else
      {
        do
        {
          v143 = v258;
          do
          {
            if (*(_BYTE *)v37)
            {
              v144 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
              v145 = ((v144 >> 8) & 0xFF00FF) + ((*v35 >> 8) & 0xFF00FF);
              *v35 = (v145 << 8) & 0xFF00FF00 | ((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) & 0xFF00FF | (15 * (v145 & 0x1000100 | ((unint64_t)((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v145 & 0x1000100 | ((unint64_t)((v144 & 0xFF00FF) + (*v35 & 0xFF00FF)) >> 8) & 0x10001));
            }
            ++v37;
            ++v35;
            --v143;
          }
          while (v143);
          v37 += v38;
          v35 += v255;
          --v261;
        }
        while (v261);
      }
      return result;
    case 13:
      do
      {
        v53 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v54 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v54))
            {
              v55 = HIDWORD(v54);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAmultiplyPDA_5206(*v35, *v30, v54, BYTE4(v54));
                  LODWORD(v54) = result;
                  v55 = HIDWORD(result);
                }
                *v35 = v54;
                *v30 = v55;
              }
              else
              {
                result = PDAmultiplyPDA_5206(*v35, 255, v54, BYTE4(v54));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v53;
        }
        while (v53);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 14:
      do
      {
        v56 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v57 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v57))
            {
              v58 = HIDWORD(v57);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAscreenPDA_5207(*v35, *v30, v57, BYTE4(v57));
                  LODWORD(v57) = result;
                  v58 = HIDWORD(result);
                }
                *v35 = v57;
                *v30 = v58;
              }
              else
              {
                result = PDAscreenPDA_5207(*v35, 0xFFu, v57, BYTE4(v57));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v56;
        }
        while (v56);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 15:
      do
      {
        v59 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v60 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v60))
            {
              v61 = HIDWORD(v60);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAoverlayPDA_5208(*v35, *v30, v60, BYTE4(v60));
                  LODWORD(v60) = result;
                  v61 = HIDWORD(result);
                }
                *v35 = v60;
                *v30 = v61;
              }
              else
              {
                result = PDAoverlayPDA_5208(*v35, 255, v60, BYTE4(v60));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v59;
        }
        while (v59);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 16:
      do
      {
        v62 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v63 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v63))
            {
              v64 = HIDWORD(v63);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAdarkenPDA_5210(*v35, *v30, v63, BYTE4(v63), v12, v13, v14, v15, v16, v17);
                  LODWORD(v63) = result;
                  v64 = HIDWORD(result);
                }
                *v35 = v63;
                *v30 = v64;
              }
              else
              {
                result = PDAdarkenPDA_5210(*v35, 0xFFu, v63, BYTE4(v63), v12, v13, v14, v15, v16, v17);
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v62;
        }
        while (v62);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 17:
      do
      {
        v65 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v66 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v66))
            {
              v67 = HIDWORD(v66);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAlightenPDA_5209(*v35, *v30, v66, BYTE4(v66), v12, v13, v14, v15, v16, v17);
                  LODWORD(v66) = result;
                  v67 = HIDWORD(result);
                }
                *v35 = v66;
                *v30 = v67;
              }
              else
              {
                result = PDAlightenPDA_5209(*v35, 0xFFu, v66, BYTE4(v66), v12, v13, v14, v15, v16, v17);
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v65;
        }
        while (v65);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 18:
      do
      {
        v68 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v69 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v69))
            {
              v70 = HIDWORD(v69);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAcolordodgePDA_5211(*v35, *v30, v69, BYTE4(v69));
                  LODWORD(v69) = result;
                  v70 = HIDWORD(result);
                }
                *v35 = v69;
                *v30 = v70;
              }
              else
              {
                result = PDAcolordodgePDA_5211(*v35, 255, v69, BYTE4(v69));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v68;
        }
        while (v68);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 19:
      do
      {
        v71 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v72 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v72))
            {
              v73 = HIDWORD(v72);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAcolorburnPDA_5212(*v35, *v30, v72, BYTE4(v72));
                  LODWORD(v72) = result;
                  v73 = HIDWORD(result);
                }
                *v35 = v72;
                *v30 = v73;
              }
              else
              {
                result = PDAcolorburnPDA_5212(*v35, 255, v72, BYTE4(v72));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v71;
        }
        while (v71);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 20:
      do
      {
        v74 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v75 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v75))
            {
              v76 = HIDWORD(v75);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAsoftlightPDA_5214(*v35, *v30, v75, BYTE4(v75));
                  LODWORD(v75) = result;
                  v76 = HIDWORD(result);
                }
                *v35 = v75;
                *v30 = v76;
              }
              else
              {
                result = PDAsoftlightPDA_5214(*v35, 255, v75, BYTE4(v75));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v74;
        }
        while (v74);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 21:
      do
      {
        v77 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v78 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v78))
            {
              v79 = HIDWORD(v78);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAhardlightPDA_5213(*v35, *v30, v78, BYTE4(v78));
                  LODWORD(v78) = result;
                  v79 = HIDWORD(result);
                }
                *v35 = v78;
                *v30 = v79;
              }
              else
              {
                result = PDAhardlightPDA_5213(*v35, 255, v78, BYTE4(v78));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v77;
        }
        while (v77);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 22:
      do
      {
        v80 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v81 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v81))
            {
              v82 = HIDWORD(v81);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAdifferencePDA_5215(*v35, *v30, v81, BYTE4(v81));
                  LODWORD(v81) = result;
                  v82 = HIDWORD(result);
                }
                *v35 = v81;
                *v30 = v82;
              }
              else
              {
                result = PDAdifferencePDA_5215(*v35, 0xFFu, v81, BYTE4(v81));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v80;
        }
        while (v80);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 23:
      do
      {
        v83 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v84 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v84))
            {
              v85 = HIDWORD(v84);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAexclusionPDA_5216(*v35, *v30, v84, BYTE4(v84));
                  LODWORD(v84) = result;
                  v85 = HIDWORD(result);
                }
                *v35 = v84;
                *v30 = v85;
              }
              else
              {
                result = PDAexclusionPDA_5216(*v35, 255, v84, BYTE4(v84));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v83;
        }
        while (v83);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 24:
      do
      {
        v86 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v87 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v87))
            {
              v88 = HIDWORD(v87);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAhuePDA_5217(*v35, *v30, v87, BYTE4(v87));
                  LODWORD(v87) = result;
                  v88 = HIDWORD(result);
                }
                *v35 = v87;
                *v30 = v88;
              }
              else
              {
                result = PDAhuePDA_5217(*v35, 255, v87, BYTE4(v87));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v86;
        }
        while (v86);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 25:
      do
      {
        v89 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v90 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v90))
            {
              v91 = HIDWORD(v90);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAsaturationPDA_5218(*v35, *v30, v90, BYTE4(v90));
                  LODWORD(v90) = result;
                  v91 = HIDWORD(result);
                }
                *v35 = v90;
                *v30 = v91;
              }
              else
              {
                result = PDAsaturationPDA_5218(*v35, 255, v90, BYTE4(v90));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v89;
        }
        while (v89);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 26:
      do
      {
        v92 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            result = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(result))
            {
              v93 = HIDWORD(result);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAluminosityPDA_5219(result, BYTE4(result), *v35, *v30);
                  v93 = HIDWORD(result);
                }
                *v35 = result;
                *v30 = v93;
              }
              else
              {
                result = PDAluminosityPDA_5219(result, BYTE4(result), *v35, 255);
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v92;
        }
        while (v92);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 27:
      do
      {
        v94 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v95 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v95))
            {
              v96 = HIDWORD(v95);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAluminosityPDA_5219(*v35, *v30, v95, BYTE4(v95));
                  LODWORD(v95) = result;
                  v96 = HIDWORD(result);
                }
                *v35 = v95;
                *v30 = v96;
              }
              else
              {
                result = PDAluminosityPDA_5219(*v35, 255, v95, BYTE4(v95));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v94;
        }
        while (v94);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 28:
      do
      {
        v97 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v98 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v98))
            {
              v99 = HIDWORD(v98);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAtranspose_huePDA(*v35, *v30, v98, BYTE4(v98));
                  LODWORD(v98) = result;
                  v99 = HIDWORD(result);
                }
                *v35 = v98;
                *v30 = v99;
              }
              else
              {
                result = PDAtranspose_huePDA(*v35, 255, v98, BYTE4(v98));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v97;
        }
        while (v97);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 29:
      do
      {
        v100 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v101 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v101))
            {
              v102 = HIDWORD(v101);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAtranspose_saturationPDA(*v35, *v30, v101, BYTE4(v101));
                  LODWORD(v101) = result;
                  v102 = HIDWORD(result);
                }
                *v35 = v101;
                *v30 = v102;
              }
              else
              {
                result = PDAtranspose_saturationPDA(*v35, 255, v101, BYTE4(v101));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v100;
        }
        while (v100);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 30:
      do
      {
        v103 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            result = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(result))
            {
              v104 = HIDWORD(result);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v35, *v30);
                  v104 = HIDWORD(result);
                }
                *v35 = result;
                *v30 = v104;
              }
              else
              {
                result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v35, 255);
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v103;
        }
        while (v103);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    case 31:
      do
      {
        v105 = v258;
        do
        {
          if (*(_BYTE *)v37)
          {
            v106 = *(_QWORD *)(v33 + 8 * *(unsigned __int8 *)v37);
            if (BYTE4(v106))
            {
              v107 = HIDWORD(v106);
              if (v4)
              {
                if (*v30)
                {
                  result = PDAtranspose_luminosityPDA(*v35, *v30, v106, BYTE4(v106));
                  LODWORD(v106) = result;
                  v107 = HIDWORD(result);
                }
                *v35 = v106;
                *v30 = v107;
              }
              else
              {
                result = PDAtranspose_luminosityPDA(*v35, 255, v106, BYTE4(v106));
                *v35 = result;
              }
            }
          }
          ++v37;
          ++v35;
          v30 += v31;
          --v105;
        }
        while (v105);
        v37 += v38;
        v35 += v255;
        v30 += v251;
        --v261;
      }
      while (v261);
      return result;
    default:
      return result;
  }
}

unint64_t cmyk32_mark_pixelmask(unint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int8 *v7;
  int v8;
  int v9;
  int v10;
  unsigned int *v11;
  _BYTE *v12;
  unint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  int v20;
  int v21;
  unsigned int *v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int *v25;
  int v26;
  int v27;
  uint64_t v28;
  unsigned int *v29;
  uint64_t v30;
  int v31;
  int v32;
  int v33;
  unint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int *v41;
  uint64_t v42;
  unsigned int *v43;
  _BYTE *v44;
  BOOL v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  int v53;
  int v54;
  int v55;
  unsigned int v56;
  int v57;
  int v58;
  unsigned int *v59;
  _BYTE *v60;
  unsigned int *v61;
  uint64_t v62;
  unsigned int *v63;
  _BYTE *v64;
  BOOL v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  int v75;
  unsigned int *v76;
  uint64_t v77;
  unsigned int *v78;
  _BYTE *v79;
  BOOL v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int v87;
  int v88;
  int v89;
  int v90;
  unsigned int *v91;
  uint64_t v92;
  unsigned int *v93;
  _BYTE *v94;
  BOOL v95;
  uint64_t v96;
  unint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  int v102;
  int v103;
  unint64_t v104;
  unsigned int *v105;
  uint64_t v106;
  unsigned int *v107;
  _BYTE *v108;
  BOOL v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  int v117;
  int v118;
  int v119;
  int v120;
  unsigned int *v121;
  uint64_t v122;
  unsigned int *v123;
  _BYTE *v124;
  BOOL v125;
  uint64_t v126;
  unint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  int v132;
  int v133;
  unsigned int *v134;
  uint64_t v135;
  unsigned int *v136;
  _BYTE *v137;
  BOOL v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  int v145;
  int v146;
  int v147;
  unsigned int *v148;
  uint64_t v149;
  unsigned int *v150;
  _BYTE *v151;
  BOOL v152;
  uint64_t v153;
  unint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  int v158;
  char v159;
  int v160;
  unint64_t v161;
  unsigned int *v162;
  uint64_t v163;
  unsigned int *v164;
  _BYTE *v165;
  BOOL v166;
  uint64_t v167;
  unint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  int v173;
  int v174;
  unint64_t v175;
  unsigned int *v176;
  uint64_t v177;
  unsigned int *v178;
  _BYTE *v179;
  BOOL v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  int v186;
  int v187;
  unint64_t v188;
  unsigned int *v189;
  uint64_t v190;
  unsigned int *v191;
  _BYTE *v192;
  BOOL v193;
  uint64_t v194;
  unint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  int v199;
  int v200;
  unsigned int v201;
  unsigned int v202;
  unsigned int v203;
  unsigned int *v204;
  uint64_t v205;
  unsigned int *v206;
  _BYTE *v207;
  BOOL v208;
  uint64_t v209;
  unint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  int v215;
  int v216;
  unsigned int v217;
  unint64_t v218;
  unsigned int *v219;
  uint64_t v220;
  unsigned int *v221;
  _BYTE *v222;
  BOOL v223;
  uint64_t v224;
  unint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  int v230;
  int v231;
  unsigned int v232;
  unint64_t v233;
  unsigned int *v234;
  uint64_t v235;
  unsigned int *v236;
  _BYTE *v237;
  BOOL v238;
  uint64_t v239;
  unint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  int v245;
  int v246;
  unsigned int v247;
  unint64_t v248;
  unsigned int *v249;
  uint64_t v250;
  unsigned int *v251;
  _BYTE *v252;
  BOOL v253;
  uint64_t v254;
  unint64_t v255;
  uint64_t v256;
  uint64_t v257;
  uint64_t v258;
  uint64_t v259;
  int v260;
  int v261;
  double v262;
  int8x16_t v263;
  double v264;
  double v265;
  double v266;
  int8x16_t v267;
  unsigned int v268;
  unint64_t v269;
  unsigned int *v270;
  uint64_t v271;
  unsigned int *v272;
  _BYTE *v273;
  BOOL v274;
  uint64_t v275;
  unint64_t v276;
  uint64_t v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t v280;
  int v281;
  int v282;
  double v283;
  int8x16_t v284;
  double v285;
  double v286;
  double v287;
  int8x16_t v288;
  unsigned int v289;
  unint64_t v290;
  unsigned int *v291;
  uint64_t v292;
  unsigned int *v293;
  _BYTE *v294;
  BOOL v295;
  uint64_t v296;
  unint64_t v297;
  uint64_t v298;
  uint64_t v299;
  uint64_t v300;
  uint64_t v301;
  int v302;
  int v303;
  unsigned int v304;
  unint64_t v305;
  unsigned int *v306;
  uint64_t v307;
  unsigned int *v308;
  _BYTE *v309;
  BOOL v310;
  uint64_t v311;
  unint64_t v312;
  uint64_t v313;
  uint64_t v314;
  uint64_t v315;
  uint64_t v316;
  int v317;
  int v318;
  unsigned int v319;
  unint64_t v320;
  unsigned int *v321;
  uint64_t v322;
  unsigned int *v323;
  _BYTE *v324;
  BOOL v325;
  uint64_t v326;
  unint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  int v332;
  int v333;
  unsigned int v334;
  unint64_t v335;
  unsigned int *v336;
  uint64_t v337;
  unsigned int *v338;
  _BYTE *v339;
  BOOL v340;
  uint64_t v341;
  unint64_t v342;
  uint64_t v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  int v347;
  int v348;
  unsigned int v349;
  unint64_t v350;
  unsigned int *v351;
  uint64_t v352;
  unsigned int *v353;
  _BYTE *v354;
  BOOL v355;
  uint64_t v356;
  unint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  int v362;
  int v363;
  unsigned int v364;
  unint64_t v365;
  unsigned int *v366;
  uint64_t v367;
  unsigned int *v368;
  _BYTE *v369;
  BOOL v370;
  uint64_t v371;
  unint64_t v372;
  uint64_t v373;
  uint64_t v374;
  uint64_t v375;
  uint64_t v376;
  int v377;
  int v378;
  unsigned int v379;
  unint64_t v380;
  unsigned int *v381;
  uint64_t v382;
  unsigned int *v383;
  _BYTE *v384;
  BOOL v385;
  uint64_t v386;
  unint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  int v392;
  int v393;
  unsigned int v394;
  unint64_t v395;
  unsigned int *v396;
  uint64_t v397;
  unsigned int *v398;
  _BYTE *v399;
  BOOL v400;
  uint64_t v401;
  unint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  int v407;
  int v408;
  unsigned int v409;
  unint64_t v410;
  unsigned int *v411;
  uint64_t v412;
  unsigned int *v413;
  _BYTE *v414;
  BOOL v415;
  uint64_t v416;
  unint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  uint64_t v421;
  int v422;
  int v423;
  unint64_t v424;
  unsigned int *v425;
  uint64_t v426;
  unsigned int *v427;
  _BYTE *v428;
  BOOL v429;
  uint64_t v430;
  unint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  uint64_t v435;
  int v436;
  int v437;
  unsigned int v438;
  unint64_t v439;
  unsigned int *v440;
  uint64_t v441;
  unsigned int *v442;
  _BYTE *v443;
  BOOL v444;
  uint64_t v445;
  unint64_t v446;
  uint64_t v447;
  uint64_t v448;
  uint64_t v449;
  uint64_t v450;
  int v451;
  int v452;
  unsigned int v453;
  unint64_t v454;
  unsigned int *v455;
  uint64_t v456;
  unsigned int *v457;
  _BYTE *v458;
  BOOL v459;
  uint64_t v460;
  unint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  int v466;
  int v467;
  unsigned int v468;
  unint64_t v469;
  unsigned int *v470;
  uint64_t v471;
  unsigned int *v472;
  _BYTE *v473;
  BOOL v474;
  uint64_t v475;
  unint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  int v481;
  int v482;
  unint64_t v483;
  unsigned int *v484;
  uint64_t v485;
  unsigned int *v486;
  _BYTE *v487;
  BOOL v488;
  uint64_t v489;
  unint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  int v495;
  int v496;
  unsigned int v497;
  unint64_t v498;
  unsigned int *v499;
  uint64_t v500;
  unsigned int *v501;
  _BYTE *v502;
  BOOL v503;
  uint64_t v504;
  unint64_t v505;
  uint64_t v506;
  int v507;
  int v508;
  int v509;
  unsigned int v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  int v515;
  int v516;
  int v517;
  unsigned int *v518;
  uint64_t v519;
  unsigned int *v520;
  unsigned int *v521;
  uint64_t v522;
  unsigned int *v523;
  unint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  int v528;
  int v529;
  int v530;
  unsigned int v531;
  int v532;
  unsigned int v533;
  unsigned int v534;
  unsigned int v535;
  int v536;
  unsigned int v537;
  unsigned int *v538;
  uint64_t v539;
  unsigned int *v540;
  _BYTE *v541;
  BOOL v542;
  uint64_t v543;
  unint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  int v548;
  int v549;
  int v550;
  unsigned int *v551;
  uint64_t v552;
  unsigned int *v553;
  _BYTE *v554;
  BOOL v555;
  uint64_t v556;
  unint64_t v557;
  uint64_t v558;
  uint64_t v559;
  uint64_t v560;
  unint64_t v561;
  _BYTE *v562;
  uint64_t v563;
  int v564;
  int v565;
  int v566;
  int v567;
  unsigned int v568;
  unsigned int v569;
  unsigned int *v570;
  uint64_t v571;
  unsigned int *v572;
  _BYTE *v573;
  BOOL v574;
  uint64_t v575;
  unint64_t v576;
  uint64_t v577;
  _BYTE *v578;
  int v579;
  int v580;
  unint64_t v581;
  unsigned int *v582;
  uint64_t v583;
  unsigned int *v584;
  _BYTE *v585;
  BOOL v586;
  uint64_t v587;
  unint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  int v592;
  int v593;
  int v594;
  unsigned int v595;
  unsigned int v596;
  unsigned int *v597;
  uint64_t v598;
  unsigned int *v599;
  unsigned int *v600;
  uint64_t v601;
  unsigned int *v602;
  unint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  int v607;
  int v608;
  unsigned int *v609;
  uint64_t v610;
  unsigned int *v611;
  unsigned int *v612;
  uint64_t v613;
  unsigned int *v614;
  unint64_t v615;
  uint64_t v616;
  uint64_t v617;
  uint64_t v618;
  uint64_t v619;
  uint64_t v620;
  uint64_t v621;
  uint64_t v622;
  uint64_t v623;
  uint64_t v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t v630;
  uint64_t v631;
  uint64_t v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  uint64_t v653;
  uint64_t v654;
  uint64_t v655;
  uint64_t v656;
  uint64_t v657;
  uint64_t v658;
  uint64_t v659;
  uint64_t v660;
  uint64_t v661;
  uint64_t v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  _BYTE *v673;
  uint64_t v674;
  uint64_t v675;
  _BYTE *v676;
  _BYTE *v677;
  _BYTE *v678;
  _BYTE *v679;
  _BYTE *v680;
  _BYTE *v681;
  _BYTE *v682;
  _BYTE *v683;
  _BYTE *v684;
  _BYTE *v685;
  _BYTE *v686;
  _BYTE *v687;
  _BYTE *v688;
  _BYTE *v689;
  _BYTE *v690;
  _BYTE *v691;
  _BYTE *v692;
  _BYTE *v693;
  _BYTE *v694;
  _BYTE *v695;
  uint64_t v696;
  unint64_t v697;
  uint64_t v698;
  uint64_t v699;
  _BYTE *v700;
  _BYTE *v701;
  _BYTE *v702;
  _BYTE *v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  _BYTE *v707;
  _BYTE *v708;
  uint64_t v709;
  uint64_t v710;
  uint64_t v711;
  unint64_t v712;
  uint64_t v713;
  uint64_t v714;
  int v715;
  unint64_t v716;
  unsigned int *v717;
  int v718;
  int v719;
  int v720;
  int v721;
  int v722;
  int v723;
  int v724;
  int v725;
  int v726;
  int v727;
  int v728;
  int v729;
  int v730;
  int v731;
  uint64_t v732;
  uint64_t v733;
  uint64_t v734;
  int v735;
  _BYTE *v736;
  _BYTE *v737;
  int v738;
  _BYTE *v739;
  _BYTE *v740;
  int v741;
  int v742;
  _BYTE *v743;
  _BYTE *v744;
  unint64_t v745;

  v2 = *(_QWORD *)(result + 48);
  v3 = *(_QWORD *)(result + 136);
  v5 = *(int *)(result + 12);
  v4 = *(int *)(result + 16);
  if (v2)
  {
    v6 = *(int *)(result + 32);
    v7 = (unsigned __int8 *)(v2 + v5 + (int)v6 * (uint64_t)(int)v4);
    v8 = -1;
    if (!v3)
      return result;
  }
  else
  {
    v7 = 0;
    v6 = 0;
    v8 = 0;
    if (!v3)
      return result;
  }
  v9 = *(_DWORD *)(result + 4);
  v10 = *(_DWORD *)(result + 8);
  v11 = *(unsigned int **)(result + 88);
  v12 = *(_BYTE **)(result + 96);
  v13 = (unint64_t)*(int *)(result + 28) >> 2;
  v14 = (unsigned int *)(*(_QWORD *)(result + 40) + 4 * (v5 + v13 * v4));
  v15 = *(int *)(result + 124);
  v16 = (char *)(v3 + *(int *)(result + 104) + *(int *)(result + 108) * (uint64_t)(int)v15);
  v17 = *(int *)(result + 56);
  v18 = *(int *)(result + 60);
  v716 = (unint64_t)*(int *)(result + 76) >> 2;
  if ((*(_DWORD *)result & 0xFF00) != 0x100)
  {
    v20 = *(_DWORD *)(result + 64);
    v21 = *(_DWORD *)(result + 68);
    if (v12)
    {
      v714 = *(int *)(result + 80);
      v19 = 1;
    }
    else
    {
      v714 = 0;
      v19 = 0;
    }
    result = (unint64_t)&v11[v716 * v21];
    v8 &= 1u;
    v26 = 1;
    v745 = (unint64_t)v11;
    v22 = v11;
    goto LABEL_19;
  }
  if (v12)
  {
    v714 = *(int *)(result + 80);
    v12 += v17 + (int)v714 * (uint64_t)(int)v18;
    v19 = -1;
  }
  else
  {
    v714 = 0;
    v19 = 0;
  }
  v22 = &v11[v17 + v716 * v18];
  if (v716 == v13 && (char *)v14 - (char *)v22 >= 1)
  {
    if (v9 >= (uint64_t)((unint64_t)((char *)v14 - (char *)v22) >> 2))
    {
      v14 += v9 - 1;
      v22 += v9 - 1;
      v16 += v9 - 1;
      v7 += v8 & (v9 - 1);
      v26 = -1;
      v716 = (unint64_t)*(int *)(result + 28) >> 2;
      v12 += v19 & (v9 - 1);
      goto LABEL_16;
    }
    v23 = v10 - 1;
    v24 = v13 * v23;
    v25 = &v22[v13 * v23];
    if (v14 <= &v25[v9 - 1])
    {
      v13 = -(uint64_t)v13;
      v16 += v15 * v23;
      v15 = -v15;
      v7 += v6 * v23;
      v6 = -v6;
      v8 &= 1u;
      v12 += v714 * v23;
      v714 = -v714;
      v19 &= 1u;
      v26 = 1;
      v22 = v25;
      v716 = v13;
      v14 += v24;
      goto LABEL_16;
    }
  }
  v8 &= 1u;
  v19 &= 1u;
  v26 = 1;
LABEL_16:
  v11 = 0;
  result = 0;
  v745 = -1;
  v21 = v714;
  v20 = v716;
LABEL_19:
  v718 = v10;
  v719 = v8;
  v27 = v26 * v9;
  v715 = v9;
  v697 = result;
  v735 = v19;
  if (result)
  {
    v28 = (int)v18 % v21;
    v29 = &v22[v716 * v28];
    result = (int)v17 % v20;
    v22 = &v29[result];
    v745 = (unint64_t)&v29[v20];
    if ((v19 & 1) != 0)
      v12 += v714 * v28 + result;
    v717 = &v29[result];
  }
  else
  {
    v716 -= v27;
    v717 = v11;
    v714 -= v19 * v9;
  }
  v713 = v15 - v27;
  v712 = v13 - v27;
  v696 = v6 - v8 * v9;
  switch(a2)
  {
    case 0:
      v30 = v26;
      if (v8)
      {
        do
        {
          v31 = v715;
          v32 = v718;
          do
          {
            v33 = *v16;
            if (*v16)
            {
              if (v33 == 255)
              {
                LOBYTE(v34) = 0;
                *v14 = 0;
              }
              else
              {
                result = PDAM_5205(*v14, *v7, v33 ^ 0xFFu);
                *v14 = result;
                v34 = HIDWORD(result);
              }
              *v7 = v34;
            }
            v16 += v30;
            v7 += v719;
            v14 += v30;
            --v31;
          }
          while (v31);
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v32 != 1);
      }
      else
      {
        do
        {
          v507 = v9;
          v508 = v718;
          do
          {
            v509 = *v16;
            if (*v16)
            {
              if (v509 == 255)
                v510 = 0;
              else
                v510 = (((*v14 & 0xFF00FF) * (v509 ^ 0xFF)
                       + 65537
                       + ((((*v14 & 0xFF00FF) * (v509 ^ 0xFF)) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v14 >> 8) & 0xFF00FF) * (v509 ^ 0xFF) + 65537 + (((((*v14 >> 8) & 0xFF00FF) * (v509 ^ 0xFF)) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              *v14 = v510;
            }
            v16 += v26;
            v14 += v26;
            --v507;
          }
          while (v507);
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v508 != 1);
      }
      return result;
    case 1:
      if (v8)
      {
        v35 = v26;
        v36 = v8;
        v720 = v8;
        if (v19)
        {
          v37 = v19;
          v38 = -(uint64_t)v20;
          v698 = -(uint64_t)(v716 * v21);
          v665 = -(v714 * v21);
          v736 = v12;
          do
          {
            v39 = v715;
            do
            {
              v40 = *v16;
              if (*v16)
              {
                if (v40 == 255)
                {
                  *v14 = *v22;
                  *v7 = *v12;
                }
                else
                {
                  result = (unint64_t)DAMplusDAM(v14, v7, *v22, *v12, v40, *v14, *v7, v40 ^ 0xFFu);
                  v36 = v720;
                }
              }
              v16 += v35;
              v7 += v36;
              v41 = &v22[v35];
              if ((unint64_t)v41 >= v745)
                v42 = v38;
              else
                v42 = 0;
              v12 += v37 + v42;
              v22 = &v41[v42];
              v14 += v35;
              --v39;
            }
            while (v39);
            if (v697)
            {
              v43 = &v717[v716];
              v44 = &v736[v714];
              v45 = (unint64_t)v43 >= v697;
              v46 = v698;
              if ((unint64_t)v43 < v697)
                v46 = 0;
              v22 = &v43[v46];
              v47 = v745 + 4 * v46;
              v48 = v665;
              if (!v45)
                v48 = 0;
              v12 = &v44[v48];
              v736 = &v44[v48];
              v745 = v47 + 4 * v716;
              v717 = v22;
            }
            else
            {
              v22 += v716;
              v12 += v714;
            }
            v16 += v713;
            v14 += v712;
            v7 += v696;
            --v718;
          }
          while (v718);
        }
        else
        {
          v605 = -(uint64_t)v20;
          v606 = -(uint64_t)(v716 * v21);
          do
          {
            v607 = v715;
            do
            {
              v608 = *v16;
              if (*v16)
              {
                if (v608 == 255)
                {
                  *v14 = *v22;
                  *v7 = -1;
                }
                else
                {
                  result = (unint64_t)DAMplusDAM(v14, v7, *v22, 255, v608, *v14, *v7, v608 ^ 0xFFu);
                  v36 = v720;
                }
              }
              v16 += v35;
              v7 += v36;
              v609 = &v22[v35];
              if ((unint64_t)v609 >= v745)
                v610 = v605;
              else
                v610 = 0;
              v22 = &v609[v610];
              v14 += v35;
              --v607;
            }
            while (v607);
            v16 += v713;
            v14 += v712;
            v7 += v696;
            v611 = v717;
            v612 = &v717[v716];
            if ((unint64_t)v612 >= v697)
              v613 = v606;
            else
              v613 = 0;
            v614 = &v612[v613];
            v615 = v745;
            v616 = v745 + 4 * v613 + 4 * v716;
            if (v697)
              v611 = v614;
            v717 = v611;
            if (v697)
              v615 = v616;
            v745 = v615;
            if (v697)
              v22 = v614;
            else
              v22 += v716;
            --v718;
          }
          while (v718);
        }
      }
      else
      {
        v511 = v26;
        v512 = -(uint64_t)v20;
        v513 = -(uint64_t)(v716 * v21);
        v514 = 4 * v26;
        do
        {
          v515 = v715;
          v516 = v718;
          do
          {
            v517 = *v16;
            if (*v16)
            {
              if (v517 == 255)
                *v14 = *v22;
              else
                result = (unint64_t)DMplusDM(v14, *v22, v517, *v14, v517 ^ 0xFFu);
            }
            v16 += v511;
            v518 = &v22[v511];
            if ((unint64_t)v518 >= v745)
              v519 = v512;
            else
              v519 = 0;
            v22 = &v518[v519];
            v14 = (unsigned int *)((char *)v14 + v514);
            --v515;
          }
          while (v515);
          v16 += v713;
          v14 += v712;
          v520 = v717;
          v521 = &v717[v716];
          if ((unint64_t)v521 >= v697)
            v522 = v513;
          else
            v522 = 0;
          v523 = &v521[v522];
          v524 = v745;
          v525 = v745 + 4 * v522 + 4 * v716;
          if (v697)
            v520 = v523;
          v717 = v520;
          if (v697)
            v524 = v525;
          v745 = v524;
          if (v697)
            v22 = v523;
          else
            v22 += v716;
          --v718;
        }
        while (v516 != 1);
      }
      return result;
    case 2:
      v49 = v26;
      if (v8)
      {
        v721 = v8;
        v50 = v19;
        v699 = -(uint64_t)(v716 * v21);
        v666 = -(v714 * v21);
        v737 = v12;
        v51 = -(uint64_t)v20;
        while (1)
        {
          v52 = v715;
          do
          {
            v53 = *v16;
            if (!*v16)
              goto LABEL_70;
            if (v53 == 255)
            {
              v54 = *v12;
              if (!*v12)
                goto LABEL_70;
              if (v54 == 255)
              {
                *v14 = *v22;
                *v7 = -1;
                goto LABEL_70;
              }
              v55 = *v22;
              v56 = *v14;
              v57 = *v7;
              v58 = v54 ^ 0xFF;
              v59 = v14;
              v60 = v7;
            }
            else
            {
              result = PDAM_5205(*v22, *v12, v53);
              if (!BYTE4(result))
                goto LABEL_70;
              v55 = result;
              v56 = *v14;
              v57 = *v7;
              v58 = ~BYTE4(result);
              LOBYTE(v54) = BYTE4(result);
              v59 = v14;
              v60 = v7;
            }
            result = (unint64_t)DAplusDAM(v59, v60, v55, v54, v56, v57, v58);
LABEL_70:
            v16 += v49;
            v7 += v721;
            v61 = &v22[v49];
            if ((unint64_t)v61 >= v745)
              v62 = v51;
            else
              v62 = 0;
            v12 += v50 + v62;
            v22 = &v61[v62];
            v14 += v49;
            --v52;
          }
          while (v52);
          if (v697)
          {
            v63 = &v717[v716];
            v64 = &v737[v714];
            v65 = (unint64_t)v63 >= v697;
            v66 = v699;
            if ((unint64_t)v63 < v697)
              v66 = 0;
            v22 = &v63[v66];
            v67 = v745 + 4 * v66;
            v68 = v666;
            if (!v65)
              v68 = 0;
            v12 = &v64[v68];
            v737 = &v64[v68];
            v745 = v67 + 4 * v716;
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          if (!--v718)
            return result;
        }
      }
      v526 = v19;
      v732 = -(uint64_t)(v716 * v21);
      v709 = -(v714 * v21);
      v743 = v12;
      v527 = -(uint64_t)v20;
      break;
    case 3:
      v69 = v26;
      v722 = v8;
      v667 = -(uint64_t)(v716 * v21);
      v638 = -(v714 * v21);
      v70 = 4 * v26;
      v700 = v12;
      v71 = -(uint64_t)v20;
      do
      {
        v72 = v715;
        do
        {
          v73 = *v16;
          if (*v16)
          {
            if (v73 == 255)
            {
              if (v735)
                v74 = *v12;
              else
                v74 = 255;
              result = PDAM_5205(*v22, v74, *v7);
              *v14 = result;
              *v7 = BYTE4(result);
            }
            else
            {
              if (v735)
                v75 = *v12;
              else
                v75 = 255;
              result = (unint64_t)DAMplusDAM(v14, v7, *v22, v75, ((unsigned __int16)(*v7 * (_WORD)v73+ ((*v7 * v73) >> 8)+ 1) >> 8), *v14, *v7, v73 ^ 0xFFu);
            }
          }
          v16 += v69;
          v7 += v722;
          v76 = &v22[v69];
          if ((unint64_t)v76 >= v745)
            v77 = v71;
          else
            v77 = 0;
          v12 += v735 + v77;
          v22 = &v76[v77];
          v14 = (unsigned int *)((char *)v14 + v70);
          --v72;
        }
        while (v72);
        if (v697)
        {
          v78 = &v717[v716];
          v79 = &v700[v714];
          v80 = (unint64_t)v78 >= v697;
          v81 = v667;
          if ((unint64_t)v78 < v697)
            v81 = 0;
          v22 = &v78[v81];
          v82 = v745 + 4 * v81;
          v83 = v638;
          if (!v80)
            v83 = 0;
          v12 = &v79[v83];
          v745 = v82 + 4 * v716;
          v700 = &v79[v83];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 4:
      v84 = v26;
      v723 = v8;
      v668 = -(uint64_t)(v716 * v21);
      v639 = -(v714 * v21);
      v85 = 4 * v26;
      v701 = v12;
      v86 = -(uint64_t)v20;
      do
      {
        v87 = v715;
        do
        {
          v88 = *v16;
          if (*v16)
          {
            if (v88 == 255)
            {
              if (v735)
                v89 = *v12;
              else
                v89 = 255;
              result = PDAM_5205(*v22, v89, *v7 ^ 0xFFu);
              *v14 = result;
              *v7 = BYTE4(result);
            }
            else
            {
              if (v735)
                v90 = *v12;
              else
                v90 = 255;
              result = (unint64_t)DAMplusDAM(v14, v7, *v22, v90, ((unsigned __int16)((*v7 ^ 0xFF) * v88+ (((*v7 ^ 0xFFu) * v88) >> 8)+ 1) >> 8), *v14, *v7, v88 ^ 0xFFu);
            }
          }
          v16 += v84;
          v7 += v723;
          v91 = &v22[v84];
          if ((unint64_t)v91 >= v745)
            v92 = v86;
          else
            v92 = 0;
          v12 += v735 + v92;
          v22 = &v91[v92];
          v14 = (unsigned int *)((char *)v14 + v85);
          --v87;
        }
        while (v87);
        if (v697)
        {
          v93 = &v717[v716];
          v94 = &v701[v714];
          v95 = (unint64_t)v93 >= v697;
          v96 = v668;
          if ((unint64_t)v93 < v697)
            v96 = 0;
          v22 = &v93[v96];
          v97 = v745 + 4 * v96;
          v98 = v639;
          if (!v95)
            v98 = 0;
          v12 = &v94[v98];
          v745 = v97 + 4 * v716;
          v701 = &v94[v98];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 5:
      v99 = v26;
      v724 = v8;
      v738 = v19;
      v100 = -(uint64_t)v20;
      v640 = -(v714 * v21);
      v669 = -(uint64_t)(v716 * v21);
      v101 = 4 * v26;
      v702 = v12;
      do
      {
        v102 = v715;
        do
        {
          if (*v16)
          {
            v103 = *v7;
            v104 = PDAM_5205(*v22, *v12, *v16);
            result = (unint64_t)DAMplusDAM(v14, v7, v104, BYTE4(v104), v103, *v14, v103, ~BYTE4(v104));
          }
          v16 += v99;
          v7 += v724;
          v105 = &v22[v99];
          if ((unint64_t)v105 >= v745)
            v106 = v100;
          else
            v106 = 0;
          v12 += v738 + v106;
          v22 = &v105[v106];
          v14 = (unsigned int *)((char *)v14 + v101);
          --v102;
        }
        while (v102);
        if (v697)
        {
          v107 = &v717[v716];
          v108 = &v702[v714];
          v109 = (unint64_t)v107 >= v697;
          v110 = v669;
          if ((unint64_t)v107 < v697)
            v110 = 0;
          v22 = &v107[v110];
          v111 = v745 + 4 * v110;
          v112 = v640;
          if (!v109)
            v112 = 0;
          v12 = &v108[v112];
          v745 = v111 + 4 * v716;
          v702 = &v108[v112];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 6:
      v113 = v26;
      v114 = v8;
      v115 = -(uint64_t)v20;
      v641 = -(v714 * v21);
      v670 = -(uint64_t)(v716 * v21);
      v116 = 4 * v26;
      v703 = v12;
      v725 = v8;
      do
      {
        v117 = v715;
        do
        {
          v118 = *v16;
          if (*v16 && *v7 != 0xFF)
          {
            if (~*v7 == 255)
            {
              if (v735)
                v119 = *v12;
              else
                v119 = 255;
              result = PDAM_5205(*v22, v119, v118);
              *v14 = result;
              *v7 = BYTE4(result);
            }
            else
            {
              if (v735)
                v120 = *v12;
              else
                v120 = 255;
              result = (unint64_t)DAplusDAM(v14, v7, *v14, *v7, *v22, v120, ((unsigned __int16)(~*v7 * (_WORD)v118+ ((~*v7* v118) >> 8)+ 1) >> 8));
            }
            v114 = v725;
          }
          v16 += v113;
          v7 += v114;
          v121 = &v22[v113];
          if ((unint64_t)v121 >= v745)
            v122 = v115;
          else
            v122 = 0;
          v12 += v735 + v122;
          v22 = &v121[v122];
          v14 = (unsigned int *)((char *)v14 + v116);
          --v117;
        }
        while (v117);
        if (v697)
        {
          v123 = &v717[v716];
          v124 = &v703[v714];
          v125 = (unint64_t)v123 >= v697;
          v126 = v670;
          if ((unint64_t)v123 < v697)
            v126 = 0;
          v22 = &v123[v126];
          v127 = v745 + 4 * v126;
          v128 = v641;
          if (!v125)
            v128 = 0;
          v12 = &v124[v128];
          v745 = v127 + 4 * v716;
          v703 = &v124[v128];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 7:
      v129 = v26;
      if (v8)
      {
        v726 = v8;
        v130 = v19;
        v704 = -(uint64_t)(v716 * v21);
        v671 = -(v714 * v21);
        v739 = v12;
        v131 = -(uint64_t)v20;
        do
        {
          v132 = v715;
          do
          {
            v133 = *v16;
            if (*v16)
            {
              if (v133 == 255)
              {
                result = PDAM_5205(*v14, *v7, *v12);
                *v14 = result;
                *v7 = BYTE4(result);
              }
              else
              {
                result = (unint64_t)DAMplusDAM(v14, v7, *v14, *v7, ((unsigned __int16)(*v12 * (_WORD)v133+ ((*v12* v133) >> 8)+ 1) >> 8), *v14, *v7, v133 ^ 0xFFu);
              }
            }
            v16 += v129;
            v7 += v726;
            v134 = &v22[v129];
            if ((unint64_t)v134 >= v745)
              v135 = v131;
            else
              v135 = 0;
            v12 += v130 + v135;
            v22 = &v134[v135];
            v14 += v129;
            --v132;
          }
          while (v132);
          if (v697)
          {
            v136 = &v717[v716];
            v137 = &v739[v714];
            v138 = (unint64_t)v136 >= v697;
            v139 = v704;
            if ((unint64_t)v136 < v697)
              v139 = 0;
            v22 = &v136[v139];
            v140 = v745 + 4 * v139;
            v141 = v671;
            if (!v138)
              v141 = 0;
            v12 = &v137[v141];
            v739 = &v137[v141];
            v745 = v140 + 4 * v716;
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        v546 = v19;
        v733 = -(uint64_t)(v716 * v21);
        v710 = -(v714 * v21);
        v744 = v12;
        v547 = -(uint64_t)v20;
        do
        {
          v548 = v715;
          do
          {
            v549 = *v16;
            if (*v16)
            {
              if (v549 == 255)
              {
                v550 = *v12;
                *v14 = (((*v14 & 0xFF00FF) * v550 + 65537 + ((((*v14 & 0xFF00FF) * v550) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (((*v14 >> 8) & 0xFF00FF) * v550 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v550) >> 8) & 0xFF00FF)) & 0xFF00FF00;
              }
              else
              {
                result = (unint64_t)DMplusDM(v14, *v14, ((unsigned __int16)(*v12 * (_WORD)v549+ ((*v12* v549) >> 8)+ 1) >> 8), *v14, v549 ^ 0xFFu);
              }
            }
            v16 += v129;
            v551 = &v22[v129];
            if ((unint64_t)v551 >= v745)
              v552 = v547;
            else
              v552 = 0;
            v12 += v546 + v552;
            v22 = &v551[v552];
            v14 += v129;
            --v548;
          }
          while (v548);
          if (v697)
          {
            v553 = &v717[v716];
            v554 = &v744[v714];
            v555 = (unint64_t)v553 >= v697;
            v556 = v733;
            if ((unint64_t)v553 < v697)
              v556 = 0;
            v22 = &v553[v556];
            v557 = v745 + 4 * v556;
            v558 = v710;
            if (!v555)
              v558 = 0;
            v12 = &v554[v558];
            v744 = &v554[v558];
            v745 = v557 + 4 * v716;
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v718);
      }
      return result;
    case 8:
      v142 = v26;
      if (v8)
      {
        v727 = v8;
        v143 = v19;
        v705 = -(uint64_t)(v716 * v21);
        v672 = -(v714 * v21);
        v740 = v12;
        v144 = -(uint64_t)v20;
        do
        {
          v145 = v715;
          do
          {
            v146 = *v16;
            if (*v16)
            {
              if (v146 == 255)
                v147 = *v12 ^ 0xFF;
              else
                v147 = ~((*v12 * v146
                                         + ((*v12 * v146) >> 8)
                                         + 1) >> 8);
              result = PDAM_5205(*v14, *v7, v147);
              *v14 = result;
              *v7 = BYTE4(result);
            }
            v16 += v142;
            v7 += v727;
            v148 = &v22[v142];
            if ((unint64_t)v148 >= v745)
              v149 = v144;
            else
              v149 = 0;
            v12 += v143 + v149;
            v22 = &v148[v149];
            v14 += v142;
            --v145;
          }
          while (v145);
          if (v697)
          {
            v150 = &v717[v716];
            v151 = &v740[v714];
            v152 = (unint64_t)v150 >= v697;
            v153 = v705;
            if ((unint64_t)v150 < v697)
              v153 = 0;
            v22 = &v150[v153];
            v154 = v745 + 4 * v153;
            v155 = v672;
            if (!v152)
              v155 = 0;
            v12 = &v151[v155];
            v740 = &v151[v155];
            v745 = v154 + 4 * v716;
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        v559 = v21;
        v560 = -(uint64_t)(v716 * v21);
        v561 = -(v714 * v559);
        v562 = v12;
        v563 = -(uint64_t)v20;
        do
        {
          v564 = v715;
          v565 = v718;
          do
          {
            v566 = *v16;
            if (*v16)
            {
              if (v566 == 255)
              {
                v567 = *v12 ^ 0xFF;
                v568 = *v14 & 0xFF00FF;
                v569 = ((*v14 >> 8) & 0xFF00FF) * v567;
              }
              else
              {
                v567 = *v14 & 0xFF00FF;
                v568 = ((*v12 * v566 + ((*v12 * v566) >> 8) + 1) >> 8) ^ 0xFF;
                v569 = v568 * ((*v14 >> 8) & 0xFF00FF);
              }
              *v14 = ((v568 * v567 + 65537 + (((v568 * v567) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF | (v569
                                                                                                  + 65537
                                                                                                  + ((v569 >> 8) & 0xFF00FF)) & 0xFF00FF00;
            }
            v16 += v26;
            v570 = &v22[v26];
            if ((unint64_t)v570 >= v745)
              v571 = v563;
            else
              v571 = 0;
            v12 += v735 + v571;
            v22 = &v570[v571];
            v14 += v26;
            --v564;
          }
          while (v564);
          result = v697;
          if (v697)
          {
            v572 = &v717[v716];
            v573 = &v562[v714];
            v574 = (unint64_t)v572 >= v697;
            if ((unint64_t)v572 >= v697)
              v575 = v560;
            else
              v575 = 0;
            v22 = &v572[v575];
            v576 = v745 + 4 * v575;
            if (v574)
              result = v561;
            else
              result = 0;
            v12 = &v573[result];
            v745 = v576 + 4 * v716;
            v562 = &v573[result];
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v565 != 1);
      }
      return result;
    case 9:
      v156 = v26;
      v728 = v8;
      v741 = v19;
      v642 = -(uint64_t)(v716 * v21);
      v673 = v12;
      v617 = -(v714 * v21);
      v706 = 4 * v26;
      v157 = -(uint64_t)v20;
      do
      {
        v158 = v715;
        do
        {
          v159 = *v16;
          if (*v16)
          {
            v160 = *v7;
            v161 = PDAM_5205(*v22, *v12, *v16);
            result = (unint64_t)DAMplusDAM(v14, v7, v161, BYTE4(v161), v160 ^ 0xFFu, *v14, v160, (BYTE4(v161) + ~v159));
          }
          v16 += v156;
          v7 += v728;
          v162 = &v22[v156];
          if ((unint64_t)v162 >= v745)
            v163 = v157;
          else
            v163 = 0;
          v12 += v741 + v163;
          v22 = &v162[v163];
          v14 = (unsigned int *)((char *)v14 + v706);
          --v158;
        }
        while (v158);
        if (v697)
        {
          v164 = &v717[v716];
          v165 = &v673[v714];
          v166 = (unint64_t)v164 >= v697;
          v167 = v642;
          if ((unint64_t)v164 < v697)
            v167 = 0;
          v22 = &v164[v167];
          v168 = v745 + 4 * v167;
          v169 = v617;
          if (!v166)
            v169 = 0;
          v12 = &v165[v169];
          v745 = v168 + 4 * v716;
          v673 = &v165[v169];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 10:
      v170 = v26;
      v729 = v8;
      v742 = v19;
      v171 = -(uint64_t)v20;
      v643 = -(v714 * v21);
      v674 = -(uint64_t)(v716 * v21);
      v172 = 4 * v26;
      v707 = v12;
      do
      {
        v173 = v715;
        do
        {
          if (*v16)
          {
            v174 = *v7;
            v175 = PDAM_5205(*v22, *v12, *v16);
            result = (unint64_t)DAMplusDAM(v14, v7, v175, BYTE4(v175), v174 ^ 0xFFu, *v14, v174, ~BYTE4(v175));
          }
          v16 += v170;
          v7 += v729;
          v176 = &v22[v170];
          if ((unint64_t)v176 >= v745)
            v177 = v171;
          else
            v177 = 0;
          v12 += v742 + v177;
          v22 = &v176[v177];
          v14 = (unsigned int *)((char *)v14 + v172);
          --v173;
        }
        while (v173);
        if (v697)
        {
          v178 = &v717[v716];
          v179 = &v707[v714];
          v180 = (unint64_t)v178 >= v697;
          v181 = v674;
          if ((unint64_t)v178 < v697)
            v181 = 0;
          v22 = &v178[v181];
          v182 = v745 + 4 * v181;
          v183 = v643;
          if (!v180)
            v183 = 0;
          v12 = &v179[v183];
          v745 = v182 + 4 * v716;
          v707 = &v179[v183];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 11:
      v184 = v26;
      if (v8)
      {
        v730 = v8;
        v675 = -(uint64_t)(v716 * v21);
        v644 = -(v714 * v21);
        v708 = v12;
        v185 = -(uint64_t)v20;
        do
        {
          v186 = v715;
          do
          {
            if (*v16)
            {
              if (v735)
                v187 = *v12;
              else
                v187 = 255;
              v188 = PDAM_5205(*v22, v187, *v16);
              result = (unint64_t)DAplusdDA(v14, v7, *v14, *v7, v188, BYTE4(v188));
            }
            v16 += v184;
            v7 += v730;
            v189 = &v22[v184];
            if ((unint64_t)v189 >= v745)
              v190 = v185;
            else
              v190 = 0;
            v12 += v735 + v190;
            v22 = &v189[v190];
            v14 += v184;
            --v186;
          }
          while (v186);
          if (v697)
          {
            v191 = &v717[v716];
            v192 = &v708[v714];
            v193 = (unint64_t)v191 >= v697;
            v194 = v675;
            if ((unint64_t)v191 < v697)
              v194 = 0;
            v22 = &v191[v194];
            v195 = v745 + 4 * v194;
            v196 = v644;
            if (!v193)
              v196 = 0;
            v12 = &v192[v196];
            v745 = v195 + 4 * v716;
            v708 = &v192[v196];
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        v577 = -(uint64_t)v20;
        v734 = -(uint64_t)(v716 * v21);
        v711 = -(v714 * v21);
        v578 = v12;
        do
        {
          v579 = v715;
          do
          {
            if (*v16)
            {
              if (v735)
                v580 = *v12;
              else
                v580 = 255;
              v581 = PDAM_5205(*v22, v580, *v16);
              result = (unint64_t)DplusdDA(v14, *v14, v581, BYTE4(v581));
            }
            v16 += v184;
            v582 = &v22[v184];
            if ((unint64_t)v582 >= v745)
              v583 = v577;
            else
              v583 = 0;
            v12 += v735 + v583;
            v22 = &v582[v583];
            v14 += v184;
            --v579;
          }
          while (v579);
          if (v697)
          {
            v584 = &v717[v716];
            v585 = &v578[v714];
            v586 = (unint64_t)v584 >= v697;
            v587 = v734;
            if ((unint64_t)v584 < v697)
              v587 = 0;
            v22 = &v584[v587];
            v588 = v745 + 4 * v587;
            v589 = v711;
            if (!v586)
              v589 = 0;
            v12 = &v585[v589];
            v745 = v588 + 4 * v716;
            v578 = &v585[v589];
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          --v718;
        }
        while (v718);
      }
      return result;
    case 12:
      v197 = v26;
      if (v8)
      {
        v731 = v8;
        v198 = -(uint64_t)v20;
        v618 = -(v714 * v21);
        v645 = -(uint64_t)(v716 * v21);
        v676 = v12;
        do
        {
          v199 = v715;
          do
          {
            if (*v16)
            {
              if (v735)
                v200 = *v12;
              else
                v200 = 255;
              result = PDAM_5205(*v22, v200, *v16);
              v201 = ((result >> 8) & 0xFF00FF) + ((*v14 >> 8) & 0xFF00FF);
              v202 = *v7 + HIDWORD(result);
              v203 = (v201 << 8) & 0xFF00FF00 | ((result & 0xFF00FF) + (*v14 & 0xFF00FF)) & 0xFF00FF | (15 * (v201 & 0x1000100 | (((result & 0xFF00FF) + (*v14 & 0xFF00FF)) >> 8) & 0x10001)) | (240 * (v201 & 0x1000100 | (((result & 0xFF00FF) + (*v14 & 0xFF00FF)) >> 8) & 0x10001));
              if (v202 >= 0xFF)
                LOBYTE(v202) = -1;
              *v7 = v202;
              *v14 = v203;
            }
            v16 += v197;
            v7 += v731;
            v204 = &v22[v197];
            if ((unint64_t)v204 >= v745)
              v205 = v198;
            else
              v205 = 0;
            v12 += v735 + v205;
            v22 = &v204[v205];
            v14 += v197;
            --v199;
          }
          while (v199);
          if (v697)
          {
            v206 = &v717[v716];
            v207 = &v676[v714];
            v208 = (unint64_t)v206 >= v697;
            v209 = v645;
            if ((unint64_t)v206 < v697)
              v209 = 0;
            v22 = &v206[v209];
            v210 = v745 + 4 * v209;
            v211 = v618;
            if (!v208)
              v211 = 0;
            v12 = &v207[v211];
            v745 = v210 + 4 * v716;
            v676 = &v207[v211];
            v717 = v22;
          }
          else
          {
            v22 += v716;
            v12 += v714;
          }
          v16 += v713;
          v14 += v712;
          v7 += v696;
          --v718;
        }
        while (v718);
      }
      else
      {
        v590 = -(uint64_t)v20;
        v591 = -(uint64_t)(v716 * v21);
        do
        {
          v592 = v715;
          v593 = v718;
          do
          {
            v594 = *v16;
            if (*v16)
            {
              v595 = (((((*v22 >> 8) & 0xFF00FF) * v594 + 65537 + (((((*v22 >> 8) & 0xFF00FF) * v594) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                   + ((*v14 >> 8) & 0xFF00FF);
              v596 = ((((*v22 & 0xFF00FF) * v594 + 65537 + ((((*v22 & 0xFF00FF) * v594) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF)
                   + (*v14 & 0xFF00FF);
              *v14 = (v595 << 8) & 0xFF00FF00 | v596 & 0xFF00FF | (15 * (v595 & 0x1000100 | (v596 >> 8) & 0x10001)) | (240 * (v595 & 0x1000100 | (v596 >> 8) & 0x10001));
            }
            v16 += v197;
            v597 = &v22[v197];
            if ((unint64_t)v597 >= v745)
              v598 = v590;
            else
              v598 = 0;
            v22 = &v597[v598];
            v14 += v197;
            --v592;
          }
          while (v592);
          v16 += v713;
          v14 += v712;
          v599 = v717;
          v600 = &v717[v716];
          result = v697;
          if ((unint64_t)v600 >= v697)
            v601 = v591;
          else
            v601 = 0;
          v602 = &v600[v601];
          v603 = v745;
          v604 = v745 + 4 * v601 + 4 * v716;
          if (v697)
            v599 = v602;
          v717 = v599;
          if (v697)
            v603 = v604;
          v745 = v603;
          if (v697)
            v22 = v602;
          else
            v22 += v716;
          --v718;
        }
        while (v593 != 1);
      }
      return result;
    case 13:
      v212 = v26;
      v646 = -(uint64_t)(v716 * v21);
      v677 = v12;
      v619 = -(v714 * v21);
      v213 = 4 * v26;
      v214 = -(uint64_t)v20;
      do
      {
        v215 = v715;
        do
        {
          if (*v16)
          {
            v216 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v216, *v16);
            if (BYTE4(result))
            {
              v217 = result;
              v218 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAmultiplyPDA_5206(*v14, *v7, result, BYTE4(result));
                  v217 = result;
                  v218 = HIDWORD(result);
                }
                *v14 = v217;
                *v7 = v218;
              }
              else
              {
                result = PDAmultiplyPDA_5206(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v212;
          v7 += v719;
          v219 = &v22[v212];
          if ((unint64_t)v219 >= v745)
            v220 = v214;
          else
            v220 = 0;
          v12 += v735 + v220;
          v22 = &v219[v220];
          v14 = (unsigned int *)((char *)v14 + v213);
          --v215;
        }
        while (v215);
        if (v697)
        {
          v221 = &v717[v716];
          v222 = &v677[v714];
          v223 = (unint64_t)v221 >= v697;
          v224 = v646;
          if ((unint64_t)v221 < v697)
            v224 = 0;
          v22 = &v221[v224];
          v225 = v745 + 4 * v224;
          v226 = v619;
          if (!v223)
            v226 = 0;
          v12 = &v222[v226];
          v745 = v225 + 4 * v716;
          v677 = &v222[v226];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 14:
      v227 = v26;
      v647 = -(uint64_t)(v716 * v21);
      v678 = v12;
      v620 = -(v714 * v21);
      v228 = 4 * v26;
      v229 = -(uint64_t)v20;
      do
      {
        v230 = v715;
        do
        {
          if (*v16)
          {
            v231 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v231, *v16);
            if (BYTE4(result))
            {
              v232 = result;
              v233 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAscreenPDA_5207(*v14, *v7, result, BYTE4(result));
                  v232 = result;
                  v233 = HIDWORD(result);
                }
                *v14 = v232;
                *v7 = v233;
              }
              else
              {
                result = PDAscreenPDA_5207(*v14, 0xFFu, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v227;
          v7 += v719;
          v234 = &v22[v227];
          if ((unint64_t)v234 >= v745)
            v235 = v229;
          else
            v235 = 0;
          v12 += v735 + v235;
          v22 = &v234[v235];
          v14 = (unsigned int *)((char *)v14 + v228);
          --v230;
        }
        while (v230);
        if (v697)
        {
          v236 = &v717[v716];
          v237 = &v678[v714];
          v238 = (unint64_t)v236 >= v697;
          v239 = v647;
          if ((unint64_t)v236 < v697)
            v239 = 0;
          v22 = &v236[v239];
          v240 = v745 + 4 * v239;
          v241 = v620;
          if (!v238)
            v241 = 0;
          v12 = &v237[v241];
          v745 = v240 + 4 * v716;
          v678 = &v237[v241];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 15:
      v242 = v26;
      v648 = -(uint64_t)(v716 * v21);
      v679 = v12;
      v621 = -(v714 * v21);
      v243 = 4 * v26;
      v244 = -(uint64_t)v20;
      do
      {
        v245 = v715;
        do
        {
          if (*v16)
          {
            v246 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v246, *v16);
            if (BYTE4(result))
            {
              v247 = result;
              v248 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAoverlayPDA_5208(*v14, *v7, result, BYTE4(result));
                  v247 = result;
                  v248 = HIDWORD(result);
                }
                *v14 = v247;
                *v7 = v248;
              }
              else
              {
                result = PDAoverlayPDA_5208(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v242;
          v7 += v719;
          v249 = &v22[v242];
          if ((unint64_t)v249 >= v745)
            v250 = v244;
          else
            v250 = 0;
          v12 += v735 + v250;
          v22 = &v249[v250];
          v14 = (unsigned int *)((char *)v14 + v243);
          --v245;
        }
        while (v245);
        if (v697)
        {
          v251 = &v717[v716];
          v252 = &v679[v714];
          v253 = (unint64_t)v251 >= v697;
          v254 = v648;
          if ((unint64_t)v251 < v697)
            v254 = 0;
          v22 = &v251[v254];
          v255 = v745 + 4 * v254;
          v256 = v621;
          if (!v253)
            v256 = 0;
          v12 = &v252[v256];
          v745 = v255 + 4 * v716;
          v679 = &v252[v256];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 16:
      v257 = v26;
      v649 = -(uint64_t)(v716 * v21);
      v680 = v12;
      v622 = -(v714 * v21);
      v258 = 4 * v26;
      v259 = -(uint64_t)v20;
      do
      {
        v260 = v715;
        do
        {
          if (*v16)
          {
            v261 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v261, *v16);
            if (BYTE4(result))
            {
              v268 = result;
              v269 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAdarkenPDA_5210(*v14, *v7, result, BYTE4(result), v262, v263, v264, v265, v266, v267);
                  v268 = result;
                  v269 = HIDWORD(result);
                }
                *v14 = v268;
                *v7 = v269;
              }
              else
              {
                result = PDAdarkenPDA_5210(*v14, 0xFFu, result, BYTE4(result), v262, v263, v264, v265, v266, v267);
                *v14 = result;
              }
            }
          }
          v16 += v257;
          v7 += v719;
          v270 = &v22[v257];
          if ((unint64_t)v270 >= v745)
            v271 = v259;
          else
            v271 = 0;
          v12 += v735 + v271;
          v22 = &v270[v271];
          v14 = (unsigned int *)((char *)v14 + v258);
          --v260;
        }
        while (v260);
        if (v697)
        {
          v272 = &v717[v716];
          v273 = &v680[v714];
          v274 = (unint64_t)v272 >= v697;
          v275 = v649;
          if ((unint64_t)v272 < v697)
            v275 = 0;
          v22 = &v272[v275];
          v276 = v745 + 4 * v275;
          v277 = v622;
          if (!v274)
            v277 = 0;
          v12 = &v273[v277];
          v745 = v276 + 4 * v716;
          v680 = &v273[v277];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 17:
      v278 = v26;
      v650 = -(uint64_t)(v716 * v21);
      v681 = v12;
      v623 = -(v714 * v21);
      v279 = 4 * v26;
      v280 = -(uint64_t)v20;
      do
      {
        v281 = v715;
        do
        {
          if (*v16)
          {
            v282 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v282, *v16);
            if (BYTE4(result))
            {
              v289 = result;
              v290 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAlightenPDA_5209(*v14, *v7, result, BYTE4(result), v283, v284, v285, v286, v287, v288);
                  v289 = result;
                  v290 = HIDWORD(result);
                }
                *v14 = v289;
                *v7 = v290;
              }
              else
              {
                result = PDAlightenPDA_5209(*v14, 0xFFu, result, BYTE4(result), v283, v284, v285, v286, v287, v288);
                *v14 = result;
              }
            }
          }
          v16 += v278;
          v7 += v719;
          v291 = &v22[v278];
          if ((unint64_t)v291 >= v745)
            v292 = v280;
          else
            v292 = 0;
          v12 += v735 + v292;
          v22 = &v291[v292];
          v14 = (unsigned int *)((char *)v14 + v279);
          --v281;
        }
        while (v281);
        if (v697)
        {
          v293 = &v717[v716];
          v294 = &v681[v714];
          v295 = (unint64_t)v293 >= v697;
          v296 = v650;
          if ((unint64_t)v293 < v697)
            v296 = 0;
          v22 = &v293[v296];
          v297 = v745 + 4 * v296;
          v298 = v623;
          if (!v295)
            v298 = 0;
          v12 = &v294[v298];
          v745 = v297 + 4 * v716;
          v681 = &v294[v298];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 18:
      v299 = v26;
      v651 = -(uint64_t)(v716 * v21);
      v682 = v12;
      v624 = -(v714 * v21);
      v300 = 4 * v26;
      v301 = -(uint64_t)v20;
      do
      {
        v302 = v715;
        do
        {
          if (*v16)
          {
            v303 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v303, *v16);
            if (BYTE4(result))
            {
              v304 = result;
              v305 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAcolordodgePDA_5211(*v14, *v7, result, BYTE4(result));
                  v304 = result;
                  v305 = HIDWORD(result);
                }
                *v14 = v304;
                *v7 = v305;
              }
              else
              {
                result = PDAcolordodgePDA_5211(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v299;
          v7 += v719;
          v306 = &v22[v299];
          if ((unint64_t)v306 >= v745)
            v307 = v301;
          else
            v307 = 0;
          v12 += v735 + v307;
          v22 = &v306[v307];
          v14 = (unsigned int *)((char *)v14 + v300);
          --v302;
        }
        while (v302);
        if (v697)
        {
          v308 = &v717[v716];
          v309 = &v682[v714];
          v310 = (unint64_t)v308 >= v697;
          v311 = v651;
          if ((unint64_t)v308 < v697)
            v311 = 0;
          v22 = &v308[v311];
          v312 = v745 + 4 * v311;
          v313 = v624;
          if (!v310)
            v313 = 0;
          v12 = &v309[v313];
          v745 = v312 + 4 * v716;
          v682 = &v309[v313];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 19:
      v314 = v26;
      v652 = -(uint64_t)(v716 * v21);
      v683 = v12;
      v625 = -(v714 * v21);
      v315 = 4 * v26;
      v316 = -(uint64_t)v20;
      do
      {
        v317 = v715;
        do
        {
          if (*v16)
          {
            v318 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v318, *v16);
            if (BYTE4(result))
            {
              v319 = result;
              v320 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAcolorburnPDA_5212(*v14, *v7, result, BYTE4(result));
                  v319 = result;
                  v320 = HIDWORD(result);
                }
                *v14 = v319;
                *v7 = v320;
              }
              else
              {
                result = PDAcolorburnPDA_5212(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v314;
          v7 += v719;
          v321 = &v22[v314];
          if ((unint64_t)v321 >= v745)
            v322 = v316;
          else
            v322 = 0;
          v12 += v735 + v322;
          v22 = &v321[v322];
          v14 = (unsigned int *)((char *)v14 + v315);
          --v317;
        }
        while (v317);
        if (v697)
        {
          v323 = &v717[v716];
          v324 = &v683[v714];
          v325 = (unint64_t)v323 >= v697;
          v326 = v652;
          if ((unint64_t)v323 < v697)
            v326 = 0;
          v22 = &v323[v326];
          v327 = v745 + 4 * v326;
          v328 = v625;
          if (!v325)
            v328 = 0;
          v12 = &v324[v328];
          v745 = v327 + 4 * v716;
          v683 = &v324[v328];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 20:
      v329 = v26;
      v653 = -(uint64_t)(v716 * v21);
      v684 = v12;
      v626 = -(v714 * v21);
      v330 = 4 * v26;
      v331 = -(uint64_t)v20;
      do
      {
        v332 = v715;
        do
        {
          if (*v16)
          {
            v333 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v333, *v16);
            if (BYTE4(result))
            {
              v334 = result;
              v335 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAsoftlightPDA_5214(*v14, *v7, result, BYTE4(result));
                  v334 = result;
                  v335 = HIDWORD(result);
                }
                *v14 = v334;
                *v7 = v335;
              }
              else
              {
                result = PDAsoftlightPDA_5214(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v329;
          v7 += v719;
          v336 = &v22[v329];
          if ((unint64_t)v336 >= v745)
            v337 = v331;
          else
            v337 = 0;
          v12 += v735 + v337;
          v22 = &v336[v337];
          v14 = (unsigned int *)((char *)v14 + v330);
          --v332;
        }
        while (v332);
        if (v697)
        {
          v338 = &v717[v716];
          v339 = &v684[v714];
          v340 = (unint64_t)v338 >= v697;
          v341 = v653;
          if ((unint64_t)v338 < v697)
            v341 = 0;
          v22 = &v338[v341];
          v342 = v745 + 4 * v341;
          v343 = v626;
          if (!v340)
            v343 = 0;
          v12 = &v339[v343];
          v745 = v342 + 4 * v716;
          v684 = &v339[v343];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 21:
      v344 = v26;
      v654 = -(uint64_t)(v716 * v21);
      v685 = v12;
      v627 = -(v714 * v21);
      v345 = 4 * v26;
      v346 = -(uint64_t)v20;
      do
      {
        v347 = v715;
        do
        {
          if (*v16)
          {
            v348 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v348, *v16);
            if (BYTE4(result))
            {
              v349 = result;
              v350 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAhardlightPDA_5213(*v14, *v7, result, BYTE4(result));
                  v349 = result;
                  v350 = HIDWORD(result);
                }
                *v14 = v349;
                *v7 = v350;
              }
              else
              {
                result = PDAhardlightPDA_5213(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v344;
          v7 += v719;
          v351 = &v22[v344];
          if ((unint64_t)v351 >= v745)
            v352 = v346;
          else
            v352 = 0;
          v12 += v735 + v352;
          v22 = &v351[v352];
          v14 = (unsigned int *)((char *)v14 + v345);
          --v347;
        }
        while (v347);
        if (v697)
        {
          v353 = &v717[v716];
          v354 = &v685[v714];
          v355 = (unint64_t)v353 >= v697;
          v356 = v654;
          if ((unint64_t)v353 < v697)
            v356 = 0;
          v22 = &v353[v356];
          v357 = v745 + 4 * v356;
          v358 = v627;
          if (!v355)
            v358 = 0;
          v12 = &v354[v358];
          v745 = v357 + 4 * v716;
          v685 = &v354[v358];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 22:
      v359 = v26;
      v655 = -(uint64_t)(v716 * v21);
      v686 = v12;
      v628 = -(v714 * v21);
      v360 = 4 * v26;
      v361 = -(uint64_t)v20;
      do
      {
        v362 = v715;
        do
        {
          if (*v16)
          {
            v363 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v363, *v16);
            if (BYTE4(result))
            {
              v364 = result;
              v365 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAdifferencePDA_5215(*v14, *v7, result, BYTE4(result));
                  v364 = result;
                  v365 = HIDWORD(result);
                }
                *v14 = v364;
                *v7 = v365;
              }
              else
              {
                result = PDAdifferencePDA_5215(*v14, 0xFFu, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v359;
          v7 += v719;
          v366 = &v22[v359];
          if ((unint64_t)v366 >= v745)
            v367 = v361;
          else
            v367 = 0;
          v12 += v735 + v367;
          v22 = &v366[v367];
          v14 = (unsigned int *)((char *)v14 + v360);
          --v362;
        }
        while (v362);
        if (v697)
        {
          v368 = &v717[v716];
          v369 = &v686[v714];
          v370 = (unint64_t)v368 >= v697;
          v371 = v655;
          if ((unint64_t)v368 < v697)
            v371 = 0;
          v22 = &v368[v371];
          v372 = v745 + 4 * v371;
          v373 = v628;
          if (!v370)
            v373 = 0;
          v12 = &v369[v373];
          v745 = v372 + 4 * v716;
          v686 = &v369[v373];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 23:
      v374 = v26;
      v656 = -(uint64_t)(v716 * v21);
      v687 = v12;
      v629 = -(v714 * v21);
      v375 = 4 * v26;
      v376 = -(uint64_t)v20;
      do
      {
        v377 = v715;
        do
        {
          if (*v16)
          {
            v378 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v378, *v16);
            if (BYTE4(result))
            {
              v379 = result;
              v380 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAexclusionPDA_5216(*v14, *v7, result, BYTE4(result));
                  v379 = result;
                  v380 = HIDWORD(result);
                }
                *v14 = v379;
                *v7 = v380;
              }
              else
              {
                result = PDAexclusionPDA_5216(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v374;
          v7 += v719;
          v381 = &v22[v374];
          if ((unint64_t)v381 >= v745)
            v382 = v376;
          else
            v382 = 0;
          v12 += v735 + v382;
          v22 = &v381[v382];
          v14 = (unsigned int *)((char *)v14 + v375);
          --v377;
        }
        while (v377);
        if (v697)
        {
          v383 = &v717[v716];
          v384 = &v687[v714];
          v385 = (unint64_t)v383 >= v697;
          v386 = v656;
          if ((unint64_t)v383 < v697)
            v386 = 0;
          v22 = &v383[v386];
          v387 = v745 + 4 * v386;
          v388 = v629;
          if (!v385)
            v388 = 0;
          v12 = &v384[v388];
          v745 = v387 + 4 * v716;
          v687 = &v384[v388];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 24:
      v389 = v26;
      v657 = -(uint64_t)(v716 * v21);
      v688 = v12;
      v630 = -(v714 * v21);
      v390 = 4 * v26;
      v391 = -(uint64_t)v20;
      do
      {
        v392 = v715;
        do
        {
          if (*v16)
          {
            v393 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v393, *v16);
            if (BYTE4(result))
            {
              v394 = result;
              v395 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAhuePDA_5217(*v14, *v7, result, BYTE4(result));
                  v394 = result;
                  v395 = HIDWORD(result);
                }
                *v14 = v394;
                *v7 = v395;
              }
              else
              {
                result = PDAhuePDA_5217(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v389;
          v7 += v719;
          v396 = &v22[v389];
          if ((unint64_t)v396 >= v745)
            v397 = v391;
          else
            v397 = 0;
          v12 += v735 + v397;
          v22 = &v396[v397];
          v14 = (unsigned int *)((char *)v14 + v390);
          --v392;
        }
        while (v392);
        if (v697)
        {
          v398 = &v717[v716];
          v399 = &v688[v714];
          v400 = (unint64_t)v398 >= v697;
          v401 = v657;
          if ((unint64_t)v398 < v697)
            v401 = 0;
          v22 = &v398[v401];
          v402 = v745 + 4 * v401;
          v403 = v630;
          if (!v400)
            v403 = 0;
          v12 = &v399[v403];
          v745 = v402 + 4 * v716;
          v688 = &v399[v403];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 25:
      v404 = v26;
      v658 = -(uint64_t)(v716 * v21);
      v689 = v12;
      v631 = -(v714 * v21);
      v405 = 4 * v26;
      v406 = -(uint64_t)v20;
      do
      {
        v407 = v715;
        do
        {
          if (*v16)
          {
            v408 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v408, *v16);
            if (BYTE4(result))
            {
              v409 = result;
              v410 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAsaturationPDA_5218(*v14, *v7, result, BYTE4(result));
                  v409 = result;
                  v410 = HIDWORD(result);
                }
                *v14 = v409;
                *v7 = v410;
              }
              else
              {
                result = PDAsaturationPDA_5218(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v404;
          v7 += v719;
          v411 = &v22[v404];
          if ((unint64_t)v411 >= v745)
            v412 = v406;
          else
            v412 = 0;
          v12 += v735 + v412;
          v22 = &v411[v412];
          v14 = (unsigned int *)((char *)v14 + v405);
          --v407;
        }
        while (v407);
        if (v697)
        {
          v413 = &v717[v716];
          v414 = &v689[v714];
          v415 = (unint64_t)v413 >= v697;
          v416 = v658;
          if ((unint64_t)v413 < v697)
            v416 = 0;
          v22 = &v413[v416];
          v417 = v745 + 4 * v416;
          v418 = v631;
          if (!v415)
            v418 = 0;
          v12 = &v414[v418];
          v745 = v417 + 4 * v716;
          v689 = &v414[v418];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 26:
      v419 = v26;
      v659 = -(uint64_t)(v716 * v21);
      v690 = v12;
      v632 = -(v714 * v21);
      v420 = 4 * v26;
      v421 = -(uint64_t)v20;
      do
      {
        v422 = v715;
        do
        {
          if (*v16)
          {
            v423 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v423, *v16);
            if (BYTE4(result))
            {
              v424 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_5219(result, BYTE4(result), *v14, *v7);
                  v424 = HIDWORD(result);
                }
                *v14 = result;
                *v7 = v424;
              }
              else
              {
                result = PDAluminosityPDA_5219(result, BYTE4(result), *v14, 255);
                *v14 = result;
              }
            }
          }
          v16 += v419;
          v7 += v719;
          v425 = &v22[v419];
          if ((unint64_t)v425 >= v745)
            v426 = v421;
          else
            v426 = 0;
          v12 += v735 + v426;
          v22 = &v425[v426];
          v14 = (unsigned int *)((char *)v14 + v420);
          --v422;
        }
        while (v422);
        if (v697)
        {
          v427 = &v717[v716];
          v428 = &v690[v714];
          v429 = (unint64_t)v427 >= v697;
          v430 = v659;
          if ((unint64_t)v427 < v697)
            v430 = 0;
          v22 = &v427[v430];
          v431 = v745 + 4 * v430;
          v432 = v632;
          if (!v429)
            v432 = 0;
          v12 = &v428[v432];
          v745 = v431 + 4 * v716;
          v690 = &v428[v432];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 27:
      v433 = v26;
      v660 = -(uint64_t)(v716 * v21);
      v691 = v12;
      v633 = -(v714 * v21);
      v434 = 4 * v26;
      v435 = -(uint64_t)v20;
      do
      {
        v436 = v715;
        do
        {
          if (*v16)
          {
            v437 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v437, *v16);
            if (BYTE4(result))
            {
              v438 = result;
              v439 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAluminosityPDA_5219(*v14, *v7, result, BYTE4(result));
                  v438 = result;
                  v439 = HIDWORD(result);
                }
                *v14 = v438;
                *v7 = v439;
              }
              else
              {
                result = PDAluminosityPDA_5219(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v433;
          v7 += v719;
          v440 = &v22[v433];
          if ((unint64_t)v440 >= v745)
            v441 = v435;
          else
            v441 = 0;
          v12 += v735 + v441;
          v22 = &v440[v441];
          v14 = (unsigned int *)((char *)v14 + v434);
          --v436;
        }
        while (v436);
        if (v697)
        {
          v442 = &v717[v716];
          v443 = &v691[v714];
          v444 = (unint64_t)v442 >= v697;
          v445 = v660;
          if ((unint64_t)v442 < v697)
            v445 = 0;
          v22 = &v442[v445];
          v446 = v745 + 4 * v445;
          v447 = v633;
          if (!v444)
            v447 = 0;
          v12 = &v443[v447];
          v745 = v446 + 4 * v716;
          v691 = &v443[v447];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 28:
      v448 = v26;
      v661 = -(uint64_t)(v716 * v21);
      v692 = v12;
      v634 = -(v714 * v21);
      v449 = 4 * v26;
      v450 = -(uint64_t)v20;
      do
      {
        v451 = v715;
        do
        {
          if (*v16)
          {
            v452 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v452, *v16);
            if (BYTE4(result))
            {
              v453 = result;
              v454 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAtranspose_huePDA(*v14, *v7, result, BYTE4(result));
                  v453 = result;
                  v454 = HIDWORD(result);
                }
                *v14 = v453;
                *v7 = v454;
              }
              else
              {
                result = PDAtranspose_huePDA(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v448;
          v7 += v719;
          v455 = &v22[v448];
          if ((unint64_t)v455 >= v745)
            v456 = v450;
          else
            v456 = 0;
          v12 += v735 + v456;
          v22 = &v455[v456];
          v14 = (unsigned int *)((char *)v14 + v449);
          --v451;
        }
        while (v451);
        if (v697)
        {
          v457 = &v717[v716];
          v458 = &v692[v714];
          v459 = (unint64_t)v457 >= v697;
          v460 = v661;
          if ((unint64_t)v457 < v697)
            v460 = 0;
          v22 = &v457[v460];
          v461 = v745 + 4 * v460;
          v462 = v634;
          if (!v459)
            v462 = 0;
          v12 = &v458[v462];
          v745 = v461 + 4 * v716;
          v692 = &v458[v462];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 29:
      v463 = v26;
      v662 = -(uint64_t)(v716 * v21);
      v693 = v12;
      v635 = -(v714 * v21);
      v464 = 4 * v26;
      v465 = -(uint64_t)v20;
      do
      {
        v466 = v715;
        do
        {
          if (*v16)
          {
            v467 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v467, *v16);
            if (BYTE4(result))
            {
              v468 = result;
              v469 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAtranspose_saturationPDA(*v14, *v7, result, BYTE4(result));
                  v468 = result;
                  v469 = HIDWORD(result);
                }
                *v14 = v468;
                *v7 = v469;
              }
              else
              {
                result = PDAtranspose_saturationPDA(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v463;
          v7 += v719;
          v470 = &v22[v463];
          if ((unint64_t)v470 >= v745)
            v471 = v465;
          else
            v471 = 0;
          v12 += v735 + v471;
          v22 = &v470[v471];
          v14 = (unsigned int *)((char *)v14 + v464);
          --v466;
        }
        while (v466);
        if (v697)
        {
          v472 = &v717[v716];
          v473 = &v693[v714];
          v474 = (unint64_t)v472 >= v697;
          v475 = v662;
          if ((unint64_t)v472 < v697)
            v475 = 0;
          v22 = &v472[v475];
          v476 = v745 + 4 * v475;
          v477 = v635;
          if (!v474)
            v477 = 0;
          v12 = &v473[v477];
          v745 = v476 + 4 * v716;
          v693 = &v473[v477];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 30:
      v478 = v26;
      v663 = -(uint64_t)(v716 * v21);
      v694 = v12;
      v636 = -(v714 * v21);
      v479 = 4 * v26;
      v480 = -(uint64_t)v20;
      do
      {
        v481 = v715;
        do
        {
          if (*v16)
          {
            v482 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v482, *v16);
            if (BYTE4(result))
            {
              v483 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v14, *v7);
                  v483 = HIDWORD(result);
                }
                *v14 = result;
                *v7 = v483;
              }
              else
              {
                result = PDAtranspose_luminosityPDA(result, BYTE4(result), *v14, 255);
                *v14 = result;
              }
            }
          }
          v16 += v478;
          v7 += v719;
          v484 = &v22[v478];
          if ((unint64_t)v484 >= v745)
            v485 = v480;
          else
            v485 = 0;
          v12 += v735 + v485;
          v22 = &v484[v485];
          v14 = (unsigned int *)((char *)v14 + v479);
          --v481;
        }
        while (v481);
        if (v697)
        {
          v486 = &v717[v716];
          v487 = &v694[v714];
          v488 = (unint64_t)v486 >= v697;
          v489 = v663;
          if ((unint64_t)v486 < v697)
            v489 = 0;
          v22 = &v486[v489];
          v490 = v745 + 4 * v489;
          v491 = v636;
          if (!v488)
            v491 = 0;
          v12 = &v487[v491];
          v745 = v490 + 4 * v716;
          v694 = &v487[v491];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    case 31:
      v492 = v26;
      v664 = -(uint64_t)(v716 * v21);
      v695 = v12;
      v637 = -(v714 * v21);
      v493 = 4 * v26;
      v494 = -(uint64_t)v20;
      do
      {
        v495 = v715;
        do
        {
          if (*v16)
          {
            v496 = v735 ? *v12 : 255;
            result = PDAM_5205(*v22, v496, *v16);
            if (BYTE4(result))
            {
              v497 = result;
              v498 = HIDWORD(result);
              if (v719)
              {
                if (*v7)
                {
                  result = PDAtranspose_luminosityPDA(*v14, *v7, result, BYTE4(result));
                  v497 = result;
                  v498 = HIDWORD(result);
                }
                *v14 = v497;
                *v7 = v498;
              }
              else
              {
                result = PDAtranspose_luminosityPDA(*v14, 255, result, BYTE4(result));
                *v14 = result;
              }
            }
          }
          v16 += v492;
          v7 += v719;
          v499 = &v22[v492];
          if ((unint64_t)v499 >= v745)
            v500 = v494;
          else
            v500 = 0;
          v12 += v735 + v500;
          v22 = &v499[v500];
          v14 = (unsigned int *)((char *)v14 + v493);
          --v495;
        }
        while (v495);
        if (v697)
        {
          v501 = &v717[v716];
          v502 = &v695[v714];
          v503 = (unint64_t)v501 >= v697;
          v504 = v664;
          if ((unint64_t)v501 < v697)
            v504 = 0;
          v22 = &v501[v504];
          v505 = v745 + 4 * v504;
          v506 = v637;
          if (!v503)
            v506 = 0;
          v12 = &v502[v506];
          v745 = v505 + 4 * v716;
          v695 = &v502[v506];
          v717 = v22;
        }
        else
        {
          v22 += v716;
          v12 += v714;
        }
        v16 += v713;
        v14 += v712;
        v7 += v696;
        --v718;
      }
      while (v718);
      return result;
    default:
      return result;
  }
  do
  {
    v528 = v715;
    do
    {
      v529 = *v16;
      if (!*v16)
        goto LABEL_814;
      if (v529 != 255)
      {
        result = PDAM_5205(*v22, *v12, v529);
        if (!BYTE4(result))
          goto LABEL_814;
        v532 = BYTE4(result) ^ 0xFF;
        v533 = ((*v14 >> 8) & 0xFF00FF) * v532 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v532) >> 8) & 0xFF00FF);
        v534 = (((*v14 & 0xFF00FF) * v532 + 65537 + ((((*v14 & 0xFF00FF) * v532) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
        v535 = (v533 & 0xFF00FF00) + result;
        goto LABEL_812;
      }
      v530 = *v12;
      if (!*v12)
        goto LABEL_814;
      if (v530 != 255)
      {
        v536 = v530 ^ 0xFF;
        v537 = ((*v14 >> 8) & 0xFF00FF) * v536 + 65537 + (((((*v14 >> 8) & 0xFF00FF) * v536) >> 8) & 0xFF00FF);
        v534 = (((*v14 & 0xFF00FF) * v536 + 65537 + ((((*v14 & 0xFF00FF) * v536) >> 8) & 0xFF00FF)) >> 8) & 0xFF00FF;
        v535 = (v537 & 0xFF00FF00) + *v22;
LABEL_812:
        v531 = v535 + v534;
        goto LABEL_813;
      }
      v531 = *v22;
LABEL_813:
      *v14 = v531;
LABEL_814:
      v16 += v49;
      v538 = &v22[v49];
      if ((unint64_t)v538 >= v745)
        v539 = v527;
      else
        v539 = 0;
      v12 += v526 + v539;
      v22 = &v538[v539];
      v14 += v49;
      --v528;
    }
    while (v528);
    if (v697)
    {
      v540 = &v717[v716];
      v541 = &v743[v714];
      v542 = (unint64_t)v540 >= v697;
      v543 = v732;
      if ((unint64_t)v540 < v697)
        v543 = 0;
      v22 = &v540[v543];
      v544 = v745 + 4 * v543;
      v545 = v709;
      if (!v542)
        v545 = 0;
      v12 = &v541[v545];
      v743 = &v541[v545];
      v745 = v544 + 4 * v716;
      v717 = v22;
    }
    else
    {
      v22 += v716;
      v12 += v714;
    }
    v16 += v713;
    v14 += v712;
    --v718;
  }
  while (v718);
  return result;
}

unint64_t PIXELCONSTANT(float *a1, int a2, float32x2_t *a3, float a4, double a5, double a6, double a7)
{
  float v7;
  float v8;
  float v9;
  int v10;
  float v11;
  float32x2_t v12;
  float32x2_t v13;
  int8x8_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  unsigned int v33;
  float v34;

  *(float *)&a7 = *a1;
  *(float *)&a6 = a1[1];
  v7 = *(float *)&a6;
  if (*(float *)&a6 >= a4)
  {
    v7 = a4;
    if (*(float *)&a7 > a4)
      v7 = *a1;
  }
  v8 = a1[3];
  v9 = v7 * a1[2];
  if (a3)
    v10 = a2;
  else
    v10 = 0;
  if (v10 == 1)
  {
    v34 = a1[1];
    if (a3->f32[0] <= *(float *)&a6)
    {
      v34 = a3->f32[0];
      if (a3->f32[0] < *(float *)&a7)
        v34 = *a1;
    }
    v20 = 0;
    v21 = 0;
    v22 = 0;
    v33 = (float)(v8 + (float)((float)(*(float *)&a6 - v34) * v9));
    v19 = (float)(v8 + v9);
  }
  else
  {
    if (v10 == 4)
    {
      v24 = a3->f32[1];
      v25 = a3[1].f32[0];
      v26 = a3[1].f32[1];
      v19 = (float)(v8 + v9);
      if (a3->f32[0] < *(float *)&a7)
        v27 = *a1;
      else
        v27 = a3->f32[0];
      if (a3->f32[0] <= *(float *)&a6)
        v28 = v27;
      else
        v28 = a1[1];
      if (v24 < *(float *)&a7)
        v29 = *a1;
      else
        v29 = a3->f32[1];
      if (v24 <= *(float *)&a6)
        v30 = v29;
      else
        v30 = a1[1];
      if (v25 < *(float *)&a7)
        v31 = *a1;
      else
        v31 = a3[1].f32[0];
      if (v25 <= *(float *)&a6)
        v32 = v31;
      else
        v32 = a1[1];
      if (v26 >= *(float *)&a7)
        LODWORD(a7) = a3[1].i32[1];
      if (v26 <= *(float *)&a6)
        *(float *)&a6 = *(float *)&a7;
      v20 = (float)(v8 + (float)(v28 * v9));
      v21 = (float)(v8 + (float)(v30 * v9));
      v22 = (float)(v8 + (float)(v32 * v9));
      v23 = v8 + (float)(*(float *)&a6 * v9);
    }
    else
    {
      if (v10 != 3)
      {
        v20 = 0;
        v21 = 0;
        v22 = 0;
        v33 = (float)(v8 + v9);
        v19 = v33;
        return (v21 << 16) | (v20 << 24) | (v22 << 8) | v33 | (unint64_t)(v19 << 32);
      }
      v11 = a3[1].f32[0];
      v12 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0);
      v13 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a7, 0);
      v14 = vbsl_s8((int8x8_t)vcgt_f32(*a3, v12), (int8x8_t)v13, (int8x8_t)vsub_f32(v12, (float32x2_t)vbic_s8((int8x8_t)*a3, (int8x8_t)vcgt_f32(v13, *a3))));
      v15 = 0.0;
      if (v11 >= *(float *)&a7)
        v15 = a3[1].f32[0];
      v16 = *(float *)&a6 - v15;
      if (v11 <= *(float *)&a6)
        v17 = v16;
      else
        v17 = *a1;
      if (*(float *)v14.i32 >= *(float *)&v14.i32[1])
        v18 = *(float *)&v14.i32[1];
      else
        v18 = *(float *)v14.i32;
      if (v17 < v18)
        v18 = v17;
      v19 = (float)(v8 + v9);
      v20 = (float)(v8 + (float)((float)(*(float *)v14.i32 - v18) * v9));
      v21 = (float)(v8 + (float)((float)(*(float *)&v14.i32[1] - v18) * v9));
      v22 = (float)(v8 + (float)((float)(v17 - v18) * v9));
      v23 = v8 + (float)(v18 * v9);
    }
    v33 = v23;
  }
  return (v21 << 16) | (v20 << 24) | (v22 << 8) | v33 | (unint64_t)(v19 << 32);
}

_DWORD *CMYK32_pattern(uint64_t a1, _DWORD *a2, unsigned int a3, int a4, float32x2_t *a5, float a6, double a7, double a8, double a9)
{
  unint64_t v11;

  v11 = PIXELCONSTANT(*(float **)(*(_QWORD *)a1 + 64), a4, a5, a6, a7, a8, a9);
  if (a2 && a3 > 7 || (a2 = malloc_type_malloc(0x38uLL, 0x705560E0uLL)) != 0)
  {
    *(_OWORD *)a2 = xmmword_185004CD0;
    a2[6] = 0;
    *((_QWORD *)a2 + 2) = 1;
    a2[12] = bswap32(v11);
    *((_QWORD *)a2 + 4) = a2 + 12;
    if (BYTE4(v11) == 255)
    {
      *((_QWORD *)a2 + 5) = 0;
    }
    else
    {
      a2[13] = 16843009 * BYTE4(v11);
      *((_QWORD *)a2 + 5) = a2 + 13;
    }
  }
  return a2;
}

uint64_t CMYK32_image(int **a1, unsigned __int8 *a2, uint64_t a3)
{
  int *v6;
  _BOOL8 v7;
  int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  __n128 v17;
  int v18;
  BOOL v19;
  unsigned int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  _OWORD v42[64];
  uint64_t v43;

  v43 = *MEMORY[0x1E0C80C00];
  v6 = *a1;
  v40 = 0u;
  v41 = 0u;
  v38 = 0u;
  v39 = 0u;
  v36 = 0u;
  v37 = 0u;
  v34 = 0u;
  v35 = 0u;
  v32 = 0u;
  v33 = 0u;
  v30 = 0u;
  v31 = 0u;
  v28 = 0u;
  v29 = 0u;
  v26 = 0u;
  v27 = 0u;
  v25 = 0u;
  memset(v42, 0, 512);
  if (*((_QWORD *)a2 + 12))
    v7 = 0;
  else
    v7 = *(float *)(a3 + 8) >= 1.0;
  v8 = *(_DWORD *)(*((_QWORD *)v6 + 7) + 16 * *a2 + 8 * v7 + 4 * (*((_QWORD *)a2 + 6) == 0));
  if (v8 > 28)
    return 0xFFFFFFFFLL;
  if (*((int *)a2 + 1) < 1 || *((int *)a2 + 2) < 1)
    return 0;
  if ((int)_blt_image_initialize((uint64_t)a2, a3, (uint64_t)&v25, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  v18 = *v6;
  v19 = *v6 != 134759428 || v8 <= 23;
  v20 = *(_DWORD *)a3;
  if (v19)
    v21 = v8;
  else
    v21 = v8 + 4;
  DWORD2(v25) = *(_DWORD *)a3;
  HIDWORD(v25) = v18;
  if (v20 != 134759428)
  {
    v22 = SAMPLEINDEX(v20, v10, v11, v12, v13, v14, v15, v16);
    if (v22)
    {
      *(_QWORD *)&v25 = *(_QWORD *)&CMYK8_image_sample[2 * v22 + 2];
      if ((_QWORD)v25)
      {
        DWORD2(v25) = 134759444;
        goto LABEL_31;
      }
      if ((HIWORD(*(_DWORD *)a3) & 0x3Fu) <= 0x10)
      {
        *(_QWORD *)&v25 = *(_QWORD *)&CMYK16_image_sample[2 * v22 + 2];
        if ((_QWORD)v25)
        {
          v23 = 16;
          v24 = 269501476;
LABEL_30:
          LODWORD(v26) = v23;
          DWORD2(v25) = v24;
          goto LABEL_31;
        }
      }
      *(_QWORD *)&v25 = *(_QWORD *)&CMYKF_image_sample[2 * v22 + 2];
      if ((_QWORD)v25)
      {
        v23 = 20;
        v24 = 538985509;
        goto LABEL_30;
      }
    }
    return 0xFFFFFFFFLL;
  }
  if (!(_QWORD)v36 && (~DWORD1(v26) & 0xC3) == 0)
  {
    v17.n128_u32[0] = *(_DWORD *)(a3 + 8);
    if (v17.n128_f32[0] >= 1.0 && !*(_QWORD *)(a3 + 24))
    {
      if ((BYTE4(v26) & 4) != 0)
      {
        v17.n128_u64[0] = *(_QWORD *)(a3 + 32);
        *((_QWORD *)a2 + 8) = v17.n128_u64[0];
      }
      cmyk32_mark((uint64_t)a1, v17);
      return 1;
    }
  }
  *(_QWORD *)&v25 = cmyk32_sample_cmyk32;
LABEL_31:
  cmyk32_image_mark((uint64_t)a2, (uint64_t)&v25, v21, v17);
  return 1;
}

uint64_t CMYK32_shade(uint64_t a1, __n128 a2)
{
  uint64_t *v2;
  unsigned __int8 *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  __n128 v13;
  void *v14;
  unint64_t v15;
  _BYTE *v16;
  _OWORD v17[2];
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  void *v38[2];
  __int128 v39;
  __int128 v40;
  uint64_t v41;
  _OWORD v42[2];
  int v43;
  _BYTE v44[16];
  uint64_t v45;
  _BYTE v46[40];
  uint64_t v47;

  v2 = (uint64_t *)MEMORY[0x1E0C80A78](a1, a2);
  v5 = v4;
  v6 = (uint64_t)v3;
  v7 = 0;
  v47 = *MEMORY[0x1E0C80C00];
  v8 = *v2;
  v41 = 0;
  v39 = 0u;
  v40 = 0u;
  v37 = 0u;
  *(_OWORD *)v38 = 0u;
  v35 = 0u;
  v36 = 0u;
  v33 = 0u;
  v34 = 0u;
  v31 = 0u;
  v32 = 0u;
  v29 = 0u;
  v30 = 0u;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  memset(v17, 0, sizeof(v17));
  v9 = *(_QWORD *)(v8 + 56);
  v10 = *v3;
  if (!*((_QWORD *)v3 + 12))
  {
    if (*(_QWORD *)(v4 + 72))
      v7 = 0;
    else
      v7 = *(float *)(v4 + 4) >= 1.0;
  }
  v43 = 0;
  memset(v42, 0, sizeof(v42));
  v11 = *(_DWORD *)(v9 + 16 * v10 + 8 * v7 + 4 * (*((_QWORD *)v3 + 6) == 0));
  if (v11 > 27)
    return 0xFFFFFFFFLL;
  if (*((int *)v3 + 1) < 1 || *((int *)v3 + 2) < 1)
    return 0;
  if ((int)_blt_shade_initialize((uint64_t)v3, v4, (uint64_t)v17, (uint64_t)v42) < 1)
    return 0xFFFFFFFFLL;
  if (v11 >= 24 && *(_DWORD *)v8 == 134759428)
    v11 += 4;
  if ((*(_DWORD *)v5 & 0xF000000) == 0x4000000)
  {
    if (*(_QWORD *)(v5 + 16))
    {
      v14 = CMYK32_shade_radial_CMYK;
    }
    else if (*(_QWORD *)(v5 + 24))
    {
      v14 = CMYK32_shade_conic_CMYK;
    }
    else if (*((uint64_t *)&v19 + 1) < 2)
    {
      v14 = CMYK32_shade_axial_CMYK;
    }
    else
    {
      v14 = CMYK32_shade_custom_CMYK;
    }
    *(_QWORD *)&v17[0] = v14;
    if ((_QWORD)v40)
    {
      *((_QWORD *)&v39 + 1) = v46;
      _blt_shade_samples_16((uint64_t)v46, 2, 4, (float *)v40, *((float **)&v40 + 1), 1uLL);
    }
    v15 = *((_QWORD *)&v19 + 1) * v19;
    if ((uint64_t)(*((_QWORD *)&v19 + 1) * v19) <= 384)
    {
      v16 = v44;
      v38[1] = v44;
LABEL_30:
      _blt_shade_samples_16((uint64_t)v16, 2, 4, (float *)v18, *((float **)&v18 + 1), v15);
      if (*(_BYTE *)(v5 + 1))
        *(_QWORD *)&v39 = &_blt_shade_samples_noise;
      goto LABEL_32;
    }
    v16 = malloc_type_malloc(10 * v15 + 32, 0xE83E6668uLL);
    if (v16)
    {
      v38[1] = v16;
      v15 = *((_QWORD *)&v19 + 1) * v19;
      goto LABEL_30;
    }
    return 0xFFFFFFFFLL;
  }
  if (!*(_QWORD *)&v17[0])
    return 0xFFFFFFFFLL;
LABEL_32:
  DWORD2(v17[0]) = *(_DWORD *)v8;
  HIDWORD(v17[0]) = DWORD2(v17[0]);
  cmyk32_image_mark(v6, (uint64_t)v17, v11, v13);
  if (v38[1] && (v38[1] < v44 || &v45 < v38[1]))
    free(v38[1]);
  return 1;
}

void CMYK32_shade_radial_CMYK(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  int8x16_t v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  uint64_t v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  float v19;
  float v20;
  float v21;
  char *v22;
  int8x16_t *v23;
  uint64_t v24;
  _WORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  uint64_t v31;
  int v32;
  int v33;
  float v34;
  float v35;
  int v36;
  int v37;
  float v38;
  float v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  float v45;
  float v46;
  float v47;
  float v48;
  float v49;
  float v50;
  float v51;
  float v52;
  float v53;
  BOOL v54;
  float v55;
  BOOL v56;
  int v57;
  float v58;
  _WORD *v59;
  unsigned int v60;
  __int16 v61;
  uint32x4_t v62;
  char v63;
  float v64;
  float v65;
  float v66;
  unsigned __int16 *v67;
  int v68;
  float v69;
  float v70;
  float v71;
  float v73;
  float v74;
  float v75;
  int v76;
  int v77;
  uint64_t v79;
  unsigned __int16 v80;
  unsigned __int16 v81;
  int v82;
  int v83;
  unsigned __int16 v84;
  _WORD *v85;
  __int16 *v86;
  __int16 v87;
  __int16 v88;
  int v89;
  int v90;
  __int16 v91;
  __int16 v92;
  unsigned __int16 v93;
  int v94;
  int v95;
  int v96;
  __int16 v97;
  unsigned __int16 v98;
  int v99;
  int v100;
  __int16 v101;
  unint64_t v102;
  uint64_t v103;
  int v104;
  __int16 v105;
  unsigned __int16 v106;
  int v107;
  int v108;
  __int16 v109;
  int v110;
  char v111;
  char v112;
  _WORD *v113;
  uint16x4_t *v114;
  __int16 v115;
  unsigned int v116;
  __int16 v117;
  uint32x4_t v118;
  uint64_t v119;
  _WORD *v120;
  int v121;
  int v122;
  int v123;
  __int16 v124;
  int v125;
  unsigned __int16 *v126;
  unsigned __int16 *v127;
  int32x2_t v128;
  int32x2_t v129;
  int32x2_t v130;
  int32x2_t v131;
  int32x2_t v132;
  int v133;
  int32x2_t v134;
  uint32x2_t v135;
  int8x8_t v136;
  int32x2_t v137;
  int32x2_t v138;
  int8x16_t v139;
  int8x16_t v140;
  int8x8_t v141;
  int8x16_t v142;
  int8x8_t v143;
  int8x16_t v144;
  uint32x2_t v145;
  int8x16_t v146;
  uint32x2_t v147;
  int8x8_t v148;
  int32x2_t v149;
  int8x16_t v150;
  int8x16_t v151;
  int8x8_t v152;
  int8x16_t v153;
  uint32x2_t v154;

  v5 = *(float *)(a1 + 280);
  v6 = *(float *)(a1 + 284);
  v7 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v8 = v7 * (float)a2;
  v9 = v7 * (float)(uint64_t)a3;
  v10 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v9) + (float)(v5 * v8));
  v11 = *(float *)(a1 + 300) + (float)((float)(v9 * *(float *)(a1 + 292)) + (float)(v6 * v8));
  v13 = *(_QWORD *)(a1 + 400);
  v14 = *(float *)(a1 + 336);
  v15 = *(float *)(a1 + 344);
  v16 = *(float *)(a1 + 304);
  v17 = *(float *)(a1 + 308);
  v18 = *(_DWORD *)(a1 + 324);
  v19 = *(float *)(v13 + 8);
  v20 = *(float *)(v13 + 16);
  v4.i32[0] = *(_DWORD *)(v13 + 20);
  v21 = *(float *)(v13 + 28);
  v24 = a1 + 144;
  v22 = *(char **)(a1 + 144);
  v23 = *(int8x16_t **)(v24 + 8);
  v25 = *(_WORD **)(a1 + 376);
  v26 = *(_QWORD *)(a1 + 360);
  v27 = ((unint64_t)a2 >> 8) & 0xF;
  if (v19 != 0.0 || v21 != 0.0 || v6 != 0.0)
  {
    v37 = *(_DWORD *)(a1 + 320);
    v38 = *(float *)(v13 + 12);
    v39 = *(float *)(v13 + 24);
    v40 = *(float *)(v13 + 32);
    v41 = a1 + 368;
    v42 = *(_QWORD *)(a1 + 368);
    v43 = v42 + ((a3 >> 4) & 0xF0);
    v30 = v42 == 0;
    v44 = 15;
    if (v30)
    {
      v44 = 0;
      v27 = 0;
    }
    else
    {
      v41 = v43;
    }
    v45 = -v39;
    v46 = v17 - v16;
    while (1)
    {
      v47 = v45 + (float)((float)(v10 + v10) * v19);
      v48 = (float)((float)(v11 * v11) + (float)(v10 * v10)) - v21;
      if (*(float *)v4.i32 == 0.0)
      {
        v55 = v48 / v47;
      }
      else
      {
        v49 = (float)((float)(*(float *)v4.i32 * -4.0) * v48) + (float)(v47 * v47);
        if (v49 < 0.0)
          goto LABEL_54;
        v50 = sqrtf(v49);
        v51 = v40 * (float)(v47 - v50);
        v52 = v47 + v50;
        v53 = v40 * v52;
        v54 = (float)(v40 * v52) <= v51;
        if ((float)(v40 * v52) <= v51)
          v55 = v40 * v52;
        else
          v55 = v51;
        if (v54)
          v53 = v51;
        if (v53 < 0.0)
        {
          v56 = v53 < v38;
LABEL_40:
          v57 = v37;
          if (v56)
            goto LABEL_54;
LABEL_41:
          if ((v57 & 0x80000000) == 0)
            goto LABEL_53;
          goto LABEL_54;
        }
        if (v53 <= 1.0)
        {
          v58 = v16 + (float)(v53 * v46);
          goto LABEL_52;
        }
        if ((v18 & 0x80000000) == 0)
        {
          v57 = v18;
          if (v53 <= v20)
          {
LABEL_53:
            v59 = (_WORD *)(v26 + 10 * v57);
            v60 = *(unsigned __int8 *)(v41 + v27);
            v61 = v60 + *v59;
            goto LABEL_56;
          }
        }
      }
      if (v55 < 0.0)
      {
        v56 = v55 < v38;
        goto LABEL_40;
      }
      if (v55 > 1.0)
      {
        v57 = v18;
        if (v55 > v20)
          goto LABEL_54;
        goto LABEL_41;
      }
      v58 = v16 + (float)(v55 * v46);
LABEL_52:
      v57 = (int)(float)(v15 * (float)(v58 - v14));
      if ((v57 & 0x80000000) == 0)
        goto LABEL_53;
LABEL_54:
      if (!v25)
      {
        v63 = 0;
        goto LABEL_58;
      }
      v60 = *(unsigned __int8 *)(v41 + v27);
      v61 = v60 + *v25;
      v59 = v25;
LABEL_56:
      v62 = vaddw_u16((uint32x4_t)vdupq_n_s32(v60), *(uint16x4_t *)(v59 + 1));
      v23->i64[0] = (v62.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v62.i16[6] & 0xFF00) >> 8) << 32) | (v62.i32[1] << 8) & 0xFF0000 | (unint64_t)(v62.i16[0] & 0xFF00) | HIBYTE(v61);
      v63 = -1;
LABEL_58:
      v27 = ((_DWORD)v27 + 1) & v44;
      v10 = v5 + v10;
      v11 = v6 + v11;
      v23 = (int8x16_t *)((char *)v23 + 8);
      *v22++ = v63;
      if (!--a4)
        return;
    }
  }
  v28 = a1 + 368;
  v29 = *(_QWORD *)(a1 + 368);
  v30 = v29 == 0;
  if (v29)
    v31 = v29 + ((a3 >> 4) & 0xF0);
  else
    v31 = v28;
  if (v30)
    LODWORD(a2) = 0;
  else
    LODWORD(a2) = (BYTE1(a2) + 1) & 0xF;
  if (v30)
    v32 = 0;
  else
    v32 = v27;
  if (v30)
    v33 = 0;
  else
    v33 = 15;
  v34 = v11 * v11;
  v35 = -*(float *)v4.i32;
  if (v34 <= (float)-*(float *)v4.i32)
  {
    v64 = fabsf(*(float *)(v13 + 32));
    v65 = *(float *)v4.i32 * -4.0;
    v66 = v17 - v16;
    v67 = (unsigned __int16 *)(v26 + 10 * v18);
    v68 = a4 + 2;
    while (1)
    {
      v69 = v34 + (float)(v10 * v10);
      v70 = v5 + v10;
      v71 = v34 + (float)(v70 * v70);
      if (v69 > v35 && v71 > v35)
      {
        if (v18 < 0)
        {
          if (!v25)
          {
            v112 = 0;
            v111 = 0;
            goto LABEL_82;
          }
          v80 = *v25;
          v81 = v25[1];
          v82 = (unsigned __int16)v25[2];
          v83 = (unsigned __int16)v25[3];
          v84 = v25[4];
        }
        else
        {
          v80 = *v67;
          v81 = v67[1];
          v82 = v67[2];
          v83 = v67[3];
          v84 = v67[4];
        }
        v104 = *(unsigned __int8 *)(v31 + v32);
        v105 = v104 + v80;
        v106 = v104 + v81;
        v107 = v104 + v82;
        v108 = v104 + v83;
        v109 = v104 + v84;
        v110 = *(unsigned __int8 *)(v31 + a2);
        v97 = v110 + v80;
        v98 = v110 + v81;
        v99 = v110 + v82;
        v100 = v110 + v83;
        v101 = v110 + v84;
        v102 = (v108 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v109 & 0xFF00) >> 8) << 32) | (v107 << 8) & 0xFF0000 | (unint64_t)(v106 & 0xFF00);
        v103 = HIBYTE(v105);
        goto LABEL_80;
      }
      v73 = sqrtf(v65 * v71);
      v74 = v64 * sqrtf(v65 * v69);
      v75 = v64 * v73;
      v76 = (int)(float)(v15 * (float)((float)(v16 + (float)(v74 * v66)) - v14));
      v77 = (int)(float)(v15 * (float)((float)(v16 + (float)((float)(v64 * v73) * v66)) - v14));
      if (v74 <= 1.0 && v75 <= 1.0)
      {
        v85 = (_WORD *)(v26 + 10 * v76);
        v86 = (__int16 *)(v26 + 10 * v77);
        v87 = *v86;
        v88 = v86[1];
        v89 = (unsigned __int16)v86[2];
        v90 = (unsigned __int16)v86[3];
        v91 = v86[4];
        LODWORD(v86) = *(unsigned __int8 *)(v31 + v32);
        v92 = (_WORD)v86 + *v85;
        v93 = (_WORD)v86 + v85[1];
        v94 = (_DWORD)v86 + (unsigned __int16)v85[2];
        v95 = (_DWORD)v86 + (unsigned __int16)v85[3];
        LOWORD(v85) = (_WORD)v86 + v85[4];
        v96 = *(unsigned __int8 *)(v31 + a2);
        v97 = v96 + v87;
        v98 = v96 + v88;
        v99 = v96 + v89;
        v100 = v96 + v90;
        v101 = v96 + v91;
        v102 = (v95 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((unsigned __int16)v85 & 0xFF00) >> 8) << 32) | (v94 << 8) & 0xFF0000 | (unint64_t)(v93 & 0xFF00);
        v103 = HIBYTE(v92);
LABEL_80:
        v23->i64[0] = v102 | v103;
        v111 = -1;
        goto LABEL_81;
      }
      if (v74 <= 1.0)
      {
        if ((v76 & 0x80000000) == 0)
        {
          v79 = 5 * v76;
LABEL_86:
          v113 = (_WORD *)(v26 + 2 * v79);
          v115 = *v113;
          v114 = (uint16x4_t *)(v113 + 1);
          v116 = *(unsigned __int8 *)(v31 + v32);
          v117 = v116 + v115;
          goto LABEL_89;
        }
      }
      else if (v74 <= v20)
      {
        v79 = 5 * v18;
        if ((v18 & 0x80000000) == 0)
          goto LABEL_86;
      }
      if (!v25)
      {
        v111 = 0;
        goto LABEL_90;
      }
      v116 = *(unsigned __int8 *)(v31 + v32);
      v117 = v116 + *v25;
      v114 = (uint16x4_t *)(v25 + 1);
LABEL_89:
      v118 = vaddw_u16((uint32x4_t)vdupq_n_s32(v116), *v114);
      v23->i64[0] = (v118.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v118.i16[6] & 0xFF00) >> 8) << 32) | (v118.i32[1] << 8) & 0xFF0000 | (unint64_t)(v118.i16[0] & 0xFF00) | HIBYTE(v117);
      v111 = -1;
LABEL_90:
      if (v75 <= 1.0)
      {
        if (v77 < 0)
          goto LABEL_97;
        v119 = 5 * v77;
      }
      else if (v75 > v20 || (v119 = 5 * v18, v18 < 0))
      {
LABEL_97:
        if (!v25)
        {
          v112 = 0;
          goto LABEL_82;
        }
        v125 = *(unsigned __int8 *)(v31 + a2);
        v97 = v125 + *v25;
        v98 = v125 + v25[1];
        v99 = v125 + (unsigned __int16)v25[2];
        v100 = v125 + (unsigned __int16)v25[3];
        v101 = v125 + v25[4];
        goto LABEL_81;
      }
      v120 = (_WORD *)(v26 + 2 * v119);
      v121 = (unsigned __int16)v120[2];
      v122 = (unsigned __int16)v120[3];
      v123 = *(unsigned __int8 *)(v31 + a2);
      v97 = v123 + *v120;
      v124 = v120[4];
      v98 = v123 + v120[1];
      v99 = v123 + v121;
      v100 = v123 + v122;
      v101 = v123 + v124;
LABEL_81:
      v23->i64[1] = (v100 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v101 & 0xFF00) >> 8) << 32) | (v99 << 8) & 0xFF0000 | (unint64_t)(v98 & 0xFF00) | HIBYTE(v97);
      v112 = -1;
LABEL_82:
      v10 = v5 + v70;
      LOBYTE(v32) = (v32 + 1) & v33;
      LOBYTE(a2) = (a2 + 1) & v33;
      ++v23;
      *v22 = v111;
      v22[1] = v112;
      v22 += 2;
      v68 -= 2;
      if (v68 <= 2)
        return;
    }
  }
  if (v25 || (v18 & 0x80000000) == 0)
  {
    v126 = (unsigned __int16 *)(v26 + 10 * v18);
    if (v18 >= 0)
      v127 = v126;
    else
      v127 = v25;
    v128 = vdup_n_s32(v127[4]);
    v129 = vdup_n_s32(v127[3]);
    v130 = vdup_n_s32(v127[2]);
    v131 = vdup_n_s32(v127[1]);
    v132 = vdup_n_s32(*v127);
    v133 = a4 + 4;
    do
    {
      v4.i8[0] = *(_BYTE *)(v31 + v32);
      v4.i8[4] = *(_BYTE *)(v31 + a2);
      v134 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
      v135 = (uint32x2_t)vadd_s32(v132, v134);
      v136 = (int8x8_t)vadd_s32(v131, v134);
      v137 = vadd_s32(v130, v134);
      v138 = vshl_n_s32(vadd_s32(v129, v134), 0x10uLL);
      v139.i64[0] = v138.i32[0] & 0xFF00FFFF;
      v139.i64[1] = v138.i32[1] & 0xFF00FFFF;
      v140 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v128, v134), (int8x8_t)0xFF000000FF00), 0x18uLL), v139);
      v141 = vand_s8((int8x8_t)vshl_n_s32(v137, 8uLL), (int8x8_t)0xFF000000FF0000);
      v139.i64[0] = v141.u32[0];
      v139.i64[1] = v141.u32[1];
      v142 = v139;
      v143 = vand_s8(v136, (int8x8_t)0xFF000000FF00);
      v139.i64[0] = v143.u32[0];
      v139.i64[1] = v143.u32[1];
      v144 = vorrq_s8(v140, vorrq_s8(v142, v139));
      v145 = vshr_n_u32(v135, 8uLL);
      v139.i64[0] = v145.i32[0] & 0xFFFFFEFF;
      v139.i64[1] = v145.i32[1] & 0xFFFFFEFF;
      v146 = vorrq_s8(v144, v139);
      *v23 = v146;
      a2 = ((_DWORD)a2 + 1) & v33;
      v146.i8[0] = *(_BYTE *)(v31 + ((v32 + 1) & v33));
      v146.i8[4] = *(_BYTE *)(v31 + a2);
      *(int8x8_t *)v146.i8 = vand_s8(*(int8x8_t *)v146.i8, (int8x8_t)0xFF000000FFLL);
      v147 = (uint32x2_t)vadd_s32(v132, *(int32x2_t *)v146.i8);
      v148 = (int8x8_t)vadd_s32(v131, *(int32x2_t *)v146.i8);
      *(int32x2_t *)v142.i8 = vadd_s32(v130, *(int32x2_t *)v146.i8);
      v149 = vshl_n_s32(vadd_s32(v129, *(int32x2_t *)v146.i8), 0x10uLL);
      v139.i64[0] = v149.i32[0] & 0xFF00FFFF;
      v139.i64[1] = v149.i32[1] & 0xFF00FFFF;
      v150 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v128, *(int32x2_t *)v146.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v139);
      *(int8x8_t *)v142.i8 = vand_s8((int8x8_t)vshl_n_s32(*(int32x2_t *)v142.i8, 8uLL), (int8x8_t)0xFF000000FF0000);
      v139.i64[0] = v142.u32[0];
      v139.i64[1] = v142.u32[1];
      v151 = v139;
      v152 = vand_s8(v148, (int8x8_t)0xFF000000FF00);
      v139.i64[0] = v152.u32[0];
      v139.i64[1] = v152.u32[1];
      v153 = vorrq_s8(v150, vorrq_s8(v151, v139));
      v154 = vshr_n_u32(v147, 8uLL);
      v139.i64[0] = v154.i32[0] & 0xFFFFFEFF;
      v139.i64[1] = v154.i32[1] & 0xFFFFFEFF;
      *(_DWORD *)v22 = -1;
      v22 += 4;
      v133 -= 4;
      v4 = vorrq_s8(v153, v139);
      v23[1] = v4;
      v23 += 2;
      v32 = (v32 + 1) & v33;
    }
    while (v133 > 4);
  }
  else
  {
    if (a4 >= 4)
      v36 = 4;
    else
      v36 = a4;
    bzero(v22, ((a4 - v36 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t CMYK32_shade_conic_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v15;
  uint64_t v16;
  unint64_t *v17;
  _BYTE *v18;
  uint64_t v19;
  float v20;
  float v21;
  unsigned int v22;
  float v23;
  float v24;
  unsigned int v25;
  float v26;
  float v27;
  unsigned __int16 *v28;
  int v29;
  int v30;
  int v31;
  int v32;
  unsigned __int16 *v33;
  int v34;
  int v35;
  uint64_t result;
  int v37;
  unsigned int v38;
  int v39;
  int v40;
  float v41;
  float v42;

  v4 = *(float *)(a1 + 280);
  v5 = *(float *)(*(_QWORD *)(a1 + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(a1 + 296) + (float)((float)(*(float *)(a1 + 288) * v7) + (float)(v4 * v6));
  v9 = *(_QWORD *)(a1 + 368);
  if (v9)
    v10 = v9 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v10 = a1 + 368;
  if (v9)
    v11 = 15;
  else
    v11 = 0;
  v12 = *(float *)(a1 + 284);
  v13 = *(float *)(a1 + 300) + (float)((float)(v7 * *(float *)(a1 + 292)) + (float)(v12 * v6));
  v41 = *(float *)(a1 + 336);
  v42 = *(float *)(a1 + 304);
  v15 = *(float *)(a1 + 344);
  v16 = *(_QWORD *)(a1 + 360);
  v18 = *(_BYTE **)(a1 + 144);
  v17 = *(unint64_t **)(a1 + 152);
  if (v9)
    v19 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v19 = 0;
  v20 = *(float *)(a1 + 308) - *(float *)(a1 + 304);
  do
  {
    v21 = v15 * (float)((float)(v42 + (float)((float)((float)(atan2f(v13, v8) * 0.15915) + 0.5) * v20)) - v41);
    v22 = vcvtms_s32_f32(v21);
    v23 = ceilf(v21);
    v24 = (float)((float)(v21 - (float)(int)floorf(v21)) * 255.0) + 0.5;
    v25 = vcvtms_s32_f32(v15 + v21);
    if (v21 < 0.0)
      v22 = v25;
    v26 = ceilf(v21 - v15);
    if (v21 <= v15)
      v27 = v23;
    else
      v27 = v26;
    v28 = (unsigned __int16 *)(v16 + 2 * (int)(5 * v22));
    v29 = *v28;
    v30 = v28[1];
    v31 = v28[2];
    v32 = v28[3];
    v33 = (unsigned __int16 *)(v16 + 10 * (int)v27);
    v34 = 255 - (int)v24;
    v35 = v33[1];
    result = v33[2];
    v37 = v33[3];
    LODWORD(v28) = v33[4] * (int)v24 + v34 * v28[4];
    LODWORD(v33) = (int)v24 * *v33 + v34 * v29;
    v38 = (int)v24 * v35 + v34 * v30;
    v39 = (int)v24 * result + v34 * v31;
    v40 = *(unsigned __int8 *)(v10 + v19);
    *v17++ = ((v40 + ((v37 * (int)v24 + v34 * v32) >> 8)) << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)((v40 + (v28 >> 8)) & 0xFF00) >> 8) << 32) | (v39 + (v40 << 8)) & 0xFF0000 | (unint64_t)((unsigned __int16)(v40 + (v38 >> 8)) & 0xFF00) | ((unsigned __int16)(v40 + (v33 >> 8)) >> 8);
    v19 = ((_DWORD)v19 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    *v18++ = -1;
    --a4;
  }
  while (a4);
  return result;
}

unint64_t CMYK32_shade_custom_CMYK(unint64_t result, uint64_t a2, uint64_t a3, int a4)
{
  float v4;
  float v5;
  float v6;
  float v7;
  float v8;
  unint64_t v9;
  uint64_t v10;
  int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  _WORD *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  unint64_t *v26;
  char *v27;
  unsigned int v31;
  __int16 v32;
  uint64_t v33;
  uint32x4_t v34;
  char v35;

  v4 = *(float *)(result + 280);
  v5 = *(float *)(*(_QWORD *)(result + 272) + 4);
  v6 = v5 * (float)a2;
  v7 = v5 * (float)a3;
  v8 = *(float *)(result + 296) + (float)((float)(*(float *)(result + 288) * v7) + (float)(v4 * v6));
  v9 = result + 368;
  v10 = *(_QWORD *)(result + 368);
  v11 = 15;
  if (v10)
    v9 = v10 + (((unint64_t)a3 >> 4) & 0xF0);
  else
    v11 = 0;
  v12 = *(float *)(result + 284);
  v13 = *(float *)(result + 300) + (float)((float)(v7 * *(float *)(result + 292)) + (float)(v12 * v6));
  v14 = *(float *)(result + 304);
  v15 = *(float *)(result + 308);
  v16 = *(float *)(result + 312);
  v17 = *(float *)(result + 316);
  v18 = *(float *)(result + 336);
  v19 = *(float *)(result + 348);
  v20 = *(float *)(result + 344);
  v21 = *(float *)(result + 356);
  v22 = *(_WORD **)(result + 376);
  v23 = *(_QWORD *)(result + 360);
  v24 = 5 * *(_DWORD *)(result + 48);
  if (v10)
    v25 = ((unint64_t)a2 >> 8) & 0xF;
  else
    v25 = 0;
  v27 = *(char **)(result + 144);
  v26 = *(unint64_t **)(result + 152);
  do
  {
    if (v8 >= v14 && v13 >= v16 && v8 <= v15 && v13 <= v17)
    {
      v33 = v23 + 2 * v24 * (int)(float)(v21 * (float)(v13 - v19)) + 10 * (int)(float)(v20 * (float)(v8 - v18));
      v31 = *(unsigned __int8 *)(v9 + v25);
      v32 = v31 + *(_WORD *)v33;
      goto LABEL_21;
    }
    if (v22)
    {
      v31 = *(unsigned __int8 *)(v9 + v25);
      v32 = v31 + *v22;
      v33 = (uint64_t)v22;
LABEL_21:
      v34 = vaddw_u16((uint32x4_t)vdupq_n_s32(v31), *(uint16x4_t *)(v33 + 2));
      result = (v34.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v34.i16[6] & 0xFF00) >> 8) << 32);
      *v26 = result | (v34.i32[1] << 8) & 0xFF0000 | (unint64_t)(v34.i16[0] & 0xFF00) | HIBYTE(v32);
      v35 = -1;
      goto LABEL_22;
    }
    v35 = 0;
LABEL_22:
    v25 = ((_DWORD)v25 + 1) & v11;
    v8 = v4 + v8;
    v13 = v12 + v13;
    ++v26;
    *v27++ = v35;
    --a4;
  }
  while (a4);
  return result;
}

void CMYK32_shade_axial_CMYK(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  int8x16_t v4;
  float v5;
  float v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  int v19;
  _DWORD *v20;
  int8x16_t *v21;
  uint64_t v22;
  unsigned __int16 *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned __int16 *v32;
  unsigned int v33;
  __int16 v34;
  uint32x4_t v35;
  char v36;
  unsigned __int16 *v37;
  unsigned __int16 *v38;
  unint64_t v39;
  unsigned int v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  int32x2_t v44;
  int32x2_t v45;
  int v46;
  int32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  int32x2_t v50;
  uint32x2_t v51;
  int8x8_t v52;
  int32x2_t v53;
  int32x2_t v54;
  int8x16_t v55;
  int8x16_t v56;
  int8x8_t v57;
  int8x16_t v58;
  int8x8_t v59;
  int8x16_t v60;
  uint32x2_t v61;
  int8x16_t v62;
  uint32x2_t v63;
  int8x8_t v64;
  int32x2_t v65;
  int8x16_t v66;
  int8x16_t v67;
  int8x8_t v68;
  int8x16_t v69;
  uint32x2_t v70;
  unint64_t v71;
  int v72;

  v5 = *(float *)(a1 + 280);
  v6 = *(float *)(a1 + 296)
     + (float)((float)(*(float *)(a1 + 288) * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a3))
             + (float)(v5 * (float)(*(float *)(*(_QWORD *)(a1 + 272) + 4) * (float)a2)));
  v7 = a1 + 368;
  v8 = *(_QWORD *)(a1 + 368);
  v9 = ((unint64_t)a3 >> 4) & 0xF0;
  v10 = v8 + v9;
  if (v8)
    v11 = v8 + v9;
  else
    v11 = a1 + 368;
  if (v8)
    v12 = 15;
  else
    v12 = 0;
  v14 = *(float *)(a1 + 336);
  v15 = *(float *)(a1 + 344);
  v16 = *(float *)(a1 + 304);
  v17 = *(float *)(a1 + 308);
  v18 = *(_DWORD *)(a1 + 320);
  v19 = *(_DWORD *)(a1 + 324);
  v22 = a1 + 144;
  v20 = *(_DWORD **)(a1 + 144);
  v21 = *(int8x16_t **)(v22 + 8);
  v23 = *(unsigned __int16 **)(a1 + 376);
  v24 = *(_QWORD *)(a1 + 360);
  if (v5 != 0.0)
  {
    if (v8)
      v30 = (a2 >> 8) & 0xF;
    else
      LOBYTE(v30) = 0;
    while (1)
    {
      v31 = v18;
      if (v6 >= v16)
      {
        v31 = v19;
        if (v6 <= v17)
          v31 = (int)(float)(v15 * (float)(v6 - v14));
      }
      if (v31 < 0)
      {
        if (!v23)
        {
          v36 = 0;
          goto LABEL_40;
        }
        v33 = *(unsigned __int8 *)(v11 + v30);
        v34 = v33 + *v23;
        v32 = v23;
      }
      else
      {
        v32 = (unsigned __int16 *)(v24 + 10 * v31);
        v33 = *(unsigned __int8 *)(v11 + v30);
        v34 = v33 + *v32;
      }
      v35 = vaddw_u16((uint32x4_t)vdupq_n_s32(v33), *(uint16x4_t *)(v32 + 1));
      v21->i64[0] = (v35.i32[2] << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v35.i16[6] & 0xFF00) >> 8) << 32) | (v35.i32[1] << 8) & 0xFF0000 | (unint64_t)(v35.i16[0] & 0xFF00) | HIBYTE(v34);
      v36 = -1;
LABEL_40:
      LOBYTE(v30) = (v30 + 1) & v12;
      v6 = v5 + v6;
      v21 = (int8x16_t *)((char *)v21 + 8);
      *(_BYTE *)v20 = v36;
      v20 = (_DWORD *)((char *)v20 + 1);
      if (!--a4)
        return;
    }
  }
  if (v8)
    v25 = v10;
  else
    v25 = v7;
  if (v8)
    LODWORD(v26) = ((a2 >> 8) + 1) & 0xF;
  else
    LODWORD(v26) = 0;
  if (v8)
    v27 = (a2 >> 8) & 0xF;
  else
    v27 = 0;
  if (v8)
    v28 = 15;
  else
    v28 = 0;
  if (v6 >= v16)
  {
    v18 = v19;
    if (v6 <= v17)
      v18 = (int)(float)(v15 * (float)(v6 - v14));
  }
  if ((v18 & 0x80000000) == 0 || v23)
  {
    v37 = (unsigned __int16 *)(v24 + 10 * v18);
    if (v18 < 0)
      v38 = v23;
    else
      v38 = v37;
    v39 = *v38;
    v40 = v38[1];
    v41 = v38[2];
    v42 = v38[3];
    v43 = v38[4];
    if (v8)
    {
      v44 = vdup_n_s32(v39);
      v45 = vdup_n_s32(v40);
      v46 = a4 + 4;
      v47 = vdup_n_s32(v41);
      v48 = vdup_n_s32(v42);
      v49 = vdup_n_s32(v43);
      do
      {
        v4.i8[0] = *(_BYTE *)(v25 + v27);
        v4.i8[4] = *(_BYTE *)(v25 + v26);
        v50 = (int32x2_t)vand_s8(*(int8x8_t *)v4.i8, (int8x8_t)0xFF000000FFLL);
        v51 = (uint32x2_t)vadd_s32(v44, v50);
        v52 = (int8x8_t)vadd_s32(v45, v50);
        v53 = vadd_s32(v47, v50);
        v54 = vshl_n_s32(vadd_s32(v48, v50), 0x10uLL);
        v55.i64[0] = v54.i32[0] & 0xFF00FFFF;
        v55.i64[1] = v54.i32[1] & 0xFF00FFFF;
        v56 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v49, v50), (int8x8_t)0xFF000000FF00), 0x18uLL), v55);
        v57 = vand_s8((int8x8_t)vshl_n_s32(v53, 8uLL), (int8x8_t)0xFF000000FF0000);
        v55.i64[0] = v57.u32[0];
        v55.i64[1] = v57.u32[1];
        v58 = v55;
        v59 = vand_s8(v52, (int8x8_t)0xFF000000FF00);
        v55.i64[0] = v59.u32[0];
        v55.i64[1] = v59.u32[1];
        v60 = vorrq_s8(v56, vorrq_s8(v58, v55));
        v61 = vshr_n_u32(v51, 8uLL);
        v55.i64[0] = v61.i32[0] & 0xFFFFFEFF;
        v55.i64[1] = v61.i32[1] & 0xFFFFFEFF;
        v62 = vorrq_s8(v60, v55);
        *v21 = v62;
        v26 = ((_DWORD)v26 + 1) & v28;
        v62.i8[0] = *(_BYTE *)(v25 + ((v27 + 1) & v28));
        v62.i8[4] = *(_BYTE *)(v25 + v26);
        *(int8x8_t *)v62.i8 = vand_s8(*(int8x8_t *)v62.i8, (int8x8_t)0xFF000000FFLL);
        v63 = (uint32x2_t)vadd_s32(v44, *(int32x2_t *)v62.i8);
        v64 = (int8x8_t)vadd_s32(v45, *(int32x2_t *)v62.i8);
        *(int32x2_t *)v58.i8 = vadd_s32(v47, *(int32x2_t *)v62.i8);
        v65 = vshl_n_s32(vadd_s32(v48, *(int32x2_t *)v62.i8), 0x10uLL);
        v55.i64[0] = v65.i32[0] & 0xFF00FFFF;
        v55.i64[1] = v65.i32[1] & 0xFF00FFFF;
        v66 = vorrq_s8((int8x16_t)vshll_n_u32((uint32x2_t)vand_s8((int8x8_t)vadd_s32(v49, *(int32x2_t *)v62.i8), (int8x8_t)0xFF000000FF00), 0x18uLL), v55);
        *(int8x8_t *)v58.i8 = vand_s8((int8x8_t)vshl_n_s32(*(int32x2_t *)v58.i8, 8uLL), (int8x8_t)0xFF000000FF0000);
        v55.i64[0] = v58.u32[0];
        v55.i64[1] = v58.u32[1];
        v67 = v55;
        v68 = vand_s8(v64, (int8x8_t)0xFF000000FF00);
        v55.i64[0] = v68.u32[0];
        v55.i64[1] = v68.u32[1];
        v69 = vorrq_s8(v66, vorrq_s8(v67, v55));
        v70 = vshr_n_u32(v63, 8uLL);
        v55.i64[0] = v70.i32[0] & 0xFFFFFEFF;
        v55.i64[1] = v70.i32[1] & 0xFFFFFEFF;
        *v20++ = -1;
        v46 -= 4;
        v4 = vorrq_s8(v69, v55);
        v21[1] = v4;
        v21 += 2;
        v27 = (v27 + 1) & v28;
      }
      while (v46 > 4);
    }
    else
    {
      v71 = (v42 << 16) & 0xFF000000 | ((unint64_t)((unsigned __int16)(v43 & 0xFF00) >> 8) << 32) | ((unint64_t)BYTE1(v41) << 16) | (unsigned __int16)v40 & 0xFF00 | (v39 >> 8);
      v72 = a4 + 4;
      do
      {
        v21->i64[0] = v71;
        v21->i64[1] = v71;
        v21[1].i64[0] = v71;
        v21[1].i64[1] = v71;
        v72 -= 4;
        v21 += 2;
        *v20++ = -1;
      }
      while (v72 > 4);
    }
  }
  else
  {
    if (a4 >= 4)
      v29 = 4;
    else
      v29 = a4;
    bzero(v20, ((a4 - v29 + 3) & 0xFFFFFFFC) + 4);
  }
}

uint64_t ReconstructZone(void *a1)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  void *v6;
  unsigned int v7;
  CPParagraphMaker *v8;
  CPColumnMaker *v9;
  CPLayoutMaker *v10;

  v2 = objc_msgSend(a1, "count");
  if (v2 >= 1)
  {
    v3 = v2;
    v4 = 0;
    do
    {
      v5 = objc_msgSend(a1, "childAtIndex:", v4);
      objc_opt_class();
      if ((objc_opt_isKindOfClass() & 1) != 0)
        ReconstructZone(v5);
      v4 = (v4 + 1);
    }
    while (v3 != (_DWORD)v4);
  }
  v6 = (void *)objc_msgSend(a1, "textLinesInZone");
  v7 = objc_msgSend(v6, "count");
  if (v7)
  {
    +[CPTextLineSplitter splitLinesIn:](CPTextLineSplitter, "splitLinesIn:", a1);
    if (objc_msgSend(v6, "count") > v7)
      objc_msgSend(a1, "sortUsingSelector:", sel_compareTopDescending_);
    v8 = objc_alloc_init(CPParagraphMaker);
    -[CPParagraphMaker makeParagraphsIn:](v8, "makeParagraphsIn:", a1);
    v9 = objc_alloc_init(CPColumnMaker);
    objc_msgSend((id)objc_msgSend(a1, "page"), "pageCropBox");
    -[CPColumnMaker setPageBounds:](v9, "setPageBounds:");
    -[CPColumnMaker makeColumnsFrom:zone:](v9, "makeColumnsFrom:zone:", -[CPParagraphMaker paragraphs](v8, "paragraphs"), a1);
    v10 = objc_alloc_init(CPLayoutMaker);
    -[CPLayoutMaker makeLayouts:from:](v10, "makeLayouts:from:", a1, -[CPColumnMaker columns](v9, "columns"));

  }
  return objc_msgSend(a1, "sortUsingSelector:", sel_compareTopDescending_);
}

__n128 CGPDFTextObjectMoveToNextLine(uint64_t a1, double a2, double a3)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  __n128 result;

  v3 = *(double *)(a1 + 72);
  v4 = *(double *)(a1 + 80);
  v5 = *(double *)(a1 + 88);
  v6 = *(double *)(a1 + 96);
  v7 = *(double *)(a1 + 112);
  v8 = v3 + v5 * 0.0;
  v9 = v5 + v3 * 0.0;
  v10 = *(double *)(a1 + 104) + v5 * a3 + a2 * v3;
  *(double *)(a1 + 72) = v8;
  *(double *)(a1 + 80) = v4 + v6 * 0.0;
  *(double *)(a1 + 88) = v9;
  *(double *)(a1 + 96) = v6 + v4 * 0.0;
  *(double *)(a1 + 104) = v10;
  *(double *)(a1 + 112) = v6 * a3 + a2 * v4 + v7;
  *(_OWORD *)(a1 + 136) = *(_OWORD *)(a1 + 88);
  *(_OWORD *)(a1 + 120) = *(_OWORD *)(a1 + 72);
  result = *(__n128 *)(a1 + 104);
  *(__n128 *)(a1 + 152) = result;
  return result;
}

void CGPDFTextObjectSetFont(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v3;

  v3 = *(CFTypeRef *)(a1 + 48);
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      CFRetain(cf);
    *(_QWORD *)(a1 + 48) = cf;
  }
}

uint64_t CGPDFTextObjectSetTextDrawingMode(uint64_t result, int a2)
{
  uint64_t v2;
  _QWORD *v3;

  *(_DWORD *)(result + 40) = a2;
  if ((a2 & 0xFFFFFFFC) == 4)
  {
    v2 = result;
    if (!*(_QWORD *)(result + 176))
    {
      v3 = malloc_type_malloc(8uLL, 0x566C45D1uLL);
      result = __CFSetLastAllocationEventName();
      *v3 = 0;
      *(_QWORD *)(v2 + 176) = v3;
    }
  }
  return result;
}

double CGPDFTextObjectAppendString(uint64_t a1, uint64_t a2)
{
  double result;
  uint64_t *v5;
  uint64_t *v6;
  __int128 v7;

  if (a1)
  {
    if (a2)
    {
      if (*(_QWORD *)(a1 + 48))
      {
        result = *(double *)(a1 + 56);
        if (result != 0.0)
        {
          v5 = *(uint64_t **)(a1 + 168);
          if (!v5)
          {
            v5 = (uint64_t *)malloc_type_malloc(8uLL, 0x566C45D1uLL);
            __CFSetLastAllocationEventName();
            *v5 = 0;
            *(_QWORD *)(a1 + 168) = v5;
          }
          v7 = 0uLL;
          CGPDFTextLayoutAppendString(v5, a1, a2, (double *)&v7);
          v6 = *(uint64_t **)(a1 + 176);
          if (v6)
            CGPDFTextLayoutAppendString(v6, a1, a2, 0);
          result = *(double *)&v7;
          *(float64x2_t *)(a1 + 152) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a1 + 120), *(double *)&v7), *(float64x2_t *)(a1 + 136), *((double *)&v7 + 1));
        }
      }
    }
  }
  return result;
}

double CGPDFTextObjectAppendStrings(uint64_t a1, CGPDFArray *a2)
{
  double result;
  uint64_t *v5;
  uint64_t *v6;
  __int128 v7;

  if (a1)
  {
    if (a2)
    {
      if (*(_QWORD *)(a1 + 48))
      {
        result = *(double *)(a1 + 56);
        if (result != 0.0)
        {
          v5 = *(uint64_t **)(a1 + 168);
          if (!v5)
          {
            v5 = (uint64_t *)malloc_type_malloc(8uLL, 0x566C45D1uLL);
            __CFSetLastAllocationEventName();
            *v5 = 0;
            *(_QWORD *)(a1 + 168) = v5;
          }
          v7 = 0uLL;
          CGPDFTextLayoutAppendStrings(v5, a1, a2, (double *)&v7);
          v6 = *(uint64_t **)(a1 + 176);
          if (v6)
            CGPDFTextLayoutAppendStrings(v6, a1, a2, 0);
          result = *(double *)&v7;
          *(float64x2_t *)(a1 + 152) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 152), *(float64x2_t *)(a1 + 120), *(double *)&v7), *(float64x2_t *)(a1 + 136), *((double *)&v7 + 1));
        }
      }
    }
  }
  return result;
}

void PDFDocumentRelease(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  _QWORD *v11;
  const void *v12;
  uint64_t v13;
  const void *v14;
  uint64_t v15;
  uint64_t v16;
  const void *v17;
  uint64_t v18;
  const void *v19;
  uint64_t v20;
  const void *v21;
  uint64_t v22;
  const void *v23;
  uint64_t v24;
  const void *v25;
  uint64_t v26;
  const void *v27;
  const void *v28;
  uint64_t v29;
  const void *v30;
  uint64_t v31;
  _QWORD *v32;
  const void *v33;
  _QWORD *v34;
  const void *v35;
  const void *v36;
  const void *v37;
  const void *v38;
  const void *v39;
  const void *v40;
  const void *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  const void *v48;
  const void *v49;
  uint64_t v50;
  const void *v51;
  const void *v52;
  const void *v53;
  void **v54;
  const char *v55;
  void *v56;
  void *v57;
  void *v58;
  const void *v59;
  const void *v60;
  const void *v61;
  void **v62;

  if (!a1)
    return;
  if ((*(_DWORD *)a1)-- != 1)
    return;
  PDFDocumentFinalize(a1, a2, a3, a4, a5, a6, a7, a8);
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 432));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 440));
  CGColorSpaceRelease(*(CGColorSpaceRef *)(a1 + 448));
  v10 = *(_QWORD *)(a1 + 328);
  if (v10)
  {
    CFRelease(*(CFTypeRef *)(v10 + 8));
    CGOrderedSetRelease(*(const void ***)(v10 + 16));
    free((void *)v10);
  }
  v11 = *(_QWORD **)(a1 + 416);
  if (v11)
  {
    v12 = (const void *)v11[1];
    if (v12)
      CFRelease(v12);
    free(v11);
  }
  v13 = *(_QWORD *)(a1 + 400);
  if (v13)
  {
    v14 = *(const void **)(v13 + 8);
    if (v14)
      CFRelease(v14);
    CGOrderedSetRelease(*(const void ***)(v13 + 16));
    free((void *)v13);
  }
  v15 = *(_QWORD *)(a1 + 336);
  if (v15)
  {
    std::__tree<unsigned long>::destroy(*(_QWORD **)(v15 + 64));
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(*(_QWORD **)(v15 + 40));
    std::__tree<std::__value_type<std::string,CGDisplayListEntryType>,std::__map_value_compare<std::string,std::__value_type<std::string,CGDisplayListEntryType>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,CGDisplayListEntryType>>>::destroy(*(char **)(v15 + 16));
    MEMORY[0x186DC23C4](v15, 0x1020C40E45BEF79);
  }
  v16 = *(_QWORD *)(a1 + 368);
  if (v16)
  {
    CGOrderedSetRelease(*(const void ***)(v16 + 16));
    v17 = *(const void **)(v16 + 8);
    if (v17)
      CFRelease(v17);
    free((void *)v16);
  }
  PDFImageSetRelease(*(_QWORD *)(a1 + 344));
  PDFImageSetRelease(*(_QWORD *)(a1 + 352));
  v18 = *(_QWORD *)(a1 + 376);
  if (v18)
  {
    v19 = *(const void **)(v18 + 8);
    if (v19)
      CFRelease(v19);
    CGOrderedSetRelease(*(const void ***)(v18 + 16));
    free((void *)v18);
  }
  v20 = *(_QWORD *)(a1 + 408);
  if (v20)
  {
    v21 = *(const void **)(v20 + 8);
    if (v21)
      CFRelease(v21);
    CGOrderedSetRelease(*(const void ***)(v20 + 16));
    free((void *)v20);
  }
  v22 = *(_QWORD *)(a1 + 384);
  if (v22)
  {
    v23 = *(const void **)(v22 + 8);
    if (v23)
      CFRelease(v23);
    CGOrderedSetRelease(*(const void ***)(v22 + 16));
    free((void *)v22);
  }
  v24 = *(_QWORD *)(a1 + 392);
  if (v24)
  {
    CGOrderedSetRelease(*(const void ***)(v24 + 16));
    v25 = *(const void **)(v24 + 8);
    if (v25)
      CFRelease(v25);
    free((void *)v24);
  }
  v26 = *(_QWORD *)(a1 + 360);
  if (v26)
  {
    CGOrderedSetRelease(*(const void ***)(v26 + 16));
    v27 = *(const void **)(v26 + 8);
    if (v27)
      CFRelease(v27);
    free((void *)v26);
  }
  v28 = *(const void **)(a1 + 312);
  if (v28)
    CFRelease(v28);
  PDFMetaSetRelease(*(unsigned int **)(a1 + 40));
  v29 = *(_QWORD *)(a1 + 456);
  if (v29)
  {
    v30 = *(const void **)(v29 + 16);
    if (v30)
      CFRelease(v30);
    v31 = *(_QWORD *)(v29 + 24);
    if (v31)
    {
      v62 = *(void ***)(v29 + 24);
      std::vector<std::shared_ptr<CG::DisplayListEntry const>>::__destroy_vector::operator()[abi:se180100](&v62);
      MEMORY[0x186DC23C4](v31, 0x20C40960023A9);
    }
    v62 = (void **)(v29 + 48);
    std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::__destroy_vector::operator()[abi:se180100](&v62);
    std::shared_ptr<CG::DisplayListResourceCFTypeRef>::~shared_ptr[abi:se180100](v29 + 32);
    MEMORY[0x186DC23C4](v29, 0x1020C40932E6E95);
  }
  PDFXRefTableRelease(*(_QWORD *)(a1 + 464));
  PDFOutputIntentRelease(*(_QWORD **)(a1 + 48));
  v32 = *(_QWORD **)(a1 + 56);
  if (v32)
  {
    v33 = (const void *)v32[2];
    if (v33)
      CFRelease(v33);
    free(v32);
  }
  v34 = *(_QWORD **)(a1 + 64);
  if (v34)
  {
    v35 = (const void *)v34[1];
    if (v35)
      CFRelease(v35);
    v36 = (const void *)v34[3];
    if (v36)
      CFRelease(v36);
    free(v34);
  }
  v37 = *(const void **)(a1 + 472);
  if (v37)
    CFRelease(v37);
  v38 = *(const void **)(a1 + 536);
  if (v38)
    CFRelease(v38);
  v39 = *(const void **)(a1 + 488);
  if (v39)
    CFRelease(v39);
  v40 = *(const void **)(a1 + 496);
  if (v40)
    CFRelease(v40);
  v41 = *(const void **)(a1 + 504);
  if (v41)
    CFRelease(v41);
  v42 = *(_QWORD *)(a1 + 288);
  if (v42)
  {
    v43 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v42);
    MEMORY[0x186DC23C4](v43, 0x10A0C408EF24B1CLL);
  }
  v44 = *(_QWORD *)(a1 + 296);
  if (v44)
  {
    v45 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v44);
    MEMORY[0x186DC23C4](v45, 0x10A0C408EF24B1CLL);
  }
  v46 = *(_QWORD *)(a1 + 304);
  if (v46)
  {
    v47 = std::__hash_table<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::__unordered_map_hasher<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::hash<CGPDFFont *>,std::equal_to<CGPDFFont *>,true>,std::__unordered_map_equal<CGPDFFont *,std::__hash_value_type<CGPDFFont *,std::pair<double,double>>,std::equal_to<CGPDFFont *>,std::hash<CGPDFFont *>,true>,std::allocator<std::__hash_value_type<CGPDFFont *,std::pair<double,double>>>>::~__hash_table(v46);
    MEMORY[0x186DC23C4](v47, 0x10A0C408EF24B1CLL);
  }
  CGPDFAssociationRelease(*(const void ***)(a1 + 32));
  v48 = *(const void **)(a1 + 24);
  if (v48)
    CFRelease(v48);
  v49 = *(const void **)(a1 + 528);
  if (v49)
    CFRelease(v49);
  v50 = *(_QWORD *)(a1 + 520);
  if (v50)
  {
    PDFXRefTableRelease(*(_QWORD *)(v50 + 88));
    PDFXRefTableRelease(*(_QWORD *)(v50 + 104));
    v51 = *(const void **)(v50 + 16);
    if (v51)
      CFRelease(v51);
    v52 = *(const void **)(v50 + 320);
    if (v52)
      CFRelease(v52);
    v53 = *(const void **)(v50 + 328);
    if (v53)
      CFRelease(v53);
    v54 = (void **)(v50 + 24);
    if (*(char *)(v50 + 47) < 0)
    {
      if (!*(_QWORD *)(v50 + 32))
      {
LABEL_91:
        std::__tree<unsigned long>::destroy(*(_QWORD **)(v50 + 240));
        std::__tree<unsigned long>::destroy(*(_QWORD **)(v50 + 216));
        v56 = *(void **)(v50 + 184);
        if (v56)
        {
          *(_QWORD *)(v50 + 192) = v56;
          operator delete(v56);
        }
        v57 = *(void **)(v50 + 160);
        if (v57)
        {
          *(_QWORD *)(v50 + 168) = v57;
          operator delete(v57);
        }
        v58 = *(void **)(v50 + 136);
        if (v58)
        {
          *(_QWORD *)(v50 + 144) = v58;
          operator delete(v58);
        }
        v62 = (void **)(v50 + 112);
        std::vector<PDFIndirectObject>::__destroy_vector::operator()[abi:se180100](&v62);
        v62 = (void **)(v50 + 48);
        std::vector<PDFLinearizerPageInfo>::__destroy_vector::operator()[abi:se180100](&v62);
        if (*(char *)(v50 + 47) < 0)
          operator delete(*v54);
        MEMORY[0x186DC23C4](v50, 0x1072C405A727712);
        goto LABEL_100;
      }
      v55 = (const char *)*v54;
    }
    else
    {
      v55 = (const char *)(v50 + 24);
      if (!*(_BYTE *)(v50 + 47))
        goto LABEL_91;
    }
    unlink(v55);
    goto LABEL_91;
  }
LABEL_100:
  v59 = *(const void **)(a1 + 560);
  if (v59)
    CFRelease(v59);
  v60 = *(const void **)(a1 + 568);
  if (v60)
    CFRelease(v60);
  v61 = *(const void **)(a1 + 512);
  if (v61)
    CFRelease(v61);
  free((void *)a1);
}

PDFDocumentPrivate *get_default_rgb_color_space(PDFDocument *a1)
{
  PDFDocumentPrivate *result;

  result = a1[27]._private;
  if (!result)
  {
    result = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceSRGB"));
    a1[27]._private = result;
    if (!result)
    {
      result = CGColorSpaceCreateDeviceRGB();
      a1[27]._private = result;
    }
  }
  return result;
}

void PDFDocumentFinalize(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGPDFArray *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  size_t i;
  uint64_t v53;
  size_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  CGPDFObjectRef v61;
  _BYTE **v62;
  const char *v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD *v68;
  _BYTE **v69;
  const char *v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  size_t j;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  CGPDFArrayRef v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t *v121;
  uint64_t *v122;
  unint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  int Type;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  uint64_t v167;
  uint64_t *v168;
  uint64_t *v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  uint64_t v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t *v190;
  uint64_t *v191;
  CGPDFObject *v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  uint64_t v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  uint64_t v216;
  uint64_t v217;
  uint64_t v218;
  char *v219;
  char *v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  uint64_t v226;
  uint64_t v227;
  uint64_t v228;
  uint64_t v229;
  char *v230;
  char *v231;
  uint64_t v232;
  uint64_t v233;
  uint64_t v234;
  uint64_t v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  uint64_t v240;
  uint64_t v241;
  uint64_t v242;
  uint64_t v243;
  uint64_t v244;
  uint64_t v245;
  const void *v246;
  uint64_t k;
  const __CFDictionary *String;
  const __CFDictionary *v249;
  const __CFDictionary *v250;
  const __CFDictionary *v251;
  const __CFDictionary *v252;
  const __CFDictionary *v253;
  CFStringRef v254;
  CFStringRef v255;
  const __CFDictionary *v256;
  const __CFDictionary *v257;
  const __CFDictionary *v258;
  const __CFDictionary *v259;
  const __CFAllocator *v260;
  CFDateFormatterRef ISO8601Formatter;
  __CFDateFormatter *v262;
  const __CFDate *NowDate;
  CFStringRef StringWithDate;
  CFStringRef v265;
  uint64_t ID;
  const UInt8 *v267;
  UInt8 *v268;
  CGPDFArray *v269;
  _BYTE *v270;
  CFIndex v271;
  CFStringRef v272;
  CFStringRef v273;
  const void *v274;
  __CFDictionary *Mutable;
  uint64_t v276;
  _QWORD *v277;
  uint64_t v278;
  uint64_t v279;
  uint64_t **v280;
  std::__shared_weak_count *v281;
  unint64_t *v282;
  unint64_t v283;
  uint64_t *v284;
  uint64_t *v285;
  CGPDFArray *v286;
  uint64_t *v287;
  unint64_t *v288;
  unint64_t v289;
  unint64_t *v290;
  unint64_t v291;
  std::__shared_weak_count *v292;
  unint64_t *v293;
  unint64_t v294;
  unint64_t *v295;
  unint64_t v296;
  std::__shared_weak_count *v297;
  unint64_t *v298;
  unint64_t v299;
  unint64_t *v300;
  unint64_t v301;
  uint64_t v302;
  unint64_t *v303;
  unint64_t v304;
  std::__shared_weak_count *v305;
  unint64_t *v306;
  unint64_t v307;
  unint64_t *v308;
  unint64_t v309;
  std::__shared_weak_count *v310;
  unint64_t *v311;
  unint64_t v312;
  std::__shared_weak_count *v313;
  unint64_t *v314;
  unint64_t *p_shared_owners;
  unint64_t v316;
  unint64_t v317;
  uint64_t v318;
  uint64_t v319;
  uint64_t v320;
  uint64_t v321;
  uint64_t v322;
  uint64_t v323;
  uint64_t v324;
  uint64_t v325;
  uint64_t v326;
  uint64_t v327;
  uint64_t v328;
  uint64_t v329;
  uint64_t v330;
  uint64_t v331;
  uint64_t v332;
  uint64_t v333;
  uint64_t v334;
  uint64_t v335;
  uint64_t v336;
  BOOL v337;
  __int128 v338;
  _OWORD *v339;
  double v340;
  double v341;
  __int128 v343;
  uint64_t v344;
  uint64_t v345;
  uint64_t v346;
  uint64_t v347;
  uint64_t v348;
  uint64_t v349;
  uint64_t v350;
  uint64_t v351;
  uint64_t v352;
  uint64_t v353;
  uint64_t v354;
  uint64_t v355;
  unint64_t v356;
  uint64_t v357;
  uint64_t v358;
  uint64_t v359;
  uint64_t v360;
  uint64_t v361;
  uint64_t v362;
  uint64_t v363;
  uint64_t v364;
  uint64_t v365;
  uint64_t v366;
  uint64_t v367;
  uint64_t v368;
  uint64_t v369;
  unint64_t *v370;
  unint64_t v371;
  uint64_t v372;
  uint64_t v373;
  unint64_t v374;
  CFIndex Count;
  uint64_t v376;
  uint64_t v377;
  uint64_t v378;
  uint64_t v379;
  uint64_t v380;
  uint64_t v381;
  uint64_t *v382;
  uint64_t v383;
  uint64_t v384;
  uint64_t v385;
  uint64_t v386;
  uint64_t v387;
  uint64_t v388;
  uint64_t v389;
  uint64_t v390;
  uint64_t v391;
  uint64_t v392;
  uint64_t v393;
  uint64_t v394;
  CFIndex m;
  const __CFDictionary *ValueAtIndex;
  uint64_t v397;
  uint64_t v398;
  uint64_t v399;
  uint64_t v400;
  uint64_t v401;
  uint64_t v402;
  uint64_t v403;
  uint64_t v404;
  uint64_t v405;
  uint64_t v406;
  uint64_t v407;
  uint64_t v408;
  uint64_t v409;
  const __CFString *v410;
  CFIndex Length;
  CFIndex v412;
  char *v413;
  char *v414;
  uint64_t v415;
  uint64_t v416;
  uint64_t v417;
  uint64_t v418;
  uint64_t v419;
  uint64_t v420;
  const void *v421;
  uint64_t v422;
  uint64_t v423;
  uint64_t v424;
  uint64_t v425;
  uint64_t v426;
  uint64_t v427;
  const void *v428;
  uint64_t v429;
  uint64_t v430;
  uint64_t v431;
  uint64_t v432;
  uint64_t v433;
  uint64_t v434;
  const void *v435;
  uint64_t v436;
  uint64_t v437;
  uint64_t v438;
  uint64_t v439;
  uint64_t v440;
  uint64_t v441;
  const void *v442;
  uint64_t v443;
  uint64_t v444;
  uint64_t v445;
  uint64_t v446;
  uint64_t v447;
  uint64_t v448;
  _QWORD *v449;
  uint64_t v450;
  uint64_t v451;
  uint64_t v452;
  uint64_t v453;
  uint64_t v454;
  uint64_t v455;
  _QWORD *v456;
  CFTypeID v457;
  uint64_t v458;
  uint64_t v459;
  uint64_t v460;
  uint64_t v461;
  uint64_t v462;
  uint64_t v463;
  uint64_t v464;
  uint64_t v465;
  uint64_t v466;
  uint64_t v467;
  uint64_t v468;
  uint64_t v469;
  uint64_t v470;
  uint64_t v471;
  uint64_t v472;
  uint64_t v473;
  uint64_t v474;
  uint64_t v475;
  uint64_t v476;
  uint64_t v477;
  uint64_t v478;
  uint64_t v479;
  uint64_t v480;
  uint64_t v481;
  uint64_t v482;
  uint64_t v483;
  uint64_t *v484;
  uint64_t v485;
  uint64_t v487;
  uint64_t *v488;
  uint64_t v489;
  uint64_t v490;
  uint64_t v491;
  uint64_t v492;
  uint64_t v493;
  uint64_t v494;
  uint64_t v495;
  uint64_t v496;
  uint64_t v497;
  uint64_t v498;
  uint64_t v499;
  uint64_t v500;
  uint64_t v501;
  uint64_t v502;
  uint64_t v503;
  uint64_t v504;
  uint64_t v505;
  uint64_t v506;
  uint64_t v507;
  const __CFData *v508;
  const UInt8 *BytePtr;
  CFIndex v510;
  uint64_t v511;
  uint64_t v512;
  uint64_t v513;
  uint64_t v514;
  uint64_t v515;
  uint64_t v516;
  uint64_t v517;
  uint64_t v518;
  uint64_t v519;
  uint64_t v520;
  uint64_t v521;
  uint64_t v522;
  uint64_t v523;
  uint64_t v524;
  uint64_t v525;
  uint64_t v526;
  uint64_t v527;
  uint64_t v528;
  uint64_t v529;
  uint64_t v530;
  uint64_t v531;
  uint64_t v532;
  uint64_t v533;
  uint64_t v534;
  uint64_t v535;
  uint64_t v536;
  uint64_t v537;
  uint64_t v538;
  uint64_t v539;
  uint64_t v540;
  const __CFDictionary *v541;
  uint64_t v542;
  uint64_t v543;
  uint64_t v544;
  uint64_t v545;
  uint64_t v546;
  uint64_t v547;
  int v548;
  uint64_t v549;
  uint64_t v550;
  uint64_t v551;
  uint64_t v552;
  uint64_t v553;
  CFMutableDictionaryRef v554;
  const __CFDictionary *v555;
  uint64_t v556;
  uint64_t v557;
  CFMutableDictionaryRef v558;
  uint64_t v559;
  uint64_t v560;
  uint64_t v561;
  uint64_t v562;
  uint64_t v563;
  uint64_t v564;
  uint64_t v565;
  uint64_t v566;
  uint64_t v567;
  CFIndex v568;
  CFIndex v569;
  const __CFString *v570;
  uint64_t v571;
  uint64_t v572;
  uint64_t v573;
  const void *v574;
  CFTypeID v575;
  const __CFData *v576;
  const __CFData *v577;
  const __CFString *v578;
  BOOL v579;
  CFTypeID v580;
  uint64_t v581;
  uint64_t v582;
  uint64_t v583;
  uint64_t v584;
  uint64_t v585;
  uint64_t v586;
  uint64_t v587;
  uint64_t v588;
  uint64_t v589;
  uint64_t v590;
  uint64_t v591;
  uint64_t v592;
  uint64_t v593;
  uint64_t v594;
  uint64_t v595;
  uint64_t v596;
  uint64_t v597;
  uint64_t v598;
  uint64_t v599;
  uint64_t *v600;
  uint64_t v601;
  uint64_t v602;
  uint64_t v603;
  uint64_t v604;
  uint64_t v605;
  uint64_t v606;
  uint64_t *v607;
  uint64_t v608;
  uint64_t v609;
  uint64_t v610;
  uint64_t v611;
  uint64_t v612;
  uint64_t v613;
  const UInt8 *v614;
  CFIndex v615;
  uint64_t v616;
  uint64_t v617;
  CGPDFArrayRef v618;
  CGPDFArrayRef v619;
  _QWORD *v620;
  CGPDFArrayRef *v621;
  char v622;
  char v623;
  BOOL v624;
  uint64_t v625;
  uint64_t v626;
  uint64_t v627;
  uint64_t v628;
  uint64_t v629;
  uint64_t *v630;
  CFStringRef v631;
  CFStringRef v632;
  uint64_t v633;
  uint64_t v634;
  uint64_t v635;
  uint64_t v636;
  uint64_t v637;
  uint64_t v638;
  uint64_t v639;
  uint64_t v640;
  uint64_t v641;
  uint64_t v642;
  uint64_t v643;
  uint64_t v644;
  uint64_t v645;
  uint64_t v646;
  uint64_t v647;
  uint64_t v648;
  uint64_t v649;
  uint64_t v650;
  uint64_t v651;
  uint64_t v652;
  const __CFDictionary *v653;
  const __CFArray *v654;
  const __CFArray *v655;
  CFTypeID v656;
  CFIndex v657;
  uint64_t v658;
  const __CFArray *MutableCopy;
  CFIndex n;
  const __CFString *v661;
  CFTypeID v662;
  uint64_t v663;
  uint64_t v664;
  uint64_t v665;
  uint64_t v666;
  uint64_t v667;
  uint64_t v668;
  uint64_t v669;
  uint64_t v670;
  uint64_t v671;
  uint64_t v672;
  uint64_t v673;
  uint64_t v674;
  uint64_t v675;
  CFIndex ii;
  const void *v677;
  uint64_t v678;
  uint64_t v679;
  uint64_t v680;
  uint64_t v681;
  uint64_t v682;
  uint64_t v683;
  uint64_t v684;
  uint64_t v685;
  uint64_t v686;
  uint64_t v687;
  uint64_t v688;
  uint64_t v689;
  uint64_t v690;
  uint64_t v691;
  uint64_t v692;
  uint64_t v693;
  uint64_t v694;
  uint64_t v695;
  uint64_t v696;
  unint64_t v697;
  uint64_t v698;
  uint64_t v699;
  uint64_t v700;
  uint64_t v701;
  uint64_t v702;
  uint64_t v703;
  uint64_t v704;
  uint64_t v705;
  uint64_t v706;
  uint64_t v707;
  uint64_t v708;
  uint64_t v709;
  const __CFString *v710;
  uint64_t v711;
  const __CFString *v712;
  const __CFString *v713;
  const __CFString *v714;
  const __CFString *v715;
  const __CFString *v716;
  _QWORD *v717;
  uint64_t v718;
  uint64_t v719;
  uint64_t v720;
  uint64_t v721;
  uint64_t v722;
  uint64_t v723;
  const __CFString *v724;
  const __CFString *v725;
  uint64_t v726;
  const void *v727;
  uint64_t v728;
  uint64_t v729;
  uint64_t v730;
  uint64_t v731;
  uint64_t v732;
  uint64_t v733;
  const char *v734;
  uint64_t v735;
  uint64_t v736;
  uint64_t v737;
  uint64_t v738;
  uint64_t v739;
  uint64_t v740;
  uint64_t v741;
  uint64_t v742;
  uint64_t v743;
  uint64_t v744;
  uint64_t v745;
  uint64_t v746;
  uint64_t v747;
  uint64_t v748;
  uint64_t v749;
  uint64_t v750;
  uint64_t v751;
  uint64_t v752;
  uint64_t v753;
  uint64_t v754;
  uint64_t v755;
  uint64_t v756;
  uint64_t v757;
  uint64_t v758;
  uint64_t v759;
  uint64_t v760;
  uint64_t v761;
  uint64_t v762;
  uint64_t v763;
  uint64_t v764;
  uint64_t v765;
  uint64_t v766;
  uint64_t v767;
  uint64_t v768;
  uint64_t v769;
  uint64_t v770;
  uint64_t v771;
  uint64_t v772;
  uint64_t v773;
  uint64_t v774;
  uint64_t v775;
  uint64_t v776;
  uint64_t v777;
  uint64_t v778;
  uint64_t v779;
  uint64_t v780;
  uint64_t v781;
  int v782;
  uint64_t v783;
  uint64_t v784;
  uint64_t v785;
  uint64_t v786;
  uint64_t v787;
  uint64_t v788;
  uint64_t v789;
  uint64_t v790;
  uint64_t v791;
  uint64_t v792;
  uint64_t v793;
  uint64_t v794;
  uint64_t v795;
  uint64_t v796;
  uint64_t v797;
  uint64_t v798;
  uint64_t v799;
  uint64_t v800;
  uint64_t v801;
  uint64_t v802;
  uint64_t v803;
  uint64_t v804;
  uint64_t v805;
  uint64_t v806;
  uint64_t v807;
  uint64_t v808;
  uint64_t v809;
  uint64_t v810;
  uint64_t v811;
  uint64_t v812;
  const char *v813;
  uint64_t v814;
  uint64_t v815;
  uint64_t v816;
  uint64_t v817;
  uint64_t v818;
  uint64_t v819;
  uint64_t v820;
  uint64_t v821;
  uint64_t v822;
  uint64_t v823;
  uint64_t v824;
  uint64_t v825;
  uint64_t v826;
  uint64_t v827;
  uint64_t v828;
  uint64_t v829;
  uint64_t v830;
  uint64_t v831;
  uint64_t v832;
  uint64_t v833;
  uint64_t v834;
  uint64_t v835;
  uint64_t v836;
  uint64_t v837;
  uint64_t v838;
  uint64_t v839;
  uint64_t v840;
  uint64_t v841;
  uint64_t v842;
  uint64_t v843;
  uint64_t v844;
  uint64_t v845;
  uint64_t v846;
  uint64_t v847;
  uint64_t v848;
  uint64_t v849;
  uint64_t v850;
  uint64_t v851;
  uint64_t v852;
  uint64_t v853;
  uint64_t v854;
  uint64_t v855;
  uint64_t v856;
  uint64_t v857;
  uint64_t v858;
  uint64_t v859;
  uint64_t v860;
  uint64_t v861;
  uint64_t v862;
  uint64_t v863;
  uint64_t v864;
  uint64_t v865;
  uint64_t v866;
  uint64_t v867;
  uint64_t v868;
  uint64_t v869;
  uint64_t v870;
  uint64_t v871;
  uint64_t v872;
  uint64_t v873;
  uint64_t v874;
  uint64_t v875;
  uint64_t v876;
  uint64_t v877;
  uint64_t v878;
  uint64_t v879;
  uint64_t v880;
  uint64_t v881;
  uint64_t v882;
  uint64_t v883;
  uint64_t v884;
  uint64_t v885;
  uint64_t v886;
  uint64_t v887;
  uint64_t v888;
  uint64_t v889;
  uint64_t v890;
  uint64_t v891;
  uint64_t v892;
  uint64_t v893;
  uint64_t v894;
  uint64_t v895;
  uint64_t v896;
  uint64_t v897;
  uint64_t v898;
  uint64_t v899;
  uint64_t v900;
  uint64_t v901;
  uint64_t v902;
  uint64_t v903;
  uint64_t v904;
  uint64_t v905;
  uint64_t v906;
  uint64_t v907;
  uint64_t v908;
  BOOL v909;
  const __CFDictionary *v910;
  const __CFArray *v911;
  const __CFArray *v912;
  CFTypeID v913;
  uint64_t v914;
  uint64_t v915;
  uint64_t v916;
  uint64_t v917;
  uint64_t v918;
  uint64_t v919;
  const __CFData *v920;
  const __CFData *v921;
  CFTypeID v922;
  CFTypeID v923;
  const UInt8 *v924;
  uint64_t v925;
  uint64_t v926;
  uint64_t v927;
  uint64_t v928;
  uint64_t v929;
  uint64_t v930;
  uint64_t v931;
  uint64_t v932;
  uint64_t v933;
  uint64_t v934;
  uint64_t v935;
  uint64_t v936;
  uint64_t v937;
  uint64_t v938;
  uint64_t v939;
  uint64_t v940;
  uint64_t v941;
  uint64_t v942;
  uint64_t v943;
  uint64_t v944;
  uint64_t v945;
  uint64_t v946;
  uint64_t v947;
  uint64_t v948;
  uint64_t v949;
  uint64_t v950;
  uint64_t v951;
  uint64_t v952;
  uint64_t v953;
  uint64_t v954;
  __CFDictionary *v955;
  CFDataRef v956;
  uint64_t v957;
  __CFDictionary *v958;
  uint64_t v959;
  uint64_t v960;
  uint64_t v961;
  uint64_t v962;
  uint64_t v963;
  uint64_t v964;
  uint64_t v965;
  uint64_t v966;
  uint64_t v967;
  uint64_t v968;
  uint64_t v969;
  uint64_t v970;
  PDFLinearizer *v971;
  uint64_t v972;
  uint64_t v973;
  uint64_t v974;
  uint64_t v975;
  uint64_t v976;
  uint64_t v977;
  uint64_t v978;
  uint64_t v979;
  uint64_t v980;
  uint64_t v981;
  uint64_t v982;
  uint64_t v983;
  uint64_t v984;
  uint64_t v985;
  uint64_t v986;
  uint64_t v987;
  uint64_t v988;
  uint64_t v989;
  uint64_t v990;
  uint64_t v991;
  uint64_t v992;
  uint64_t v993;
  uint64_t v994;
  uint64_t v995;
  uint64_t v996;
  uint64_t v997;
  uint64_t v998;
  uint64_t v999;
  uint64_t v1000;
  uint64_t v1001;
  uint64_t v1002;
  uint64_t v1003;
  uint64_t v1004;
  uint64_t v1005;
  uint64_t v1006;
  uint64_t v1007;
  uint64_t v1008;
  uint64_t v1009;
  uint64_t v1010;
  uint64_t v1011;
  uint64_t v1012;
  uint64_t v1013;
  uint64_t v1014;
  std::__shared_weak_count *v1015;
  __int128 v1016;
  uint64_t *v1017;
  uint64_t v1018;
  unint64_t v1019;
  CGPDFArrayRef array[2];
  CGPDFObjectRef v1021[2];
  void (*v1022)(uint64_t, uint64_t);
  void *v1023;
  CGPDFArrayRef *v1024;
  CGPDFArrayRef value[2];
  __int128 v1026;
  void (*v1027)(uint64_t);
  const char *v1028;
  _QWORD **v1029;
  _QWORD *v1030[2];
  CGPDFObjectRef v1031;
  CGPDFInteger v1032[2];

  if (*(_BYTE *)(a1 + 72))
    return;
  if (!*(_QWORD *)(a1 + 568))
    goto LABEL_55;
  v9 = (CGPDFArray *)PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
  v10 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
  v11 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
  v12 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
  PDFDocumentBeginObject(a1, v10, v13, v14, v15, v16, v17, v18);
  PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"<< /Type /StructTreeRoot /K %R /ParentTree %R /IDTree %R>>", v19, v20, v21, v22, v23, v24, (uint64_t)v9);
  PDFDocumentEndObject(a1, v25, v26, v27, v28, v29, v30, v31);
  *(_QWORD *)(a1 + 576) = v10;
  v1019 = -1;
  CGCFDictionaryGetNumber(*(const __CFDictionary **)(a1 + 568), CFSTR("TagNodeObjectRefID"), kCFNumberSInt64Type, &v1019);
  v32 = *(float **)(a1 + 288);
  value[0] = (CGPDFArrayRef)v1019;
  value[1] = v9;
  std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v32, v1019, value);
  PDFDocumentEmitTaggedNodeStructure((PDFDocument *)a1, (unint64_t)v9, *(__CFDictionary **)(a1 + 568), v10);
  value[0] = 0;
  if (CGPDFDictionaryGetArray(*(CGPDFDictionaryRef *)(a1 + 496), "Nums", value))
  {
    PDFDocumentBeginObject(a1, v11, v33, v34, v35, v36, v37, v38);
    PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"<</Nums[", v39, v40, v41, v42, v43, v44, v972);
    v1021[0] = 0;
    array[0] = 0;
    v1032[0] = -1;
    if (value[0])
    {
      v51 = *((_QWORD *)value[0] + 2);
      if (v51)
      {
        for (i = 0; i != v51; ++i)
        {
          if (CGPDFArrayGetArray(value[0], i, array))
          {
            if (array[0])
            {
              v53 = *((_QWORD *)array[0] + 2);
              if (v53)
              {
                PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"[", v45, v46, v47, v48, v49, v50, v973);
                v54 = 0;
                while (1)
                {
                  v1031 = 0;
                  CGPDFArrayGetObject(array[0], v54, &v1031);
                  v61 = v1031;
                  if (v1031 && *((_DWORD *)v1031 + 2) != 1)
                  {
                    v64 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(_QWORD **)(a1 + 304), v1032[0]);
                    if (v64)
                      v65 = v64[3];
                    else
                      LODWORD(v65) = -1;
                    v66 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(_QWORD **)(a1 + 296), v54 | ((unint64_t)v65 << 32));
                    if (!v66 || (v67 = v66[3], v67 == -1))
                    {
                      v68 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(_QWORD **)(a1 + 288), *((_QWORD *)v61 + 2));
                      if (!v68)
                        goto LABEL_23;
                      v67 = v68[3];
                      if (v67 == -1)
                        goto LABEL_23;
                    }
                    v62 = *(_BYTE ***)(a1 + 32);
                    v974 = v67;
                    v63 = "%R";
                  }
                  else
                  {
                    v62 = *(_BYTE ***)(a1 + 32);
                    v63 = "null";
                  }
                  PDFWriterPrintf(v62, (uint64_t)v63, v55, v56, v57, v58, v59, v60, v974);
LABEL_23:
                  if (v53 == ++v54)
                  {
                    v69 = *(_BYTE ***)(a1 + 32);
                    v70 = "]";
                    goto LABEL_27;
                  }
                }
              }
            }
          }
          else if (CGPDFArrayGetInteger(value[0], i, v1032))
          {
            v69 = *(_BYTE ***)(a1 + 32);
            v974 = v1032[0];
            v70 = "%d";
LABEL_27:
            PDFWriterPrintf(v69, (uint64_t)v70, v55, v56, v57, v58, v59, v60, v974);
          }
          else if (CGPDFArrayGetObject(value[0], i, v1021))
          {
            v71 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(_QWORD **)(a1 + 288), *((_QWORD *)v1021[0] + 2));
            if (v71)
            {
              v72 = v71[3];
              if (v72 != -1)
                PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"%R", v45, v46, v47, v48, v49, v50, v72);
            }
          }
        }
      }
    }
    PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"]>>", v45, v46, v47, v48, v49, v50, v973);
    PDFDocumentEndObject(a1, v73, v74, v75, v76, v77, v78, v79);
  }
  value[0] = 0;
  if (CGPDFDictionaryGetArray(*(CGPDFDictionaryRef *)(a1 + 504), "Names", value))
  {
    PDFDocumentBeginObject(a1, v12, a3, a4, a5, a6, a7, a8);
    PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"<</Names[", v81, v82, v83, v84, v85, v86, v972);
    v1021[0] = 0;
    if (value[0])
    {
      v93 = *((_QWORD *)value[0] + 2);
      if (v93)
      {
        for (j = 0; j != v93; ++j)
        {
          if (CGPDFArrayGetObject(value[0], j, v1021) && v1021[0])
          {
            v95 = *((_DWORD *)v1021[0] + 2);
            if (v95 == 8)
            {
              v104 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(*(_QWORD **)(a1 + 288), *((_QWORD *)v1021[0] + 2));
              if (v104)
              {
                v105 = v104[3];
                if (v105 != -1)
                  PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"%R", v87, v88, v89, v90, v91, v92, v105);
              }
            }
            else if (v95 == 6)
            {
              array[0] = 0;
              CGPDFArrayGetString(value[0], j, array);
              v102 = array[0];
              if (array[0])
              {
                if (*((_QWORD *)array[0] + 3))
                  decrypt_string((uint64_t)array[0]);
                v103 = (uint64_t)v102 + 80;
              }
              else
              {
                v103 = 0;
              }
              PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"(%s)", v96, v97, v98, v99, v100, v101, v103);
            }
          }
        }
      }
    }
    PDFWriterPrintf(*(_BYTE ***)(a1 + 32), (uint64_t)"]>>", v87, v88, v89, v90, v91, v92, v975);
    PDFDocumentEndObject(a1, v106, v107, v108, v109, v110, v111, v112);
  }
  if (*(_QWORD *)(a1 + 568))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", v80, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEmitStructureTree");
  }
  else
  {
LABEL_55:
    if (*(_QWORD *)(a1 + 600) != *(_QWORD *)(a1 + 608))
    {
      v119 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
      *(_QWORD *)(a1 + 576) = v119;
      if (*(uint64_t *)(a1 + 592) < 1)
        v120 = 0;
      else
        v120 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
      v121 = *(uint64_t **)(a1 + 600);
      v122 = *(uint64_t **)(a1 + 608);
      while (v121 != v122)
      {
        v123 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
        v124 = *v121++;
        PDFStructureElement::Emit((PDFStructureElement *)(v124 + 16), (PDFDocument *)a1, v119, v123, v125, v126, v127, v128);
      }
      PDFDocumentBeginObject(a1, v119, v113, v114, v115, v116, v117, v118);
      PDFDocumentPrintf(a1, (uint64_t)"<<", v129, v130, v131, v132, v133, v134, v972);
      PDFDocumentPrintf(a1, (uint64_t)"/Type /StructTreeRoot", v135, v136, v137, v138, v139, v140, v976);
      PDFDocumentPrintf(a1, (uint64_t)"/K", v141, v142, v143, v144, v145, v146, v977);
      v154 = *(_QWORD *)(a1 + 608);
      v155 = *(_QWORD *)(a1 + 600);
      if (v154 - v155 == 8)
      {
        if (v155 == v154)
          goto LABEL_438;
        PDFDocumentPrintf(a1, (uint64_t)"%R", v148, v149, v150, v151, v152, v153, *(_QWORD *)(*(_QWORD *)v155 + 64));
      }
      else
      {
        PDFDocumentPrintf(a1, (uint64_t)"[", v148, v149, v150, v151, v152, v153, v978);
        v168 = *(uint64_t **)(a1 + 600);
        v169 = *(uint64_t **)(a1 + 608);
        while (v168 != v169)
        {
          v170 = *v168++;
          PDFDocumentPrintf(a1, (uint64_t)"%R", v162, v163, v164, v165, v166, v167, *(_QWORD *)(v170 + 64));
        }
        PDFDocumentPrintf(a1, (uint64_t)"]", v162, v163, v164, v165, v166, v167, v980);
      }
      if (v120)
      {
        PDFDocumentPrintf(a1, (uint64_t)"/ParentTree %R", v156, v157, v158, v159, v160, v161, v120);
        PDFDocumentPrintf(a1, (uint64_t)"/ParentTreeNextKey %d", v171, v172, v173, v174, v175, v176, *(_QWORD *)(a1 + 592));
      }
      PDFDocumentPrintf(a1, (uint64_t)">>", v156, v157, v158, v159, v160, v161, v979);
      PDFDocumentEndObject(a1, v177, v178, v179, v180, v181, v182, v183);
      value[0] = 0;
      value[1] = (CGPDFArrayRef)value;
      *(_QWORD *)&v1026 = 0x4812000000;
      *((_QWORD *)&v1026 + 1) = __Block_byref_object_copy__5309;
      v1027 = __Block_byref_object_dispose__5310;
      v1030[0] = 0;
      v1030[1] = 0;
      v1028 = "";
      v1029 = v1030;
      v190 = *(uint64_t **)(a1 + 600);
      v191 = *(uint64_t **)(a1 + 608);
      if (v190 != v191)
      {
        v192 = (CGPDFObject *)MEMORY[0x1E0C809B0];
        do
        {
          v193 = *v190;
          v1021[0] = v192;
          v1021[1] = (CGPDFObjectRef)3221225472;
          v1022 = ___ZL28PDFDocumentEmitStructureTreeP11PDFDocument_block_invoke;
          v1023 = &unk_1E1644FF0;
          v1024 = value;
          PDFStructureElement::EnumerateMarkedContentItemsRecursively(v193 + 16, v1021);
          ++v190;
        }
        while (v190 != v191);
      }
      if (v120)
      {
        PDFDocumentBeginObject(a1, v120, v184, v185, v186, v187, v188, v189);
        PDFDocumentPrintf(a1, (uint64_t)"<<", v194, v195, v196, v197, v198, v199, v972);
        PDFDocumentPrintf(a1, (uint64_t)"/Nums", v200, v201, v202, v203, v204, v205, v981);
        PDFDocumentPrintf(a1, (uint64_t)"[", v206, v207, v208, v209, v210, v211, v982);
        v219 = (char *)*((_QWORD *)value[1] + 6);
        v220 = (char *)value[1] + 56;
        if (v219 != (char *)value[1] + 56)
        {
          v221 = 0;
          do
          {
            while (1)
            {
              v222 = *((_QWORD *)v219 + 4);
              if (v221 >= v222)
                break;
              CGPostError((uint64_t)"%s: Object reference with struct parent of %ld not added to a structure element", v212, v213, v214, v215, v216, v217, v218, (char)"PDFDocumentEmitStructureTree");
              PDFDocumentPrintf(a1, (uint64_t)"%d null", v223, v224, v225, v226, v227, v228, v221++);
            }
            PDFDocumentPrintf(a1, (uint64_t)"%d", v213, v214, v215, v216, v217, v218, *((_QWORD *)v219 + 4));
            array[0] = (CGPDFArrayRef)a1;
            array[1] = (CGPDFArrayRef)a1;
            v229 = *((unsigned int *)v219 + 16);
            if ((_DWORD)v229 == -1)
              std::__throw_bad_variant_access[abi:se180100]();
            v1032[0] = (CGPDFInteger)array;
            ((void (*)(CGPDFInteger *, char *))off_1E1645030[v229])(v1032, v219 + 40);
            v230 = (char *)*((_QWORD *)v219 + 1);
            if (v230)
            {
              do
              {
                v231 = v230;
                v230 = *(char **)v230;
              }
              while (v230);
            }
            else
            {
              do
              {
                v231 = (char *)*((_QWORD *)v219 + 2);
                v337 = *(_QWORD *)v231 == (_QWORD)v219;
                v219 = v231;
              }
              while (!v337);
            }
            v221 = v222 + 1;
            v219 = v231;
          }
          while (v231 != v220);
        }
        PDFDocumentPrintf(a1, (uint64_t)"]", v213, v214, v215, v216, v217, v218, v983);
        PDFDocumentPrintf(a1, (uint64_t)">>", v232, v233, v234, v235, v236, v237, v984);
        PDFDocumentEndObject(a1, v238, v239, v240, v241, v242, v243, v244);
      }
      _Block_object_dispose(value, 8);
      std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(v1030[0]);
    }
  }
  if (*(_QWORD *)(a1 + 64))
  {
    array[0] = 0;
    if (*(_BYTE *)(a1 + 91))
    {
      if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
        dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_5315);
      v245 = create_pdfa_xmp_metadata(PDFDocument *)::f();
      if (v245)
      {
        v246 = (const void *)v245;
        for (k = 0; k != 10; k += 2)
        {
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_126_5316);
          if ((create_pdfa_xmp_metadata(PDFDocument *)::f(v246, off_1E1645060[k], off_1E1645060[k + 1], 0) & 1) == 0)
            goto LABEL_148;
        }
        String = PDFInfoGetString(*(const __CFDictionary **)(a1 + 64), CFSTR("kCGPDFContextTitle"), CFSTR("Title"));
        if (String)
        {
          v249 = String;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_130);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("dc:title[\"x-default\"]"), v249);
        }
        v250 = PDFInfoGetString(*(const __CFDictionary **)(a1 + 64), CFSTR("kCGPDFContextAuthor"), CFSTR("Author"));
        if (v250)
        {
          v251 = v250;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_136);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("dc:creator[0]"), v251);
        }
        v252 = PDFInfoGetString(*(const __CFDictionary **)(a1 + 64), CFSTR("kCGPDFContextSubject"), CFSTR("Subject"));
        if (v252)
        {
          v253 = v252;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_141);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("dc:description[\"x-default\"]"), v253);
        }
        v254 = PDFInfoCopyKeywordsString(*(_QWORD *)(a1 + 64));
        if (v254)
        {
          v255 = v254;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_144);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("pdf:Keywords"), v255);
          CFRelease(v255);
        }
        v256 = PDFInfoGetString(*(const __CFDictionary **)(a1 + 64), CFSTR("kCGPDFContextCreator"), CFSTR("Creator"));
        if (v256)
        {
          v257 = v256;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_149_5323);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("xmp:CreatorTool"), v257);
        }
        v258 = PDFInfoCopyProducer(*(const __CFDictionary ***)(a1 + 64));
        if (v258)
        {
          v259 = v258;
          if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
            dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_152_5325);
          create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("pdf:Producer"), v259);
          CFRelease(v259);
        }
        v260 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
        ISO8601Formatter = CFDateFormatterCreateISO8601Formatter((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0x773uLL);
        if (ISO8601Formatter)
        {
          v262 = ISO8601Formatter;
          NowDate = (const __CFDate *)PDFInfoGetNowDate(*(_QWORD **)(a1 + 64));
          StringWithDate = CFDateFormatterCreateStringWithDate(v260, v262, NowDate);
          if (StringWithDate)
          {
            v265 = StringWithDate;
            if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
              dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_155);
            create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("xmp:CreateDate"), v265);
            if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
              dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_158_5327);
            create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("xmp:ModifyDate"), v265);
            CFRelease(v265);
          }
          CFRelease(v262);
        }
        if (create_pdfa_xmp_metadata(PDFDocument *)::predicate != -1)
          dispatch_once(&create_pdfa_xmp_metadata(PDFDocument *)::predicate, &__block_literal_global_161_5328);
        create_pdfa_xmp_metadata(PDFDocument *)::f(v246, 0, CFSTR("pdfaid:part"), CFSTR("2"));
        if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__10_ != -1)
          dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__10_, &__block_literal_global_166_5329);
        _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__10_(v246, 0, CFSTR("pdfaid:conformance"), CFSTR("B"));
        value[0] = 0;
        ID = PDFDocumentGetID(a1, value);
        v267 = (const UInt8 *)malloc_type_malloc((2 * (uint64_t)value[0]) | 1, 0x20E20AFDuLL);
        if (v267)
        {
          v268 = (UInt8 *)v267;
          if (value[0])
          {
            v269 = 0;
            v270 = v267 + 1;
            do
            {
              *(v270 - 1) = a0123456789abcd[(unint64_t)*((unsigned __int8 *)v269 + ID) >> 4];
              *v270 = a0123456789abcd[*((_BYTE *)v269 + ID) & 0xF];
              v270 += 2;
              v269 = (CGPDFArray *)((char *)v269 + 1);
            }
            while (v269 < value[0]);
            v271 = 2 * (uint64_t)value[0];
          }
          else
          {
            v271 = 0;
          }
          v272 = CFStringCreateWithBytes(v260, v267, v271, 0x600u, 0);
          if (v272)
          {
            v273 = v272;
            if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__11_ != -1)
              dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__11_, &__block_literal_global_171);
            _ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__11_(v246, 0, CFSTR("xmpMM:DocumentID"), v273);
            CFRelease(v273);
          }
          free(v268);
        }
        if (_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__12_ != -1)
          dispatch_once(&_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE9predicate__12_, &__block_literal_global_174_5333);
        v274 = (const void *)_ZZL24create_pdfa_xmp_metadataP11PDFDocumentE1f__12_(v246, 0);
        CFRelease(v246);
        if (v274)
        {
          Mutable = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CFDictionarySetValue(Mutable, CFSTR("/Type"), CFSTR("/Metadata"));
          CFDictionarySetValue(Mutable, CFSTR("/Subtype"), CFSTR("/XML"));
          CFDictionarySetValue(Mutable, CFSTR("/%Stream"), v274);
          PDFDocumentAddCatalogEntry(a1, CFSTR("/Metadata"), Mutable);
          CFRelease(Mutable);
          v246 = v274;
LABEL_148:
          CFRelease(v246);
        }
      }
    }
    v276 = *(_QWORD *)(a1 + 456);
    if (!v276)
    {
      v302 = 0;
      goto LABEL_238;
    }
    v277 = *(_QWORD **)(v276 + 24);
    if (!v277 || *(_QWORD *)(*(_QWORD *)(v276 + 24) + 8) == *v277)
    {
      PDFDocumentBeginPage(*(_QWORD **)v276, 0);
      PDFDocumentEndPage(*(_QWORD *)v276);
    }
    v278 = *(_QWORD *)(v276 + 48);
    v279 = *(_QWORD *)(v276 + 56);
    if (v279 != v278)
    {
LABEL_211:
      while (v278 != v279)
      {
        v314 = *(unint64_t **)v278;
        v313 = *(std::__shared_weak_count **)(v278 + 8);
        if (v313)
        {
          p_shared_owners = (unint64_t *)&v313->__shared_owners_;
          do
            v316 = __ldxr(p_shared_owners);
          while (__stxr(v316 + 1, p_shared_owners));
        }
        v317 = *(_QWORD *)(v278 + 16);
        PDFDocumentBeginObject(*(_QWORD *)v276, *v314, a3, a4, a5, a6, a7, a8);
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"<<", v318, v319, v320, v321, v322, v323, v972);
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"/Type /Pages", v324, v325, v326, v327, v328, v329, v985);
        v336 = *(_QWORD *)v276;
        if (v317)
        {
          PDFDocumentPrintPageParentReference(v336, (uint64_t)"/Parent %R", v317, v331, v332, v333, v334, v335);
        }
        else if (!*(_BYTE *)(v336 + 90))
        {
          v337 = *(double *)(v336 + 96) == INFINITY || *(double *)(v336 + 104) == INFINITY;
          if (!v337)
          {
            v338 = *(_OWORD *)(v336 + 112);
            *(_OWORD *)value = *(_OWORD *)(v336 + 96);
            v1026 = v338;
            PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"/MediaBox %r", v330, v331, v332, v333, v334, v335, (uint64_t)value);
            v336 = *(_QWORD *)v276;
          }
          v340 = *(double *)(v336 + 128);
          v341 = *(double *)(v336 + 136);
          v339 = (_OWORD *)(v336 + 128);
          if (v340 != INFINITY && v341 != INFINITY)
          {
            v343 = v339[1];
            *(_OWORD *)value = *v339;
            v1026 = v343;
            PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"/CropBox %r", v330, v331, v332, v333, v334, v335, (uint64_t)value);
          }
        }
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"/Count %d", v330, v331, v332, v333, v334, v335, v314[1]);
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"/Kids [", v344, v345, v346, v347, v348, v349, v986);
        if (v314[2])
        {
          v356 = 0;
          do
            PDFDocumentPrintReference(*(_QWORD *)v276, (uint64_t)"%R", v314[v356++ + 3], v351, v352, v353, v354, v355);
          while (v356 < v314[2]);
        }
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)"]", v350, v351, v352, v353, v354, v355, v987);
        PDFDocumentPrintf(*(_QWORD *)v276, (uint64_t)">>", v357, v358, v359, v360, v361, v362, v988);
        PDFDocumentEndObject(*(_QWORD *)v276, v363, v364, v365, v366, v367, v368, v369);
        if (v313)
        {
          v370 = (unint64_t *)&v313->__shared_owners_;
          do
            v371 = __ldaxr(v370);
          while (__stlxr(v371 - 1, v370));
          if (!v371)
          {
            ((void (*)(std::__shared_weak_count *))v313->__on_zero_shared)(v313);
            std::__shared_weak_count::__release_weak(v313);
          }
        }
        v278 += 24;
      }
      v302 = *(_QWORD *)(v276 + 72);
LABEL_238:
      v372 = *(_QWORD *)(a1 + 48);
      if (v372 && (v373 = PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)v372 + 464))) != 0)
      {
        v374 = v373;
        Count = CFArrayGetCount(*(CFArrayRef *)(v372 + 16));
        v382 = (uint64_t *)malloc_type_calloc(1uLL, 8 * Count, 0x2004093837F09uLL);
        if (v382)
        {
          PDFDocumentBeginObject(*(_QWORD *)v372, v374, v376, v377, v378, v379, v380, v381);
          PDFDocumentPrintf(*(_QWORD *)v372, (uint64_t)"[", v383, v384, v385, v386, v387, v388, v972);
          v1014 = v302;
          v1017 = (uint64_t *)v374;
          if (Count)
          {
            for (m = 0; m != Count; ++m)
            {
              ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v372 + 16), m);
              v397 = *(_QWORD *)v372;
              PDFDocumentPrintf(*(_QWORD *)v372, (uint64_t)"<<", v398, v399, v400, v401, v402, v403, v989);
              PDFDocumentPrintf(v397, (uint64_t)"/Type /OutputIntent", v404, v405, v406, v407, v408, v409, v990);
              v410 = (const __CFString *)get_string(ValueAtIndex, CFSTR("S"));
              Length = CFStringGetLength(v410);
              v412 = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u) + 1;
              v413 = (char *)malloc_type_malloc(v412, 0xA7E497E8uLL);
              if (v413)
              {
                v414 = v413;
                if (CFStringGetCString(v410, v413, v412, 0x8000100u))
                  PDFDocumentPrintf(v397, (uint64_t)"/S /%N", v415, v416, v417, v418, v419, v420, (uint64_t)v414);
                free(v414);
              }
              v421 = get_string(ValueAtIndex, CFSTR("OutputConditionIdentifier"));
              PDFDocumentPrintf(v397, (uint64_t)"/OutputConditionIdentifier %S", v422, v423, v424, v425, v426, v427, (uint64_t)v421);
              v428 = get_string(ValueAtIndex, CFSTR("OutputCondition"));
              if (v428)
                PDFDocumentPrintf(v397, (uint64_t)"/OutputCondition %T", v429, v430, v431, v432, v433, v434, (uint64_t)v428);
              v435 = get_string(ValueAtIndex, CFSTR("RegistryName"));
              if (v435)
                PDFDocumentPrintf(v397, (uint64_t)"/RegistryName %S", v436, v437, v438, v439, v440, v441, (uint64_t)v435);
              v442 = get_string(ValueAtIndex, CFSTR("Info"));
              if (v442)
                PDFDocumentPrintf(v397, (uint64_t)"/Info %T", v443, v444, v445, v446, v447, v448, (uint64_t)v442);
              else
                PDFDocumentPrintf(v397, (uint64_t)"/Info (none)", v443, v444, v445, v446, v447, v448, v991);
              v449 = CFDictionaryGetValue(ValueAtIndex, CFSTR("DestOutputProfile"));
              v456 = v449;
              if (v449)
              {
                v457 = CFGetTypeID(v449);
                if (kCGColorSpaceSceneReferredDerivative_block_invoke_once != -1)
                  dispatch_once(&kCGColorSpaceSceneReferredDerivative_block_invoke_once, &__block_literal_global_77);
                if (v457 == CGColorSpaceGetTypeID_type_id
                  && (CGColorSpaceGetType(v456) == 6 || CGColorSpaceGetType(v456) == 11))
                {
                  v456 = PDFColorSpaceCreate(v397, v456, 0);
                  PDFDocumentPrintf(v397, (uint64_t)"/DestOutputProfile", v458, v459, v460, v461, v462, v463, v992);
                  PDFColorSpaceEmitReference(v456, v464, v465, v466, v467, v468, v469, v470);
                }
                else
                {
                  v456 = 0;
                }
              }
              PDFDocumentPrintf(v397, (uint64_t)">>", v450, v451, v452, v453, v454, v455, v992);
              v382[m] = (uint64_t)v456;
            }
            PDFDocumentPrintf(*(_QWORD *)v372, (uint64_t)"]", v471, v472, v473, v474, v475, v476, v989);
            PDFDocumentEndObject(*(_QWORD *)v372, v477, v478, v479, v480, v481, v482, v483);
            v484 = v382;
            while (1)
            {
              v485 = *v484;
              if (*v484)
              {
                Type = CGColorSpaceGetType(*(_QWORD **)(v485 + 24));
                if ((Type - 10) >= 2 && Type != 6)
                  goto LABEL_439;
                v487 = *(_QWORD *)(v485 + 16);
                if (!v487)
                  _CGHandleAssert("PDFColorSpaceEmitICCDataStream", 408, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ColorSpaces/PDFColorSpace.c", "cs->object_number != PDFObjectNumberInvalid", "invalid PDF object number", v151, v152, v153, v972);
                v488 = PDFStreamCreateWithObjectNumber(*(_QWORD *)(v485 + 8), v487);
                PDFDocumentBeginObject(*v488, v488[1], v489, v490, v491, v492, v493, v494);
                PDFDocumentPrintf(*v488, (uint64_t)"<<", v495, v496, v497, v498, v499, v500, v972);
                v507 = *(_QWORD *)(v485 + 24);
                if (v507)
                  v507 = *(_QWORD *)(*(_QWORD *)(v507 + 24) + 40);
                PDFDocumentPrintf(*(_QWORD *)(v485 + 8), (uint64_t)"/N %z", v501, v502, v503, v504, v505, v506, v507);
                PDFStreamBeginData((CGDataConsumerRef)v488);
                v508 = CGColorSpaceCopyICCData(*(CGColorSpaceRef *)(v485 + 24));
                BytePtr = CFDataGetBytePtr(v508);
                v510 = CFDataGetLength(v508);
                CGDataConsumerPutBytes(v488[3], (uint64_t)BytePtr, v510);
                CFRelease(v508);
                PDFStreamEndData(v488);
                PDFStreamEnd((CFDataRef *)v488);
                PDFStreamRelease((uint64_t)v488);
                PDFColorSpaceRelease(*v484);
              }
              ++v484;
              if (!--Count)
                goto LABEL_278;
            }
          }
          PDFDocumentPrintf(*(_QWORD *)v372, (uint64_t)"]", v389, v390, v391, v392, v393, v394, v989);
          PDFDocumentEndObject(*(_QWORD *)v372, v511, v512, v513, v514, v515, v516, v517);
LABEL_278:
          free(v382);
          v302 = v1014;
          v382 = v1017;
        }
      }
      else
      {
        v382 = 0;
      }
      v1018 = PDFXRefTableAddObject(*(_QWORD **)(a1 + 464));
      if (v1018)
      {
        PDFDocumentBeginObject(a1, v1018, v518, v519, v520, v521, v522, v523);
        PDFDocumentPrintf(a1, (uint64_t)"<<", v524, v525, v526, v527, v528, v529, v972);
        PDFDocumentPrintf(a1, (uint64_t)"/Type /Catalog", v530, v531, v532, v533, v534, v535, v993);
        v541 = *(const __CFDictionary **)(a1 + 312);
        if (v541)
          CFDictionaryApplyFunction(v541, (CFDictionaryApplierFunction)emit_catalog_entries, (void *)a1);
        PDFDocumentPrintReference(a1, (uint64_t)"/Pages %R", v302, v536, v537, v538, v539, v540);
        v548 = *(_DWORD *)(a1 + 4);
        if (v548 < 2)
        {
          if (v548 == 1 && *(int *)(a1 + 8) >= 4)
            PDFDocumentPrintf(a1, (uint64_t)"/Version /%d.%d", v542, v543, v544, v545, v546, v547, 1);
        }
        else
        {
          PDFDocumentPrintf(a1, (uint64_t)"/Version /%d.%d", v542, v543, v544, v545, v546, v547, *(unsigned int *)(a1 + 4));
        }
        if (v382)
          PDFDocumentPrintReference(a1, (uint64_t)"/OutputIntents %R ", (uint64_t)v382, v543, v544, v545, v546, v547);
        if (*(_QWORD *)(a1 + 576))
        {
          PDFDocumentPrintf(a1, (uint64_t)"/MarkInfo << /Marked true >>", v542, v543, v544, v545, v546, v547, v994);
          PDFDocumentPrintReference(a1, (uint64_t)"/StructTreeRoot %R", *(_QWORD *)(a1 + 576), v549, v550, v551, v552, v553);
        }
        if (*(_QWORD *)(a1 + 520))
        {
          v554 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          v555 = *(const __CFDictionary **)(a1 + 312);
          if (v555)
            CFDictionaryApplyFunction(v555, (CFDictionaryApplierFunction)copy_catalog_entries, v554);
          CGCFDictionarySetInteger(v554, CFSTR("/Pages"), v302);
          if (v382)
            CGCFDictionarySetInteger(v554, CFSTR("/OutputIntents"), (int)v382);
          v556 = *(_QWORD *)(a1 + 576);
          if (v556)
            CGCFDictionarySetInteger(v554, CFSTR("/StructTreeRoot"), v556);
          v557 = *(_QWORD *)(a1 + 520);
          if (v557)
          {
            *(_QWORD *)(v557 + 256) = v1018;
            v558 = *(CFMutableDictionaryRef *)(v557 + 328);
            if (v558 != v554)
            {
              if (v558)
                CFRelease(v558);
              if (v554)
                CFRetain(v554);
              *(_QWORD *)(v557 + 328) = v554;
            }
          }
          CFRelease(v554);
        }
        PDFDocumentPrintf(a1, (uint64_t)">>", v542, v543, v544, v545, v546, v547, v994);
        PDFDocumentEndObject(a1, v559, v560, v561, v562, v563, v564, v565);
      }
      v566 = *(_QWORD *)(a1 + 416);
      if (v566)
        CFDictionaryApplyFunction(*(CFDictionaryRef *)(v566 + 8), (CFDictionaryApplierFunction)emitDestination, 0);
      v567 = *(_QWORD *)(a1 + 40);
      if (v567)
      {
        while (1)
        {
          v568 = CFArrayGetCount(*(CFArrayRef *)(v567 + 16));
          if (!v568)
            break;
          v569 = v568 - 1;
          v570 = (const __CFString *)CFArrayGetValueAtIndex(*(CFArrayRef *)(v567 + 16), v568 - 1);
          CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(v567 + 16), v569);
          v574 = CFDictionaryGetValue(*(CFDictionaryRef *)(v567 + 24), v570);
          if (!v574)
            _CGHandleAssert("write_top_level_object", 388, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Annotations/PDFMetaSet.c", "n != PDFObjectNumberInvalid", "invalid PDF object %lu", v571, v572, v573, 0);
          v575 = CFGetTypeID(v570);
          if (v575 == CFDictionaryGetTypeID()
            && (v576 = (const __CFData *)CFDictionaryGetValue((CFDictionaryRef)v570, CFSTR("/%Stream"))) != 0)
          {
            v577 = v576;
            v578 = (const __CFString *)CFDictionaryGetValue((CFDictionaryRef)v570, CFSTR("/Type"));
            if (v578)
              v579 = CFStringCompare(v578, CFSTR("/Metadata"), 0) == kCFCompareEqualTo;
            else
              v579 = 0;
            v600 = PDFStreamCreateWithObjectNumber(*(_QWORD *)(v567 + 8), (uint64_t)v574);
            v607 = v600;
            if (v600)
              *((_BYTE *)v600 + 65) = v579;
            PDFDocumentBeginObject(*v600, v600[1], v601, v602, v603, v604, v605, v606);
            PDFDocumentPrintf(*v607, (uint64_t)"<<", v608, v609, v610, v611, v612, v613, v972);
            CFDictionaryApplyFunction((CFDictionaryRef)v570, (CFDictionaryApplierFunction)write_dictionary_entry, (void *)v567);
            PDFStreamBeginData((CGDataConsumerRef)v607);
            v614 = CFDataGetBytePtr(v577);
            v615 = CFDataGetLength(v577);
            CGDataConsumerPutBytes(v607[3], (uint64_t)v614, v615);
            PDFStreamEndData(v607);
            PDFStreamEnd((CFDataRef *)v607);
            PDFStreamRelease((uint64_t)v607);
          }
          else
          {
            v580 = CFGetTypeID(v570);
            if (v580 == CFDataGetTypeID())
            {
              write_object((uint64_t *)v567, v570, v581, v582, v583, v584, v585, v586, v972);
            }
            else
            {
              PDFDocumentBeginObject(*(_QWORD *)(v567 + 8), (unint64_t)v574, v581, v582, v583, v584, v585, v586);
              write_object((uint64_t *)v567, v570, v587, v588, v589, v590, v591, v592, v972);
              PDFDocumentEndObject(*(_QWORD *)(v567 + 8), v593, v594, v595, v596, v597, v598, v599);
            }
          }
        }
      }
      emit_page_resources((PDFDocument *)a1);
      LOBYTE(v616) = 0;
      do
      {
        v617 = *(_QWORD *)(a1 + 336);
        if (v617)
        {
          v616 = *(_QWORD *)(v617 + 72);
          if (v616)
          {
            do
            {
              v618 = *(CGPDFArrayRef *)(v617 + 64);
              value[0] = *(CGPDFArrayRef *)(v617 + 56);
              v619 = value[0];
              value[1] = v618;
              *(_QWORD *)(v617 + 64) = 0;
              *(_QWORD *)(v617 + 72) = 0;
              *(_QWORD *)&v1026 = v616;
              *((_QWORD *)v618 + 2) = &value[1];
              *(_QWORD *)(v617 + 56) = v617 + 64;
              if (v619 != (CGPDFArrayRef)&value[1])
              {
                do
                {
                  (*(void (**)(_QWORD))(**((_QWORD **)v619 + 4) + 40))(*((_QWORD *)v619 + 4));
                  v620 = (_QWORD *)*((_QWORD *)v619 + 1);
                  if (v620)
                  {
                    do
                    {
                      v621 = (CGPDFArrayRef *)v620;
                      v620 = (_QWORD *)*v620;
                    }
                    while (v620);
                  }
                  else
                  {
                    do
                    {
                      v621 = (CGPDFArrayRef *)*((_QWORD *)v619 + 2);
                      v337 = *v621 == v619;
                      v619 = (CGPDFArrayRef)v621;
                    }
                    while (!v337);
                  }
                  v619 = (CGPDFArrayRef)v621;
                }
                while (v621 != &value[1]);
                v618 = value[1];
              }
              std::__tree<unsigned long>::destroy(v618);
              v616 = *(_QWORD *)(v617 + 72);
            }
            while (v616);
            LOBYTE(v616) = 1;
          }
        }
        v622 = v616;
        v623 = PDFColorSpaceSetEmitDefinitions(*(_QWORD *)(a1 + 328));
        v624 = PDFFunctionSetEmitDefinitions(*(_QWORD *)(a1 + 368));
        LOBYTE(v616) = 1;
      }
      while ((v622 & 1) != 0 || (v623 & 1) != 0 || v624);
      v630 = *(uint64_t **)(a1 + 64);
      if (!v630)
      {
LABEL_380:
        v742 = *(_QWORD *)(a1 + 56);
        if (v742
          && ((v743 = *(_QWORD *)(a1 + 32)) == 0 || (*(_QWORD *)(v743 + 8) = 0, (v742 = *(_QWORD *)(a1 + 56)) != 0)))
        {
          v745 = PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)v742 + 464));
          if (v745)
          {
            PDFDocumentBeginObject(*(_QWORD *)v742, v745, v744, v625, v626, v627, v628, v629);
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"<<", v746, v747, v748, v749, v750, v751, v972);
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/Filter /Standard", v752, v753, v754, v755, v756, v757, v997);
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/V %d", v758, v759, v760, v761, v762, v763, *(unsigned int *)(v742 + 8));
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/R %d", v764, v765, v766, v767, v768, v769, *(unsigned int *)(v742 + 12));
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/Length %d", v770, v771, v772, v773, v774, v775, *(_QWORD *)(v742 + 128));
            v782 = *(_DWORD *)(v742 + 8);
            if ((v782 - 4) >= 2)
            {
              if (v782 != 2)
                _CGHandleAssert("PDFSecurityHandlerEmitEncrypt", 1189, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/Encryption/PDFSecurityHandler.c", "0", "unhandled file version %d  (File too new?)", v779, v780, v781, *(_DWORD *)(v742 + 8));
            }
            else
            {
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/CF", v776, v777, v778, v779, v780, v781, v998);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"<<", v783, v784, v785, v786, v787, v788, v999);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/StdCF", v789, v790, v791, v792, v793, v794, v1000);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"<<", v795, v796, v797, v798, v799, v800, v1001);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/AuthEvent /DocOpen", v801, v802, v803, v804, v805, v806, v1002);
              if (*(_DWORD *)(v742 + 8) == 4)
                v813 = "/AESV2";
              else
                v813 = "/AESV3";
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/CFM %s", v807, v808, v809, v810, v811, v812, (uint64_t)v813);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/Length %d", v814, v815, v816, v817, v818, v819, *(_QWORD *)(v742 + 128) >> 3);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)">>", v820, v821, v822, v823, v824, v825, v1003);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)">>", v826, v827, v828, v829, v830, v831, v1004);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/StmF /StdCF", v832, v833, v834, v835, v836, v837, v1005);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/StrF /StdCF", v838, v839, v840, v841, v842, v843, v1006);
              PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/EncryptMetadata %b", v844, v845, v846, v847, v848, v849, *(unsigned __int8 *)(v742 + 136));
            }
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/O %X", v776, v777, v778, v779, v780, v781, 32);
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/U %X", v850, v851, v852, v853, v854, v855, 32);
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)"/P %d", v856, v857, v858, v859, v860, v861, *(unsigned int *)(v742 + 24));
            PDFDocumentPrintf(*(_QWORD *)v742, (uint64_t)">>", v862, v863, v864, v865, v866, v867, v1007);
            PDFDocumentEndObject(*(_QWORD *)v742, v868, v869, v870, v871, v872, v873, v874);
          }
        }
        else
        {
          v745 = 0;
        }
        v875 = *(_QWORD *)(a1 + 24);
        if (v875)
          v876 = *(_QWORD *)(v875 + 40);
        else
          v876 = 0;
        PDFXRefTableEmit(*(_BYTE **)(a1 + 464), v875, 0, v625, v626, v627, v628, v629);
        v883 = *(_QWORD *)(a1 + 464);
        if (v883)
          v884 = (uint64_t)(*(_QWORD *)(v883 + 24) - *(_QWORD *)(v883 + 16)) >> 4;
        else
          v884 = 0;
        PDFDocumentPrintf(a1, (uint64_t)"trailer\n", v877, v878, v879, v880, v881, v882, v972);
        PDFDocumentPrintf(a1, (uint64_t)"<<", v885, v886, v887, v888, v889, v890, v1008);
        PDFDocumentPrintf(a1, (uint64_t)"/Size %d", v891, v892, v893, v894, v895, v896, v884);
        PDFDocumentPrintReference(a1, (uint64_t)"/Root %R", v1018, v897, v898, v899, v900, v901);
        if (v745)
          PDFDocumentPrintReference(a1, (uint64_t)"/Encrypt %R", v745, v902, v903, v904, v905, v906);
        v907 = *(_QWORD *)(a1 + 64);
        if (v907)
        {
          v908 = *(_QWORD *)(v907 + 16);
          v909 = v908 == 0;
          if (!v908
            || (PDFDocumentPrintReference(a1, (uint64_t)"/Info %R", *(_QWORD *)(v907 + 16), v902, v903, v904, v905, v906),
                (v907 = *(_QWORD *)(a1 + 64)) != 0))
          {
            v910 = *(const __CFDictionary **)(v907 + 8);
            if (v910)
            {
              v911 = (const __CFArray *)CFDictionaryGetValue(v910, CFSTR("CGPDFContextDocumentID"));
              if (v911)
              {
                v912 = v911;
                v913 = CFGetTypeID(v911);
                if (v913 == CFArrayGetTypeID()
                  && CFArrayGetCount(v912) == 2
                  && (v920 = (const __CFData *)CFArrayGetValueAtIndex(v912, 0),
                      v921 = (const __CFData *)CFArrayGetValueAtIndex(v912, 1),
                      v922 = CFGetTypeID(v920),
                      v922 == CFDataGetTypeID())
                  && (v923 = CFGetTypeID(v921), v923 == CFDataGetTypeID())
                  && CFDataGetLength(v920) == 16
                  && CFDataGetLength(v921) == 16)
                {
                  v924 = CFDataGetBytePtr(v920);
                  CFDataGetBytePtr(v921);
                  array[0] = (CGPDFArrayRef)16;
                }
                else
                {
                  if (v912 != (const __CFArray *)*MEMORY[0x1E0C9B0D0])
                    pdf_error("Invalid value for kCGPDFContextDocumentID.");
                  array[0] = (CGPDFArrayRef)16;
                  v924 = (const UInt8 *)&emit_trailer(PDFDocument *)::md5;
                }
                goto LABEL_414;
              }
            }
          }
        }
        else
        {
          LODWORD(v908) = 0;
          v909 = 1;
        }
        v924 = (const UInt8 *)PDFDocumentGetID(a1, array);
LABEL_414:
        PDFDocumentPrintf(a1, (uint64_t)"/ID [", v914, v915, v916, v917, v918, v919, v1009);
        PDFDocumentPrintf(a1, (uint64_t)"%X", v925, v926, v927, v928, v929, v930, (uint64_t)array[0]);
        PDFDocumentPrintf(a1, (uint64_t)"%X", v931, v932, v933, v934, v935, v936, (uint64_t)array[0]);
        PDFDocumentPrintf(a1, (uint64_t)"]", v937, v938, v939, v940, v941, v942, v1010);
        PDFDocumentPrintf(a1, (uint64_t)">>\n", v943, v944, v945, v946, v947, v948, v1011);
        if (*(_QWORD *)(a1 + 520))
        {
          v955 = CFDictionaryCreateMutable(0, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CGCFDictionarySetInteger(v955, CFSTR("/Size"), v884);
          CGCFDictionarySetInteger(v955, CFSTR("/Root"), v1018);
          if (v745)
            CGCFDictionarySetInteger(v955, CFSTR("/Encrypt"), v745);
          if (!v909)
            CGCFDictionarySetInteger(v955, CFSTR("/Info"), v908);
          v956 = CFDataCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v924, (CFIndex)array[0]);
          CFDictionaryAddValue(v955, CFSTR("/ID"), v956);
          CFRelease(v956);
          v957 = *(_QWORD *)(a1 + 520);
          if (v957)
          {
            v958 = *(__CFDictionary **)(v957 + 320);
            if (v958 != v955)
            {
              if (v958)
                CFRelease(v958);
              if (v955)
                CFRetain(v955);
              *(_QWORD *)(v957 + 320) = v955;
            }
          }
          CFRelease(v955);
        }
        PDFDocumentPrintf(a1, (uint64_t)"startxref\n", v949, v950, v951, v952, v953, v954, v1012);
        PDFDocumentPrintf(a1, (uint64_t)"%O\n", v959, v960, v961, v962, v963, v964, v876);
        PDFDocumentPrintf(a1, (uint64_t)"%%%%EOF\n", v965, v966, v967, v968, v969, v970, v1013);
        goto LABEL_428;
      }
      if (v630[1])
      {
        v631 = PDFInfoCopyKeywordsString(*(_QWORD *)(a1 + 64));
        if (v631)
        {
          v632 = v631;
          v633 = PDFXRefTableAddObject(*(_QWORD **)(*v630 + 464));
          PDFDocumentBeginObject(*v630, v633, v634, v635, v636, v637, v638, v639);
          PDFDocumentPrintf(*v630, (uint64_t)"%T", v640, v641, v642, v643, v644, v645, (uint64_t)v632);
          PDFDocumentEndObject(*v630, v646, v647, v648, v649, v650, v651, v652);
          CFRelease(v632);
        }
        else
        {
          v633 = 0;
        }
        v653 = (const __CFDictionary *)v630[1];
        if (v653)
        {
          v654 = (const __CFArray *)CFDictionaryGetValue(v653, CFSTR("kCGPDFContextKeywords"));
          if (v654)
          {
            v655 = v654;
            v656 = CFGetTypeID(v654);
            if (v656 == CFArrayGetTypeID())
            {
              v657 = CFArrayGetCount(v655);
              if (v657 >= 1)
              {
                v658 = v657;
                MutableCopy = CFArrayCreateMutableCopy((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, v655);
                for (n = 0; n < v658; ++n)
                {
                  v661 = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, n);
                  v662 = CFGetTypeID(v661);
                  if (v662 != CFStringGetTypeID() || CFStringGetLength(v661) <= 0)
                  {
                    CFArrayRemoveValueAtIndex(MutableCopy, n);
                    --v658;
                    --n;
                  }
                }
                if (v658 >= 1)
                {
                  v663 = PDFXRefTableAddObject(*(_QWORD **)(*v630 + 464));
                  PDFDocumentBeginObject(*v630, v663, v664, v665, v666, v667, v668, v669);
                  PDFDocumentPrintf(*v630, (uint64_t)"[", v670, v671, v672, v673, v674, v675, v972);
                  for (ii = 0; ii != v658; ++ii)
                  {
                    v677 = CFArrayGetValueAtIndex(MutableCopy, ii);
                    PDFDocumentPrintf(*v630, (uint64_t)"%T", v678, v679, v680, v681, v682, v683, (uint64_t)v677);
                  }
                  CFRelease(MutableCopy);
                  PDFDocumentPrintf(*v630, (uint64_t)"]", v684, v685, v686, v687, v688, v689, v995);
                  PDFDocumentEndObject(*v630, v690, v691, v692, v693, v694, v695, v696);
                  goto LABEL_360;
                }
                CFRelease(MutableCopy);
              }
            }
          }
        }
      }
      else
      {
        v633 = 0;
      }
      v663 = 0;
LABEL_360:
      v697 = PDFXRefTableAddObject(*(_QWORD **)(*v630 + 464));
      v630[2] = v697;
      PDFDocumentBeginObject(*v630, v697, v698, v699, v700, v701, v702, v703);
      PDFDocumentPrintf(*v630, (uint64_t)"<<", v704, v705, v706, v707, v708, v709, v972);
      v710 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v630, CFSTR("kCGPDFContextTitle"), CFSTR("Title"));
      v711 = *(_QWORD *)(*v630 + 48);
      if (!v710)
      {
        if (PDFOutputIntentGetIsX3(*(_BYTE **)(*v630 + 48)))
          v710 = CFSTR("Untitled");
        else
          v710 = 0;
      }
      emit_key_string(v630, CFSTR("/Title"), v710);
      v712 = (const __CFString *)PDFInfoCopyProducer((const __CFDictionary **)v630);
      if (v712)
      {
        v713 = v712;
        emit_key_string(v630, CFSTR("/Producer"), v712);
        CFRelease(v713);
      }
      v714 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v630, CFSTR("kCGPDFContextAuthor"), CFSTR("Author"));
      emit_key_string(v630, CFSTR("/Author"), v714);
      v715 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v630, CFSTR("kCGPDFContextSubject"), CFSTR("Subject"));
      emit_key_string(v630, CFSTR("/Subject"), v715);
      v716 = (const __CFString *)PDFInfoGetString((const __CFDictionary *)v630, CFSTR("kCGPDFContextCreator"), CFSTR("Creator"));
      emit_key_string(v630, CFSTR("/Creator"), v716);
      v717 = PDFInfoGetNowDate(v630);
      if (v717)
      {
        v724 = (const __CFString *)PDFCreateDateString((uint64_t)v717);
        if (v724)
        {
          v725 = v724;
          emit_key_string(v630, CFSTR("/CreationDate"), v724);
          emit_key_string(v630, CFSTR("/ModDate"), v725);
          CFRelease(v725);
        }
      }
      if (v633)
        PDFDocumentPrintReference(*v630, (uint64_t)"/Keywords %R", v633, v719, v720, v721, v722, v723);
      if (v663)
        PDFDocumentPrintReference(*v630, (uint64_t)"/AAPL:Keywords %R", v663, v719, v720, v721, v722, v723);
      if (v711 && PDFOutputIntentGetIsX3((_BYTE *)v711))
      {
        v726 = *(_QWORD *)v711;
        PDFDocumentPrintf(*(_QWORD *)v711, (uint64_t)"/GTS_PDFXVersion (PDF/X-3:2002)", v718, v719, v720, v721, v722, v723, v996);
        v727 = CFDictionaryGetValue(*(CFDictionaryRef *)(v711 + 8), CFSTR("Trapped"));
        v734 = "False";
        if (v727 && CFEqual(v727, CFSTR("True")))
          v734 = "True";
        PDFDocumentPrintf(v726, (uint64_t)"/Trapped /%N", v728, v729, v730, v731, v732, v733, (uint64_t)v734);
      }
      PDFDocumentPrintf(*v630, (uint64_t)">>", v718, v719, v720, v721, v722, v723, v996);
      PDFDocumentEndObject(*v630, v735, v736, v737, v738, v739, v740, v741);
      goto LABEL_380;
    }
    v1016 = 0u;
    *(_OWORD *)v1021 = 0u;
LABEL_155:
    v280 = *(uint64_t ***)(v276 + 24);
    *(_QWORD *)(v276 + 24) = 0;
    value[0] = 0;
    value[1] = 0;
    LOBYTE(Type) = std::shared_ptr<PDFPageNode>::operator=[abi:se180100](v276 + 32, (__int128 *)value);
    v281 = (std::__shared_weak_count *)value[1];
    if (value[1])
    {
      v282 = (unint64_t *)((char *)value[1] + 8);
      do
        v283 = __ldaxr(v282);
      while (__stlxr(v283 - 1, v282));
      if (!v283)
      {
        ((void (*)(std::__shared_weak_count *))v281->__on_zero_shared)(v281);
        std::__shared_weak_count::__release_weak(v281);
      }
    }
    v284 = *v280;
    v285 = v280[1];
    if ((char *)v285 - (char *)*v280 != 16)
    {
      while (1)
      {
        if (v284 == v285)
        {
          value[0] = (CGPDFArrayRef)v280;
          std::vector<std::shared_ptr<CG::DisplayListEntry const>>::__destroy_vector::operator()[abi:se180100]((void ***)value);
          MEMORY[0x186DC23C4](v280, 0x20C40960023A9);
          goto LABEL_155;
        }
        v1015 = (std::__shared_weak_count *)*((_QWORD *)&v1016 + 1);
        v287 = (uint64_t *)*v284;
        v286 = (CGPDFArray *)v284[1];
        if (v286)
        {
          v288 = (unint64_t *)((char *)v286 + 8);
          do
            v289 = __ldxr(v288);
          while (__stxr(v289 + 1, v288));
        }
        PDFPageTree::addNode((PDFPageTree *)value, (_QWORD *)v276, *v287, v287[1]);
        v1016 = *(_OWORD *)value;
        value[0] = 0;
        value[1] = 0;
        if (v1015)
        {
          v290 = (unint64_t *)&v1015->__shared_owners_;
          do
            v291 = __ldaxr(v290);
          while (__stlxr(v291 - 1, v290));
          if (!v291)
          {
            ((void (*)(std::__shared_weak_count *))v1015->__on_zero_shared)(v1015);
            std::__shared_weak_count::__release_weak(v1015);
          }
        }
        v292 = (std::__shared_weak_count *)value[1];
        if (value[1])
        {
          v293 = (unint64_t *)((char *)value[1] + 8);
          do
            v294 = __ldaxr(v293);
          while (__stlxr(v294 - 1, v293));
          if (!v294)
          {
            ((void (*)(std::__shared_weak_count *))v292->__on_zero_shared)(v292);
            std::__shared_weak_count::__release_weak(v292);
          }
        }
        value[0] = (CGPDFArrayRef)v287;
        value[1] = v286;
        if (v286)
        {
          v295 = (unint64_t *)((char *)v286 + 8);
          do
            v296 = __ldxr(v295);
          while (__stxr(v296 + 1, v295));
        }
        *(_QWORD *)&v1026 = *(_QWORD *)v1016;
        std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::push_back[abi:se180100]((char **)(v276 + 48), (uint64_t)value);
        v297 = (std::__shared_weak_count *)value[1];
        if (!value[1])
          goto LABEL_182;
        v298 = (unint64_t *)((char *)value[1] + 8);
        do
          v299 = __ldaxr(v298);
        while (__stlxr(v299 - 1, v298));
        if (!v299)
        {
          ((void (*)(std::__shared_weak_count *))v297->__on_zero_shared)(v297);
          std::__shared_weak_count::__release_weak(v297);
          if (!v286)
            goto LABEL_188;
        }
        else
        {
LABEL_182:
          if (!v286)
            goto LABEL_188;
        }
        v300 = (unint64_t *)((char *)v286 + 8);
        do
          v301 = __ldaxr(v300);
        while (__stlxr(v301 - 1, v300));
        if (!v301)
        {
          (*(void (**)(CGPDFArray *))(*(_QWORD *)v286 + 16))(v286);
          std::__shared_weak_count::__release_weak((std::__shared_weak_count *)v286);
        }
LABEL_188:
        v284 += 2;
      }
    }
    if (v284 != v285)
    {
      std::shared_ptr<PDFPageNode>::operator=[abi:se180100](v1021, *v284, v284[1]);
      value[0] = v1021[0];
      value[1] = v1021[1];
      if (v1021[1])
      {
        v303 = (unint64_t *)((char *)v1021[1] + 8);
        do
          v304 = __ldxr(v303);
        while (__stxr(v304 + 1, v303));
      }
      *(_QWORD *)&v1026 = 0;
      std::vector<std::pair<std::shared_ptr<PDFPageNode>,unsigned long>>::push_back[abi:se180100]((char **)(v276 + 48), (uint64_t)value);
      v305 = (std::__shared_weak_count *)value[1];
      if (value[1])
      {
        v306 = (unint64_t *)((char *)value[1] + 8);
        do
          v307 = __ldaxr(v306);
        while (__stlxr(v307 - 1, v306));
        if (!v307)
        {
          ((void (*)(std::__shared_weak_count *))v305->__on_zero_shared)(v305);
          std::__shared_weak_count::__release_weak(v305);
        }
      }
      *(_QWORD *)(v276 + 72) = *(_QWORD *)v1021[0];
      value[0] = (CGPDFArrayRef)v280;
      std::vector<std::shared_ptr<CG::DisplayListEntry const>>::__destroy_vector::operator()[abi:se180100]((void ***)value);
      MEMORY[0x186DC23C4](v280, 0x20C40960023A9);
      if (*((_QWORD *)&v1016 + 1))
      {
        v308 = (unint64_t *)(*((_QWORD *)&v1016 + 1) + 8);
        do
          v309 = __ldaxr(v308);
        while (__stlxr(v309 - 1, v308));
        if (!v309)
        {
          (*(void (**)(_QWORD))(**((_QWORD **)&v1016 + 1) + 16))(*((_QWORD *)&v1016 + 1));
          std::__shared_weak_count::__release_weak(*((std::__shared_weak_count **)&v1016 + 1));
        }
      }
      v310 = (std::__shared_weak_count *)v1021[1];
      if (v1021[1])
      {
        v311 = (unint64_t *)((char *)v1021[1] + 8);
        do
          v312 = __ldaxr(v311);
        while (__stlxr(v312 - 1, v311));
        if (!v312)
        {
          ((void (*)(std::__shared_weak_count *))v310->__on_zero_shared)(v310);
          std::__shared_weak_count::__release_weak(v310);
        }
      }
      v278 = *(_QWORD *)(v276 + 48);
      v279 = *(_QWORD *)(v276 + 56);
      goto LABEL_211;
    }
LABEL_438:
    __break(1u);
LABEL_439:
    _CGHandleAssert("PDFColorSpaceEmitICCDataStream", 407, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphicsRIP/PDF/ColorSpaces/PDFColorSpace.c", "type == kCGColorSpaceICCBased || type == kCGColorSpaceProfileSets || type == kCGColorSpaceFlexGTCProxy", "invalid colorspace type %d", v151, v152, v153, Type);
  }
LABEL_428:
  CGDataConsumerClose(*(_QWORD *)(a1 + 24));
  v971 = *(PDFLinearizer **)(a1 + 520);
  if (v971)
    PDFLinearizer::endDocument(v971, *(CGDataConsumer **)(a1 + 528));
  *(_BYTE *)(a1 + 72) = 1;
}

void std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(_QWORD *a1)
{
  uint64_t v2;

  if (a1)
  {
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(*a1);
    std::__tree<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::__map_value_compare<CGFont *,std::__value_type<CGFont *,std::unique_ptr<PDFFont>>,std::less<CGFont *>,true>,std::allocator<std::__value_type<CGFont *,std::unique_ptr<PDFFont>>>>::destroy(a1[1]);
    v2 = a1[5];
    a1[5] = 0;
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    operator delete(a1);
  }
}

uint64_t *PDFDocumentBeginObject(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t *result;
  uint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = 0;
  result = PDFWriterBeginObject(*(uint64_t **)(a1 + 32), a2, &v17, a4, a5, a6, a7, a8);
  v11 = *(_QWORD *)(a1 + 464);
  if (v11)
  {
    v12 = *(_QWORD *)(v11 + 8);
    v13 = a2 >= v12;
    v14 = a2 - v12;
    if (v13)
    {
      v16 = v11 + 16;
      v15 = *(_QWORD *)(v11 + 16);
      if (v14 < (*(_QWORD *)(v16 + 8) - v15) >> 4)
        *(_QWORD *)(v15 + 16 * v14) = v17;
    }
  }
  *(_QWORD *)(a1 + 280) = a2;
  return result;
}

_BYTE *PDFDocumentEndObject(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE *result;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v17 = 0;
  result = PDFWriterEndObject(*(_BYTE **)(a1 + 32), &v17, a3, a4, a5, a6, a7, a8);
  v10 = *(_QWORD *)(a1 + 464);
  if (v10)
  {
    v11 = *(_QWORD *)(a1 + 280);
    v12 = *(_QWORD *)(v10 + 8);
    v13 = v11 >= v12;
    v14 = v11 - v12;
    if (v13)
    {
      v16 = v10 + 16;
      v15 = *(_QWORD *)(v10 + 16);
      if (v14 < (*(_QWORD *)(v16 + 8) - v15) >> 4)
        *(_QWORD *)(v15 + 16 * v14 + 8) = v17 - *(_QWORD *)(v15 + 16 * v14);
    }
  }
  *(_QWORD *)(a1 + 280) = 0;
  return result;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(float *a1, unint64_t a2, _OWORD *a3)
{
  unint64_t v3;
  unint64_t v5;
  unint64_t v7;
  uint8x8_t v8;
  _QWORD *v9;
  _QWORD *i;
  unint64_t v11;
  _QWORD *v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  int8x8_t prime;
  void *v19;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  unint64_t v23;
  uint8x8_t v24;
  unint64_t v25;
  uint8x8_t v26;
  uint64_t v27;
  _QWORD *v28;
  unint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  unint64_t v32;
  _QWORD *v33;

  v5 = a2;
  v7 = *((_QWORD *)a1 + 1);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = a2;
      if (v7 <= a2)
        v3 = a2 % v7;
    }
    else
    {
      v3 = (v7 - 1) & a2;
    }
    v9 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      for (i = (_QWORD *)*v9; i; i = (_QWORD *)*i)
      {
        v11 = i[1];
        if (v11 == a2)
        {
          if (i[2] == a2)
            return;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v3)
            break;
        }
      }
    }
  }
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v5;
  *((_OWORD *)v12 + 1) = *a3;
  v13 = (float)(unint64_t)(*((_QWORD *)a1 + 3) + 1);
  v14 = a1[8];
  if (v7 && (float)(v14 * (float)v7) >= v13)
  {
    v5 = v3;
    goto LABEL_64;
  }
  v15 = 1;
  if (v7 >= 3)
    v15 = (v7 & (v7 - 1)) != 0;
  v16 = v15 | (2 * v7);
  v17 = vcvtps_u32_f32(v13 / v14);
  if (v16 <= v17)
    prime = (int8x8_t)v17;
  else
    prime = (int8x8_t)v16;
  if (*(_QWORD *)&prime == 1)
  {
    prime = (int8x8_t)2;
  }
  else if ((*(_QWORD *)&prime & (*(_QWORD *)&prime - 1)) != 0)
  {
    prime = (int8x8_t)std::__next_prime(*(_QWORD *)&prime);
    v7 = *((_QWORD *)a1 + 1);
  }
  if (*(_QWORD *)&prime <= v7)
  {
    if (*(_QWORD *)&prime >= v7)
      goto LABEL_60;
    v25 = vcvtps_u32_f32((float)*((unint64_t *)a1 + 3) / a1[8]);
    if (v7 < 3 || (v26 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v26.i16[0] = vaddlv_u8(v26), v26.u32[0] > 1uLL))
    {
      v25 = std::__next_prime(v25);
    }
    else
    {
      v27 = 1 << -(char)__clz(v25 - 1);
      if (v25 >= 2)
        v25 = v27;
    }
    if (*(_QWORD *)&prime <= v25)
      prime = (int8x8_t)v25;
    if (*(_QWORD *)&prime >= v7)
    {
      v7 = *((_QWORD *)a1 + 1);
      goto LABEL_60;
    }
    if (!*(_QWORD *)&prime)
    {
      v33 = *(_QWORD **)a1;
      *(_QWORD *)a1 = 0;
      if (v33)
        operator delete(v33);
      v7 = 0;
      *((_QWORD *)a1 + 1) = 0;
      goto LABEL_60;
    }
  }
  if (*(_QWORD *)&prime >> 61)
    std::__throw_bad_array_new_length[abi:se180100]();
  v19 = operator new(8 * *(_QWORD *)&prime);
  v20 = *(_QWORD **)a1;
  *(_QWORD *)a1 = v19;
  if (v20)
    operator delete(v20);
  v21 = 0;
  *((int8x8_t *)a1 + 1) = prime;
  do
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v21++) = 0;
  while (*(_QWORD *)&prime != v21);
  v22 = (_QWORD *)*((_QWORD *)a1 + 2);
  if (v22)
  {
    v23 = v22[1];
    v24 = (uint8x8_t)vcnt_s8(prime);
    v24.i16[0] = vaddlv_u8(v24);
    if (v24.u32[0] > 1uLL)
    {
      if (v23 >= *(_QWORD *)&prime)
        v23 %= *(_QWORD *)&prime;
    }
    else
    {
      v23 &= *(_QWORD *)&prime - 1;
    }
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v23) = a1 + 4;
    v28 = (_QWORD *)*v22;
    if (*v22)
    {
      do
      {
        v29 = v28[1];
        if (v24.u32[0] > 1uLL)
        {
          if (v29 >= *(_QWORD *)&prime)
            v29 %= *(_QWORD *)&prime;
        }
        else
        {
          v29 &= *(_QWORD *)&prime - 1;
        }
        if (v29 != v23)
        {
          if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v29))
          {
            *(_QWORD *)(*(_QWORD *)a1 + 8 * v29) = v22;
            goto LABEL_56;
          }
          *v22 = *v28;
          *v28 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v29);
          **(_QWORD **)(*(_QWORD *)a1 + 8 * v29) = v28;
          v28 = v22;
        }
        v29 = v23;
LABEL_56:
        v22 = v28;
        v28 = (_QWORD *)*v28;
        v23 = v29;
      }
      while (v28);
    }
  }
  v7 = (unint64_t)prime;
LABEL_60:
  if ((v7 & (v7 - 1)) != 0)
  {
    if (v7 <= v5)
      v5 %= v7;
  }
  else
  {
    v5 &= v7 - 1;
  }
LABEL_64:
  v30 = *(_QWORD **)a1;
  v31 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v5);
  if (v31)
  {
    *v12 = *v31;
LABEL_72:
    *v31 = v12;
    goto LABEL_73;
  }
  *v12 = *((_QWORD *)a1 + 2);
  *((_QWORD *)a1 + 2) = v12;
  v30[v5] = a1 + 4;
  if (*v12)
  {
    v32 = *(_QWORD *)(*v12 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v32 >= v7)
        v32 %= v7;
    }
    else
    {
      v32 &= v7 - 1;
    }
    v31 = (_QWORD *)(*(_QWORD *)a1 + 8 * v32);
    goto LABEL_72;
  }
LABEL_73:
  ++*((_QWORD *)a1 + 3);
}

void sub_184BD24C0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void PDFDocumentEmitTaggedNodeStructure(PDFDocument *a1, unint64_t a2, __CFDictionary *a3, uint64_t a4)
{
  CGPDFTagType v8;
  const char *Name;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int Integer;
  float *v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  __CFArray *Mutable;
  const __CFArray *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  const __CFArray *v35;
  CFIndex Count;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  const __CFDictionary *v89;
  const __CFDictionary *v90;
  CFTypeID TypeID;
  const void *ValueWithType;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  CFTypeID v99;
  CFTypeID v100;
  const void *v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  CFTypeID v108;
  CFTypeID v109;
  const void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  CFTypeID v117;
  CFTypeID v118;
  const void *v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  CFTypeID v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  const char *CStringPtr;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  CFIndex v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  const char *v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  float *isa;
  CFIndex i;
  __CFDictionary *ValueAtIndex;
  const __CFNumber *v170;
  const __CFNumber *v171;
  CFTypeID v172;
  int v173;
  int v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unint64_t valuePtr;
  CFNumberRef number;
  unsigned int v183;
  CGPDFTagType tagType;
  uint64_t v185;
  __int128 value;

  v185 = -1;
  CGCFDictionaryGetNumber(a3, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &v185);
  tagType = 0;
  if (CGCFDictionaryGetInteger(a3, CFSTR("TagNodeType"), &tagType))
  {
    v8 = tagType;
    Name = CGPDFTagTypeGetName(tagType);
    if (Name)
    {
      v10 = (uint64_t)Name;
      v183 = 0;
      Integer = CGCFDictionaryGetInteger(a3, CFSTR("PageObjectNumber"), &v183);
      if (v185 != -1)
      {
        v18 = (float *)a1[18]._private;
        *(_QWORD *)&value = v185 | ((unint64_t)v183 << 32);
        *((_QWORD *)&value + 1) = a2;
        std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v18, value, &value);
      }
      if (v8 == 800)
      {
        PDFDocumentBeginObject((uint64_t)a1, a2, v11, v12, v13, v14, v15, v16);
        LODWORD(value) = 0;
        CGCFDictionaryGetInteger(a3, CFSTR("TagNodeObjectRefID"), &value);
        v19 = std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>((_QWORD *)a1[18].super.isa, (int)value);
        if (v19)
          v26 = v19[3];
        else
          v26 = -1;
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"<<", v20, v21, v22, v23, v24, v25, v175);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Type /OBJR", v37, v38, v39, v40, v41, v42, v176);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Obj %R", v43, v44, v45, v46, v47, v48, v26);
        PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/P %R", a4, v49, v50, v51, v52, v53);
        if (Integer)
          PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/Pg %R", (int)v183, v55, v56, v57, v58, v59);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)">>", v54, v55, v56, v57, v58, v59, v177);
        PDFDocumentEndObject((uint64_t)a1, v60, v61, v62, v63, v64, v65, v66);
      }
      else
      {
        Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        v28 = (const __CFArray *)CFDictionaryGetValue(a3, CFSTR("TagNodeChildren"));
        v35 = v28;
        if (v28)
          Count = CFArrayGetCount(v28);
        else
          Count = 0;
        PDFDocumentBeginObject((uint64_t)a1, a2, v29, v30, v31, v32, v33, v34);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"<< /Type /StructElem", v67, v68, v69, v70, v71, v72, v175);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/S %s", v73, v74, v75, v76, v77, v78, v10);
        PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/P %R", a4, v79, v80, v81, v82, v83);
        if (Integer && (Count < 1 || v185 != -1))
          PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"/Pg %R", (int)v183, v84, v85, v86, v87, v88);
        v89 = (const __CFDictionary *)CFDictionaryGetValue(a3, CFSTR("TagNodeProperties"));
        if (v89)
        {
          v90 = v89;
          TypeID = CFStringGetTypeID();
          ValueWithType = CGCFDictionaryGetValueWithType(v90, CFSTR("CGPDFTagPropertyLanguageText"), TypeID);
          if (ValueWithType
            || (v99 = CFStringGetTypeID(),
                (ValueWithType = CGCFDictionaryGetValueWithType(v90, CFSTR("Lang"), v99)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Lang %T", v93, v94, v95, v96, v97, v98, (uint64_t)ValueWithType);
          }
          v100 = CFStringGetTypeID();
          v101 = CGCFDictionaryGetValueWithType(v90, CFSTR("CGPDFTagPropertyAlternativeText"), v100);
          if (v101
            || (v108 = CFStringGetTypeID(), (v101 = CGCFDictionaryGetValueWithType(v90, CFSTR("Alt"), v108)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/Alt %T", v102, v103, v104, v105, v106, v107, (uint64_t)v101);
          }
          v109 = CFStringGetTypeID();
          v110 = CGCFDictionaryGetValueWithType(v90, CFSTR("CGPDFTagPropertyActualText"), v109);
          if (v110
            || (v117 = CFStringGetTypeID(),
                (v110 = CGCFDictionaryGetValueWithType(v90, CFSTR("ActualText"), v117)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/ActualText %T", v111, v112, v113, v114, v115, v116, (uint64_t)v110);
          }
          v118 = CFStringGetTypeID();
          v119 = CGCFDictionaryGetValueWithType(v90, CFSTR("CGPDFTagPropertyTitleText"), v118);
          if (v119
            || (v126 = CFStringGetTypeID(), (v119 = CGCFDictionaryGetValueWithType(v90, CFSTR("T"), v126)) != 0))
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/T %T", v120, v121, v122, v123, v124, v125, (uint64_t)v119);
          }
        }
        *(_QWORD *)&value = 0;
        if (CFDictionaryGetValueIfPresent(a3, CFSTR("ID"), (const void **)&value))
        {
          CStringPtr = CFStringGetCStringPtr((CFStringRef)value, 0x8000100u);
          PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/ID (%s)", v134, v135, v136, v137, v138, v139, (uint64_t)CStringPtr);
        }
        if (Count <= 0)
        {
          v179 = v185;
          v153 = "/K %d ";
        }
        else
        {
          PDFDocumentPrintf((uint64_t)a1, (uint64_t)"/K [", v127, v128, v129, v130, v131, v132, v178);
          v146 = Count;
          if ((v185 & 0x8000000000000000) == 0)
          {
            PDFDocumentPrintf((uint64_t)a1, (uint64_t)"%d", v140, v141, v142, v143, v144, v145, v185);
            v146 = Count;
          }
          do
          {
            v147 = PDFXRefTableAddObject((_QWORD *)a1[29].super.isa);
            CGCFArrayAppendInteger(Mutable, v147);
            PDFDocumentPrintReference((uint64_t)a1, (uint64_t)"%R", v147, v148, v149, v150, v151, v152);
            --v146;
          }
          while (v146);
          v153 = "]";
        }
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)v153, v127, v128, v129, v130, v131, v132, v179);
        PDFDocumentPrintf((uint64_t)a1, (uint64_t)" >>", v154, v155, v156, v157, v158, v159, v180);
        PDFDocumentEndObject((uint64_t)a1, v160, v161, v162, v163, v164, v165, v166);
        number = 0;
        if (CFDictionaryGetValueIfPresent(a3, CFSTR("TagNodeObjectRefID"), (const void **)&number))
        {
          valuePtr = 0;
          CFNumberGetValue(number, kCFNumberLongType, &valuePtr);
          isa = (float *)a1[18].super.isa;
          *(_QWORD *)&value = valuePtr;
          *((_QWORD *)&value + 1) = a2;
          std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(isa, valuePtr, &value);
        }
        if (Count >= 1)
        {
          for (i = 0; i != Count; ++i)
          {
            ValueAtIndex = (__CFDictionary *)CFArrayGetValueAtIndex(v35, i);
            if (Mutable
              && (v170 = (const __CFNumber *)CFArrayGetValueAtIndex(Mutable, i)) != 0
              && (v171 = v170, v172 = CFGetTypeID(v170), v172 == CFNumberGetTypeID()))
            {
              LODWORD(value) = 0;
              v173 = CFNumberGetValue(v171, kCFNumberIntType, &value);
              v174 = value;
              if (!v173)
                v174 = 0;
            }
            else
            {
              v174 = 0;
            }
            PDFDocumentEmitTaggedNodeStructure(a1, v174, ValueAtIndex, a2);
          }
        }
        CFRelease(Mutable);
      }
    }
  }
}

void PDFDocumentPrintf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  PDFWriterVPrintf(*(_BYTE ***)(a1 + 32), a2, (uint64_t)&a9, a4, a5, a6, a7, a8);
}

_QWORD *__Block_byref_object_copy__5309(_QWORD *result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;

  result[6] = a2[6];
  v2 = a2 + 7;
  v3 = a2[7];
  result[7] = v3;
  v4 = result + 7;
  v5 = a2[8];
  result[8] = v5;
  if (v5)
  {
    *(_QWORD *)(v3 + 16) = v4;
    a2[6] = v2;
    *v2 = 0;
    a2[8] = 0;
  }
  else
  {
    result[6] = v4;
  }
  return result;
}

void __Block_byref_object_dispose__5310(uint64_t a1)
{
  std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(*(_QWORD **)(a1 + 56));
}

void ___ZL28PDFDocumentEmitStructureTreeP11PDFDocument_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t **v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t *v8;
  uint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t *i;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _QWORD v28[3];
  int v29;

  v3 = *(_QWORD *)(a2 + 40);
  v4 = *(_QWORD *)(*(_QWORD *)(a2 + 48) + 64);
  v5 = (uint64_t **)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48);
  if (*(_DWORD *)(a2 + 16))
  {
    v27 = v3;
    v28[0] = v4;
    v29 = 0;
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(v5, v3, (uint64_t)&v27);
    std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v28);
    return;
  }
  v27 = v3;
  memset(v28, 0, sizeof(v28));
  v29 = 1;
  v6 = std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(v5, v3, (uint64_t)&v27);
  std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)v28);
  if (*((_DWORD *)v6 + 16) != 1)
LABEL_29:
    std::__throw_bad_variant_access[abi:se180100]();
  v7 = *(_QWORD *)(a2 + 32);
  v8 = v6[5];
  v9 = v6[6];
  v10 = v9 - v8;
  v11 = v7 + 1;
  if (v7 + 1 > v10)
  {
    v12 = v6[7];
    if (v11 - v10 <= v12 - v9)
    {
      v22 = &v9[v11 - v10];
      v26 = 8 * v7 - 8 * v10 + 8;
      do
      {
        if (!v9)
          goto LABEL_28;
        *v9++ = 0;
        v26 -= 8;
      }
      while (v26);
      v6[6] = v22;
    }
    else
    {
      if (v11 >> 61)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v13 = (char *)v12 - (char *)v8;
      v14 = v13 >> 2;
      if (v13 >> 2 <= v11)
        v14 = v7 + 1;
      if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFF8)
        v15 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v15 = v14;
      v16 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v15);
      v17 = &v16[8 * v10];
      v19 = (uint64_t *)&v16[8 * v18];
      v20 = 8 * v7 - 8 * v10 + 8;
      v21 = v17;
      v22 = (uint64_t *)&v16[8 * v11];
      do
      {
        if (!v21)
          goto LABEL_28;
        *(_QWORD *)v21 = 0;
        v21 += 8;
        v20 -= 8;
      }
      while (v20);
      v23 = v6[5];
      for (i = v6[6]; i != v23; --i)
      {
        v25 = *(i - 1);
        *((_QWORD *)v17 - 1) = v25;
        v17 -= 8;
      }
      v6[5] = (uint64_t *)v17;
      v6[6] = v22;
      v6[7] = v19;
      if (v23)
      {
        operator delete(v23);
        v22 = v6[6];
      }
    }
    v8 = v6[5];
    v10 = v22 - v8;
  }
  if (v10 <= v7)
  {
LABEL_28:
    __break(1u);
    goto LABEL_29;
  }
  v8[v7] = v4;
}

void sub_184BD2C64(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor(v1);
  _Unwind_Resume(a1);
}

void std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(_QWORD *a1)
{
  if (a1)
  {
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(*a1);
    std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::destroy(a1[1]);
    std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor((uint64_t)(a1 + 5));
    operator delete(a1);
  }
}

uint64_t PDFDocumentGetID(uint64_t a1, _QWORD *a2)
{
  CC_MD5_CTX *v4;
  uint64_t v5;
  unint64_t v6;
  CFURLRef *v8;
  const __CFURL *v9;
  const __CFURL *v10;
  const __CFString *v11;
  const __CFString *v12;
  CFIndex Length;
  UniChar *v14;
  CFIndex v15;
  time_t data;
  unsigned __int8 md[16];
  uint64_t v18;
  CFRange v19;

  v18 = *MEMORY[0x1E0C80C00];
  if (!*(_BYTE *)(a1 + 256))
  {
    v4 = (CC_MD5_CTX *)malloc_type_malloc(0x5CuLL, 0x2062DE7BuLL);
    CC_MD5_Init(v4);
    data = time(0);
    if (v4)
    {
      CC_MD5_Update(v4, &data, 8u);
      CC_MD5_Update(v4, &PDFDocumentGetID::stamp, 4u);
    }
    ++PDFDocumentGetID::stamp;
    v5 = *(_QWORD *)(a1 + 24);
    if (v5)
      v6 = *(_QWORD *)(v5 + 40);
    else
      v6 = 0;
    v15 = v6;
    if (v4)
    {
      CC_MD5_Update(v4, &v15, 8u);
      v5 = *(_QWORD *)(a1 + 24);
    }
    if (v5)
    {
      if (*(unint64_t (**)(uint64_t, const UInt8 *, unint64_t))(v5 + 72) == url_put_bytes)
      {
        v8 = *(CFURLRef **)(v5 + 16);
        if (v8)
        {
          if (*v8)
          {
            v9 = CFURLCopyAbsoluteURL(*v8);
            if (v9)
            {
              v10 = v9;
              v11 = CFURLCopyPath(v9);
              if (v11)
              {
                v12 = v11;
                Length = CFStringGetLength(v11);
                v15 = 2 * Length;
                v14 = (UniChar *)malloc_type_malloc(2 * Length, 0xE9B63996uLL);
                v19.location = 0;
                v19.length = Length;
                CFStringGetCharacters(v12, v19, v14);
                if (v4)
                  md5_update(v4, (char *)v14, v15);
                free(v14);
                CFRelease(v12);
              }
              CFRelease(v10);
            }
          }
        }
      }
    }
    data = time(0);
    if (v4)
    {
      CC_MD5_Update(v4, &data, 8u);
      CC_MD5_Final(md, v4);
    }
    free(v4);
    *(_OWORD *)(a1 + 257) = *(_OWORD *)md;
    *(_BYTE *)(a1 + 256) = 1;
  }
  if (a2)
    *a2 = 16;
  return a1 + 257;
}

void PDFDocumentAddCatalogEntry(uint64_t a1, const void *a2, void *key)
{
  uint64_t v6;
  const void *Value;
  __CFDictionary *Mutable;

  if (a1)
  {
    v6 = *(_QWORD *)(a1 + 40);
    Value = CFDictionaryGetValue(*(CFDictionaryRef *)(v6 + 24), key);
    if (Value
      || (Value = (const void *)PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)(v6 + 8) + 464)),
          CFDictionarySetValue(*(CFMutableDictionaryRef *)(v6 + 24), key, Value),
          CFArrayAppendValue(*(CFMutableArrayRef *)(v6 + 16), key),
          Value))
    {
      Mutable = *(__CFDictionary **)(a1 + 312);
      if (!Mutable)
      {
        Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], 0);
        *(_QWORD *)(a1 + 312) = Mutable;
      }
      CFDictionarySetValue(Mutable, a2, Value);
    }
  }
}

void emit_catalog_entries(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFDocumentPrintNameReferencePair(a3, (uint64_t)"%/ %R", a1, a2, a5, a6, a7, a8);
}

void PDFDocumentPrintReference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;

  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  v10 = *(_QWORD **)(a1 + 520);
  if (v10)
    PDFLinearizerRecordReference(v10, a3, *(_QWORD *)(a1 + 280));
}

void copy_catalog_entries(const void *a1, uint64_t a2, __CFDictionary *a3)
{
  CGCFDictionarySetLongInteger(a3, a1, a2);
}

BOOL emit_page_resources(PDFDocument *a1)
{
  PDFDocumentPrivate *v2;
  uint64_t v3;
  const __CFArray *v4;
  PDFDocumentPrivate *v5;
  uint64_t v6;
  const __CFArray *v7;
  PDFDocumentPrivate *v8;
  uint64_t v9;
  const __CFArray *v10;
  Class isa;
  uint64_t v12;
  const __CFArray *v13;
  char v14;
  Class v15;
  uint64_t v16;
  char v17;
  const __CFArray *v18;
  PDFDocumentPrivate *v19;
  uint64_t v20;
  const __CFArray *v21;
  BOOL v22;
  char v23;
  char v24;
  _BOOL8 result;
  char v26;
  char v27;
  char v28;
  char v29;
  BOOL v30;
  BOOL v31;
  BOOL v32;
  char context;
  char v34;
  char v35;
  char v36;
  char v37;
  char v38;
  CFRange v39;
  CFRange v40;
  CFRange v41;
  CFRange v42;
  CFRange v43;
  CFRange v44;

  do
  {
    v2 = a1[22]._private;
    context = 0;
    if (v2 && (v3 = *((_QWORD *)v2 + 2)) != 0)
    {
      do
      {
        *((_QWORD *)v2 + 2) = 0;
        v4 = *(const __CFArray **)(v3 + 8);
        v39.length = CFArrayGetCount(v4);
        v39.location = 0;
        CFArrayApplyFunction(v4, v39, (CFArrayApplierFunction)emitFormDefinition, &context);
        CGOrderedSetRelease((const void **)v3);
        v3 = *((_QWORD *)v2 + 2);
      }
      while (v3);
      v32 = context != 0;
    }
    else
    {
      v32 = 0;
    }
    v5 = a1[24]._private;
    v34 = 0;
    if (v5 && (v6 = *((_QWORD *)v5 + 2)) != 0)
    {
      do
      {
        *((_QWORD *)v5 + 2) = 0;
        v7 = *(const __CFArray **)(v6 + 8);
        v40.length = CFArrayGetCount(v7);
        v40.location = 0;
        CFArrayApplyFunction(v7, v40, (CFArrayApplierFunction)emitClipMaskDefinition, &v34);
        CGOrderedSetRelease((const void **)v6);
        v6 = *((_QWORD *)v5 + 2);
      }
      while (v6);
      v31 = v34 != 0;
    }
    else
    {
      v31 = 0;
    }
    v8 = a1[23]._private;
    v35 = 0;
    if (v8 && (v9 = *((_QWORD *)v8 + 2)) != 0)
    {
      do
      {
        *((_QWORD *)v8 + 2) = 0;
        v10 = *(const __CFArray **)(v9 + 8);
        v41.length = CFArrayGetCount(v10);
        v41.location = 0;
        CFArrayApplyFunction(v10, v41, (CFArrayApplierFunction)emitPatternDefinition, &v35);
        CGOrderedSetRelease((const void **)v9);
        v9 = *((_QWORD *)v8 + 2);
      }
      while (v9);
      v30 = v35 != 0;
    }
    else
    {
      v30 = 0;
    }
    isa = a1[24].super.isa;
    v36 = 0;
    if (isa)
    {
      v12 = *((_QWORD *)isa + 2);
      if (v12)
      {
        do
        {
          *((_QWORD *)isa + 2) = 0;
          v13 = *(const __CFArray **)(v12 + 8);
          v42.length = CFArrayGetCount(v13);
          v42.location = 0;
          CFArrayApplyFunction(v13, v42, (CFArrayApplierFunction)emitShadingDefinition, &v36);
          CGOrderedSetRelease((const void **)v12);
          v12 = *((_QWORD *)isa + 2);
        }
        while (v12);
        v12 = v36 != 0;
      }
    }
    else
    {
      LOBYTE(v12) = 0;
    }
    v29 = PDFImageSetEmitDefinitions((uint64_t)a1[21]._private);
    v14 = PDFImageSetEmitDefinitions((uint64_t)a1[22].super.isa);
    v15 = a1[25].super.isa;
    v37 = 0;
    if (v15)
    {
      v16 = *((_QWORD *)v15 + 2);
      if (v16)
      {
        v27 = v14;
        v17 = v12;
        do
        {
          *((_QWORD *)v15 + 2) = 0;
          v18 = *(const __CFArray **)(v16 + 8);
          v43.length = CFArrayGetCount(v18);
          v43.location = 0;
          CFArrayApplyFunction(v18, v43, (CFArrayApplierFunction)emitEStateDefinition, &v37);
          CGOrderedSetRelease((const void **)v16);
          v16 = *((_QWORD *)v15 + 2);
        }
        while (v16);
        LOBYTE(v15) = v37 != 0;
        LOBYTE(v12) = v17;
        v14 = v27;
      }
      else
      {
        LOBYTE(v15) = 0;
      }
    }
    v19 = a1[25]._private;
    v38 = 0;
    if (v19 && (v20 = *((_QWORD *)v19 + 2)) != 0)
    {
      v26 = v12;
      v28 = v14;
      do
      {
        *((_QWORD *)v19 + 2) = 0;
        v21 = *(const __CFArray **)(v20 + 8);
        v44.length = CFArrayGetCount(v21);
        v44.location = 0;
        CFArrayApplyFunction(v21, v44, (CFArrayApplierFunction)emitPropertyListDefinition, &v38);
        CGOrderedSetRelease((const void **)v20);
        v20 = *((_QWORD *)v19 + 2);
      }
      while (v20);
      v22 = v38 != 0;
      LOBYTE(v12) = v26;
      v14 = v28;
    }
    else
    {
      v22 = 0;
    }
    v23 = (v32 || v31 || v30) | v12 | v29 | v14 | v15 | v22;
    v24 = PDFColorSpaceSetEmitDefinitions((uint64_t)a1[20]._private);
    result = PDFFunctionSetEmitDefinitions((_BOOL8)a1[23].super.isa);
  }
  while ((v23 & 1) != 0 || (v24 & 1) != 0 || result);
  return result;
}

void PDFDocumentPrintNameReferencePair(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v10;

  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  v10 = *(_QWORD **)(a1 + 520);
  if (v10)
    PDFLinearizerRecordReference(v10, a4, *(_QWORD *)(a1 + 280));
}

uint64_t std::__variant_detail::__dtor<std::__variant_detail::__traits<unsigned long,std::vector<unsigned long>>,(std::__variant_detail::_Trait)1>::~__dtor(uint64_t a1)
{
  uint64_t v2;
  char v4;

  v2 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v2 != -1)
    ((void (*)(char *, uint64_t))off_1E1645010[v2])(&v4, a1);
  *(_DWORD *)(a1 + 24) = -1;
  return a1;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1EEE10__dispatchB8se180100IOZNS0_6__dtorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEELNS0_6_TraitE1EE9__destroyB8se180100EvEUlRT_E_JRNS0_6__baseILSD_1EJmSB_EEEEEEDcSF_DpT0_(uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v2;
    operator delete(v2);
  }
}

void std::__variant_detail::__visitation::__base::__dispatcher<0ul>::__dispatch[abi:se180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<PDFDocumentEmitStructureTree(PDFDocument *)::$_0,PDFDocumentEmitStructureTree(PDFDocument *)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,std::vector<unsigned long>> const&>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  PDFDocumentPrintf(**a1, (uint64_t)"%R", a3, a4, a5, a6, a7, a8, *a2);
}

void std::__variant_detail::__visitation::__base::__dispatcher<1ul>::__dispatch[abi:se180100]<std::__variant_detail::__visitation::__variant::__value_visitor<overloaded<PDFDocumentEmitStructureTree(PDFDocument *)::$_0,PDFDocumentEmitStructureTree(PDFDocument *)::$_1>> &&,std::__variant_detail::__base<(std::__variant_detail::_Trait)1,unsigned long,std::vector<unsigned long>> const&>(uint64_t *a1, uint64_t **a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v10 = *a1;
  PDFDocumentPrintf(*(_QWORD *)(*a1 + 8), (uint64_t)"[", a3, a4, a5, a6, a7, a8, v20);
  v17 = *a2;
  v18 = a2[1];
  if (*a2 != v18)
  {
    do
    {
      v19 = *(_QWORD *)(v10 + 8);
      if (*v17)
        PDFDocumentPrintf(v19, (uint64_t)"%R", v11, v12, v13, v14, v15, v16, *v17);
      else
        PDFDocumentPrintf(v19, (uint64_t)"null", v11, v12, v13, v14, v15, v16, v21);
      ++v17;
    }
    while (v17 != v18);
  }
  PDFDocumentPrintf(*(_QWORD *)(v10 + 8), (uint64_t)"]", v11, v12, v13, v14, v15, v16, a9);
}

uint64_t **std::__tree<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::__map_value_compare<long,std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>,std::less<long>,true>,std::allocator<std::__value_type<long,std::variant<unsigned long,std::vector<unsigned long>>>>>::__emplace_unique_key_args<long,std::pair<long const,std::variant<unsigned long,std::vector<unsigned long>>>>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  _QWORD *v12;
  char v14;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    do
    {
      while (1)
      {
        v7 = (uint64_t **)v5;
        v8 = v5[4];
        if (v8 <= a2)
          break;
        v5 = *v7;
        v6 = v7;
        if (!*v7)
          goto LABEL_10;
      }
      if (v8 >= a2)
        return v7;
      v5 = v7[1];
    }
    while (v5);
    v6 = v7 + 1;
  }
  else
  {
    v7 = a1 + 1;
  }
LABEL_10:
  v12 = operator new(0x48uLL);
  v12[4] = *(_QWORD *)a3;
  *((_BYTE *)v12 + 40) = 0;
  *((_DWORD *)v12 + 16) = -1;
  v9 = *(unsigned int *)(a3 + 32);
  if ((_DWORD)v9 != -1)
  {
    ((void (*)(char *, _QWORD *, uint64_t))off_1E1645020[v9])(&v14, v12 + 5, a3 + 8);
    *((_DWORD *)v12 + 16) = v9;
  }
  *v12 = 0;
  v12[1] = 0;
  v12[2] = v7;
  *v6 = v12;
  v10 = (uint64_t *)**a1;
  v11 = v12;
  if (v10)
  {
    *a1 = v10;
    v11 = *v6;
  }
  std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(a1[1], v11);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return (uint64_t **)v12;
}

void _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm0ELm0EEE10__dispatchB8se180100IOZNS0_6__ctorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEEE19__generic_constructB8se180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJmSB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  *a2 = *a3;
}

__n128 _ZNSt3__116__variant_detail12__visitation6__base12__dispatcherIJLm1ELm1EEE10__dispatchB8se180100IOZNS0_6__ctorINS0_8__traitsIJmNS_6vectorImNS_9allocatorImEEEEEEEE19__generic_constructB8se180100INS0_18__move_constructorISC_LNS0_6_TraitE1EEEEEvRSD_OT_EUlRSJ_OT0_E_JRNS0_6__baseILSG_1EJmSB_EEEOSR_EEEDcSJ_DpT0_(uint64_t a1, __n128 *a2, __n128 *a3)
{
  __n128 result;

  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  result = *a3;
  *a2 = *a3;
  a2[1].n128_u64[0] = a3[1].n128_u64[0];
  a3->n128_u64[0] = 0;
  a3->n128_u64[1] = 0;
  a3[1].n128_u64[0] = 0;
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::find<unsigned long long>(_QWORD *a1, unint64_t a2)
{
  int8x8_t v2;
  uint8x8_t v3;
  unint64_t v4;
  _QWORD *v5;
  _QWORD *result;
  unint64_t v7;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = (uint8x8_t)vcnt_s8(v2);
  v3.i16[0] = vaddlv_u8(v3);
  if (v3.u32[0] > 1uLL)
  {
    v4 = a2;
    if (*(_QWORD *)&v2 <= a2)
      v4 = a2 % *(_QWORD *)&v2;
  }
  else
  {
    v4 = (*(_QWORD *)&v2 - 1) & a2;
  }
  v5 = *(_QWORD **)(*a1 + 8 * v4);
  if (!v5)
    return 0;
  result = (_QWORD *)*v5;
  if (*v5)
  {
    do
    {
      v7 = result[1];
      if (v7 == a2)
      {
        if (result[2] == a2)
          return result;
      }
      else
      {
        if (v3.u32[0] > 1uLL)
        {
          if (v7 >= *(_QWORD *)&v2)
            v7 %= *(_QWORD *)&v2;
        }
        else
        {
          v7 &= *(_QWORD *)&v2 - 1;
        }
        if (v7 != v4)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

void PDFDocumentPushContentStream(uint64_t a1, void *value)
{
  __CFArray *Mutable;

  Mutable = *(__CFArray **)(a1 + 472);
  if (!Mutable)
  {
    Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
    *(_QWORD *)(a1 + 472) = Mutable;
  }
  CFArrayAppendValue(Mutable, value);
}

void PDFDocumentPopContentStream(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;

  v2 = *(const __CFArray **)(a1 + 472);
  if (v2)
  {
    Count = CFArrayGetCount(v2);
    if (Count >= 1)
      CFArrayRemoveValueAtIndex(*(CFMutableArrayRef *)(a1 + 472), Count - 1);
  }
}

const void *PDFDocumentGetContentStream(uint64_t a1)
{
  const __CFArray *v2;
  CFIndex Count;

  v2 = *(const __CFArray **)(a1 + 472);
  if (v2 && (Count = CFArrayGetCount(v2)) != 0)
    return CFArrayGetValueAtIndex(*(CFArrayRef *)(a1 + 472), Count - 1);
  else
    return 0;
}

uint64_t PDFDocumentSetOutputIntent(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  uint64_t result;

  v4 = CFGetTypeID(cf);
  result = CFDictionaryGetTypeID();
  if (v4 == result)
  {
    PDFOutputIntentRelease(*(_QWORD **)(a1 + 48));
    result = (uint64_t)PDFOutputIntentCreate(a1, cf);
    *(_QWORD *)(a1 + 48) = result;
  }
  return result;
}

void PDFDocumentAddPDFXInfo(uint64_t a1, CFTypeRef cf)
{
  CFTypeID v4;
  const void *Value;
  const void *v6;

  v4 = CFGetTypeID(cf);
  if (v4 == CFDictionaryGetTypeID())
  {
    PDFDocumentSetOutputIntent(a1, cf);
    Value = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("kCGPDFContextAuthor"));
    if (Value)
      PDFInfoSetValue(*(_QWORD *)(a1 + 64), CFSTR("kCGPDFContextAuthor"), Value);
    v6 = CFDictionaryGetValue((CFDictionaryRef)cf, CFSTR("kCGPDFContextCreator"));
    if (v6)
      PDFInfoSetValue(*(_QWORD *)(a1 + 64), CFSTR("kCGPDFContextCreator"), v6);
  }
}

PDFDocumentPrivate *PDFDocumentPushTag(PDFDocument *a1, int a2, const __CFDictionary *a3)
{
  PDFDocumentPrivate *v4;
  PDFDocumentPrivate *TagNode;
  PDFDocumentPrivate *v6;
  const __CFArray *isa;
  CFIndex Count;
  const __CFDictionary *ValueAtIndex;
  void *Value;

  v4 = a1[34]._private;
  a1[34]._private = (PDFDocumentPrivate *)((char *)v4 + 1);
  TagNode = PDFDocumentCreateTagNode(a1, (uint64_t)v4, a2, a3, 1);
  v6 = TagNode;
  if (a1[35]._private)
  {
    isa = a1[35].super.isa;
    if (isa && CFArrayGetCount(isa))
    {
      Count = CFArrayGetCount(a1[35].super.isa);
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(a1[35].super.isa, Count - 1);
      Value = (void *)CFDictionaryGetValue(ValueAtIndex, CFSTR("TagNodeChildren"));
      if (!Value)
      {
        Value = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
        CFDictionarySetValue(ValueAtIndex, CFSTR("TagNodeChildren"), Value);
        CFRelease(Value);
      }
      CFDictionaryRemoveValue(ValueAtIndex, CFSTR("TagNodeMCID"));
      CFArrayAppendValue((CFMutableArrayRef)Value, v6);
      CFRelease(v6);
    }
  }
  else
  {
    a1[35]._private = TagNode;
  }
  CFArrayAppendValue(a1[35].super.isa, v6);
  return v4;
}

__CFDictionary *PDFDocumentCreateTagNode(PDFDocument *a1, uint64_t a2, int a3, const __CFDictionary *a4, int a5)
{
  __CFDictionary *Mutable;
  Class isa;
  uint64_t valuePtr;

  valuePtr = a2;
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  CGCFDictionarySetNumber(Mutable, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &valuePtr);
  CGCFDictionarySetInteger(Mutable, CFSTR("TagNodeType"), a3);
  if (a4)
    CFDictionarySetValue(Mutable, CFSTR("TagNodeProperties"), a4);
  isa = a1[30].super.isa;
  if (isa && a5)
    CGCFDictionarySetInteger(Mutable, CFSTR("PageObjectNumber"), *((_DWORD *)isa + 4));
  return Mutable;
}

uint64_t StructureElementPathForMCID(const __CFDictionary *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t result;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  CFMutableArrayRef Mutable;
  uint64_t v14;

  v14 = -1;
  if (CGCFDictionaryGetNumber(a1, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &v14) && v14 == a2)
  {
    Mutable = *a3;
    if (!*a3)
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      *a3 = Mutable;
    }
    CFArrayAppendValue(Mutable, a1);
  }
  else
  {
    result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("TagNodeChildren"));
    if (!result)
      return result;
    v8 = (const __CFArray *)result;
    Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1)
      return 0;
    v10 = Count;
    v11 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
      if (StructureElementPathForMCID(ValueAtIndex, a2, a3))
        break;
      if (v10 == ++v11)
        return 0;
    }
    CFArrayInsertValueAtIndex(*a3, 0, a1);
  }
  return 1;
}

void PDFDocumentInsertStructureElementPath(PDFDocument *a1, CFArrayRef theArray)
{
  const __CFArray *v2;
  CFIndex Count;
  CFIndex v5;
  const __CFDictionary *TagNode;
  const __CFDictionary *ValueAtIndex;
  CFIndex v9;
  const __CFDictionary *v10;
  const __CFArray *Value;
  const __CFArray *Mutable;
  CFIndex v13;
  CFIndex v14;
  const __CFArray *v15;
  PDFDocument *v16;
  CFIndex v17;
  const __CFDictionary *v18;
  const void *v19;
  CFIndex v20;
  CFIndex v21;
  const __CFDictionary *v22;
  const __CFAllocator *allocator;
  CFIndex v24;
  CFIndex v25;
  CGPDFTagType v26;
  uint64_t v27;
  uint64_t valuePtr;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v2 = theArray;
  Count = CFArrayGetCount(theArray);
  v25 = Count - 1;
  if (Count >= 1)
  {
    v5 = Count;
    TagNode = a1[35]._private;
    ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, 0);
    if (StructureElementsAreEqual(TagNode, ValueAtIndex, 0) && v5 != 1)
    {
      v9 = 1;
      allocator = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      v24 = v5;
      do
      {
        v10 = (const __CFDictionary *)CFArrayGetValueAtIndex(v2, v9);
        Value = (const __CFArray *)CFDictionaryGetValue(TagNode, CFSTR("TagNodeChildren"));
        if (Value)
        {
          Mutable = Value;
          v13 = CFArrayGetCount(Value);
          if (v13 >= 1)
          {
            v14 = v13;
            v15 = v2;
            v16 = a1;
            v17 = 0;
            while (1)
            {
              TagNode = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v17);
              if (StructureElementsAreEqual(v10, TagNode, 1))
                break;
              if (v14 == ++v17)
              {
                a1 = v16;
                v2 = v15;
                v5 = v24;
                goto LABEL_15;
              }
            }
            a1 = v16;
            v2 = v15;
            v5 = v24;
            if (TagNode)
              goto LABEL_24;
          }
        }
        else
        {
          Mutable = CFArrayCreateMutable(allocator, 0, MEMORY[0x1E0C9B378]);
          CFDictionarySetValue(TagNode, CFSTR("TagNodeChildren"), Mutable);
          CFRelease(Mutable);
        }
LABEL_15:
        v29 = -1;
        CGCFDictionaryGetNumber(v10, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &v29);
        valuePtr = -1;
        CGCFDictionaryGetNumber(v10, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &valuePtr);
        v27 = -1;
        CGCFDictionaryGetNumber(v10, CFSTR("TagNodeObjectRefID"), kCFNumberSInt64Type, &v27);
        v26 = CGPDFTagTypeDiv;
        CGCFDictionaryGetInteger(v10, CFSTR("TagNodeType"), &v26);
        v18 = (const __CFDictionary *)CFDictionaryGetValue(v10, CFSTR("TagNodeProperties"));
        TagNode = PDFDocumentCreateTagNode(a1, v29, v26, v18, v9 == v25);
        CGCFDictionarySetNumber(TagNode, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &valuePtr);
        CGCFDictionarySetNumber(TagNode, CFSTR("TagNodeObjectRefID"), kCFNumberSInt64Type, &v27);
        v19 = CFDictionaryGetValue(v10, CFSTR("ID"));
        if (v19)
          CFDictionarySetValue(TagNode, CFSTR("ID"), v19);
        v20 = CFArrayGetCount(Mutable);
        v31 = -1;
        CGCFDictionaryGetNumber(TagNode, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &v31);
        if (v20 < 1)
        {
          v21 = 0;
        }
        else
        {
          v21 = 0;
          while (1)
          {
            v30 = -1;
            v22 = (const __CFDictionary *)CFArrayGetValueAtIndex(Mutable, v21);
            CGCFDictionaryGetNumber(v22, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &v30);
            if (v30 >= v31)
              break;
            if (v20 == ++v21)
            {
              v21 = v20;
              break;
            }
          }
        }
        CFArrayInsertValueAtIndex(Mutable, v21, TagNode);
        CFRelease(TagNode);
LABEL_24:
        ++v9;
      }
      while (v9 != v5);
    }
  }
}

uint64_t StructureElementsAreEqual(const __CFDictionary *a1, const __CFDictionary *a2, int a3)
{
  uint64_t result;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;

  v12 = -1;
  result = CGCFDictionaryGetNumber(a1, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &v12);
  if ((_DWORD)result)
  {
    v11 = -1;
    result = CGCFDictionaryGetNumber(a2, CFSTR("TagNodeMCID"), kCFNumberSInt64Type, &v11);
    if ((_DWORD)result)
    {
      if (v12 != v11)
        return 0;
      v10 = 104;
      result = CGCFDictionaryGetInteger(a1, CFSTR("TagNodeType"), &v10);
      if ((_DWORD)result)
      {
        v9 = 104;
        result = CGCFDictionaryGetInteger(a2, CFSTR("TagNodeType"), &v9);
        if ((_DWORD)result)
        {
          if (v10 == v9)
          {
            if (!a3
              || (v8 = -1, CGCFDictionaryGetNumber(a1, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &v8))
              && (v7 = -1, CGCFDictionaryGetNumber(a2, CFSTR("TagNodeStructureID"), kCFNumberSInt64Type, &v7))
              && v8 == v7)
            {
              LODWORD(v8) = -1;
              LODWORD(v7) = -1;
              if (!CGCFDictionaryGetInteger(a1, CFSTR("PageObjectNumber"), &v8)
                || !CGCFDictionaryGetInteger(a2, CFSTR("PageObjectNumber"), &v7)
                || (_DWORD)v8 == (_DWORD)v7)
              {
                return 1;
              }
            }
          }
          return 0;
        }
      }
    }
  }
  return result;
}

void PDFDocumentBeginMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  CGPDFTagType v8;
  _BYTE ***ContentStream;
  const char *Name;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (*(_QWORD *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginMarkedContentSequence");
  }
  else if (*(_QWORD *)(a1 + 480))
  {
    v8 = (int)a2;
    ContentStream = (_BYTE ***)PDFDocumentGetContentStream(a1);
    Name = CGPDFTagTypeGetName(v8);
    PDFWriterPrintf(ContentStream[8], (uint64_t)"%s BMC", v11, v12, v13, v14, v15, v16, (uint64_t)Name);
    ContentStream[24] = (_BYTE **)((char *)ContentStream[24] + 1);
  }
  else
  {
    CGPostError((uint64_t)"%s: Cannot start a marked content sequence without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginMarkedContentSequence");
  }
}

uint64_t PDFDocumentBeginStructuralMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  CGPDFTagType v11;
  _QWORD *ContentStream;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _QWORD *v21;
  const char *Name;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;

  if (*(_QWORD *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginStructuralMarkedContentSequence");
    return 0;
  }
  if (!*(_QWORD *)(a1 + 480))
  {
    CGPostError((uint64_t)"%s: Cannot start a structural marked content sequence without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginStructuralMarkedContentSequence");
    return 0;
  }
  v11 = (int)a2;
  ContentStream = PDFDocumentGetContentStream(a1);
  if ((ContentStream[23] & 0x8000000000000000) == 0)
  {
    CGPostError((uint64_t)"%s: Cannot start a structural marked content sequence once one has already started", v13, v14, v15, v16, v17, v18, v19, (char)"PDFContentStreamBeginStructuralMarkedContentSequence");
    return 0;
  }
  v20 = ContentStream;
  v21 = *(_QWORD **)(a1 + 480);
  Name = CGPDFTagTypeGetName(v11);
  v23 = CGPDFMarkedContentItemCreate();
  v8 = v23;
  if (v23)
    PDFMarkedContentItem::PDFMarkedContentItem(v23 + 16, 0, v21);
  PDFWriterPrintf((_BYTE **)v20[8], (uint64_t)"%s << /MCID %d >> BDC", v24, v25, v26, v27, v28, v29, (uint64_t)Name);
  v30 = v20[24];
  v20[23] = v30;
  v20[24] = v30 + 1;
  return v8;
}

void PDFDocumentEndMarkedContentSequence(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BYTE ***ContentStream;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE ***v16;
  _BYTE **v17;
  uint64_t v18;
  uint64_t v19;

  if (*(_QWORD *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndMarkedContentSequence");
  }
  else
  {
    ContentStream = (_BYTE ***)PDFDocumentGetContentStream(a1);
    if ((uint64_t)ContentStream[24] <= 0)
    {
      CGPostError((uint64_t)"%s: End marked content sequence does not have a matching begin", v9, v10, v11, v12, v13, v14, v15, (char)"PDFContentStreamEndMarkedContentSequence");
    }
    else
    {
      v16 = ContentStream;
      PDFWriterPrintf(ContentStream[8], (uint64_t)"EMC", v10, v11, v12, v13, v14, v15, v19);
      v17 = v16[23];
      v18 = (uint64_t)v16[24] - 1;
      v16[24] = (_BYTE **)v18;
      if (v17 == (_BYTE **)v18)
        v16[23] = (_BYTE **)-1;
    }
  }
}

uint64_t PDFDocumentBeginObjectReference(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v10;

  if (a1[70])
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  v10 = a1[60];
  if (!v10)
  {
    CGPostError((uint64_t)"%s: Cannot start an object reference without first starting a page", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  if (a1[73])
  {
    CGPostError((uint64_t)"%s: Cannot start another object reference without ending the first one", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentBeginObjectReference");
    return 0;
  }
  result = CGPDFMarkedContentItemCreate();
  if (result)
  {
    *(_DWORD *)(result + 16) = 1;
    *(_QWORD *)(result + 24) = *(_QWORD *)(v10 + 16);
    *(_QWORD *)(result + 48) = 0;
    *(_OWORD *)(result + 32) = xmmword_185004D30;
  }
  a1[73] = result;
  return result;
}

void PDFDocumentEndObjectReference(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (*(_QWORD *)(a1 + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndObjectReference");
  }
  else
  {
    if (!*(_QWORD *)(a1 + 584))
      CGPostError((uint64_t)"%s: Cannot end an object reference without first starting one", a2, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentEndObjectReference");
    *(_QWORD *)(a1 + 584) = 0;
  }
}

uint64_t PDFDocumentAddStructureTreeRootChild(uint64_t result, CFTypeRef cf, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v8;
  uint64_t v9;
  uint64_t *v10;
  unint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t *v19;
  uint64_t v20;
  int64x2_t v21;
  char *v22;
  char *v23;
  const void *v24;
  const void *v25;

  if (*(_QWORD *)(result + 560))
  {
    CGPostError((uint64_t)"%s: Don't mix the old and new tagging functions", (uint64_t)cf, a3, a4, a5, a6, a7, a8, (char)"PDFDocumentAddStructureTreeRootChild");
    return 1000;
  }
  v8 = (_QWORD *)result;
  if (cf)
  {
    result = (uint64_t)CFRetain(cf);
    v9 = result;
  }
  else
  {
    v9 = 0;
  }
  v10 = (uint64_t *)v8[76];
  v11 = v8[77];
  if ((unint64_t)v10 >= v11)
  {
    v13 = (_QWORD *)v8[75];
    v14 = v10 - v13;
    v15 = v14 + 1;
    if ((unint64_t)(v14 + 1) >> 61)
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    v16 = v11 - (_QWORD)v13;
    if (v16 >> 2 > v15)
      v15 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v15;
    if (v17)
    {
      if (v17 >> 61)
        std::__throw_bad_array_new_length[abi:se180100]();
      v18 = (char *)operator new(8 * v17);
      v19 = (uint64_t *)&v18[8 * v14];
      *v19 = v9;
      v12 = v19 + 1;
      if (v10 == v13)
      {
        v21 = vdupq_n_s64((unint64_t)v10);
      }
      else
      {
        do
        {
          v20 = *--v10;
          *--v19 = v20;
          *v10 = 0;
        }
        while (v10 != v13);
        v21 = *(int64x2_t *)(v8 + 75);
      }
      v8[75] = v19;
      v8[76] = v12;
      v8[77] = &v18[8 * v17];
      v23 = (char *)v21.i64[1];
      v22 = (char *)v21.i64[0];
      while (v23 != v22)
      {
        v25 = (const void *)*((_QWORD *)v23 - 1);
        v23 -= 8;
        v24 = v25;
        if (v25)
          CFRelease(v24);
      }
      if (v22)
        operator delete(v22);
      goto LABEL_27;
    }
  }
  else if (v10)
  {
    *v10 = v9;
    v12 = v10 + 1;
LABEL_27:
    result = 0;
    v8[76] = v12;
    return result;
  }
  __break(1u);
  return result;
}

void sub_184BD5064(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::ObjectRef<CGPDFStructureElement *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

void PDFDocumentBeginPage(_QWORD *a1, const __CFDictionary *a2)
{
  CFDictionaryRef *v3;
  char *v5;
  const void *ObjectNumberForPageNumber;
  CGFloat v7;
  CFDictionaryRef v8;
  const __CFDictionary *v9;
  CGFloat v10;
  float *v11;
  CFTypeID TypeID;
  const __CFDictionary *v13;
  size_t Count;
  const __CFDictionary *v15;
  const __CFDictionary *v16;
  std::__shared_weak_count *v17;
  unint64_t *p_shared_owners;
  unint64_t v19;
  _QWORD *v20;
  CFDictionaryRef v21;
  unint64_t v22;
  CFDictionaryRef *v23;
  _QWORD *v24;
  _QWORD *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  char *v30;
  char *v31;
  uint64_t v32;
  __int128 v33;
  CFDictionaryRef *v34;
  const __CFDictionary *v35;
  CFDictionaryRef v36;
  uint64_t v37;
  double v38;
  double v39;
  CGSize v41;
  char *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  CFDictionaryRef v57;
  uint64_t v58;
  uint64_t v59;
  const __CFDictionary **v60;
  std::__shared_weak_count *v61;
  void *value;
  CGRect context;
  _QWORD *v64;
  CFDictionaryRef *v65;
  _QWORD valuePtr[3];
  int v67;
  CFTypeRef v68;

  v3 = (CFDictionaryRef *)a1[57];
  if (v3)
  {
    v5 = (char *)v3[1];
    v3[1] = (CFDictionaryRef)(v5 + 1);
    ObjectNumberForPageNumber = PDFPageTree::getObjectNumberForPageNumber(v3, v5);
    if (ObjectNumberForPageNumber)
    {
      v7 = *(double *)&ObjectNumberForPageNumber;
      PDFPageTree::addNode((PDFPageTree *)&v60, v3, (uint64_t)ObjectNumberForPageNumber, 1);
      if (v60)
      {
        v8 = *v3;
        v9 = *v60;
        v3 = (CFDictionaryRef *)malloc_type_calloc(1uLL, 0x68uLL, 0x33BCE901uLL);
        __CFSetLastAllocationEventName();
        if (v3)
        {
          *(_DWORD *)v3 = 1;
          v3[1] = v8;
          *((CGFloat *)v3 + 2) = v7;
          v3[3] = v9;
          v3[5] = 0;
          value = 0;
          if (a2)
          {
            if (CFDictionaryGetValueIfPresent(a2, CFSTR("StructParents"), (const void **)&value))
            {
              valuePtr[0] = 0;
              CFNumberGetValue((CFNumberRef)value, kCFNumberLongType, valuePtr);
              v10 = *(double *)valuePtr;
              v3[12] = (CFDictionaryRef)valuePtr[0];
              if (v8)
              {
                v11 = (float *)*((_QWORD *)v8 + 38);
                context.origin.x = v10;
                context.origin.y = v7;
                std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(v11, *(unint64_t *)&v10, &context);
              }
            }
            else
            {
              v3[12] = (CFDictionaryRef)-1;
            }
            a2 = (const __CFDictionary *)CFRetain(a2);
          }
          else
          {
            v3[12] = (CFDictionaryRef)-1;
          }
          v3[6] = a2;
          v3[9] = 0;
          v3[11] = 0;
          v68 = 0;
          TypeID = CFDictionaryGetTypeID();
          if (CGCFDictionaryGetCFTypeRef(a2, CFSTR("CGPDFContextPageApplicationData"), TypeID, (uint64_t *)&v68))
          {
            v13 = (const __CFDictionary *)CFRetain(v68);
            v3[7] = v13;
            Count = CFDictionaryGetCount(v13);
            v15 = (const __CFDictionary *)malloc_type_calloc(Count, 8uLL, 0x33BCE901uLL);
            __CFSetLastAllocationEventName();
            v3[8] = v15;
            valuePtr[0] = 0;
            valuePtr[1] = valuePtr;
            valuePtr[2] = 0x2000000000;
            v67 = 0;
            v16 = v3[7];
            *(_QWORD *)&context.origin.x = MEMORY[0x1E0C809B0];
            *(_QWORD *)&context.origin.y = 0x40000000;
            *(_QWORD *)&context.size.width = __init_appl_data_block_invoke;
            *(_QWORD *)&context.size.height = &unk_1E1662518;
            v64 = valuePtr;
            v65 = v3;
            CFDictionaryApplyFunction(v16, (CFDictionaryApplierFunction)call_dict_block, &context);
            _Block_object_dispose(valuePtr, 8);
          }
        }
      }
      else
      {
        v3 = 0;
      }
      v17 = v61;
      if (v61)
      {
        p_shared_owners = (unint64_t *)&v61->__shared_owners_;
        do
          v19 = __ldaxr(p_shared_owners);
        while (__stlxr(v19 - 1, p_shared_owners));
        if (!v19)
        {
          ((void (*)(std::__shared_weak_count *))v17->__on_zero_shared)(v17);
          std::__shared_weak_count::__release_weak(v17);
        }
      }
    }
    else
    {
      v3 = 0;
    }
  }
  a1[60] = v3;
  v20 = (_QWORD *)a1[65];
  if (v20)
  {
    v20[1] = v3;
    if (v3)
      v21 = v3[2];
    else
      v21 = 0;
    v23 = (CFDictionaryRef *)v20[7];
    v22 = v20[8];
    if ((unint64_t)v23 >= v22)
    {
      v25 = (_QWORD *)v20[6];
      v26 = 0x8E38E38E38E38E39 * (v23 - (CFDictionaryRef *)v25) + 1;
      if (v26 > 0x38E38E38E38E38ELL)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v27 = 0x8E38E38E38E38E39 * ((uint64_t)(v22 - (_QWORD)v25) >> 3);
      if (2 * v27 > v26)
        v26 = 2 * v27;
      if (v27 >= 0x1C71C71C71C71C7)
        v28 = 0x38E38E38E38E38ELL;
      else
        v28 = v26;
      if (v28)
      {
        if (v28 > 0x38E38E38E38E38ELL)
          std::__throw_bad_array_new_length[abi:se180100]();
        v29 = (char *)operator new(72 * v28);
      }
      else
      {
        v29 = 0;
      }
      v30 = &v29[8 * (v23 - (CFDictionaryRef *)v25)];
      *(_QWORD *)v30 = v21;
      *(_OWORD *)(v30 + 8) = 0u;
      *(_OWORD *)(v30 + 24) = 0u;
      v31 = &v29[72 * v28];
      *(_OWORD *)(v30 + 40) = 0u;
      *(_OWORD *)(v30 + 56) = 0u;
      v24 = v30 + 72;
      if (v23 == v25)
      {
        v20[6] = v30;
        v20[7] = v24;
        v20[8] = v31;
        if (!v23)
          goto LABEL_46;
      }
      else
      {
        do
        {
          v32 = (uint64_t)*(v23 - 7);
          *(_OWORD *)(v30 - 72) = *(_OWORD *)(v23 - 9);
          *((_QWORD *)v30 - 7) = v32;
          *((_QWORD *)v30 - 6) = 0;
          *((_QWORD *)v30 - 5) = 0;
          *((_QWORD *)v30 - 4) = 0;
          *((_OWORD *)v30 - 3) = *((_OWORD *)v23 - 3);
          *((_QWORD *)v30 - 4) = *(v23 - 4);
          *(v23 - 6) = 0;
          *(v23 - 5) = 0;
          *(v23 - 4) = 0;
          v33 = *(_OWORD *)(v23 - 3);
          *((_QWORD *)v30 - 1) = *(v23 - 1);
          *(_OWORD *)(v30 - 24) = v33;
          v30 -= 72;
          v23 -= 9;
        }
        while (v23 != v25);
        v34 = (CFDictionaryRef *)v20[6];
        v23 = (CFDictionaryRef *)v20[7];
        v20[6] = v30;
        v20[7] = v24;
        v20[8] = v31;
        if (v23 != v34)
        {
          do
          {
            v35 = *(v23 - 6);
            if (v35)
            {
              *(v23 - 5) = v35;
              operator delete(v35);
            }
            v23 -= 9;
          }
          while (v23 != v34);
          v23 = v34;
        }
        if (!v23)
          goto LABEL_46;
      }
      operator delete(v23);
    }
    else
    {
      *v23 = v21;
      *(_OWORD *)(v23 + 1) = 0u;
      *(_OWORD *)(v23 + 3) = 0u;
      *(_OWORD *)(v23 + 5) = 0u;
      *(_OWORD *)(v23 + 7) = 0u;
      v24 = v23 + 9;
    }
LABEL_46:
    v20[7] = v24;
    v3 = (CFDictionaryRef *)a1[60];
  }
  memset(&context, 0, sizeof(context));
  if (!CGCFDictionaryGetRect(v3[6], CFSTR("MediaBox"), (UInt8 *)&context))
  {
    v36 = v3[1];
    v38 = *((double *)v36 + 12);
    v39 = *((double *)v36 + 13);
    v37 = (uint64_t)v36 + 96;
    if (v38 != INFINITY && v39 != INFINITY)
    {
      v41 = *(CGSize *)(v37 + 16);
      context.origin = *(CGPoint *)v37;
      context.size = v41;
    }
  }
  v42 = PDFContentStreamCreate((uint64_t)v3[1], &context);
  v3[5] = (CFDictionaryRef)v42;
  if (v42)
  {
    PDFContentStreamBegin((uint64_t)v42, v43, v44, v45, v46, v47, v48, v49, v58);
    PDFContentStreamBeginData((uint64_t *)v3[5], v50, v51, v52, v53, v54, v55, v56, v59);
    v57 = v3[5];
  }
  else
  {
    v57 = 0;
  }
  PDFDocumentPushContentStream((uint64_t)a1, v57);
}

void sub_184BD5500(void *a1, int a2)
{
  void *v3;

  v3 = __cxa_begin_catch(a1);
  if (a2 == 2)
  {
    (*(void (**)(void *))(*(_QWORD *)v3 + 16))(v3);
    pdf_error("%s caught exception: %s");
  }
  else
  {
    pdf_error("%s caught an unknown exception");
  }
  __cxa_end_catch();
  JUMPOUT(0x184BD5448);
}

void PDFDocumentEndPage(uint64_t a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  BOOL v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  __int128 v89;
  uint64_t v90;
  __int128 *v91;
  double v92;
  double v93;
  __int128 v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  _BOOL4 Rect;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  const char *v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  double *v120;
  double *v121;
  double *v122;
  double v123;
  __int128 v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  CGContext *v132;
  CGImageRef Image;
  const void *v134;
  const __CFData *Mutable;
  const void *v136;
  CGDataProvider *v137;
  CGImageRef v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  const __CFDictionary *v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t v163;
  uint64_t v164;
  uint64_t v165;
  uint64_t v166;
  CFIndex Count;
  uint64_t v168;
  uint64_t v169;
  uint64_t v170;
  uint64_t v171;
  uint64_t v172;
  uint64_t v173;
  CFIndex v174;
  CFIndex i;
  const void *ValueAtIndex;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  const __CFDictionary *v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  const void *v198;
  const void *v199;
  const void *v200;
  const void *v201;
  uint64_t v202;
  uint64_t v203;
  uint64_t v204;
  uint64_t v205;
  uint64_t v206;
  unsigned int v207;
  __int128 context;
  __int128 v209;
  __int128 *v210;
  void *v211;
  __int128 v212;
  __int128 v213;

  v2 = *(void **)(a1 + 480);
  *(_QWORD *)(a1 + 480) = 0;
  if (!v2)
    goto LABEL_107;
  PDFDocumentPopContentStream(a1);
  PDFContentStreamEndData(*((_QWORD *)v2 + 5), v3, v4, v5, v6, v7, v8, v9);
  PDFContentStreamEnd(*((CFDataRef **)v2 + 5));
  PDFDocumentBeginObject(*((_QWORD *)v2 + 1), *((_QWORD *)v2 + 2), v10, v11, v12, v13, v14, v15);
  PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"<<", v16, v17, v18, v19, v20, v21, v202);
  PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/Type /Page", v22, v23, v24, v25, v26, v27, v203);
  PDFDocumentPrintPageParentReference(*((_QWORD *)v2 + 1), (uint64_t)"/Parent %R", *((_QWORD *)v2 + 3), v28, v29, v30, v31, v32);
  if (*((_QWORD *)v2 + 12) != -1)
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/StructParents %d", v33, v34, v35, v36, v37, v38, *((_QWORD *)v2 + 12));
  v39 = *((_QWORD *)v2 + 5);
  if (v39)
  {
    v40 = *(_QWORD *)(v39 + 112);
    v41 = v40 == 0;
    if (v40)
    {
      PDFDocumentPrintReference(*((_QWORD *)v2 + 1), (uint64_t)"/Resources %R", *(_QWORD *)(v40 + 16), v34, v35, v36, v37, v38);
      v39 = *((_QWORD *)v2 + 5);
      v207 = 0;
      if (!v39)
      {
        v42 = 0;
        goto LABEL_11;
      }
    }
    else
    {
      v207 = 0;
    }
    v42 = *(_QWORD *)(v39 + 8);
  }
  else
  {
    v40 = 0;
    v42 = 0;
    v207 = 0;
    v41 = 1;
  }
LABEL_11:
  PDFDocumentPrintReference(*((_QWORD *)v2 + 1), (uint64_t)"/Contents %R", v42, v34, v35, v36, v37, v38);
  v43 = *((_QWORD *)v2 + 1);
  if (PDFOutputIntentGetIsX3(*(_BYTE **)(v43 + 48)))
  {
    v212 = 0uLL;
    v213 = 0uLL;
    v44 = *(unsigned __int8 *)(v43 + 90);
    if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("MediaBox"), (UInt8 *)&v212))
    {
      v51 = *((_QWORD *)v2 + 1);
    }
    else
    {
      if (!v44)
      {
        if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("CropBox"), (UInt8 *)&v212))
          goto LABEL_42;
        goto LABEL_41;
      }
      v51 = *((_QWORD *)v2 + 1);
      v82 = *(double *)(v51 + 96) == INFINITY || *(double *)(v51 + 104) == INFINITY;
      if (v82)
      {
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("CropBox"), (UInt8 *)&v212))
          goto LABEL_41;
LABEL_36:
        v90 = *((_QWORD *)v2 + 1);
        v92 = *(double *)(v90 + 128);
        v93 = *(double *)(v90 + 136);
        v91 = (__int128 *)(v90 + 128);
        if (v92 != INFINITY && v93 != INFINITY)
        {
          v95 = v91[1];
          v212 = *v91;
          v213 = v95;
          goto LABEL_41;
        }
LABEL_42:
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("BleedBox"), (UInt8 *)&v212))
          PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/BleedBox %r", v96, v97, v98, v99, v100, v101, (uint64_t)&v212);
        if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("TrimBox"), (UInt8 *)&v212))
        {
          PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/TrimBox %r", v102, v103, v104, v105, v106, v107, (uint64_t)&v212);
          goto LABEL_64;
        }
        Rect = CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("ArtBox"), (UInt8 *)&v212);
        v115 = *((_QWORD *)v2 + 1);
        if (Rect)
          goto LABEL_47;
        if (*(double *)(v115 + 192) == INFINITY || *(double *)(v115 + 200) == INFINITY)
        {
          if (*(double *)(v115 + 224) != INFINITY && *(double *)(v115 + 232) != INFINITY)
          {
            v119 = *(_OWORD *)(v115 + 240);
            v212 = *(_OWORD *)(v115 + 224);
            v213 = v119;
LABEL_47:
            v116 = "/ArtBox %r";
LABEL_63:
            PDFDocumentPrintf(v115, (uint64_t)v116, v109, v110, v111, v112, v113, v114, (uint64_t)&v212);
            goto LABEL_64;
          }
          context = 0u;
          v209 = 0u;
          if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("CropBox"), (UInt8 *)&context)
            && !CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("MediaBox"), (UInt8 *)&context))
          {
            if ((v120 = (double *)*((_QWORD *)v2 + 1), v121 = v120 + 16, v120[16] != INFINITY) && v120[17] != INFINITY
              || (v123 = v120[12], v122 = v120 + 12, v123 != INFINITY) && (v121 = v122, v122[1] != INFINITY))
            {
              v124 = *((_OWORD *)v121 + 1);
              context = *(_OWORD *)v121;
              v209 = v124;
            }
          }
          v117 = context;
          v118 = v209;
        }
        else
        {
          v117 = *(_OWORD *)(v115 + 192);
          v118 = *(_OWORD *)(v115 + 208);
        }
        v212 = v117;
        v213 = v118;
        v116 = "/TrimBox %r";
        goto LABEL_63;
      }
      v89 = *(_OWORD *)(v51 + 112);
      v212 = *(_OWORD *)(v51 + 96);
      v213 = v89;
    }
    PDFDocumentPrintf(v51, (uint64_t)"/MediaBox %r", v45, v46, v47, v48, v49, v50, (uint64_t)&v212);
    if (!CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("CropBox"), (UInt8 *)&v212))
    {
      if (!v44)
        goto LABEL_42;
      goto LABEL_36;
    }
LABEL_41:
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/CropBox %r", v83, v84, v85, v86, v87, v88, (uint64_t)&v212);
    goto LABEL_42;
  }
  context = 0uLL;
  v209 = 0uLL;
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("MediaBox"), (UInt8 *)&context))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/MediaBox %r", v52, v53, v54, v55, v56, v57, (uint64_t)&context);
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("CropBox"), (UInt8 *)&context))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/CropBox %r", v58, v59, v60, v61, v62, v63, (uint64_t)&context);
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("BleedBox"), (UInt8 *)&context))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/BleedBox %r", v64, v65, v66, v67, v68, v69, (uint64_t)&context);
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("TrimBox"), (UInt8 *)&context))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/TrimBox %r", v70, v71, v72, v73, v74, v75, (uint64_t)&context);
  if (CGCFDictionaryGetRect(*((const __CFDictionary **)v2 + 6), CFSTR("ArtBox"), (UInt8 *)&context))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/ArtBox %r", v76, v77, v78, v79, v80, v81, (uint64_t)&context);
LABEL_64:
  if (CGCFDictionaryGetInteger(*((CFDictionaryRef *)v2 + 6), CFSTR("Rotate"), &v207))
    PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)"/Rotate %d", v125, v126, v127, v128, v129, v130, v207);
  v131 = *((_QWORD *)v2 + 4);
  if (v131)
    PDFDocumentPrintReference(*((_QWORD *)v2 + 1), (uint64_t)"/Annots %R", *(_QWORD *)(v131 + 8), v126, v127, v128, v129, v130);
  v132 = (CGContext *)*((_QWORD *)v2 + 9);
  if (!v132)
    goto LABEL_83;
  Image = CGBitmapContextCreateImage(v132);
  v134 = (const void *)*((_QWORD *)v2 + 9);
  if (v134)
    CFRelease(v134);
  *((_QWORD *)v2 + 9) = 0;
  Mutable = CFDataCreateMutable(0, 0);
  if (emit_thumbnail_predicate != -1)
    dispatch_once(&emit_thumbnail_predicate, &__block_literal_global_20281);
  v136 = (const void *)emit_thumbnail_f(Mutable, CFSTR("public.jpeg"), 1, 0);
  if (emit_thumbnail_predicate_24 != -1)
    dispatch_once(&emit_thumbnail_predicate_24, &__block_literal_global_26_20283);
  emit_thumbnail_f_23(v136, Image, 0);
  if (Image)
    CFRelease(Image);
  if (emit_thumbnail_predicate_29 != -1)
    dispatch_once(&emit_thumbnail_predicate_29, &__block_literal_global_31_20284);
  emit_thumbnail_f_28(v136);
  CFRelease(v136);
  v137 = CGDataProviderCreateWithCFData(Mutable);
  CFRelease(Mutable);
  v138 = CGImageCreateWithJPEGDataProvider2((uint64_t)v137, 0, 0, 0, 0);
  CGDataProviderRelease(v137);
  v144 = *((_QWORD *)PDFDocumentAddImage(*((_QWORD *)v2 + 1), (uint64_t)v138, 1u) + 2);
  if (!v144)
  {
    v145 = 0;
    if (!v138)
      goto LABEL_82;
    goto LABEL_81;
  }
  v145 = *(_QWORD *)(v144 + 8);
  if (v138)
LABEL_81:
    CFRelease(v138);
LABEL_82:
  PDFDocumentPrintReference(*((_QWORD *)v2 + 1), (uint64_t)"/Thumb %R", v145, v139, v140, v141, v142, v143);
LABEL_83:
  v146 = (const __CFDictionary *)*((_QWORD *)v2 + 7);
  if (v146 && *((_QWORD *)v2 + 8))
  {
    *(_QWORD *)&v212 = 0;
    *((_QWORD *)&v212 + 1) = &v212;
    *(_QWORD *)&v213 = 0x2000000000;
    DWORD2(v213) = 0;
    *(_QWORD *)&context = MEMORY[0x1E0C809B0];
    *((_QWORD *)&context + 1) = 0x40000000;
    *(_QWORD *)&v209 = __emit_application_data_block_invoke;
    *((_QWORD *)&v209 + 1) = &unk_1E1662620;
    v210 = &v212;
    v211 = v2;
    CFDictionaryApplyFunction(v146, (CFDictionaryApplierFunction)call_dict_block, &context);
    _Block_object_dispose(&v212, 8);
  }
  PDFDocumentPrintf(*((_QWORD *)v2 + 1), (uint64_t)">>", v125, v126, v127, v128, v129, v130, v204);
  PDFDocumentEndObject(*((_QWORD *)v2 + 1), v147, v148, v149, v150, v151, v152, v153);
  if (!v41)
    PDFResourceSetEmit(v40, v154, v155, v156, v157, v158, v159, v160);
  if (v131)
  {
    PDFDocumentBeginObject(*(_QWORD *)(v131 + 16), *(_QWORD *)(v131 + 8), v155, v156, v157, v158, v159, v160);
    PDFDocumentPrintf(*(_QWORD *)(v131 + 16), (uint64_t)"[", v161, v162, v163, v164, v165, v166, v205);
    Count = CFArrayGetCount(*(CFArrayRef *)(v131 + 32));
    if (Count)
    {
      v174 = Count;
      for (i = 0; i != v174; ++i)
      {
        ValueAtIndex = CFArrayGetValueAtIndex(*(CFArrayRef *)(v131 + 32), i);
        PDFDocumentPrintReference(*(_QWORD *)(v131 + 16), (uint64_t)"%R", (uint64_t)ValueAtIndex, v177, v178, v179, v180, v181);
      }
    }
    PDFDocumentPrintf(*(_QWORD *)(v131 + 16), (uint64_t)"]", v168, v169, v170, v171, v172, v173, v206);
    PDFDocumentEndObject(*(_QWORD *)(v131 + 16), v182, v183, v184, v185, v186, v187, v188);
  }
  v189 = (const __CFDictionary *)*((_QWORD *)v2 + 7);
  if (v189 && *((_QWORD *)v2 + 8))
  {
    *(_QWORD *)&v212 = 0;
    *((_QWORD *)&v212 + 1) = &v212;
    *(_QWORD *)&v213 = 0x2000000000;
    DWORD2(v213) = 0;
    *(_QWORD *)&context = MEMORY[0x1E0C809B0];
    *((_QWORD *)&context + 1) = 0x40000000;
    *(_QWORD *)&v209 = __emit_application_data_streams_block_invoke;
    *((_QWORD *)&v209 + 1) = &unk_1E1662648;
    v210 = &v212;
    v211 = v2;
    CFDictionaryApplyFunction(v189, (CFDictionaryApplierFunction)call_dict_block, &context);
    _Block_object_dispose(&v212, 8);
  }
  emit_page_resources((PDFDocument *)a1);
  v197 = *(_QWORD *)(a1 + 520);
  if (v197)
    *(_QWORD *)(v197 + 8) = 0;
  v82 = (*(_DWORD *)v2)-- == 1;
  if (v82)
  {
    PDFContentStreamRelease(*((_QWORD *)v2 + 5), v190, v191, v192, v193, v194, v195, v196);
    PDFAnnotationSetRelease(*((unsigned int **)v2 + 4));
    v198 = (const void *)*((_QWORD *)v2 + 6);
    if (v198)
      CFRelease(v198);
    v199 = (const void *)*((_QWORD *)v2 + 7);
    if (v199)
      CFRelease(v199);
    v200 = (const void *)*((_QWORD *)v2 + 9);
    if (v200)
      CFRelease(v200);
    free(*((void **)v2 + 8));
    free(v2);
  }
LABEL_107:
  v201 = *(const void **)(a1 + 536);
  if (v201)
  {
    CFRelease(v201);
    *(_QWORD *)(a1 + 536) = 0;
  }
  *(_DWORD *)(a1 + 544) = 0;
}

void PDFDocumentSetPageRedactionPath(uint64_t a1, CFTypeRef cf)
{
  CFTypeRef v4;

  if (a1)
  {
    v4 = *(CFTypeRef *)(a1 + 488);
    if (v4 != cf)
    {
      if (v4)
        CFRelease(v4);
      if (cf)
        CFRetain(cf);
      *(_QWORD *)(a1 + 488) = cf;
    }
  }
}

_QWORD *PDFDocumentSetParentTree(_QWORD *result, _QWORD *cf)
{
  _QWORD *v3;

  if (result)
  {
    v3 = result;
    result = (_QWORD *)result[62];
    if (result != cf)
    {
      if (result)
        CFRelease(result);
      result = CFRetain(cf);
      v3[62] = result;
    }
  }
  return result;
}

_QWORD *PDFDocumentSetIDTree(_QWORD *result, _QWORD *cf)
{
  _QWORD *v3;

  if (result)
  {
    v3 = result;
    result = (_QWORD *)result[63];
    if (result != cf)
    {
      if (result)
        CFRelease(result);
      result = CFRetain(cf);
      v3[63] = result;
    }
  }
  return result;
}

_QWORD *PDFDocumentSetPageTagStructureTree(_QWORD *result, _QWORD *cf)
{
  _QWORD *v3;

  if (result)
  {
    v3 = result;
    result = (_QWORD *)result[64];
    if (result != cf)
    {
      if (result)
        CFRelease(result);
      result = CFRetain(cf);
      v3[64] = result;
    }
  }
  return result;
}

void *PDFDocumentAddColorSpace(uint64_t a1, void *key)
{
  void *v3;
  BOOL v5;
  void *v6;
  void *Value;
  uint64_t v8;
  int v9;
  const void **v10;

  v3 = *(void **)(a1 + 328);
  if (!v3)
  {
    v3 = malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    *(_QWORD *)v3 = a1;
    *((_QWORD *)v3 + 1) = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, &color_space_callbacks);
    *((_QWORD *)v3 + 2) = 0;
    *((_DWORD *)v3 + 6) = 0;
    *(_QWORD *)(a1 + 328) = v3;
  }
  if (v3)
    v5 = key == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  Value = (void *)CFDictionaryGetValue(*((CFDictionaryRef *)v3 + 1), key);
  v6 = Value;
  if (!Value)
  {
    v8 = *(_QWORD *)v3;
    v9 = *((_DWORD *)v3 + 6) + 1;
    *((_DWORD *)v3 + 6) = v9;
    v6 = PDFColorSpaceCreate(v8, key, v9);
    CFDictionarySetValue(*((CFMutableDictionaryRef *)v3 + 1), key, v6);
    v10 = (const void **)*((_QWORD *)v3 + 2);
    if (!v10)
    {
      v10 = CGOrderedSetCreate();
      *((_QWORD *)v3 + 2) = v10;
    }
    CGOrderedSetAddValue((CFSetRef *)v10, v6);
    PDFColorSpaceRelease((uint64_t)v6);
  }
  return v6;
}

PDFDocumentPrivate *PDFDocumentResolveColorSpace(uint64_t a1, CGColorSpace *a2)
{
  CGColorSpaceRef DeviceCMYK;
  int Type;

  DeviceCMYK = a2;
  if (a2 && *(_BYTE *)(*((_QWORD *)a2 + 3) + 9))
    return DeviceCMYK;
  Type = CGColorSpaceGetType(a2);
  if (Type == 2)
  {
    if (*(_BYTE *)(a1 + 91))
    {
      DeviceCMYK = *(CGColorSpaceRef *)(a1 + 448);
      if (!DeviceCMYK)
      {
        DeviceCMYK = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericCMYK"));
        *(_QWORD *)(a1 + 448) = DeviceCMYK;
        if (!DeviceCMYK)
        {
          DeviceCMYK = CGColorSpaceCreateDeviceCMYK();
          *(_QWORD *)(a1 + 448) = DeviceCMYK;
        }
      }
    }
    return DeviceCMYK;
  }
  if (Type != 1)
  {
    if (!Type)
    {
      DeviceCMYK = *(CGColorSpaceRef *)(a1 + 432);
      if (!DeviceCMYK)
      {
        DeviceCMYK = CGColorSpaceCreateWithName(CFSTR("kCGColorSpaceGenericGrayGamma2_2"));
        *(_QWORD *)(a1 + 432) = DeviceCMYK;
        if (!DeviceCMYK)
        {
          DeviceCMYK = CGColorSpaceCreateDeviceGray();
          *(_QWORD *)(a1 + 432) = DeviceCMYK;
        }
      }
    }
    return DeviceCMYK;
  }
  return get_default_rgb_color_space((PDFDocument *)a1);
}

void PDFDocumentAddAnnotationToPage(PDFDocument *a1, uint64_t a2, const __CFDictionary *a3)
{
  __CFDictionary *MutableCopy;
  const __CFNumber *Value;
  void *v8;
  uint64_t v9;
  CFMutableArrayRef Mutable;
  uint64_t v11;
  uint64_t v12;
  CFIndex Count;
  CFMutableDictionaryRef v14;
  __CFDictionary *v15;
  const void *v16;
  uint64_t v17;
  uint64_t v18;
  float *isa;
  const __CFArray *v20;
  uint64_t v21[2];
  __int128 theArray;

  MutableCopy = CFDictionaryCreateMutableCopy(0, 0, a3);
  v21[1] = (uint64_t)MutableCopy;
  Value = (const __CFNumber *)CFDictionaryGetValue(a3, CFSTR("ObjectNumber"));
  CFDictionaryRemoveValue(MutableCopy, CFSTR("ObjectNumber"));
  v8 = *(void **)(a2 + 32);
  if (!v8)
  {
    v9 = *(_QWORD *)(a2 + 8);
    v8 = malloc_type_calloc(1uLL, 0x28uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8)
    {
      *(_DWORD *)v8 = 1;
      *((_QWORD *)v8 + 2) = v9;
      *((_QWORD *)v8 + 1) = PDFXRefTableAddObject(*(_QWORD **)(v9 + 464));
      *((_QWORD *)v8 + 3) = *(_QWORD *)(v9 + 40);
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
      *((_QWORD *)v8 + 4) = Mutable;
      if (!Mutable)
      {
        PDFAnnotationSetRelease((unsigned int *)v8);
        v8 = 0;
      }
    }
    *(_QWORD *)(a2 + 32) = v8;
  }
  v11 = -1;
  if (v8 && MutableCopy)
  {
    v12 = *(_QWORD *)(*((_QWORD *)v8 + 2) + 584);
    if (v12
      && (Count = CFDictionaryGetCount(MutableCopy),
          (v14 = CFDictionaryCreateMutableCopy(0, Count + 1, MutableCopy)) != 0))
    {
      v15 = v14;
      v16 = PDFMetaSetAddDictionary(*((_QWORD *)v8 + 3), v14);
      v11 = (uint64_t)v16;
      if (*(_DWORD *)(v12 + 16) == 1 && !*(_QWORD *)(v12 + 32))
      {
        v17 = *((_QWORD *)v8 + 2);
        *(_QWORD *)(v12 + 32) = v16;
        v18 = *(_QWORD *)(v17 + 592);
        *(_QWORD *)(v17 + 592) = v18 + 1;
        *(_QWORD *)(v12 + 40) = v18;
        if (v18 != -1)
          CGCFDictionarySetLongInteger(v15, CFSTR("/StructParent"), v18);
      }
      CFRelease(v15);
    }
    else
    {
      v11 = (uint64_t)PDFMetaSetAddDictionary(*((_QWORD *)v8 + 3), MutableCopy);
    }
    CFArrayAppendValue(*((CFMutableArrayRef *)v8 + 4), (const void *)v11);
  }
  if (a1[32].super.isa)
  {
    if (Value)
    {
      v21[0] = 0;
      CFNumberGetValue(Value, kCFNumberLongType, v21);
      isa = (float *)a1[18].super.isa;
      *(_QWORD *)&theArray = v21[0];
      *((_QWORD *)&theArray + 1) = v11;
      std::__hash_table<std::__hash_value_type<unsigned long long,unsigned long long>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,unsigned long long>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,unsigned long long>>>::__emplace_unique_key_args<unsigned long long,std::pair<unsigned long long const,unsigned long long>>(isa, v21[0], &theArray);
      *(_QWORD *)&theArray = 0;
      StructureElementPathForObjectRefID(a1[32].super.isa, v21[0], (__CFArray **)&theArray);
      v20 = (const __CFArray *)theArray;
      if ((_QWORD)theArray)
      {
        if (CFArrayGetCount((CFArrayRef)theArray) >= 1)
          PDFDocumentInsertStructureElementPath(a1, v20);
      }
    }
  }
  if (MutableCopy)
    CFRelease(MutableCopy);
}

void sub_184BD6308(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef((const void **)va);
  _Unwind_Resume(a1);
}

uint64_t StructureElementPathForObjectRefID(const __CFDictionary *a1, uint64_t a2, __CFArray **a3)
{
  uint64_t result;
  const __CFArray *v8;
  CFIndex Count;
  CFIndex v10;
  CFIndex v11;
  const __CFDictionary *ValueAtIndex;
  CFMutableArrayRef Mutable;
  uint64_t v14;

  v14 = -1;
  if (CGCFDictionaryGetNumber(a1, CFSTR("TagNodeObjectRefID"), kCFNumberSInt64Type, &v14) && v14 == a2)
  {
    Mutable = *a3;
    if (!*a3)
    {
      Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B378]);
      *a3 = Mutable;
    }
    CFArrayAppendValue(Mutable, a1);
  }
  else
  {
    result = (uint64_t)CFDictionaryGetValue(a1, CFSTR("TagNodeChildren"));
    if (!result)
      return result;
    v8 = (const __CFArray *)result;
    Count = CFArrayGetCount((CFArrayRef)result);
    if (Count < 1)
      return 0;
    v10 = Count;
    v11 = 0;
    while (1)
    {
      ValueAtIndex = (const __CFDictionary *)CFArrayGetValueAtIndex(v8, v11);
      if (StructureElementPathForObjectRefID(ValueAtIndex, a2, a3))
        break;
      if (v10 == ++v11)
        return 0;
    }
    CFArrayInsertValueAtIndex(*a3, 0, a1);
  }
  return 1;
}

const void **applesauce::CF::ObjectRef<__CFDictionary *>::~ObjectRef(const void **a1)
{
  const void *v2;

  v2 = *a1;
  if (v2)
    CFRelease(v2);
  return a1;
}

uint64_t PDFDocumentAddFont(uint64_t a1, _QWORD *a2)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t **v5;
  uint64_t *v6;
  unint64_t v7;
  BOOL v8;
  _QWORD *v9;
  int v10;
  int v11;
  uint64_t v14;
  void (**v15)(TrueType *__hidden);
  void **v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t **v19;
  int v20;
  int v21;
  uint64_t **v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t **v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  const void *v31;
  void *__p[2];
  char v33;
  __int128 v34;
  uint64_t v35;

  v3 = *(_QWORD *)(a1 + 336);
  if (v3)
  {
    if (a2)
      goto LABEL_3;
    return 0;
  }
  v3 = operator new();
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)v3 = a1;
  *(_QWORD *)(v3 + 8) = v3 + 16;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 32) = v3 + 40;
  *(_QWORD *)(v3 + 72) = 0;
  *(_QWORD *)(v3 + 64) = 0;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = v3 + 64;
  *(_DWORD *)(v3 + 80) = 0;
  *(_QWORD *)(a1 + 336) = v3;
  if (!a2)
    return 0;
LABEL_3:
  v5 = (uint64_t **)(v3 + 40);
  v4 = *(_QWORD **)(v3 + 40);
  if (!v4)
    goto LABEL_14;
  v6 = (uint64_t *)(v3 + 40);
  do
  {
    v7 = v4[4];
    v8 = v7 >= (unint64_t)a2;
    if (v7 >= (unint64_t)a2)
      v9 = v4;
    else
      v9 = v4 + 1;
    if (v8)
      v6 = v4;
    v4 = (_QWORD *)*v9;
  }
  while (*v9);
  if (v6 == (uint64_t *)v5 || v6[4] > (unint64_t)a2)
  {
LABEL_14:
    v10 = *(_DWORD *)(v3 + 80) + 1;
    *(_DWORD *)(v3 + 80) = v10;
    v31 = a2;
    v30 = v10;
    LODWORD(v34) = 0;
    if (CGFontGetIntProperty((uint64_t)a2, CFSTR("com.apple.CoreGraphics.CGPDFFontFormat"), &v34))
      v11 = v34;
    else
      v11 = (*(uint64_t (**)(_QWORD))(a2[2] + 336))(a2[14]);
    switch(v11)
    {
      case 0:
      case 5:
        goto LABEL_29;
      case 1:
        v14 = operator new();
        *(_QWORD *)v14 = off_1E1628BE8;
        *(_QWORD *)(v14 + 8) = v3;
        CFRetain(a2);
        *(_QWORD *)(v14 + 16) = a2;
        *(_DWORD *)(v14 + 24) = v10;
        *(_QWORD *)(v14 + 40) = 0;
        *(_QWORD *)(v14 + 48) = 0;
        *(_QWORD *)(v14 + 32) = 0;
        *(_BYTE *)(v14 + 56) = 0;
        *(_QWORD *)(v14 + 64) = 0;
        *(_QWORD *)(v14 + 72) = 0;
        *(_QWORD *)(v14 + 96) = 0;
        *(_QWORD *)(v14 + 104) = 0;
        *(_QWORD *)(v14 + 80) = 0;
        *(_QWORD *)(v14 + 88) = v14 + 96;
        v15 = &off_1E1628C28;
        goto LABEL_23;
      case 2:
        v14 = operator new();
        *(_QWORD *)v14 = off_1E1628BE8;
        *(_QWORD *)(v14 + 8) = v3;
        CFRetain(a2);
        *(_QWORD *)(v14 + 16) = a2;
        *(_DWORD *)(v14 + 24) = v10;
        *(_QWORD *)(v14 + 40) = 0;
        *(_QWORD *)(v14 + 48) = 0;
        *(_QWORD *)(v14 + 32) = 0;
        *(_BYTE *)(v14 + 56) = 0;
        *(_QWORD *)(v14 + 64) = 0;
        *(_QWORD *)(v14 + 72) = 0;
        *(_QWORD *)(v14 + 96) = 0;
        *(_QWORD *)(v14 + 104) = 0;
        *(_QWORD *)(v14 + 80) = 0;
        *(_QWORD *)(v14 + 88) = v14 + 96;
        v15 = &off_1E1628B58;
        goto LABEL_23;
      case 3:
        v14 = operator new();
        *(_QWORD *)v14 = off_1E1628BE8;
        *(_QWORD *)(v14 + 8) = v3;
        CFRetain(a2);
        *(_QWORD *)(v14 + 16) = a2;
        *(_DWORD *)(v14 + 24) = v10;
        *(_QWORD *)(v14 + 40) = 0;
        *(_QWORD *)(v14 + 48) = 0;
        *(_QWORD *)(v14 + 32) = 0;
        *(_BYTE *)(v14 + 56) = 0;
        *(_QWORD *)(v14 + 64) = 0;
        *(_QWORD *)(v14 + 72) = 0;
        *(_QWORD *)(v14 + 96) = 0;
        *(_QWORD *)(v14 + 104) = 0;
        *(_QWORD *)(v14 + 80) = 0;
        *(_QWORD *)(v14 + 88) = v14 + 96;
        v15 = &off_1E1628BA0;
LABEL_23:
        *(_QWORD *)v14 = v15;
        break;
      case 4:
        v14 = operator new();
        *(_QWORD *)v14 = off_1E1628BE8;
        *(_QWORD *)(v14 + 8) = v3;
        CFRetain(a2);
        *(_QWORD *)(v14 + 16) = a2;
        *(_DWORD *)(v14 + 24) = v10;
        *(_QWORD *)(v14 + 40) = 0;
        *(_QWORD *)(v14 + 48) = 0;
        *(_QWORD *)(v14 + 32) = 0;
        *(_BYTE *)(v14 + 56) = 0;
        *(_QWORD *)v14 = off_1E1627E88;
        *(_QWORD *)(v14 + 64) = 0;
        v16 = (void **)(v14 + 64);
        *(_QWORD *)(v14 + 72) = 0;
        *(_QWORD *)(v14 + 80) = 0;
        PDFFont::get_embedded_font_name((std::string *)(v14 + 88), v14);
        v17 = PDFXRefTableAddObject(*(_QWORD **)(*(_QWORD *)v3 + 464));
        *(_QWORD *)(v14 + 128) = 0;
        *(_QWORD *)(v14 + 136) = 0;
        *(_QWORD *)(v14 + 112) = v17;
        *(_QWORD *)(v14 + 120) = v14 + 128;
        std::string::basic_string[abi:se180100]<0>((char **)__p, "C");
        PDFFont::get_next_subset_name((uint64_t)&v34, *(_QWORD *)(v14 + 8), (uint64_t)__p);
        if (*(char *)(v14 + 87) < 0)
          operator delete(*v16);
        *(_OWORD *)v16 = v34;
        *(_QWORD *)(v14 + 80) = v35;
        HIBYTE(v35) = 0;
        LOBYTE(v34) = 0;
        if (v33 < 0)
          operator delete(__p[0]);
        break;
      default:
        pdf_error("unsupported streaming format: %d", v11);
LABEL_29:
        v14 = v34;
        break;
    }
    v19 = (uint64_t **)(v3 + 64);
    v18 = *(uint64_t **)(v3 + 64);
    if (v18)
    {
      v20 = *(_DWORD *)(v14 + 24);
      while (1)
      {
        while (1)
        {
          v19 = (uint64_t **)v18;
          v21 = *(_DWORD *)(v18[4] + 24);
          if (v20 >= v21)
            break;
          v18 = *v19;
          v22 = v19;
          if (!*v19)
            goto LABEL_39;
        }
        if (v21 >= v20)
          break;
        v22 = v19 + 1;
        v18 = v19[1];
        if (!v18)
          goto LABEL_39;
      }
    }
    else
    {
      v22 = (uint64_t **)(v3 + 64);
LABEL_39:
      v23 = (uint64_t *)operator new(0x28uLL);
      v23[4] = v14;
      *v23 = 0;
      v23[1] = 0;
      v23[2] = (uint64_t)v19;
      *v22 = v23;
      v24 = **(_QWORD **)(v3 + 56);
      if (v24)
      {
        *(_QWORD *)(v3 + 56) = v24;
        v23 = *v22;
      }
      std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 64), v23);
      ++*(_QWORD *)(v3 + 72);
    }
    v25 = *v5;
    v26 = (uint64_t **)(v3 + 40);
    if (*v5)
    {
      while (1)
      {
        while (1)
        {
          v26 = (uint64_t **)v25;
          v27 = v25[4];
          if (v27 <= (unint64_t)a2)
            break;
          v25 = *v26;
          v5 = v26;
          if (!*v26)
            goto LABEL_49;
        }
        if (v27 >= (unint64_t)a2)
          break;
        v25 = v26[1];
        if (!v25)
        {
          v5 = v26 + 1;
          goto LABEL_49;
        }
      }
      if (v14)
        (*(void (**)(uint64_t))(*(_QWORD *)v14 + 8))(v14);
      v6 = (uint64_t *)v26;
    }
    else
    {
LABEL_49:
      v6 = (uint64_t *)operator new(0x30uLL);
      v6[4] = (uint64_t)a2;
      v6[5] = v14;
      *v6 = 0;
      v6[1] = 0;
      v6[2] = (uint64_t)v26;
      *v5 = v6;
      v28 = **(_QWORD **)(v3 + 32);
      v29 = v6;
      if (v28)
      {
        *(_QWORD *)(v3 + 32) = v28;
        v29 = *v5;
      }
      std::__tree_balance_after_insert[abi:se180100]<std::__tree_node_base<void *> *>(*(uint64_t **)(v3 + 40), v29);
      ++*(_QWORD *)(v3 + 48);
    }
  }
  return v6[5];
}

void sub_184BD6920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18)
{
  char *v18;
  void **v19;
  void **v20;
  _QWORD **v21;

  if (a18 < 0)
    operator delete(__p);
  std::__tree<unsigned long>::destroy(*v21);
  if (v18[111] < 0)
    operator delete(*v19);
  if (v18[87] < 0)
    operator delete(*v20);
  PDFFont::~PDFFont((PDFFont *)v18);
  MEMORY[0x186DC23C4]();
  _Unwind_Resume(a1);
}

void *PDFDocumentAddFormWithDisplayList(uint64_t a1, void *value)
{
  __CFSet *Mutable;
  void *result;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;
  const void **v18;
  void *valuea;

  if (!*(_QWORD *)(a1 + 360))
    *(_QWORD *)(a1 + 360) = PDFFormSetCreate(a1);
  Mutable = *(__CFSet **)(a1 + 536);
  if (!Mutable)
  {
    Mutable = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B3B0]);
    *(_QWORD *)(a1 + 536) = Mutable;
  }
  CFSetAddValue(Mutable, value);
  result = 0;
  v6 = *(_QWORD *)(a1 + 360);
  if (v6 && value)
  {
    if (!*(_QWORD *)(v6 + 8))
      *(_QWORD *)(v6 + 8) = CFSetCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, &callbacks_11326);
    valuea = 0;
    v7 = *(_QWORD *)v6;
    v8 = malloc_type_calloc(1uLL, 0x58uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v8)
    {
      *(_DWORD *)v8 = 1;
      v8[1] = v7;
      v8[2] = PDFContentStreamCreate(v7, 0);
      *((_DWORD *)v8 + 6) = 0;
      v8[4] = CFRetain(value);
      v8[8] = 0;
      v8[9] = 0;
      v8[10] = -1;
    }
    if (!CFSetGetValueIfPresent(*(CFSetRef *)(v6 + 8), v8, (const void **)&valuea))
    {
      v16 = (*(_DWORD *)(v6 + 24) + 1);
      *(_DWORD *)(v6 + 24) = v16;
      if (*((_DWORD *)v8 + 6) == 1)
        v17 = "Sm";
      else
        v17 = "Fm";
      snprintf_l((char *)v8 + 40, 0x10uLL, 0, "%s%zu", v17, v16);
      CFSetAddValue(*(CFMutableSetRef *)(v6 + 8), v8);
      valuea = v8;
    }
    PDFFormRelease(v8, v9, v10, v11, v12, v13, v14, v15);
    v18 = *(const void ***)(v6 + 16);
    if (!v18)
    {
      v18 = CGOrderedSetCreate();
      *(_QWORD *)(v6 + 16) = v18;
    }
    CGOrderedSetAddValue((CFSetRef *)v18, valuea);
    return valuea;
  }
  return result;
}

void *PDFDocumentAddFunction(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  unint64_t v5;

  v4 = *(uint64_t **)(a1 + 368);
  if (!v4)
  {
    v4 = PDFFunctionSetCreate(a1);
    *(_QWORD *)(a1 + 368) = v4;
    if (a2)
      goto LABEL_3;
LABEL_5:
    v5 = -1;
    return PDFFunctionSetAddFunctionWithRange(v4, a2, v5, 0);
  }
  if (!a2)
    goto LABEL_5;
LABEL_3:
  v5 = *(_QWORD *)(a2 + 48) - 1;
  return PDFFunctionSetAddFunctionWithRange(v4, a2, v5, 0);
}

void PDFDocumentAddImageTag(uint64_t a1, uint64_t a2, void *value)
{
  _QWORD *v5;
  __CFDictionary *Mutable;
  const void *v8;

  v5 = *(_QWORD **)(a1 + 344);
  if (!v5)
  {
    v5 = PDFImageSetCreate(a1);
    *(_QWORD *)(a1 + 344) = v5;
  }
  Mutable = (__CFDictionary *)v5[3];
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, MEMORY[0x1E0C9B3A0]);
    v5[3] = Mutable;
    if (a2)
      goto LABEL_5;
LABEL_7:
    v8 = 0;
    goto LABEL_8;
  }
  if (!a2)
    goto LABEL_7;
LABEL_5:
  v8 = (const void *)*(unsigned int *)(a2 + 24);
LABEL_8:
  CFDictionarySetValue(Mutable, v8, value);
}

const void *PDFDocumentAddImage(uint64_t a1, uint64_t a2, unsigned int a3)
{
  _QWORD *v6;

  v6 = *(_QWORD **)(a1 + 344);
  if (!v6)
  {
    v6 = PDFImageSetCreate(a1);
    *(_QWORD *)(a1 + 344) = v6;
  }
  return add_image((uint64_t)v6, a2, 0, 0, a3);
}

const void *PDFDocumentAddSMask(uint64_t a1, uint64_t a2, const void *a3, unsigned int a4)
{
  _QWORD *v8;

  v8 = *(_QWORD **)(a1 + 352);
  if (!v8)
  {
    v8 = PDFImageSetCreate(a1);
    *(_QWORD *)(a1 + 352) = v8;
  }
  return add_image((uint64_t)v8, a2, a3, 1, a4);
}

_QWORD *PDFDocumentAddShading(uint64_t a1, unsigned int *a2)
{
  uint64_t *v3;
  BOOL v5;
  _QWORD *Value;
  const __CFDictionary *Mutable;
  const void *v8;
  uint64_t v9;
  uint64_t v10;
  const void **v11;

  v3 = *(uint64_t **)(a1 + 384);
  if (!v3)
  {
    v3 = (uint64_t *)malloc_type_calloc(1uLL, 0x20uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v3)
      *v3 = a1;
    *(_QWORD *)(a1 + 384) = v3;
  }
  if (v3)
    v5 = a2 == 0;
  else
    v5 = 1;
  if (v5)
    return 0;
  Mutable = (const __CFDictionary *)v3[1];
  if (!Mutable)
  {
    Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0, &shadingCallbacks);
    v3[1] = (uint64_t)Mutable;
  }
  v8 = (const void *)a2[4];
  Value = CFDictionaryGetValue(Mutable, v8);
  if (!Value)
  {
    v9 = *v3;
    v10 = (*((_DWORD *)v3 + 6) + 1);
    *((_DWORD *)v3 + 6) = v10;
    Value = malloc_type_calloc(1uLL, 0x38uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (Value)
    {
      *(_DWORD *)Value = 1;
      Value[1] = v9;
      CFRetain(a2);
      Value[2] = a2;
      Value[3] = PDFXRefTableAddObject(*(_QWORD **)(v9 + 464));
      *((_BYTE *)Value + 48) = 0;
      snprintf_l((char *)Value + 32, 0x10uLL, 0, "Sh%lu", v10);
    }
    CFDictionarySetValue((CFMutableDictionaryRef)v3[1], v8, Value);
    PDFShadingRelease(Value);
  }
  v11 = (const void **)v3[2];
  if (!v11)
  {
    v11 = CGOrderedSetCreate();
    v3[2] = (uint64_t)v11;
  }
  CGOrderedSetAddValue((CFSetRef *)v11, Value);
  return Value;
}

_QWORD *PDFDocumentGetDestinationSet(uint64_t a1)
{
  _QWORD *v1;

  v1 = *(_QWORD **)(a1 + 416);
  if (!v1)
  {
    v1 = malloc_type_calloc(1uLL, 0x10uLL, 0x33BCE901uLL);
    __CFSetLastAllocationEventName();
    if (v1)
      *v1 = a1;
    *(_QWORD *)(a1 + 416) = v1;
  }
  return v1;
}

void PDFDocumentPrintPageParentReference(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t *v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t **v16;
  __int128 v17;
  uint64_t **v18;

  PDFDocumentPrintf(a1, a2, a3, a4, a5, a6, a7, a8, a3);
  v10 = *(_QWORD *)(a1 + 520);
  if (v10)
  {
    v11 = *(_QWORD *)(a1 + 280);
    if (a3 && v11)
    {
      v12 = (uint64_t *)operator new(0x30uLL);
      v15 = *(uint64_t **)(v10 + 216);
      v14 = (uint64_t **)(v10 + 216);
      v13 = v15;
      v16 = v14 - 1;
      *(_QWORD *)&v17 = a3;
      *((_QWORD *)&v17 + 1) = v11;
      *((_OWORD *)v12 + 2) = v17;
      if (v15)
      {
        do
        {
          while (1)
          {
            v14 = (uint64_t **)v13;
            if (v13[4] <= a3)
              break;
            v13 = (uint64_t *)*v13;
            v18 = v14;
            if (!*v14)
              goto LABEL_13;
          }
          v13 = (uint64_t *)v13[1];
        }
        while (v13);
        v18 = v14 + 1;
      }
      else
      {
        v18 = v14;
      }
LABEL_13:
      std::__tree<unsigned long>::__insert_node_at(v16, (uint64_t)v14, v18, v12);
    }
    else
    {
      pdf_log("%s: Invalid param. object = %lu, referrer = %lu", "void PDFLinearizer::recordPageParentReference(PDFObjectNumber, PDFObjectNumber)", a3, v11);
    }
  }
}

void CGGStateSetAlpha(uint64_t a1, double a2)
{
  if (*(double *)(*(_QWORD *)(a1 + 120) + 8) != a2)
  {
    maybeCopyRenderingState(a1);
    *(double *)(*(_QWORD *)(a1 + 120) + 8) = a2;
  }
}

void CGGStateSetShouldAntialias(uint64_t a1, int a2)
{
  int v4;

  if (((((*(_BYTE *)(*(_QWORD *)(a1 + 120) + 7) & 1) == 0) ^ a2) & 1) == 0)
  {
    maybeCopyRenderingState(a1);
    if (a2)
      v4 = 0x1000000;
    else
      v4 = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) & 0xFEFFFFFF | v4;
  }
}

void CGGStateSetCompositeOperation(uint64_t a1, int a2)
{
  char v2;

  if (a2 != (int)(*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) << 16) >> 24)
  {
    v2 = a2;
    maybeCopyRenderingState(a1);
    *(_BYTE *)(*(_QWORD *)(a1 + 120) + 5) = v2;
  }
}

uint64_t CGGStateGetRenderingIntent(uint64_t a1)
{
  return ((int)(*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) << 12) >> 28);
}

void CGGStateSetRenderingIntent(uint64_t a1, int a2)
{
  char v2;

  if (a2 != (int)(*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) << 12) >> 28)
  {
    v2 = a2;
    maybeCopyRenderingState(a1);
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) & 0xFFF0FFFF | ((v2 & 0xF) << 16);
  }
}

float CGGStateGetEDRTargetHeadroom(uint64_t a1)
{
  return *(float *)(*(_QWORD *)(a1 + 120) + 48);
}

void CGGStateSetEDRTargetHeadroom(uint64_t a1, float a2)
{
  if (*(float *)(*(_QWORD *)(a1 + 120) + 48) != a2)
  {
    maybeCopyRenderingState(a1);
    *(float *)(*(_QWORD *)(a1 + 120) + 48) = a2;
  }
}

double CGGStateGetPatternPhase(uint64_t a1)
{
  return *(double *)(*(_QWORD *)(a1 + 120) + 24);
}

void CGGStateSetPatternPhase(uint64_t a1, double a2, double a3)
{
  uint64_t v5;
  uint64_t v8;

  v5 = *(_QWORD *)(a1 + 120);
  if (*(double *)(v5 + 24) != a2 || *(double *)(v5 + 32) != a3)
  {
    maybeCopyRenderingState(a1);
    v8 = *(_QWORD *)(a1 + 120);
    *(double *)(v8 + 24) = a2;
    *(double *)(v8 + 32) = a3;
  }
}

uint64_t CGGStateGetAlphaIsShape(uint64_t a1)
{
  return (*(unsigned __int8 *)(*(_QWORD *)(a1 + 120) + 7) >> 1) & 1;
}

void CGGStateSetAlphaIsShape(uint64_t a1, int a2)
{
  int v4;

  if (((((*(_BYTE *)(*(_QWORD *)(a1 + 120) + 7) & 2) == 0) ^ a2) & 1) == 0)
  {
    maybeCopyRenderingState(a1);
    if (a2)
      v4 = 0x2000000;
    else
      v4 = 0;
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) & 0xFDFFFFFF | v4;
  }
}

uint64_t CGGStateGetImageRenderingIntent(uint64_t a1)
{
  unsigned int v1;
  int v2;

  v1 = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4);
  if (((v1 >> 20) & 0xF) != 0)
    v2 = v1 << 8;
  else
    v2 = v1 << 12;
  return (v2 >> 28);
}

void CGGStateSetImageRenderingIntent(uint64_t a1, int a2)
{
  char v2;

  if (a2 != (int)(*(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) << 8) >> 28)
  {
    v2 = a2;
    maybeCopyRenderingState(a1);
    *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) = *(_DWORD *)(*(_QWORD *)(a1 + 120) + 4) & 0xFF0FFFFF | ((v2 & 0xF) << 20);
  }
}

void CGGStateSetInterpolationQuality(uint64_t a1, int a2)
{
  char v2;

  if (*(char *)(*(_QWORD *)(a1 + 120) + 4) != a2)
  {
    v2 = a2;
    maybeCopyRenderingState(a1);
    *(_BYTE *)(*(_QWORD *)(a1 + 120) + 4) = v2;
  }
}

CFTypeID CGFunctionGetTypeID(void)
{
  if (_block_invoke_once_5555 != -1)
    dispatch_once(&_block_invoke_once_5555, &__block_literal_global_6_5556);
  return CGFunctionGetTypeID_function_type_id;
}

CGFunctionRef CGFunctionRetain(CGFunctionRef function)
{
  if (function)
    CFRetain(function);
  return function;
}

void CGFunctionRelease(CGFunctionRef function)
{
  if (function)
    CFRelease(function);
}

uint64_t CGFunctionCreateIdentity()
{
  uint64_t v0;

  if (CGFunctionCreateIdentity_predicate != -1)
    dispatch_once(&CGFunctionCreateIdentity_predicate, &__block_literal_global_5564);
  v0 = CGFunctionCreateIdentity_identity;
  if (CGFunctionCreateIdentity_identity)
    CFRetain((CFTypeRef)CGFunctionCreateIdentity_identity);
  return v0;
}

double evaluate_identity(uint64_t a1, double *a2, _QWORD *a3)
{
  double result;

  result = *a2;
  *a3 = *(_QWORD *)a2;
  return result;
}

uint64_t CGFunctionGetDomainDimension(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 32);
  return result;
}

uint64_t CGFunctionGetDomain(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 40);
  return result;
}

uint64_t CGFunctionGetRangeDimension(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 48);
  return result;
}

uint64_t CGFunctionGetRange(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 56);
  return result;
}

uint64_t CGFunctionGetIdentifier(uint64_t result)
{
  if (result)
    return *(unsigned int *)(result + 16);
  return result;
}

uint64_t CGFunctionGetInfo(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 24);
  return result;
}

CGFunctionRef CGFunctionCreateEvaluatedCopy(uint64_t a1)
{
  size_t v2;
  CGFunctionRef v3;
  __n128 v4;
  size_t v5;
  void *v6;
  size_t v7;
  void *v8;
  size_t v9;
  uint64_t v10;
  double *v11;
  const void *v12;
  uint64_t v13;
  double *v14;
  _QWORD *v15;
  double *v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double v21[2];

  v21[1] = *(double *)MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  v2 = *(_QWORD *)(a1 + 32);
  if (v2 > 1)
    return 0;
  v3 = CGFunctionCreate(0, v2, 0, *(_QWORD *)(a1 + 48), 0, (const CGFunctionCallbacks *)(a1 + 64));
  if (v3)
  {
    if (*(_QWORD *)(a1 + 40))
    {
      v5 = 16 * *(_QWORD *)(a1 + 32);
      v6 = malloc_type_malloc(v5, 0x2062DE7BuLL);
      *((_QWORD *)v3 + 5) = v6;
      memcpy(v6, *(const void **)(a1 + 40), v5);
    }
    if (*(_QWORD *)(a1 + 56))
    {
      v7 = 16 * *(_QWORD *)(a1 + 48);
      v8 = malloc_type_malloc(v7, 0x2062DE7BuLL);
      *((_QWORD *)v3 + 7) = v8;
      memcpy(v8, *(const void **)(a1 + 56), v7);
    }
    v9 = MEMORY[0x1E0C80A78](8 * *((_QWORD *)v3 + 4), v4);
    v11 = (double *)((char *)v21 - v10);
    if (v9 >= 0x101)
      v11 = (double *)malloc_type_malloc(v9, 0xC4C2B412uLL);
    v13 = *((_QWORD *)v3 + 4);
    v12 = (const void *)*((_QWORD *)v3 + 5);
    if (v12)
    {
      memcpy(v11, v12, 8 * v13);
    }
    else if (v13)
    {
      v14 = v11;
      do
      {
        *(_OWORD *)v14++ = xmmword_185004A20;
        --v13;
      }
      while (v13);
    }
    *((_OWORD *)v3 + 4) = xmmword_1E16451F0;
    *((_QWORD *)v3 + 10) = evaluated_function_release_info;
    v15 = malloc_type_malloc(0x18uLL, 0x108004098BBCF0FuLL);
    v16 = (double *)malloc_type_malloc(*((_QWORD *)v3 + 6) << 14, 0x100004000313F17uLL);
    v15[2] = v16;
    v17 = *((_QWORD *)v3 + 6);
    v18 = 2048;
    *v15 = 2048;
    v15[1] = v17;
    *((_QWORD *)v3 + 3) = v15;
    v19 = (v11[1] - *v11) * 0.00048828125;
    v21[0] = *v11;
    do
    {
      CGFunctionEvaluate(a1, (char *)v21, v16);
      v21[0] = v19 + v21[0];
      v16 += *((_QWORD *)v3 + 6);
      --v18;
    }
    while (v18);
  }
  return v3;
}

double evaluated_function_evaluate(_QWORD *a1, double *a2, double *a3)
{
  double v3;
  double v4;
  _BOOL4 v5;
  uint64_t v6;
  uint64_t v7;
  double result;
  uint64_t v9;
  double *v10;
  double *v11;
  double v12;
  double v13;
  double v14;
  double v15;

  v3 = *a2;
  v4 = 1.0;
  v5 = *a2 > 1.0 || *a2 < 0.0;
  if (*a2 < 0.0 && *a2 <= 1.0)
    v4 = 0.0;
  if (v5)
    v3 = v4;
  v6 = a1[1];
  v7 = a1[2];
  result = v3 * (double)(unint64_t)(*a1 - 1);
  v9 = vcvtmd_s64_f64(result);
  v10 = (double *)(v7 + 8 * v6 * v9);
  if ((unint64_t)(v9 + 1) >= *a1)
  {
    for (; v6; --v6)
    {
      v15 = *v10++;
      result = v15;
      *a3++ = v15;
    }
  }
  else if (v6)
  {
    v11 = (double *)(v7 + 8 * (v9 + 1) * v6);
    result = result - (double)v9;
    do
    {
      v12 = *v10++;
      v13 = v12;
      v14 = *v11++;
      *a3++ = v13 + result * (v14 - v13);
      --v6;
    }
    while (v6);
  }
  return result;
}

void evaluated_function_release_info(void **a1)
{
  if (a1)
  {
    free(a1[2]);
    free(a1);
  }
}

BOOL CGFunctionIsIdentity(_BOOL8 result)
{
  if (result)
    return *(_QWORD *)(result + 72) == (_QWORD)evaluate_identity;
  return result;
}

void CGFunctionEvaluateFloat(uint64_t a1, float *a2, float *a3, __n128 a4)
{
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char *v11;
  char *v12;
  double *v13;
  double *v14;
  float v15;
  uint64_t i;
  double v17;
  float v18;
  _QWORD v19[2];

  v19[1] = *MEMORY[0x1E0C80C00];
  MEMORY[0x1E0C80A78](a1, a4);
  v11 = (char *)v19 - v10;
  if (v9 <= 0x1FFFFFFFFFFFFFFELL)
    v12 = (char *)v19 - v10;
  else
    v12 = 0;
  if (v9 - 0x1FFFFFFFFFFFFFFFLL >= 0xE000000000000012)
  {
    v12 = (char *)malloc_type_malloc(8 * v8, 0x66B37E0BuLL);
    v7 = *(_QWORD *)(a1 + 32);
  }
  v13 = (double *)&v12[8 * v7];
  if (v7)
  {
    v14 = (double *)v12;
    do
    {
      v15 = *a2++;
      *v14++ = v15;
      --v7;
    }
    while (v7);
  }
  CGFunctionEvaluate(a1, v12, v13);
  for (i = *(_QWORD *)(a1 + 48); i; --i)
  {
    v17 = *v13++;
    v18 = v17;
    *a3++ = v18;
  }
  if (v12 != v11)
    free(v12);
}

uint64_t CGFunctionCopyPDFDescription(uint64_t a1)
{
  uint64_t (*v1)(_QWORD);

  if (a1 && (v1 = *(uint64_t (**)(_QWORD))(a1 + 88)) != 0)
    return v1(*(_QWORD *)(a1 + 24));
  else
    return 0;
}

unint64_t CGFunctionSetAssociate(unint64_t result, unint64_t a2)
{
  unint64_t *v2;

  if (result)
  {
    v2 = (unint64_t *)(result + 96);
    while (!__ldxr(v2))
    {
      if (!__stxr(a2, v2))
        return *v2;
    }
    __clrex();
    return *v2;
  }
  return result;
}

uint64_t CGFunctionGetAssociate(uint64_t result)
{
  if (result)
    return *(_QWORD *)(result + 96);
  return result;
}

void CGFunctionSetProperty(uint64_t a1, const void *a2, const void *a3)
{
  unint64_t *v5;
  _DWORD *v6;

  v5 = (unint64_t *)(a1 + 104);
  if (!*(_QWORD *)(a1 + 104))
  {
    v6 = CGPropertiesCreate();
    while (!__ldxr(v5))
    {
      if (!__stxr((unint64_t)v6, v5))
        goto LABEL_7;
    }
    __clrex();
    CGPropertiesRelease((uint64_t)v6);
  }
LABEL_7:
  CGPropertiesSetProperty(*v5, a2, a3);
}

const void *CGImageCopyProperty(uint64_t a1, const void *a2)
{
  return CGPropertiesCopyProperty(*(_QWORD *)(a1 + 104), a2);
}

__CFHTTPMessage *http_message_send_request(void *a1)
{
  const __CFAllocator *v2;
  __CFReadStream *v3;
  CFWriteStreamRef v4;
  __CFWriteStream *v5;
  CFStreamStatus Status;
  uint64_t v7;
  uint64_t v8;
  CFIndex v9;
  __CFHTTPMessage *v10;
  CFStreamStatus v11;
  const __CFData *v13;
  __CFHTTPMessage *v14;
  UInt8 buffer[512];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = CFGetAllocator(a1);
  v3 = CFReadStreamCreateForHTTPRequest(v2, (CFHTTPMessageRef)a1);
  v4 = CFWriteStreamCreateWithAllocatedBuffers(v2, v2);
  v5 = v4;
  if (v3 && v4)
  {
    CFReadStreamSetProperty(v3, CFSTR("kCFStreamPropertyHTTPShouldAutoredirect"), (CFTypeRef)*MEMORY[0x1E0C9AE50]);
    if (CFReadStreamOpen(v3) && CFWriteStreamOpen(v5))
    {
LABEL_5:
      Status = CFReadStreamGetStatus(v3);
      while ((Status | 2) != 7)
      {
        v7 = CFReadStreamRead(v3, buffer, 512);
        if (v7 < 1)
          goto LABEL_5;
        v8 = v7;
        v9 = CFWriteStreamWrite(v5, buffer, v7);
        Status = CFReadStreamGetStatus(v3);
        if (v9 != v8)
        {
          CFReadStreamClose(v3);
          CFWriteStreamClose(v5);
          goto LABEL_16;
        }
      }
      v11 = CFReadStreamGetStatus(v3);
      CFReadStreamClose(v3);
      CFWriteStreamClose(v5);
      if (v11 != kCFStreamStatusError)
      {
        v13 = (const __CFData *)CFWriteStreamCopyProperty(v5, (CFStreamPropertyKey)*MEMORY[0x1E0C9B2A8]);
        v14 = (__CFHTTPMessage *)CFReadStreamCopyProperty(v3, CFSTR("kCFStreamPropertyHTTPResponseHeader"));
        v10 = v14;
        if (v14)
          CFHTTPMessageSetBody(v14, v13);
        if (v13)
          CFRelease(v13);
        goto LABEL_17;
      }
    }
LABEL_16:
    v10 = 0;
LABEL_17:
    CFRelease(v3);
    CFRelease(v5);
    return v10;
  }
  if (v3)
    CFRelease(v3);
  if (v5)
    CFRelease(v5);
  return 0;
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::basic_stringstream[abi:se180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  std::ios_base *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = MEMORY[0x1E0DE4FD0];
  v3 = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 128) = MEMORY[0x1E0DE4FD0] + 104;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  v4 = a1 + 16;
  v5 = (_QWORD *)MEMORY[0x1E0DE4F50];
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 16);
  v7 = *(_QWORD *)(MEMORY[0x1E0DE4F50] + 24);
  *(_QWORD *)a1 = v6;
  *(_QWORD *)(a1 + *(_QWORD *)(v6 - 24)) = v7;
  *(_QWORD *)(a1 + 8) = 0;
  v8 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v8, (void *)(a1 + 24));
  v8[1].__vftable = 0;
  v8[1].__fmtflags_ = -1;
  v9 = v5[4];
  v10 = v5[5];
  *(_QWORD *)(a1 + 16) = v9;
  *(_QWORD *)(v4 + *(_QWORD *)(v9 - 24)) = v10;
  v11 = v5[1];
  *(_QWORD *)a1 = v11;
  *(_QWORD *)(a1 + *(_QWORD *)(v11 - 24)) = v5[6];
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 128) = v3;
  *(_QWORD *)(a1 + 16) = v2 + 64;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 104) = 0u;
  *(_DWORD *)(a1 + 120) = 24;
  return a1;
}

void sub_184BD7BE4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::iostream::~basic_iostream();
  MEMORY[0x186DC2388](v1);
  _Unwind_Resume(a1);
}

uint64_t std::basic_stringstream<char,std::char_traits<char>,std::allocator<char>>::~basic_stringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v2 = MEMORY[0x1E0DE4F50];
  v3 = *MEMORY[0x1E0DE4F50];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F50];
  v4 = *(_QWORD *)(v2 + 72);
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 64);
  *(_QWORD *)(a1 + 24) = MEMORY[0x1E0DE4FB8] + 16;
  *(_QWORD *)(a1 + 16) = v4;
  if (*(char *)(a1 + 111) < 0)
    operator delete(*(void **)(a1 + 88));
  std::streambuf::~streambuf();
  std::iostream::~basic_iostream();
  MEMORY[0x186DC2388](a1 + 128);
  return a1;
}

void type1_draw_colored_pattern(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  CGPDFStream *v4;
  CGPDFDictionary *v5;

  v3 = *a1;
  if (*a1 && *(_DWORD *)(v3 + 16) == 1)
  {
    v4 = *(CGPDFStream **)(v3 + 24);
    v5 = *(CGPDFDictionary **)(v3 + 88);
  }
  else
  {
    v4 = 0;
    v5 = 0;
  }
  CGPDFDrawingContextDrawStream(0, v4, v5, (__int128 *)a1[2], a2);
}

void type1_draw_uncolored_pattern(uint64_t *a1, uint64_t a2)
{
  __int128 *Copy;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  const void *FillColorAsColor;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  const void *StrokeColorAsColor;
  uint64_t v21;
  CGPDFStream *v22;
  CGPDFDictionary *v23;

  Copy = (__int128 *)CGPDFGStateCreateCopy((__int128 *)a1[2]);
  FillColorAsColor = (const void *)CGContextGetFillColorAsColor(a2, v5, v6, v7, v8, v9, v10, v11);
  CGPDFGStateSetFillColor((uint64_t)Copy, FillColorAsColor);
  StrokeColorAsColor = (const void *)CGContextGetStrokeColorAsColor(a2, v13, v14, v15, v16, v17, v18, v19);
  CGPDFGStateSetStrokeColor((uint64_t)Copy, StrokeColorAsColor);
  v21 = *a1;
  if (*a1 && *(_DWORD *)(v21 + 16) == 1)
  {
    v22 = *(CGPDFStream **)(v21 + 24);
    v23 = *(CGPDFDictionary **)(v21 + 88);
  }
  else
  {
    v22 = 0;
    v23 = 0;
  }
  CGPDFDrawingContextDrawStream(0, v22, v23, Copy, a2);
  if (Copy)
  {
    CGPDFGStateReleaseProperties(Copy);
    free(Copy);
  }
}

void type1_release_info(_QWORD *a1)
{
  void *v2;
  const void *v3;

  if (a1)
  {
    v2 = (void *)a1[2];
    if (v2)
    {
      CGPDFGStateReleaseProperties((_QWORD *)a1[2]);
      free(v2);
    }
    v3 = (const void *)a1[1];
    if (v3)
      CFRelease(v3);
    free(a1);
  }
}

void PageLayoutFactory::appendCurLine(PageLayoutFactory *this, BOOL *a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  void *v7;
  char v8;
  _BOOL4 v9;
  uint64_t v10;
  int Length;
  int v12;
  uint64_t v13;
  int ProcessedLength;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  char *v20;
  uint64_t v21;
  int *v22;
  int *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int *v30;
  id v31;
  void *v32;
  uint64_t v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  unint64_t v37;
  _QWORD *v38;
  size_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  uint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *i;
  uint64_t v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  unint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  uint64_t v64;
  char *v65;
  char *v66;
  char *v67;
  char *j;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t *v72;
  uint64_t v73;
  unint64_t v74;
  _QWORD *v75;
  uint64_t v76;
  uint64_t v77;
  unint64_t v78;
  char *v79;
  uint64_t v80;
  char *v81;
  uint64_t *v82;
  char *v83;
  char *k;
  uint64_t v85;
  _QWORD *v86;
  uint64_t v87;
  __int128 v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  char *v93;
  uint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  char *v99;
  uint64_t v100;
  char *v101;
  char *v102;
  char *v103;
  char *v104;
  __int128 v105;
  __int128 v106;
  __int128 v107;
  unint64_t v108;
  unint64_t v109;
  double *v110;
  double *v111;
  char v112;
  double v113;
  double *v114;
  double v115;
  __double2 v116;
  double v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  BOOL v121;
  double *v122;
  CGRect *v123;
  uint64_t v124;
  CGRect *v125;
  double y;
  double width;
  double height;
  CGFloat x;
  CGFloat v130;
  CGRect *v131;
  double v132;
  double v133;
  double v134;
  _BOOL4 v135;
  char v136;
  CGRect *v137;
  double v138;
  double v139;
  double v140;
  CGFloat v141;
  uint64_t v142;
  double v143;
  CGRect *v144;
  double v145;
  double v146;
  double v147;
  double *v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t v152;
  double v153;
  double v154;
  float64x2_t v155;
  __double2 v156;
  float64x2_t v157;
  uint64_t v158;
  unint64_t v159;
  uint64_t v160;
  unint64_t v161;
  uint64_t v162;
  double v163;
  double v164;
  double v165;
  double v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  double v170;
  double v171;
  double v172;
  double v173;
  uint64_t v174;
  uint64_t v175;
  double v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  unint64_t v180;
  uint64_t v181;
  double v182;
  double v183;
  double v184;
  double v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  CGFloat v189;
  double v190;
  double v191;
  double v192;
  double v193;
  double v194;
  uint64_t v195;
  _QWORD *v196;
  unint64_t v197;
  _QWORD *v198;
  double *v199;
  double *v200;
  double *v201;
  unint64_t v202;
  double *v203;
  double *v204;
  int v205;
  double v206;
  double *v207;
  double *v208;
  double v209;
  double v210;
  double *v211;
  double *v212;
  double v213;
  double v214;
  double v215;
  double v216;
  double v217;
  double *v218;
  double v219;
  double v220;
  double v221;
  double *v222;
  double v223;
  double v224;
  double v225;
  double v226;
  double v227;
  double v228;
  double v229;
  double v230;
  double *v231;
  double v232;
  double v233;
  double *v234;
  double *v235;
  double *v236;
  double v237;
  double v238;
  double v239;
  double *v240;
  double *v241;
  BOOL v242;
  double v243;
  double *v244;
  double v245;
  double v246;
  uint64_t v247;
  double v248;
  double v249;
  _WORD *v250;
  _WORD *v251;
  std::runtime_error *exception;
  void *n;
  unint64_t m;
  _QWORD *v255;
  unint64_t v256;
  __int128 v257;
  uint64_t v258;
  void *__p;
  double *v260;
  uint64_t v261;
  int v262;
  uint64_t v263;
  void *v264;
  char *v265;
  char *v266;
  uint64_t v267;
  CGRect v268;
  CGRect v269;
  CGRect v270;
  CGRect v271;
  CGRect v272;
  CGRect v273;
  CGRect v274;
  CGRect v275;

  v4 = *((_QWORD *)this + 2);
  v5 = *((_QWORD *)this + 3);
  while (v5 != v4)
  {
    v6 = *(unsigned __int16 *)(v5 - 2);
    v5 -= 2;
    objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceAndNewlineCharacterSet");
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = objc_msgSend(v7, "characterIsMember:", v6);

    if ((v8 & 1) == 0)
    {
      v4 = v5 + 2;
      break;
    }
  }
  PageLayoutFactory::eraseLastUniChars(this, (*((_QWORD *)this + 3) - v4) >> 1);
  if (*((_QWORD *)this + 5) != *((_QWORD *)this + 6))
  {
    v264 = 0;
    v265 = 0;
    v266 = 0;
    v9 = *a2;
    *a2 = 0;
    if (*(_BYTE *)(*((_QWORD *)this + 1) + 8))
    {
      v10 = ubidi_open();
      v263 = v10;
      v262 = 0;
      ubidi_setReorderingMode();
      ubidi_setContext();
      ubidi_setPara();
      Length = ubidi_getLength();
      v12 = ubidi_countRuns();
      std::vector<unsigned short>::resize((char **)&v264, Length + 2 * v12);
      v13 = (int)ubidi_writeReordered();
      ProcessedLength = ubidi_getProcessedLength();
      if (ProcessedLength != ((uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 1))
        _CGHandleAssert("appendCurLine", 480, "/Library/Caches/com.apple.xbs/Sources/CoreGraphics/CoreGraphics/PDF/PageLayout/PageLayoutFactory.mm", "mapLen == static_cast<int32_t>(_curLineUniChars.size())", "%d != %lu", v15, v16, v17, ProcessedLength);
      if (ProcessedLength)
      {
        if (ProcessedLength < 0)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v18 = ProcessedLength;
        v19 = 4 * ProcessedLength;
        v20 = (char *)operator new(v19);
        v21 = 0;
        v22 = (int *)&v20[4 * v18];
        do
        {
          *(_DWORD *)&v20[v21] = 0;
          v21 += 4;
        }
        while (v19 != v21);
        v23 = (int *)v20;
      }
      else
      {
        v22 = 0;
        v23 = 0;
      }
      ubidi_getVisualMap();
      if (v262)
      {
        exception = (std::runtime_error *)__cxa_allocate_exception(0x10uLL);
        std::runtime_error::runtime_error(exception, "UBiDi error");
        __cxa_throw(exception, MEMORY[0x1E0DE4E80], MEMORY[0x1E0DE4338]);
      }
      v28 = *(_QWORD *)(*((_QWORD *)this + 1) + 296);
      v27 = *(_QWORD *)(*((_QWORD *)this + 1) + 304);
      __p = (void *)(*((_QWORD *)this + 1) + 296);
      if (v23 != v22)
      {
        v29 = (v27 - v28) >> 3;
        v30 = v23;
        do
        {
          v267 = v29 + *v30;
          std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100]((void ***)&__p, &v267);
          ++v30;
        }
        while (v30 != v22);
      }
      v263 = 0;
      if (v10)
        ubidi_close();
      if (v23)
        operator delete(v23);
      if (v13)
      {
LABEL_30:
        v31 = objc_alloc(MEMORY[0x1E0CB3940]);
        v32 = (void *)objc_msgSend(v31, "initWithCharacters:length:", v264, v13);
        v33 = objc_msgSend(v32, "length");
        objc_msgSend(*((id *)this + 21), "appendString:", v32);
        if (!*a2)
        {
          objc_msgSend(*((id *)this + 21), "appendString:", CFSTR("\n"));
          v34 = (_QWORD *)*((_QWORD *)this + 1);
          v35 = (_QWORD *)v34[25];
          v36 = (_QWORD *)v34[26];
          if (v35 == v36)
            goto LABEL_308;
          v37 = v34[27];
          if ((unint64_t)v36 >= v37)
          {
            v43 = v36 - v35;
            if ((unint64_t)(v43 + 1) >> 61)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v44 = v37 - (_QWORD)v35;
            v45 = v44 >> 2;
            if (v44 >> 2 <= (unint64_t)(v43 + 1))
              v45 = v43 + 1;
            if ((unint64_t)v44 >= 0x7FFFFFFFFFFFFFF8)
              v46 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v46 = v45;
            if (!v46)
              goto LABEL_308;
            v47 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v46);
            if (!v47)
              goto LABEL_308;
            v49 = &v47[8 * v48];
            v50 = &v47[8 * v43];
            *(_QWORD *)v50 = *(v36 - 1);
            v38 = v50 + 8;
            v51 = (char *)v34[25];
            for (i = (char *)v34[26]; i != v51; i -= 8)
            {
              v53 = *((_QWORD *)i - 1);
              *((_QWORD *)v50 - 1) = v53;
              v50 -= 8;
            }
            v34[25] = v50;
            v34[26] = v38;
            v34[27] = v49;
            if (v51)
              operator delete(v51);
          }
          else
          {
            if (!v36)
              goto LABEL_308;
            *v36 = *(v36 - 1);
            v38 = v36 + 1;
          }
          v34[26] = v38;
          v54 = (_QWORD *)*((_QWORD *)this + 1);
          v55 = (_QWORD *)v54[28];
          v56 = (_QWORD *)v54[29];
          if (v55 == v56)
            goto LABEL_308;
          v57 = v54[30];
          if ((unint64_t)v56 >= v57)
          {
            v59 = v56 - v55;
            if ((unint64_t)(v59 + 1) >> 61)
              std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
            v60 = v57 - (_QWORD)v55;
            v61 = v60 >> 2;
            if (v60 >> 2 <= (unint64_t)(v59 + 1))
              v61 = v59 + 1;
            if ((unint64_t)v60 >= 0x7FFFFFFFFFFFFFF8)
              v62 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v62 = v61;
            if (!v62)
              goto LABEL_308;
            v63 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v62);
            if (!v63)
              goto LABEL_308;
            v65 = &v63[8 * v64];
            v66 = &v63[8 * v59];
            *(_QWORD *)v66 = *(v56 - 1);
            v58 = v66 + 8;
            v67 = (char *)v54[28];
            for (j = (char *)v54[29]; j != v67; j -= 8)
            {
              v69 = *((_QWORD *)j - 1);
              *((_QWORD *)v66 - 1) = v69;
              v66 -= 8;
            }
            v54[28] = v66;
            v54[29] = v58;
            v54[30] = v65;
            if (v67)
              operator delete(v67);
          }
          else
          {
            if (!v56)
              goto LABEL_308;
            *v56 = *(v56 - 1);
            v58 = v56 + 1;
          }
          v54[29] = v58;
          v70 = *((_QWORD *)this + 1);
          if (*(_BYTE *)(v70 + 8))
          {
            v71 = *(_QWORD *)(v70 + 296);
            v72 = *(uint64_t **)(v70 + 304);
            v73 = ((uint64_t)v72 - v71) >> 3;
            v74 = *(_QWORD *)(v70 + 312);
            if ((unint64_t)v72 >= v74)
            {
              if ((unint64_t)(v73 + 1) >> 61)
                std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
              v76 = v74 - v71;
              v77 = v76 >> 2;
              if (v76 >> 2 <= (unint64_t)(v73 + 1))
                v77 = v73 + 1;
              if ((unint64_t)v76 >= 0x7FFFFFFFFFFFFFF8)
                v78 = 0x1FFFFFFFFFFFFFFFLL;
              else
                v78 = v77;
              if (!v78)
                goto LABEL_308;
              v79 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v78);
              if (!v79)
                goto LABEL_308;
              v81 = &v79[8 * v80];
              v82 = (uint64_t *)&v79[8 * v73];
              *v82 = v73;
              v75 = v82 + 1;
              v83 = *(char **)(v70 + 296);
              for (k = *(char **)(v70 + 304); k != v83; k -= 8)
              {
                v85 = *((_QWORD *)k - 1);
                *--v82 = v85;
              }
              *(_QWORD *)(v70 + 296) = v82;
              *(_QWORD *)(v70 + 304) = v75;
              *(_QWORD *)(v70 + 312) = v81;
              if (v83)
                operator delete(v83);
            }
            else
            {
              if (!v72)
                goto LABEL_308;
              *v72 = v73;
              v75 = v72 + 1;
            }
            *(_QWORD *)(v70 + 304) = v75;
          }
          ++v33;
        }
LABEL_95:
        v86 = (_QWORD *)*((_QWORD *)this + 1);
        v87 = *((_QWORD *)this + 6) - *((_QWORD *)this + 5);
        *(_QWORD *)&v88 = ((uint64_t)(v86[14] - v86[13]) >> 5) - (v87 >> 3);
        *((_QWORD *)&v88 + 1) = v87 >> 3;
        v257 = v88;
        v89 = (uint64_t)(v86[8] - v86[7]) >> 1;
        v90 = v86[2];
        v86[2] = v90 + 1;
        v91 = v86[5];
        v92 = v86[6];
        if (v91 >= v92)
        {
          v94 = v86[4];
          v95 = 0x8E38E38E38E38E39 * ((uint64_t)(v91 - v94) >> 3);
          v96 = v95 + 1;
          if (v95 + 1 > 0x38E38E38E38E38ELL)
            std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
          v97 = 0x8E38E38E38E38E39 * ((uint64_t)(v92 - v94) >> 3);
          if (2 * v97 > v96)
            v96 = 2 * v97;
          if (v97 >= 0x1C71C71C71C71C7)
            v98 = 0x38E38E38E38E38ELL;
          else
            v98 = v96;
          if (!v98)
            goto LABEL_308;
          v99 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(v98);
          if (!v99)
            goto LABEL_308;
          v101 = &v99[72 * v100];
          v102 = &v99[72 * v95];
          *(_OWORD *)v102 = v257;
          *((_QWORD *)v102 + 2) = v89;
          *(int64x2_t *)(v102 + 24) = vdupq_n_s64(0x7FF0000000000000uLL);
          *((_QWORD *)v102 + 5) = 0;
          *((_QWORD *)v102 + 6) = 0;
          *((_QWORD *)v102 + 7) = 0;
          *((_QWORD *)v102 + 8) = v90;
          v93 = v102 + 72;
          v104 = (char *)v86[4];
          v103 = (char *)v86[5];
          if (v103 != v104)
          {
            do
            {
              *(_OWORD *)(v102 - 72) = *(_OWORD *)(v103 - 72);
              v105 = *(_OWORD *)(v103 - 56);
              v106 = *(_OWORD *)(v103 - 40);
              v107 = *(_OWORD *)(v103 - 24);
              *((_QWORD *)v102 - 1) = *((_QWORD *)v103 - 1);
              *(_OWORD *)(v102 - 24) = v107;
              *(_OWORD *)(v102 - 40) = v106;
              *(_OWORD *)(v102 - 56) = v105;
              v102 -= 72;
              v103 -= 72;
            }
            while (v103 != v104);
            v103 = (char *)v86[4];
          }
          v86[4] = v102;
          v86[5] = v93;
          v86[6] = v101;
          if (v103)
            operator delete(v103);
        }
        else
        {
          if (!v91)
            goto LABEL_308;
          *(_OWORD *)v91 = v88;
          *(_QWORD *)(v91 + 16) = v89;
          *(int64x2_t *)(v91 + 24) = vdupq_n_s64(0x7FF0000000000000uLL);
          *(_QWORD *)(v91 + 40) = 0;
          *(_QWORD *)(v91 + 48) = 0;
          *(_QWORD *)(v91 + 56) = 0;
          *(_QWORD *)(v91 + 64) = v90;
          v93 = (char *)(v91 + 72);
          v86[5] = v91 + 72;
        }
        v86[5] = v93;
        v109 = *((_QWORD *)v93 - 9);
        v108 = *((_QWORD *)v93 - 8);
        v110 = (double *)*((_QWORD *)this + 5);
        v111 = (double *)*((_QWORD *)this + 6);
        v258 = v108;
        if (v110 == v111)
        {
          v117 = 0.0;
        }
        else
        {
          v112 = 0;
          v113 = 0.0;
          v114 = (double *)*((_QWORD *)this + 5);
          v115 = 0.0;
          do
          {
            while (*v114 != 0.0)
            {
              v116 = __sincos_stret(*v114);
              v108 = v258;
              v113 = v113 + v116.__cosval;
              v115 = v115 + v116.__sinval;
              ++v114;
              v112 = 1;
              if (v114 == v111)
                goto LABEL_119;
            }
            v113 = v113 + 1.0;
            v115 = v115 + 0.0;
            ++v114;
          }
          while (v114 != v111);
          v117 = 0.0;
          if ((v112 & 1) == 0)
            goto LABEL_121;
LABEL_119:
          v117 = atan2(v115 / (double)(unint64_t)(v111 - v110), v113 / (double)(unint64_t)(v111 - v110));
          v108 = v258;
        }
LABEL_121:
        *((double *)v93 - 2) = v117;
        v118 = *((_QWORD *)this + 1);
        v119 = *(_QWORD *)(v118 + 104);
        v256 = (*(_QWORD *)(v118 + 112) - v119) >> 5;
        v120 = v256 - v109;
        if (v256 < v109)
          goto LABEL_308;
        if (v108 != -1)
        {
          v121 = v120 >= v108;
          v120 = v108;
          if (!v121)
            goto LABEL_308;
        }
        if (!v120
          || (v122 = (double *)(v119 + 32 * v109),
              v123 = (CGRect *)&v122[4 * v120],
              v124 = 32 * v120,
              v122 == (double *)v123))
        {
LABEL_296:

          if (v264)
            operator delete(v264);
          *((_QWORD *)this + 3) = *((_QWORD *)this + 2);
          *((_QWORD *)this + 6) = *((_QWORD *)this + 5);
          return;
        }
        v255 = (_QWORD *)*((_QWORD *)this + 1);
        v125 = (CGRect *)(v119 + 32 * v109);
        y = v125->origin.y;
        if (v125 != v123)
        {
          width = v125->size.width;
          height = v125->size.height;
          if (width < 0.0 || height < 0.0)
          {
            x = v125->origin.x;
            v130 = v125->origin.y;
            v268 = CGRectStandardize(*(CGRect *)(&width - 2));
            y = v268.origin.y;
          }
          v131 = v125 + 1;
          for (m = v33; v131 != v123; ++v131)
          {
            v132 = v131->origin.y;
            if (v131 == v123)
              break;
            v133 = v131->size.width;
            v134 = v131->size.height;
            v135 = v134 >= 0.0 && v133 >= 0.0;
            if (v135)
            {
              if (v132 < y)
                y = v131->origin.y;
            }
            else
            {
              v269 = CGRectStandardize(*v131);
              v136 = v269.origin.y >= y || v135;
              if (v269.origin.y < y)
                y = v132;
              if ((v136 & 1) == 0)
              {
                v270.origin.x = v131->origin.x;
                v270.origin.y = v132;
                v270.size.width = v133;
                v270.size.height = v134;
                v271 = CGRectStandardize(v270);
                y = v271.origin.y;
              }
            }
          }
          v137 = (CGRect *)(v119 + 32 * v109);
          v138 = v137->origin.y;
          if (v137 != v123)
          {
            v139 = v137->size.width;
            v140 = v137->size.height;
            if (v139 < 0.0 || v140 < 0.0)
            {
              v141 = v137->origin.x;
              *(CGRect *)(&v138 - 1) = CGRectStandardize(*(CGRect *)(&v138 - 1));
            }
            v142 = v258;
            v143 = v138 + v140;
            v144 = v137 + 1;
            for (n = v32; v144 != v123; ++v144)
            {
              v145 = v144->origin.y;
              if (v144 == v123)
                break;
              v147 = v144->size.width;
              v146 = v144->size.height;
              if (v147 < 0.0 || v146 < 0.0)
              {
                v272 = CGRectStandardize(*v144);
                v142 = v258;
                if (v143 < v272.origin.y + v272.size.height)
                {
                  v273.origin.x = v144->origin.x;
                  v273.origin.y = v145;
                  v273.size.width = v147;
                  v273.size.height = v146;
                  v274 = CGRectStandardize(v273);
                  v142 = v258;
                  v145 = v274.origin.y;
                  v146 = v274.size.height;
LABEL_165:
                  v143 = v145 + v146;
                }
              }
              else if (v143 < v145 + v146)
              {
                goto LABEL_165;
              }
            }
            v148 = (double *)(v119 + 32 * v109 + 24);
            do
            {
              *(v148 - 2) = y;
              *v148 = v143 - y;
              v148 += 4;
              v124 -= 32;
            }
            while (v124);
            if (v142 >= 1)
            {
              v149 = 0;
              v150 = *((_QWORD *)this + 5);
              v151 = (*((_QWORD *)this + 6) - v150) >> 3;
              if (v256 >= v109)
                v152 = v256 - v109;
              else
                v152 = 0;
              while (v151 != v149 && v152 != v149)
              {
                v153 = *((double *)v93 - 2);
                v154 = *(double *)(v150 + 8 * v149);
                if (vabdd_f64(v153, v154) > 2.22044605e-16)
                {
                  v156 = __sincos_stret(v153 - v154);
                  v155.f64[0] = v156.__cosval;
                  v142 = v258;
                  v157.f64[0] = -v156.__sinval;
                  v157.f64[1] = v156.__cosval;
                  v155.f64[1] = v156.__sinval;
                  *(float64x2_t *)v122 = vaddq_f64(vmlaq_n_f64(vmulq_n_f64(v157, v122[1]), v155, *v122), (float64x2_t)0);
                }
                ++v149;
                v122 += 4;
                if (v149 >= v142)
                  goto LABEL_177;
              }
              goto LABEL_308;
            }
LABEL_177:
            v158 = v109 + v142 - 1;
            if ((uint64_t)v109 < v158)
            {
              if (v256 >= v109)
                v159 = v256 - v109;
              else
                v159 = 0;
              v160 = 32 * v109;
              while (v159)
              {
                v161 = v109 + 1;
                if (v256 <= v109 + 1)
                  break;
                v162 = v119 + v160;
                v163 = *(double *)(v119 + v160 + 32);
                v165 = *(double *)(v119 + v160 + 48);
                v164 = *(double *)(v119 + v160 + 56);
                if (v165 < 0.0 || (v166 = *(double *)(v119 + v160 + 32), v164 < 0.0))
                {
                  v167 = *(_QWORD *)(v162 + 40);
                  v168 = *(_QWORD *)(v119 + v160 + 32);
                  v169 = *(_QWORD *)(v119 + v160 + 48);
                  *(_QWORD *)&v166 = (unint64_t)CGRectStandardize(*(CGRect *)(&v164 - 3));
                }
                v170 = *(double *)(v119 + v160);
                v172 = *(double *)(v119 + v160 + 16);
                v171 = *(double *)(v119 + v160 + 24);
                if (v172 < 0.0 || v171 < 0.0)
                {
                  v174 = *(_QWORD *)(v119 + v160 + 8);
                  v175 = *(_QWORD *)(v119 + v160 + 16);
                  *(CGRect *)&v170 = CGRectStandardize(*(CGRect *)&v170);
                }
                else
                {
                  v173 = *(double *)(v119 + v160 + 16);
                }
                v176 = (v166 - (v170 + v173)) * 0.5;
                v177 = v119 + v160;
                *(double *)(v177 + 16) = v176 + v172;
                *(double *)(v162 + 32) = v163 - v176;
                *(double *)(v177 + 48) = v176 + v165;
                v178 = v255[16];
                v179 = v255[17];
                v180 = (v179 - v178) >> 5;
                if (v180 <= v109 || v180 <= v161)
                  break;
                v181 = v178 + v160;
                v182 = *(double *)(v178 + v160 + 32);
                v184 = *(double *)(v178 + v160 + 48);
                v183 = *(double *)(v178 + v160 + 56);
                if (v184 < 0.0 || (v185 = *(double *)(v178 + v160 + 32), v183 < 0.0))
                {
                  v186 = *(_QWORD *)(v181 + 40);
                  v187 = *(_QWORD *)(v178 + v160 + 32);
                  v188 = *(_QWORD *)(v178 + v160 + 48);
                  *(_QWORD *)&v185 = (unint64_t)CGRectStandardize(*(CGRect *)(&v183 - 3));
                }
                v189 = *(double *)(v178 + v160);
                v191 = *(double *)(v178 + v160 + 16);
                v190 = *(double *)(v178 + v160 + 24);
                if (v191 < 0.0 || (v192 = *(double *)(v178 + v160), v193 = *(double *)(v178 + v160 + 16), v190 < 0.0))
                  *(CGRect *)&v192 = CGRectStandardize(*(CGRect *)(v178 + v160));
                v194 = (v185 - (v192 + v193)) * 0.5;
                v195 = v178 + v160;
                v275.size.width = v194 + v191;
                *(double *)(v195 + 16) = v194 + v191;
                *(double *)(v181 + 32) = v182 - v194;
                *(double *)(v195 + 48) = v194 + v184;
                v275.origin.y = *(CGFloat *)(v178 + v160 + 8);
                v275.origin.x = v189;
                v275.size.height = v190;
                *(CGRect *)(v93 - 48) = CGRectUnion(*(CGRect *)(v93 - 48), v275);
                --v159;
                v160 += 32;
                v109 = v161;
                if (v161 == v158)
                  goto LABEL_202;
              }
              goto LABEL_308;
            }
            v178 = v255[16];
            v179 = v255[17];
LABEL_202:
            v32 = n;
            if (v178 == v179)
              goto LABEL_308;
            *(CGRect *)(v93 - 48) = CGRectUnion(*(CGRect *)(v93 - 48), *(CGRect *)(v179 - 32));
            v197 = m;
            v196 = v255;
            if (m)
            {
              v198 = (_QWORD *)v255[29];
              __p = 0;
              v260 = 0;
              v261 = 0;
              std::__unwrap_and_dispatch[abi:se180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>(&v198[-m], v198, &__p);
              v199 = (double *)__p;
              v200 = v260;
              v201 = (double *)((char *)__p + 8 * (m >> 1));
              if (v201 != v260)
              {
                do
                {
                  v202 = v200 - v199;
                  if (v202 < 2)
                    break;
                  if (v202 == 3)
                  {
                    std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(v199, v199 + 1, v200 - 1);
                    break;
                  }
                  if (v202 == 2)
                  {
                    v229 = *(v200 - 1);
                    v230 = *v199;
                    if (v229 < *v199)
                    {
                      *v199 = v229;
                      *(v200 - 1) = v230;
                    }
                    break;
                  }
                  if ((char *)v200 - (char *)v199 <= 63)
                  {
                    while (v199 != v200 - 1)
                    {
                      v231 = v199++;
                      if (v231 != v200 && v199 != v200)
                      {
                        v232 = *v231;
                        v233 = *v231;
                        v234 = v199;
                        v235 = v231;
                        v236 = v199;
                        do
                        {
                          v237 = *v236++;
                          v238 = v237;
                          if (v237 < v233)
                          {
                            v233 = v238;
                            v235 = v234;
                          }
                          v234 = v236;
                        }
                        while (v236 != v200);
                        if (v235 != v231)
                        {
                          *v231 = *v235;
                          *v235 = v232;
                        }
                      }
                    }
                    break;
                  }
                  v203 = &v199[v202 >> 1];
                  v204 = v200 - 1;
                  v205 = std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(v199, v203, v200 - 1);
                  v206 = *v199;
                  if (*v199 >= *v203)
                  {
                    v207 = v200 - 2;
                    while (v207 != v199)
                    {
                      v208 = v207;
                      v209 = *v207--;
                      v210 = v209;
                      if (v209 < *v203)
                      {
                        *v199 = v210;
                        *v208 = v206;
                        ++v205;
                        v204 = v208;
                        goto LABEL_214;
                      }
                    }
                    v218 = v199 + 1;
                    if (v206 >= *v204)
                    {
                      v197 = m;
                      if (v218 == v204)
                        break;
                      while (1)
                      {
                        v221 = *v218;
                        if (v206 < *v218)
                          break;
                        if (++v218 == v204)
                          goto LABEL_274;
                      }
                      *v218++ = *v204;
                      *v204 = v221;
                    }
                    else
                    {
                      v197 = m;
                    }
                    if (v218 != v204)
                    {
LABEL_251:
                      v225 = *v199;
                      while (1)
                      {
                        v226 = *v218;
                        if (v225 < *v218)
                          break;
                        if (++v218 == v200)
                          goto LABEL_308;
                      }
                      while (v204 != v199)
                      {
                        v227 = *--v204;
                        v228 = v227;
                        if (v225 >= v227)
                        {
                          if (v218 < v204)
                          {
                            *v218++ = v228;
                            *v204 = v226;
                            goto LABEL_251;
                          }
                          if (v218 <= v201)
                            goto LABEL_233;
                          goto LABEL_274;
                        }
                      }
                      goto LABEL_308;
                    }
                    break;
                  }
LABEL_214:
                  v211 = v199 + 1;
                  v212 = v199 + 1;
                  if (v199 + 1 < v204)
                  {
LABEL_215:
                    v213 = *v203;
                    while (1)
                    {
                      v214 = *v212;
                      if (*v212 >= v213)
                        break;
                      if (++v212 == v200)
                        goto LABEL_308;
                    }
                    while (v204 != v199)
                    {
                      v215 = *--v204;
                      v216 = v215;
                      if (v215 < v213)
                      {
                        if (v212 >= v204)
                          goto LABEL_225;
                        v242 = v203 == v212;
                        *v212++ = v216;
                        *v204 = v214;
                        ++v205;
                        if (v242)
                          v203 = v204;
                        goto LABEL_215;
                      }
                    }
                    goto LABEL_308;
                  }
LABEL_225:
                  if (v212 != v203)
                  {
                    v217 = *v212;
                    if (*v203 < *v212)
                    {
                      *v212 = *v203;
                      *v203 = v217;
                      ++v205;
                    }
                  }
                  v197 = m;
                  if (v212 == v201)
                    break;
                  if (!v205)
                  {
                    if (v212 <= v201)
                    {
                      v222 = v212 + 1;
                      while (v222 != v200)
                      {
                        v224 = *(v222 - 1);
                        v223 = *v222++;
                        if (v223 < v224)
                          goto LABEL_230;
                      }
                    }
                    else
                    {
                      while (v211 != v212)
                      {
                        v220 = *(v211 - 1);
                        v219 = *v211++;
                        if (v219 < v220)
                          goto LABEL_230;
                      }
                    }
                    break;
                  }
LABEL_230:
                  if (v212 <= v201)
                  {
                    v218 = v212 + 1;
                  }
                  else
                  {
                    v200 = v212;
                    v218 = v199;
                  }
LABEL_233:
                  v199 = v218;
                }
                while (v200 != v201);
              }
LABEL_274:
              v239 = *v201;
              if ((v197 & 1) != 0)
              {
                v32 = n;
              }
              else
              {
                v240 = (double *)__p;
                v241 = (double *)((char *)__p + 8);
                v242 = __p == v201 || v241 == v201;
                v32 = n;
                if (!v242)
                {
                  v243 = *(double *)__p;
                  v244 = (double *)((char *)__p + 8);
                  do
                  {
                    v245 = *v244++;
                    v246 = v245;
                    if (v243 < v245)
                    {
                      v243 = v246;
                      v240 = v241;
                    }
                    v241 = v244;
                  }
                  while (v244 != v201);
                }
                v239 = (v239 + *v240) * 0.5;
              }
              v247 = 0x1FFFFFFFFFFFFFFFLL * v197;
              do
              {
                v248 = *(double *)&v198[v247];
                if (vabdd_f64(v248, v239) >= 0.00001)
                  v249 = v248 - v239;
                else
                  v249 = 0.0;
                *(double *)&v198[v247++] = v249;
              }
              while (v247 * 8);
              if (__p)
              {
                v260 = (double *)__p;
                operator delete(__p);
              }
              v196 = (_QWORD *)*((_QWORD *)this + 1);
            }
            v251 = (_WORD *)*((_QWORD *)this + 2);
            v250 = (_WORD *)*((_QWORD *)this + 3);
            __p = v196 + 7;
            while (v251 != v250)
              std::back_insert_iterator<std::vector<unsigned short>>::operator=[abi:se180100]((void ***)&__p, v251++);
            goto LABEL_296;
          }
        }
LABEL_308:
        __break(1u);
        return;
      }
LABEL_45:
      v33 = 0;
      v32 = 0;
      goto LABEL_95;
    }
    v24 = (char *)*((_QWORD *)this + 2);
    if (v9)
    {
      v25 = (char *)*((_QWORD *)this + 3);
      v26 = (char *)*((_QWORD *)this + 2);
      if (v24 != v25)
      {
        while (*(_WORD *)v26 != 32)
        {
          v26 += 2;
          if (v26 == v25)
          {
            v26 = (char *)*((_QWORD *)this + 3);
            break;
          }
        }
      }
      if (v26 != v25)
        *(_WORD *)v26 = 10;
    }
    else
    {
      v25 = (char *)*((_QWORD *)this + 3);
    }
    if (v24 == v25)
    {
      v40 = 0;
    }
    else
    {
      if (*((_WORD *)v25 - 1) == 173)
      {
        PageLayoutFactory::eraseLastUniChars(this, 1uLL);
        *a2 = 1;
        v24 = (char *)*((_QWORD *)this + 2);
        v25 = (char *)*((_QWORD *)this + 3);
      }
      v39 = v25 - v24;
      v40 = (v25 - v24) >> 1;
      if (v25 != v24)
      {
        if ((v39 & 0x8000000000000000) != 0)
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        v41 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<unsigned short>>((v25 - v24) >> 1);
        v264 = v41;
        v265 = v41;
        v266 = &v41[2 * v42];
        memmove(v41, v24, v39);
LABEL_44:
        v265 = &v41[2 * v40];
        v13 = (uint64_t)(*((_QWORD *)this + 3) - *((_QWORD *)this + 2)) >> 1;
        if (v13)
          goto LABEL_30;
        goto LABEL_45;
      }
    }
    v41 = 0;
    goto LABEL_44;
  }
}

void sub_184BD9164(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  _QWORD *v22;
  void *v23;

  if (__p)
    operator delete(__p);

  if (a22)
    operator delete(a22);
  v22[3] = v22[2];
  v22[6] = v22[5];
  _Unwind_Resume(a1);
}

void PageLayoutFactory::addUniChars(uint64_t a1, uint64_t a2, _WORD *a3, uint64_t a4, uint64_t a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10, CGFloat a11, CGFloat a12, CGFloat a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  uint64_t v26;
  _WORD *v27;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  double v42;
  double v43;
  double v44;
  double v45;
  uint64_t v46;
  double v47;
  double v48;
  double v49;
  double v50;
  uint64_t v51;
  _QWORD *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t *v55;
  _QWORD *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t v61;
  char *v62;
  uint64_t v63;
  char *v64;
  uint64_t *v65;
  char *v66;
  char *i;
  uint64_t v68;
  uint64_t v69;
  unint64_t v70;
  _QWORD *v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  unint64_t v77;
  char *v78;
  uint64_t v79;
  char *v80;
  char *v81;
  char *v82;
  char *j;
  uint64_t v84;
  _QWORD *v85;
  double *v86;
  unint64_t v87;
  double *v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  char *v94;
  uint64_t v95;
  char *v96;
  double *v97;
  char *v98;
  char *v99;
  __int128 v100;
  _QWORD *v101;
  double *v102;
  unint64_t v103;
  double *v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  unint64_t v109;
  char *v110;
  uint64_t v111;
  char *v112;
  double *v113;
  char *v114;
  char *v115;
  __int128 v116;
  _QWORD *v117;
  unint64_t v118;
  _QWORD *v119;
  _QWORD *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  char *v126;
  uint64_t v127;
  char *v128;
  char *v129;
  char *v130;
  char *k;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  unint64_t v135;
  _QWORD *v136;
  _QWORD *v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  unint64_t v142;
  char *v143;
  uint64_t v144;
  char *v145;
  char *v146;
  char *v147;
  char *m;
  uint64_t v149;
  uint64_t v151;
  void **v152;
  CGRect v153;
  CGRect v154;

  v26 = a4;
  v27 = a3;
  if (a4 != 1 || *a3 != 32)
    goto LABEL_10;
  v30 = *(_QWORD *)(a1 + 24);
  if (*(_QWORD *)(a1 + 16) != v30 && *(_WORD *)(v30 - 2) != 32)
  {
    v31 = *(_QWORD *)(a1 + 8);
    v33 = *(_QWORD *)(v31 + 104);
    v32 = *(_QWORD *)(v31 + 112);
    if (v33 == v32)
      goto LABEL_134;
    v34 = *(double *)(v32 - 32);
    v35 = *(double *)(v32 - 16);
    v36 = *(double *)(v32 - 8);
    if (v35 < 0.0 || v36 < 0.0)
    {
      v37 = *(_QWORD *)(v32 - 24);
      *(CGRect *)&v34 = CGRectStandardize(*(CGRect *)&v34);
    }
    a6 = v34 + v35;
    a9 = 0.0;
    a7 = NAN;
LABEL_10:
    v38 = *(_QWORD *)(a1 + 24);
    if (*(_QWORD *)(a1 + 16) != v38 && *(_WORD *)(v38 - 2) == 32)
    {
      v39 = *(_QWORD **)(a1 + 8);
      v40 = v39[14];
      if (v39[13] == v40)
        goto LABEL_134;
      v41 = v39[17];
      if (v39[16] == v41)
        goto LABEL_134;
      if (a8 < 0.0 || (v42 = a6, a9 < 0.0))
      {
        v153.origin.x = a6;
        v153.origin.y = a7;
        v153.size.width = a8;
        v153.size.height = a9;
        *(_QWORD *)&v42 = (unint64_t)CGRectStandardize(v153);
      }
      v43 = *(double *)(v40 - 32);
      v44 = *(double *)(v40 - 16);
      v45 = *(double *)(v40 - 8);
      if (v44 < 0.0 || v45 < 0.0)
      {
        v46 = *(_QWORD *)(v40 - 24);
        *(_QWORD *)&v43 = (unint64_t)CGRectStandardize(*(CGRect *)&v43);
      }
      *(double *)(v40 - 16) = v42 - v43;
      if (a12 < 0.0 || (v47 = a10, a13 < 0.0))
      {
        v154.origin.x = a10;
        v154.origin.y = a11;
        v154.size.width = a12;
        v154.size.height = a13;
        *(_QWORD *)&v47 = (unint64_t)CGRectStandardize(v154);
      }
      v48 = *(double *)(v41 - 32);
      v49 = *(double *)(v41 - 16);
      v50 = *(double *)(v41 - 8);
      if (v49 < 0.0 || v50 < 0.0)
      {
        v51 = *(_QWORD *)(v41 - 24);
        *(_QWORD *)&v48 = (unint64_t)CGRectStandardize(*(CGRect *)&v48);
      }
      *(double *)(v41 - 16) = v47 - v48;
    }
    v52 = *(_QWORD **)(a1 + 8);
    v53 = objc_msgSend(*(id *)(a1 + 168), "length") + ((uint64_t)(*(_QWORD *)(a1 + 24) - *(_QWORD *)(a1 + 16)) >> 1);
    v55 = (uint64_t *)v52[20];
    v54 = v52[21];
    if ((unint64_t)v55 >= v54)
    {
      v57 = v52[19];
      v58 = ((uint64_t)v55 - v57) >> 3;
      if ((unint64_t)(v58 + 1) >> 61)
        goto LABEL_135;
      v59 = v54 - v57;
      v60 = v59 >> 2;
      if (v59 >> 2 <= (unint64_t)(v58 + 1))
        v60 = v58 + 1;
      if ((unint64_t)v59 >= 0x7FFFFFFFFFFFFFF8)
        v61 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v61 = v60;
      if (!v61)
        goto LABEL_134;
      v62 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v61);
      if (!v62)
        goto LABEL_134;
      v64 = &v62[8 * v63];
      v65 = (uint64_t *)&v62[8 * v58];
      *v65 = v53;
      v56 = v65 + 1;
      v66 = (char *)v52[19];
      for (i = (char *)v52[20]; i != v66; i -= 8)
      {
        v68 = *((_QWORD *)i - 1);
        *--v65 = v68;
      }
      v52[19] = v65;
      v52[20] = v56;
      v52[21] = v64;
      if (v66)
        operator delete(v66);
    }
    else
    {
      if (!v55)
        goto LABEL_134;
      *v55 = v53;
      v56 = v55 + 1;
    }
    v52[20] = v56;
    v152 = (void **)(a1 + 16);
    if (v26)
    {
      v69 = 2 * v26;
      do
      {
        std::back_insert_iterator<std::vector<unsigned short>>::operator=[abi:se180100](&v152, v27++);
        v69 -= 2;
      }
      while (v69);
    }
    v71 = *(_QWORD **)(a1 + 48);
    v70 = *(_QWORD *)(a1 + 56);
    if ((unint64_t)v71 >= v70)
    {
      v73 = *(_QWORD *)(a1 + 40);
      v74 = ((uint64_t)v71 - v73) >> 3;
      if ((unint64_t)(v74 + 1) >> 61)
        std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
      v75 = v70 - v73;
      v76 = v75 >> 2;
      if (v75 >> 2 <= (unint64_t)(v74 + 1))
        v76 = v74 + 1;
      if ((unint64_t)v75 >= 0x7FFFFFFFFFFFFFF8)
        v77 = 0x1FFFFFFFFFFFFFFFLL;
      else
        v77 = v76;
      if (!v77)
        goto LABEL_134;
      v78 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v77);
      if (!v78)
        goto LABEL_134;
      v80 = &v78[8 * v79];
      v81 = &v78[8 * v74];
      *(_QWORD *)v81 = a17;
      v72 = v81 + 8;
      v82 = *(char **)(a1 + 40);
      for (j = *(char **)(a1 + 48); j != v82; j -= 8)
      {
        v84 = *((_QWORD *)j - 1);
        *((_QWORD *)v81 - 1) = v84;
        v81 -= 8;
      }
      *(_QWORD *)(a1 + 40) = v81;
      *(_QWORD *)(a1 + 48) = v72;
      *(_QWORD *)(a1 + 56) = v80;
      if (v82)
        operator delete(v82);
    }
    else
    {
      if (!v71)
        goto LABEL_134;
      *v71 = a17;
      v72 = v71 + 1;
    }
    *(_QWORD *)(a1 + 48) = v72;
    v85 = *(_QWORD **)(a1 + 8);
    v86 = (double *)v85[14];
    v87 = v85[15];
    if ((unint64_t)v86 >= v87)
    {
      v89 = v85[13];
      v90 = ((uint64_t)v86 - v89) >> 5;
      v91 = v90 + 1;
      if ((unint64_t)(v90 + 1) >> 59)
        goto LABEL_136;
      v92 = v87 - v89;
      if (v92 >> 4 > v91)
        v91 = v92 >> 4;
      if ((unint64_t)v92 >= 0x7FFFFFFFFFFFFFE0)
        v93 = 0x7FFFFFFFFFFFFFFLL;
      else
        v93 = v91;
      if (!v93)
        goto LABEL_134;
      v94 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v93);
      if (!v94)
        goto LABEL_134;
      v96 = &v94[32 * v95];
      v97 = (double *)&v94[32 * v90];
      *v97 = a6;
      v97[1] = a7;
      v97[2] = a8;
      v97[3] = a9;
      v88 = v97 + 4;
      v99 = (char *)v85[13];
      v98 = (char *)v85[14];
      if (v98 != v99)
      {
        do
        {
          v100 = *((_OWORD *)v98 - 1);
          *((_OWORD *)v97 - 2) = *((_OWORD *)v98 - 2);
          *((_OWORD *)v97 - 1) = v100;
          v97 -= 4;
          v98 -= 32;
        }
        while (v98 != v99);
        v98 = (char *)v85[13];
      }
      v85[13] = v97;
      v85[14] = v88;
      v85[15] = v96;
      if (v98)
        operator delete(v98);
    }
    else
    {
      if (!v86)
        goto LABEL_134;
      *v86 = a6;
      v86[1] = a7;
      v88 = v86 + 4;
      v86[2] = a8;
      v86[3] = a9;
    }
    v85[14] = v88;
    v101 = *(_QWORD **)(a1 + 8);
    v102 = (double *)v101[17];
    v103 = v101[18];
    if ((unint64_t)v102 < v103)
    {
      if (!v102)
        goto LABEL_134;
      *v102 = a10;
      v102[1] = a11;
      v104 = v102 + 4;
      v102[2] = a12;
      v102[3] = a13;
      goto LABEL_94;
    }
    v105 = v101[16];
    v106 = ((uint64_t)v102 - v105) >> 5;
    v107 = v106 + 1;
    if (!((unint64_t)(v106 + 1) >> 59))
    {
      v108 = v103 - v105;
      if (v108 >> 4 > v107)
        v107 = v108 >> 4;
      if ((unint64_t)v108 >= 0x7FFFFFFFFFFFFFE0)
        v109 = 0x7FFFFFFFFFFFFFFLL;
      else
        v109 = v107;
      if (!v109)
        goto LABEL_134;
      v110 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CGRect>>(v109);
      if (!v110)
        goto LABEL_134;
      v112 = &v110[32 * v111];
      v113 = (double *)&v110[32 * v106];
      *v113 = a10;
      v113[1] = a11;
      v113[2] = a12;
      v113[3] = a13;
      v104 = v113 + 4;
      v115 = (char *)v101[16];
      v114 = (char *)v101[17];
      if (v114 != v115)
      {
        do
        {
          v116 = *((_OWORD *)v114 - 1);
          *((_OWORD *)v113 - 2) = *((_OWORD *)v114 - 2);
          *((_OWORD *)v113 - 1) = v116;
          v113 -= 4;
          v114 -= 32;
        }
        while (v114 != v115);
        v114 = (char *)v101[16];
      }
      v101[16] = v113;
      v101[17] = v104;
      v101[18] = v112;
      if (v114)
        operator delete(v114);
LABEL_94:
      v101[17] = v104;
      v117 = *(_QWORD **)(a1 + 8);
      v119 = (_QWORD *)v117[11];
      v118 = v117[12];
      if ((unint64_t)v119 >= v118)
      {
        v121 = v117[10];
        v122 = ((uint64_t)v119 - v121) >> 3;
        if ((unint64_t)(v122 + 1) >> 61)
          goto LABEL_135;
        v123 = v118 - v121;
        v124 = v123 >> 2;
        if (v123 >> 2 <= (unint64_t)(v122 + 1))
          v124 = v122 + 1;
        if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFF8)
          v125 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v125 = v124;
        if (!v125)
          goto LABEL_134;
        v126 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v125);
        if (!v126)
          goto LABEL_134;
        v128 = &v126[8 * v127];
        v129 = &v126[8 * v122];
        *(_QWORD *)v129 = v26;
        v120 = v129 + 8;
        v130 = (char *)v117[10];
        for (k = (char *)v117[11]; k != v130; k -= 8)
        {
          v132 = *((_QWORD *)k - 1);
          *((_QWORD *)v129 - 1) = v132;
          v129 -= 8;
        }
        v117[10] = v129;
        v117[11] = v120;
        v117[12] = v128;
        if (v130)
          operator delete(v130);
      }
      else
      {
        if (!v119)
          goto LABEL_134;
        *v119 = v26;
        v120 = v119 + 1;
      }
      v117[11] = v120;
      v133 = *(_QWORD *)(a1 + 8);
      v152 = (void **)(v133 + 200);
      if (v26)
      {
        v134 = v26;
        do
        {
          v151 = a2;
          std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](&v152, &v151);
          --v134;
        }
        while (v134);
        v152 = (void **)(*(_QWORD *)(a1 + 8) + 224);
        do
        {
          v151 = a18;
          std::back_insert_iterator<std::vector<double>>::operator=[abi:se180100](&v152, &v151);
          --v26;
        }
        while (v26);
        v133 = *(_QWORD *)(a1 + 8);
      }
      v136 = *(_QWORD **)(v133 + 280);
      v135 = *(_QWORD *)(v133 + 288);
      if ((unint64_t)v136 >= v135)
      {
        v138 = *(_QWORD *)(v133 + 272);
        v139 = ((uint64_t)v136 - v138) >> 3;
        if ((unint64_t)(v139 + 1) >> 61)
          goto LABEL_135;
        v140 = v135 - v138;
        v141 = v140 >> 2;
        if (v140 >> 2 <= (unint64_t)(v139 + 1))
          v141 = v139 + 1;
        if ((unint64_t)v140 >= 0x7FFFFFFFFFFFFFF8)
          v142 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v142 = v141;
        if (v142)
        {
          v143 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v142);
          if (v143)
          {
            v145 = &v143[8 * v144];
            v146 = &v143[8 * v139];
            *(_QWORD *)v146 = a5;
            v137 = v146 + 8;
            v147 = *(char **)(v133 + 272);
            for (m = *(char **)(v133 + 280); m != v147; m -= 8)
            {
              v149 = *((_QWORD *)m - 1);
              *((_QWORD *)v146 - 1) = v149;
              v146 -= 8;
            }
            *(_QWORD *)(v133 + 272) = v146;
            *(_QWORD *)(v133 + 280) = v137;
            *(_QWORD *)(v133 + 288) = v145;
            if (v147)
              operator delete(v147);
            goto LABEL_132;
          }
        }
      }
      else if (v136)
      {
        *v136 = a5;
        v137 = v136 + 1;
LABEL_132:
        *(_QWORD *)(v133 + 280) = v137;
        return;
      }
LABEL_134:
      __break(1u);
LABEL_135:
      std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
    }
LABEL_136:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
}

void PageLayoutFactory::getSpaceWidth(int8x8_t *this, const TextChunk *a2)
{
  unint64_t *v3;
  int8x8_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  unint64_t v9;
  double **v10;
  double *i;
  unint64_t v12;
  uint64_t v13;
  int advances;
  __int16 v15;
  CGGlyph glyphs;

  v3 = *(unint64_t **)((char *)&a2[13].ckSize + 2);
  if (v3)
    CFRetain(*(CFTypeRef *)((char *)&a2[13].ckSize + 2));
  v4 = this[9];
  if (!*(_QWORD *)&v4)
    goto LABEL_21;
  v5 = 0x9DDFEA08EB382D69 * (((8 * (_DWORD)v3) + 8) ^ ((unint64_t)v3 >> 32));
  v6 = 0x9DDFEA08EB382D69 * (((unint64_t)v3 >> 32) ^ (v5 >> 47) ^ v5);
  v7 = 0x9DDFEA08EB382D69 * (v6 ^ (v6 >> 47));
  v8 = (uint8x8_t)vcnt_s8(v4);
  v8.i16[0] = vaddlv_u8(v8);
  if (v8.u32[0] > 1uLL)
  {
    v9 = v7;
    if (v7 >= *(_QWORD *)&v4)
      v9 = v7 % *(_QWORD *)&v4;
  }
  else
  {
    v9 = v7 & (*(_QWORD *)&v4 - 1);
  }
  v10 = *(double ***)(*(_QWORD *)&this[8] + 8 * v9);
  if (!v10)
  {
LABEL_21:
    i = 0;
    if (!v3)
      goto LABEL_23;
    goto LABEL_22;
  }
  for (i = *v10; i; i = *(double **)i)
  {
    v12 = *((_QWORD *)i + 1);
    if (v12 == v7)
    {
      if (*((unint64_t **)i + 2) == v3)
        break;
    }
    else
    {
      if (v8.u32[0] > 1uLL)
      {
        if (v12 >= *(_QWORD *)&v4)
          v12 %= *(_QWORD *)&v4;
      }
      else
      {
        v12 &= *(_QWORD *)&v4 - 1;
      }
      if (v12 != v9)
        goto LABEL_21;
    }
  }
  if (v3)
LABEL_22:
    CFRelease(v3);
LABEL_23:
  if (i)
  {
    if (i[3] > 0.0)
      return;
    if (v3)
      goto LABEL_26;
  }
  else if (v3)
  {
LABEL_26:
    v13 = atomic_load(v3 + 11);
    if (v13)
      CGPropertiesGetProperty(v13, CFSTR("com.apple.CoreGraphics.CGPDFFontToUnicodeCMap"));
    glyphs = 0;
    v15 = 32;
    (*(void (**)(unint64_t, __int16 *, CGGlyph *, uint64_t))(v3[2] + 376))(v3[14], &v15, &glyphs, 1);
    if (glyphs)
    {
      advances = 0;
      CGFontGetGlyphAdvances((CGFontRef)v3, &glyphs, 1uLL, &advances);
    }
    goto LABEL_32;
  }
  glyphs = 0;
LABEL_32:
  get_font_info(v3);
}

void PageLayoutFactory::addChunkUnicodes(PageLayoutFactory::TextChunk const&)::$_0::operator()(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v11;
  unint64_t v12;
  uint64_t *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  void *v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  BOOL v25;
  int *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;

  v8 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 72);
  if (a2 >= (*(_QWORD *)(*(_QWORD *)(a1 + 8) + 80) - v8) >> 3)
    goto LABEL_25;
  v11 = *(_QWORD *)a1;
  v12 = *(_QWORD *)(v8 + 8 * a2);
  v13 = *(uint64_t **)(a1 + 16);
  if (v12 != 1)
  {
    v21 = *v13;
    v22 = (v13[1] - *v13) >> 1;
    v23 = **(_QWORD **)(a1 + 24);
    v24 = v22 - v23;
    if (v22 < v23)
      goto LABEL_25;
    if (v12 != -1)
    {
      v25 = v24 >= v12;
      v24 = v12;
      if (!v25)
        goto LABEL_25;
    }
    v26 = (int *)(v21 + 2 * v23);
    goto LABEL_22;
  }
  v14 = **(_QWORD **)(a1 + 24);
  v15 = *v13;
  if (v14 >= (*(_QWORD *)(*(_QWORD *)(a1 + 16) + 8) - v15) >> 1)
    goto LABEL_25;
  v16 = *(unsigned __int16 *)(v15 + 2 * v14);
  objc_msgSend(MEMORY[0x1E0CB3500], "whitespaceCharacterSet");
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = objc_msgSend(v17, "characterIsMember:", v16);

  if (v18)
    v19 = 32;
  else
    v19 = v16;
  if (v19 > 64256)
  {
    if (v19 != 64257)
    {
      v20 = 64258;
      goto LABEL_17;
    }
LABEL_19:
    v27 = 6881382;
    goto LABEL_20;
  }
  if (v19 == 61441)
    goto LABEL_19;
  v20 = 61442;
LABEL_17:
  if (v19 != v20)
  {
    LOWORD(v31) = v19;
    v26 = &v31;
    v24 = 1;
    goto LABEL_22;
  }
  v27 = 7077990;
LABEL_20:
  v31 = v27;
  v26 = &v31;
  v24 = 2;
LABEL_22:
  v28 = *(_QWORD *)(a1 + 8);
  v29 = *(_QWORD *)(v28 + 24);
  if (a2 < (*(_QWORD *)(v28 + 32) - v29) >> 5)
  {
    v30 = *(_QWORD *)(v28 + 48);
    if (a2 < (*(_QWORD *)(v28 + 56) - v30) >> 5)
    {
      PageLayoutFactory::addUniChars(v11, *(_QWORD *)(v28 + 224), v26, v24, *(_QWORD *)(v28 + 176), *(CGFloat *)(v29 + 32 * a2), *(CGFloat *)(v28 + 120), *(CGFloat *)(v29 + 32 * a2 + 16), *(CGFloat *)(v28 + 128), *(CGFloat *)(v30 + 32 * a2), *(CGFloat *)(v30 + 32 * a2 + 8), *(CGFloat *)(v30 + 32 * a2 + 16), *(CGFloat *)(v30 + 32 * a2 + 24), a6, a7, a8, *(_QWORD *)(v28 + 144), *(_QWORD *)(v28 + 152));
      **(_QWORD **)(a1 + 24) += v12;
      return;
    }
  }
LABEL_25:
  __break(1u);
}

void sub_184BD9CB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ***std::back_insert_iterator<std::vector<unsigned long>>::operator=[abi:se180100](void ***a1, _QWORD *a2)
{
  void **v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *i;
  uint64_t v18;

  v4 = *a1;
  v6 = (*a1)[1];
  v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 < v5)
  {
    if (v6)
    {
      *v6 = *a2;
      v7 = v6 + 1;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v8 = ((char *)v6 - (_BYTE *)*v4) >> 3;
  if ((unint64_t)(v8 + 1) >> 61)
    goto LABEL_19;
  v9 = v5 - (_QWORD)*v4;
  v10 = v9 >> 2;
  if (v9 >> 2 <= (unint64_t)(v8 + 1))
    v10 = v8 + 1;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
    v11 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v11 = v10;
  if (!v11
    || (v12 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v11)) == 0)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v14 = &v12[8 * v13];
  v15 = &v12[8 * v8];
  *(_QWORD *)v15 = *a2;
  v7 = v15 + 8;
  v16 = (char *)*v4;
  for (i = (char *)v4[1]; i != v16; i -= 8)
  {
    v18 = *((_QWORD *)i - 1);
    *((_QWORD *)v15 - 1) = v18;
    v15 -= 8;
  }
  *v4 = v15;
  v4[1] = v7;
  v4[2] = v14;
  if (v16)
    operator delete(v16);
LABEL_17:
  v4[1] = v7;
  return a1;
}

void ***std::back_insert_iterator<std::vector<double>>::operator=[abi:se180100](void ***a1, _QWORD *a2)
{
  void **v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *i;
  uint64_t v18;

  v4 = *a1;
  v6 = (*a1)[1];
  v5 = (unint64_t)(*a1)[2];
  if ((unint64_t)v6 < v5)
  {
    if (v6)
    {
      *v6 = *a2;
      v7 = v6 + 1;
      goto LABEL_17;
    }
    goto LABEL_18;
  }
  v8 = ((char *)v6 - (_BYTE *)*v4) >> 3;
  if ((unint64_t)(v8 + 1) >> 61)
    goto LABEL_19;
  v9 = v5 - (_QWORD)*v4;
  v10 = v9 >> 2;
  if (v9 >> 2 <= (unint64_t)(v8 + 1))
    v10 = v8 + 1;
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
    v11 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v11 = v10;
  if (!v11
    || (v12 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v11)) == 0)
  {
LABEL_18:
    __break(1u);
LABEL_19:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  v14 = &v12[8 * v13];
  v15 = &v12[8 * v8];
  *(_QWORD *)v15 = *a2;
  v7 = v15 + 8;
  v16 = (char *)*v4;
  for (i = (char *)v4[1]; i != v16; i -= 8)
  {
    v18 = *((_QWORD *)i - 1);
    *((_QWORD *)v15 - 1) = v18;
    v15 -= 8;
  }
  *v4 = v15;
  v4[1] = v7;
  v4[2] = v14;
  if (v16)
    operator delete(v16);
LABEL_17:
  v4[1] = v7;
  return a1;
}

uint64_t std::unique_ptr<UBiDi,applesauce::raii::v1::detail::opaque_deletion_functor<UBiDi*,&(ubidi_close)>>::reset[abi:se180100](uint64_t *a1)
{
  uint64_t result;

  result = *a1;
  *a1 = 0;
  if (result)
    return ubidi_close();
  return result;
}

_QWORD *PageLayoutFactory::eraseLastUniChars(_QWORD *this, unint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  char *v9;
  char *v10;
  int64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *v23;
  uint64_t v24;
  _BYTE *v25;
  char *v26;
  char *v27;
  int64_t v28;
  _BYTE *v29;
  char *v30;
  char *v31;
  _QWORD *v32;
  int64_t v33;
  _BYTE *v34;
  char *v35;
  char *v36;
  _QWORD *v37;
  int64_t v38;
  _BYTE *v39;
  char *v40;
  char *v41;
  int64_t v42;

  if (a2)
  {
    v2 = this;
    v3 = this[3];
    if (this[2] != v3)
    {
      v4 = a2;
      if ((a2 & 0x8000000000000000) == 0)
      {
        this[3] = v3 - 2 * a2;
        v5 = (_QWORD *)this[1];
        v6 = v5[26];
        v7 = v5;
        v5[26] = v6 - 8 * a2;
        v8 = (_BYTE *)v5[29];
        v9 = &v8[-8 * a2];
        v10 = &v9[8 * ((uint64_t)(8 * a2) >> 3)];
        v11 = v8 - v10;
        if (v8 != v10)
        {
          this = memmove(&v8[-8 * v4], v10, v8 - v10);
          v5 = (_QWORD *)v2[1];
        }
        v12 = 0;
        v7[29] = &v9[v11];
        v13 = v5[10];
        v14 = (v5[11] - v13) >> 3;
        v15 = v14 - 1;
        while (v14 > v15)
        {
          v16 = *(_QWORD *)(v13 + 8 * v15);
          v17 = v4 - v16;
          if (v4 < v16)
          {
            *(_QWORD *)(v13 + 8 * v15) = v16 - v4;
LABEL_12:
            if (v12 < 0)
              break;
            if (v12)
            {
              v18 = v2[6];
              v19 = -v12;
              v2[6] = v18 - 8 * v12;
              v20 = v5[14];
              v21 = v20 - 32 * v12;
              v22 = (32 * v12) >> 5;
              v23 = v5;
              v24 = (8 * v12) >> 3;
              v5[14] = v21;
              v25 = (_BYTE *)v5[17];
              v26 = &v25[32 * v19];
              v27 = &v26[32 * v22];
              v28 = v25 - v27;
              if (v25 != v27)
              {
                this = memmove(&v25[32 * v19], v27, v25 - v27);
                v5 = (_QWORD *)v2[1];
              }
              v23[17] = &v26[v28];
              v29 = (_BYTE *)v5[11];
              v30 = &v29[8 * v19];
              v31 = &v30[8 * v24];
              v32 = v5;
              v33 = v29 - v31;
              if (v29 != v31)
              {
                this = memmove(&v29[8 * v19], v31, v29 - v31);
                v32 = (_QWORD *)v2[1];
              }
              v5[11] = &v30[v33];
              v34 = (_BYTE *)v32[20];
              v35 = &v34[8 * v19];
              v36 = &v35[8 * v24];
              v37 = v32;
              v38 = v34 - v36;
              if (v34 != v36)
              {
                this = memmove(&v34[8 * v19], v36, v34 - v36);
                v37 = (_QWORD *)v2[1];
              }
              v32[20] = &v35[v38];
              v39 = (_BYTE *)v37[35];
              v40 = &v39[8 * v19];
              v41 = &v40[8 * v24];
              v42 = v39 - v41;
              if (v39 != v41)
                this = memmove(&v39[8 * v19], v41, v39 - v41);
              v37[35] = &v40[v42];
            }
            return this;
          }
          ++v12;
          --v15;
          v4 -= v16;
          if (!v17)
            goto LABEL_12;
        }
      }
      __break(1u);
    }
  }
  return this;
}

void std::__unwrap_and_dispatch[abi:se180100]<std::__overload<std::__copy_loop<std::_ClassicAlgPolicy>,std::__copy_trivial>,std::__wrap_iter<double *>,std::__wrap_iter<double *>,std::back_insert_iterator<std::vector<double>>,0>(_QWORD *a1, _QWORD *a2, void **a3)
{
  _QWORD *v5;
  char *v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  char *v14;
  char *v15;
  char *i;
  uint64_t v17;

  if (a1 != a2)
  {
    v5 = a1;
    v6 = (char *)a3[1];
    do
    {
      v7 = (unint64_t)a3[2];
      if ((unint64_t)v6 >= v7)
      {
        v8 = (v6 - (_BYTE *)*a3) >> 3;
        if ((unint64_t)(v8 + 1) >> 61)
          goto LABEL_22;
        v9 = v7 - (_QWORD)*a3;
        v10 = v9 >> 2;
        if (v9 >> 2 <= (unint64_t)(v8 + 1))
          v10 = v8 + 1;
        if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8)
          v11 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v11 = v10;
        if (!v11
          || (v12 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<CG::DisplayListResource const*>>(v11)) == 0)
        {
LABEL_21:
          __break(1u);
LABEL_22:
          std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
        }
        v14 = &v12[8 * v8];
        *(_QWORD *)v14 = *v5;
        v6 = v14 + 8;
        v15 = (char *)*a3;
        for (i = (char *)a3[1]; i != v15; i -= 8)
        {
          v17 = *((_QWORD *)i - 1);
          *((_QWORD *)v14 - 1) = v17;
          v14 -= 8;
        }
        *a3 = v14;
        a3[1] = v6;
        a3[2] = &v12[8 * v13];
        if (v15)
          operator delete(v15);
      }
      else
      {
        if (!v6)
          goto LABEL_21;
        *(_QWORD *)v6 = *v5;
        v6 += 8;
      }
      a3[1] = v6;
      ++v5;
    }
    while (v5 != a2);
  }
}

uint64_t std::__sort3[abi:se180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::__wrap_iter<double *>>(double *a1, double *a2, double *a3)
{
  double v3;
  double v4;
  double v5;
  double v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 >= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

void *std::__allocate_at_least[abi:se180100]<std::allocator<PageLayout::TextLine>>(unint64_t a1)
{
  if (a1 >= 0x38E38E38E38E38FLL)
    std::__throw_bad_array_new_length[abi:se180100]();
  return operator new(72 * a1);
}

_OWORD *std::construct_at[abi:se180100]<PageLayout::CharacterStyle,PageLayout::CharacterStyle const&,PageLayout::CharacterStyle*>(_OWORD *result, uint64_t a2)
{
  _OWORD *v2;
  uint64_t v3;

  if (result)
  {
    v2 = result;
    *result = *(_OWORD *)a2;
    v3 = *(_QWORD *)(a2 + 16);
    if (v3)
      CFRetain(*(CFTypeRef *)(a2 + 16));
    *((_QWORD *)v2 + 2) = v3;
    return v2;
  }
  else
  {
    __break(1u);
  }
  return result;
}

uint64_t std::__split_buffer<PageLayout::CharacterStyle>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 24;
    std::__destroy_at[abi:se180100]<PageLayout::CharacterStyle,0>(i - 24);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__destroy_at[abi:se180100]<PageLayout::CharacterStyle,0>(uint64_t a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *(const void **)(a1 + 16);
    if (v1)
      CFRelease(v1);
  }
  else
  {
    __break(1u);
  }
}

void PageLayout::addVertEdge(PageLayout *this, const CGPoint *a2, const CGPoint *a3, double a4, double a5, double a6)
{
  double *v8;
  double *v9;
  uint64_t v10;
  unint64_t v11;
  double *v12;
  unint64_t v13;
  double *v14;
  double *v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  double *v33;
  char *v34;
  int64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  double *v40;
  double *v41;
  double *v42;
  double *v43;
  __int128 v44;
  double *v45;
  int64_t v46;
  void *v47;

  v9 = (double *)*((_QWORD *)this + 57);
  v8 = (double *)*((_QWORD *)this + 58);
  v10 = (char *)v8 - (char *)v9;
  if (v8 == v9)
  {
    v12 = (double *)*((_QWORD *)this + 58);
  }
  else
  {
    v11 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
    v12 = (double *)*((_QWORD *)this + 57);
    do
    {
      v13 = v11 >> 1;
      v14 = &v12[3 * (v11 >> 1)];
      v16 = *v14;
      v15 = v14 + 3;
      v11 += ~(v11 >> 1);
      if (v16 < a4)
        v12 = v15;
      else
        v11 = v13;
    }
    while (v11);
  }
  if (a5 >= a6)
    v17 = a6;
  else
    v17 = a5;
  if (a5 >= a6)
    v18 = a5;
  else
    v18 = a6;
  if (v8 != v12 && *v12 == a4)
  {
    v19 = v12[1];
    v20 = v12[2];
    if (v17 == v19 && v18 == v20)
      return;
    if (v17 <= v20 && v18 >= v19)
    {
      if (v17 < v19)
        v19 = v17;
      if (v20 < v18)
        v20 = v18;
      v12[1] = v19;
      v12[2] = v20;
      return;
    }
  }
  v23 = *((_QWORD *)this + 59);
  if ((unint64_t)v8 < v23)
  {
    if (v12 != v8)
    {
      v24 = v12 + 3;
      v25 = v8 - 3;
      v26 = *((_QWORD *)this + 58);
      while (v25 < v8)
      {
        v27 = *(_OWORD *)v25;
        *(double *)(v26 + 16) = v25[2];
        *(_OWORD *)v26 = v27;
        v26 += 24;
        v25 += 3;
      }
      *((_QWORD *)this + 58) = v26;
      if (v8 != v24)
        memmove(v12 + 3, v12, (char *)v8 - (char *)v24);
      *v12 = a4;
      v12[1] = v17;
      v12[2] = v18;
      return;
    }
    if (v9)
    {
      *v8 = a4;
      v8[1] = v17;
      v8[2] = v18;
      *((_QWORD *)this + 58) = v8 + 3;
      return;
    }
    goto LABEL_70;
  }
  v28 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3) + 1;
  if (v28 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_71;
  v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (_QWORD)v9) >> 3);
  if (2 * v29 > v28)
    v28 = 2 * v29;
  if (v29 >= 0x555555555555555)
    v30 = 0xAAAAAAAAAAAAAAALL;
  else
    v30 = v28;
  if (v30)
  {
    v32 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v30);
  }
  else
  {
    v32 = 0;
    v31 = 0;
  }
  v33 = (double *)&v32[8 * (v12 - v9)];
  v34 = &v32[24 * v31];
  if (0xAAAAAAAAAAAAAAABLL * (v12 - v9) == v31)
  {
    if ((char *)v12 - (char *)v9 < 1)
    {
      if (v12 == v9)
        v37 = 1;
      else
        v37 = 0x5555555555555556 * (v12 - v9);
      v38 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v37);
      v33 = (double *)&v38[24 * (v37 >> 2)];
      v34 = &v38[24 * v39];
      if (v32)
        operator delete(v32);
    }
    else
    {
      v35 = 0xAAAAAAAAAAAAAAABLL * ((8 * (v12 - v9)) >> 3);
      if (v35 >= -1)
        v36 = v35 + 1;
      else
        v36 = v35 + 2;
      v33 -= 3 * (v36 >> 1);
    }
  }
  if (!v33)
  {
LABEL_70:
    __break(1u);
LABEL_71:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  *v33 = a4;
  v33[1] = v17;
  v33[2] = v18;
  v40 = (double *)*((_QWORD *)this + 57);
  v41 = v33;
  if (v40 != v12)
  {
    v42 = v12;
    v43 = v33;
    do
    {
      v44 = *(_OWORD *)(v42 - 3);
      v41 = v43 - 3;
      *(v43 - 1) = *(v42 - 1);
      *(_OWORD *)(v43 - 3) = v44;
      v42 -= 3;
      v43 -= 3;
    }
    while (v42 != v40);
  }
  v45 = (double *)*((_QWORD *)this + 58);
  v46 = (char *)v45 - (char *)v12;
  if (v45 != v12)
    memmove(v33 + 3, v12, (char *)v45 - (char *)v12);
  v47 = (void *)*((_QWORD *)this + 57);
  *((_QWORD *)this + 57) = v41;
  *((_QWORD *)this + 58) = (char *)v33 + v46 + 24;
  *((_QWORD *)this + 59) = v34;
  if (v47)
    operator delete(v47);
}

void sub_184BDA658(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void PageLayout::addHorzEdge(PageLayout *this, const CGPoint *a2, const CGPoint *a3, double a4, double a5, double a6)
{
  double *v8;
  double *v9;
  uint64_t v10;
  unint64_t v11;
  double *v12;
  unint64_t v13;
  double *v14;
  double *v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char *v32;
  double *v33;
  char *v34;
  int64_t v35;
  uint64_t v36;
  unint64_t v37;
  char *v38;
  uint64_t v39;
  double *v40;
  double *v41;
  double *v42;
  double *v43;
  __int128 v44;
  double *v45;
  int64_t v46;
  void *v47;

  v9 = (double *)*((_QWORD *)this + 54);
  v8 = (double *)*((_QWORD *)this + 55);
  v10 = (char *)v8 - (char *)v9;
  if (v8 == v9)
  {
    v12 = (double *)*((_QWORD *)this + 55);
  }
  else
  {
    v11 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3);
    v12 = (double *)*((_QWORD *)this + 54);
    do
    {
      v13 = v11 >> 1;
      v14 = &v12[3 * (v11 >> 1)];
      v16 = *v14;
      v15 = v14 + 3;
      v11 += ~(v11 >> 1);
      if (v16 < a5)
        v12 = v15;
      else
        v11 = v13;
    }
    while (v11);
  }
  if (a4 >= a6)
    v17 = a6;
  else
    v17 = a4;
  if (a4 >= a6)
    v18 = a4;
  else
    v18 = a6;
  if (v8 != v12 && *v12 == a5)
  {
    v19 = v12[1];
    v20 = v12[2];
    if (v17 == v19 && v18 == v20)
      return;
    if (v17 <= v20 && v18 >= v19)
    {
      if (v17 < v19)
        v19 = v17;
      if (v20 < v18)
        v20 = v18;
      v12[1] = v19;
      v12[2] = v20;
      return;
    }
  }
  v23 = *((_QWORD *)this + 56);
  if ((unint64_t)v8 < v23)
  {
    if (v12 != v8)
    {
      v24 = v12 + 3;
      v25 = v8 - 3;
      v26 = *((_QWORD *)this + 55);
      while (v25 < v8)
      {
        v27 = *(_OWORD *)v25;
        *(double *)(v26 + 16) = v25[2];
        *(_OWORD *)v26 = v27;
        v26 += 24;
        v25 += 3;
      }
      *((_QWORD *)this + 55) = v26;
      if (v8 != v24)
        memmove(v12 + 3, v12, (char *)v8 - (char *)v24);
      *v12 = a5;
      v12[1] = v17;
      v12[2] = v18;
      return;
    }
    if (v9)
    {
      *v8 = a5;
      v8[1] = v17;
      v8[2] = v18;
      *((_QWORD *)this + 55) = v8 + 3;
      return;
    }
    goto LABEL_70;
  }
  v28 = 0xAAAAAAAAAAAAAAABLL * (v10 >> 3) + 1;
  if (v28 > 0xAAAAAAAAAAAAAAALL)
    goto LABEL_71;
  v29 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v23 - (_QWORD)v9) >> 3);
  if (2 * v29 > v28)
    v28 = 2 * v29;
  if (v29 >= 0x555555555555555)
    v30 = 0xAAAAAAAAAAAAAAALL;
  else
    v30 = v28;
  if (v30)
  {
    v32 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v30);
  }
  else
  {
    v32 = 0;
    v31 = 0;
  }
  v33 = (double *)&v32[8 * (v12 - v9)];
  v34 = &v32[24 * v31];
  if (0xAAAAAAAAAAAAAAABLL * (v12 - v9) == v31)
  {
    if ((char *)v12 - (char *)v9 < 1)
    {
      if (v12 == v9)
        v37 = 1;
      else
        v37 = 0x5555555555555556 * (v12 - v9);
      v38 = (char *)std::__allocate_at_least[abi:se180100]<std::allocator<std::vector<ClipperLib::IntPoint>>>(v37);
      v33 = (double *)&v38[24 * (v37 >> 2)];
      v34 = &v38[24 * v39];
      if (v32)
        operator delete(v32);
    }
    else
    {
      v35 = 0xAAAAAAAAAAAAAAABLL * ((8 * (v12 - v9)) >> 3);
      if (v35 >= -1)
        v36 = v35 + 1;
      else
        v36 = v35 + 2;
      v33 -= 3 * (v36 >> 1);
    }
  }
  if (!v33)
  {
LABEL_70:
    __break(1u);
LABEL_71:
    std::vector<CG::DisplayListResource const*>::__throw_length_error[abi:se180100]();
  }
  *v33 = a5;
  v33[1] = v17;
  v33[2] = v18;
  v40 = (double *)*((_QWORD *)this + 54);
  v41 = v33;
  if (v40 != v12)
  {
    v42 = v12;
    v43 = v33;
    do
    {
      v44 = *(_OWORD *)(v42 - 3);
      v41 = v43 - 3;
      *(v43 - 1) = *(v42 - 1);
      *(_OWORD *)(v43 - 3) = v44;
      v42 -= 3;
      v43 -= 3;
    }
    while (v42 != v40);
  }
  v45 = (double *)*((_QWORD *)this + 55);
  v46 = (char *)v45 - (char *)v12;
  if (v45 != v12)
    memmove(v33 + 3, v12, (char *)v45 - (char *)v12);
  v47 = (void *)*((_QWORD *)this + 54);
  *((_QWORD *)this + 54) = v41;
  *((_QWORD *)this + 55) = (char *)v33 + v46 + 24;
  *((_QWORD *)this + 56) = v34;
  if (v47)
    operator delete(v47);
}

void sub_184BDA978(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CGColorSpaceCoreMedia709()
{
  uint64_t v0;

  if (CGColorSpaceCoreMedia709_predicate != -1)
    dispatch_once(&CGColorSpaceCoreMedia709_predicate, &__block_literal_global_101);
  v0 = CGColorSpaceCoreMedia709_space;
  if (CGColorSpaceCoreMedia709_space)
    CFRetain((CFTypeRef)CGColorSpaceCoreMedia709_space);
  return v0;
}

uint64_t CGColorSpaceCreateUncalibratedGray()
{
  uint64_t v0;

  if (CGColorSpaceCreateUncalibratedGray_predicate != -1)
    dispatch_once(&CGColorSpaceCreateUncalibratedGray_predicate, &__block_literal_global_125_5878);
  v0 = CGColorSpaceCreateUncalibratedGray_space;
  if (CGColorSpaceCreateUncalibratedGray_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedGray_space);
  return v0;
}

uint64_t CGColorSpaceCreateUncalibratedRGB()
{
  uint64_t v0;

  if (CGColorSpaceCreateUncalibratedRGB_predicate != -1)
    dispatch_once(&CGColorSpaceCreateUncalibratedRGB_predicate, &__block_literal_global_127_5876);
  v0 = CGColorSpaceCreateUncalibratedRGB_space;
  if (CGColorSpaceCreateUncalibratedRGB_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedRGB_space);
  return v0;
}

uint64_t CGColorSpaceCreateUncalibratedCMYK()
{
  uint64_t v0;

  if (CGColorSpaceCreateUncalibratedCMYK_predicate != -1)
    dispatch_once(&CGColorSpaceCreateUncalibratedCMYK_predicate, &__block_literal_global_129);
  v0 = CGColorSpaceCreateUncalibratedCMYK_space;
  if (CGColorSpaceCreateUncalibratedCMYK_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateUncalibratedCMYK_space);
  return v0;
}

uint64_t CGColorSpaceCreateExtendedDisplayP3()
{
  uint64_t v0;

  if (CGColorSpaceCreateExtendedDisplayP3_predicate != -1)
    dispatch_once(&CGColorSpaceCreateExtendedDisplayP3_predicate, &__block_literal_global_139_5872);
  v0 = CGColorSpaceCreateExtendedDisplayP3_space;
  if (CGColorSpaceCreateExtendedDisplayP3_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedDisplayP3_space);
  return v0;
}

uint64_t CGColorSpaceCreateExtendedLinearDisplayP3()
{
  uint64_t v0;

  if (CGColorSpaceCreateExtendedLinearDisplayP3_predicate != -1)
    dispatch_once(&CGColorSpaceCreateExtendedLinearDisplayP3_predicate, &__block_literal_global_143);
  v0 = CGColorSpaceCreateExtendedLinearDisplayP3_space;
  if (CGColorSpaceCreateExtendedLinearDisplayP3_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedLinearDisplayP3_space);
  return v0;
}

uint64_t CGColorSpaceCreateDisplayP3_709OETF()
{
  uint64_t v0;

  if (CGColorSpaceCreateDisplayP3_709OETF_predicate != -1)
    dispatch_once(&CGColorSpaceCreateDisplayP3_709OETF_predicate, &__block_literal_global_149_5868);
  v0 = CGColorSpaceCreateDisplayP3_709OETF_space;
  if (CGColorSpaceCreateDisplayP3_709OETF_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateDisplayP3_709OETF_space);
  return v0;
}

uint64_t CGColorSpaceCreateGenericLab()
{
  uint64_t v0;

  if (CGColorSpaceCreateGenericLab_predicate != -1)
    dispatch_once(&CGColorSpaceCreateGenericLab_predicate, &__block_literal_global_157);
  v0 = CGColorSpaceCreateGenericLab_space;
  if (CGColorSpaceCreateGenericLab_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateGenericLab_space);
  return v0;
}

uint64_t CGColorSpaceCreateACESCGLinear()
{
  uint64_t v0;

  if (CGColorSpaceCreateACESCGLinear_predicate != -1)
    dispatch_once(&CGColorSpaceCreateACESCGLinear_predicate, &__block_literal_global_165_5864);
  v0 = CGColorSpaceCreateACESCGLinear_space;
  if (CGColorSpaceCreateACESCGLinear_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateACESCGLinear_space);
  return v0;
}

uint64_t CGColorSpaceCreateITUR_709_PQ()
{
  uint64_t v0;

  if (CGColorSpaceCreateITUR_709_PQ_predicate != -1)
    dispatch_once(&CGColorSpaceCreateITUR_709_PQ_predicate, &__block_literal_global_169_5862);
  v0 = CGColorSpaceCreateITUR_709_PQ_space;
  if (CGColorSpaceCreateITUR_709_PQ_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_709_PQ_space);
  return v0;
}

uint64_t CGColorSpaceCreateITUR_709_HLG()
{
  uint64_t v0;

  if (CGColorSpaceCreateITUR_709_HLG_predicate != -1)
    dispatch_once(&CGColorSpaceCreateITUR_709_HLG_predicate, &__block_literal_global_171_5861);
  v0 = CGColorSpaceCreateITUR_709_HLG_space;
  if (CGColorSpaceCreateITUR_709_HLG_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateITUR_709_HLG_space);
  return v0;
}

uint64_t CGColorSpaceCreateLinearITUR_2020()
{
  uint64_t v0;

  if (CGColorSpaceCreateLinearITUR_2020_predicate != -1)
    dispatch_once(&CGColorSpaceCreateLinearITUR_2020_predicate, &__block_literal_global_177_5859);
  v0 = CGColorSpaceCreateLinearITUR_2020_space;
  if (CGColorSpaceCreateLinearITUR_2020_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateLinearITUR_2020_space);
  return v0;
}

uint64_t CGColorSpaceCreateExtendedITUR_2020()
{
  uint64_t v0;

  if (CGColorSpaceCreateExtendedITUR_2020_predicate != -1)
    dispatch_once(&CGColorSpaceCreateExtendedITUR_2020_predicate, &__block_literal_global_179_5857);
  v0 = CGColorSpaceCreateExtendedITUR_2020_space;
  if (CGColorSpaceCreateExtendedITUR_2020_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedITUR_2020_space);
  return v0;
}

uint64_t CGColorSpaceCreateExtendedLinearITUR_2020()
{
  uint64_t v0;

  if (CGColorSpaceCreateExtendedLinearITUR_2020_predicate != -1)
    dispatch_once(&CGColorSpaceCreateExtendedLinearITUR_2020_predicate, &__block_literal_global_181);
  v0 = CGColorSpaceCreateExtendedLinearITUR_2020_space;
  if (CGColorSpaceCreateExtendedLinearITUR_2020_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateExtendedLinearITUR_2020_space);
  return v0;
}

uint64_t CGColorSpaceCreateDCIP3()
{
  uint64_t v0;

  if (CGColorSpaceCreateDCIP3_predicate != -1)
    dispatch_once(&CGColorSpaceCreateDCIP3_predicate, &__block_literal_global_189);
  v0 = CGColorSpaceCreateDCIP3_space;
  if (CGColorSpaceCreateDCIP3_space)
    CFRetain((CFTypeRef)CGColorSpaceCreateDCIP3_space);
  return v0;
}

uint64_t CGColorSpaceExtendedLinearGray()
{
  uint64_t v0;

  if (CGColorSpaceExtendedLinearGray_predicate != -1)
    dispatch_once(&CGColorSpaceExtendedLinearGray_predicate, &__block_literal_global_201);
  v0 = CGColorSpaceExtendedLinearGray_space;
  if (CGColorSpaceExtendedLinearGray_space)
    CFRetain((CFTypeRef)CGColorSpaceExtendedLinearGray_space);
  return v0;
}

uint64_t CGColorSpacePerceptualStandardRGB()
{
  uint64_t v0;

  if (CGColorSpacePerceptualStandardRGB_predicate != -1)
    dispatch_once(&CGColorSpacePerceptualStandardRGB_predicate, &__block_literal_global_203_5847);
  v0 = CGColorSpacePerceptualStandardRGB_space;
  if (CGColorSpacePerceptualStandardRGB_space)
    CFRetain((CFTypeRef)CGColorSpacePerceptualStandardRGB_space);
  return v0;
}

CGColorSpaceRef CGColorSpaceCreateColoredPattern()
{
  return CGColorSpaceCreatePattern(0);
}

void print_cache_size()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  while (1)
  {
    sleep(reporting_frequency);
    pthread_mutex_lock(&font_caches_mutex);
    v7 = (uint64_t *)font_caches;
    if (font_caches)
    {
      do
      {
        v8 = *v7;
        if (*v7)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(v8 + 4));
          v9 = *(_QWORD *)(v8 + 40);
          if (v9)
          {
            v10 = 0;
            do
            {
              v10 += (uint64_t)CGFontStrikeGetSize(*(os_unfair_lock_s **)v9);
              v9 = *(_QWORD *)(v9 + 8);
            }
            while (v9);
            v11 = *(_QWORD *)(v8 + 40);
            if (v11)
            {
              v12 = 0;
              do
              {
                ++v12;
                v11 = *(_QWORD *)(v11 + 8);
              }
              while (v11);
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v8 + 4));
        }
        CGPostError((uint64_t)"Cache %p: %zu bytes count = %zu", v0, v1, v2, v3, v4, v5, v6, v8);
        v7 = (uint64_t *)v7[1];
      }
      while (v7);
    }
    pthread_mutex_unlock(&font_caches_mutex);
  }
}

void __setup_block_invoke()
{
  if (CGFontCacheGetLocalCache_predicate != -1)
    dispatch_once(&CGFontCacheGetLocalCache_predicate, &__block_literal_global_5899);
  CGFontCacheReset(CGFontCacheGetLocalCache_local_font_cache);
}

void CGFontCacheReset(uint64_t a1)
{
  os_unfair_lock_s *v2;
  const void *v3;
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;

  if (a1)
  {
    v2 = (os_unfair_lock_s *)(a1 + 4);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
    *(_DWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    v3 = *(const void **)(a1 + 32);
    if (v3)
    {
      CFRelease(v3);
      *(_QWORD *)(a1 + 32) = 0;
    }
    v4 = *(_QWORD *)(a1 + 40);
    if (v4)
    {
      do
      {
        CGFontStrikeRelease(*(unsigned int **)v4);
        v4 = *(_QWORD *)(v4 + 8);
      }
      while (v4);
      v5 = *(_QWORD **)(a1 + 40);
      if (v5)
      {
        do
        {
          v6 = (_QWORD *)v5[1];
          free(v5);
          v5 = v6;
        }
        while (v6);
      }
    }
    *(_QWORD *)(a1 + 40) = 0;
    os_unfair_lock_unlock(v2);
  }
}

unsigned int *CGFontCacheRetain(unsigned int *result)
{
  unsigned int v1;

  if (result)
  {
    do
      v1 = __ldxr(result);
    while (__stxr(v1 + 1, result));
  }
  return result;
}

void CGFontCacheRelease(unsigned int *a1)
{
  unsigned int v2;
  unsigned int v3;

  if (a1)
  {
    do
    {
      v2 = __ldxr(a1);
      v3 = v2 - 1;
    }
    while (__stxr(v3, a1));
    if (!v3)
    {
      pthread_mutex_lock(&font_caches_mutex);
      font_caches = (uint64_t)x_list_remove((_QWORD *)font_caches, (uint64_t)a1);
      pthread_mutex_unlock(&font_caches_mutex);
      CGFontCacheReset((uint64_t)a1);
      free(a1);
    }
  }
}

uint64_t CGFontCacheResetAllCaches()
{
  uint64_t *v0;

  pthread_mutex_lock(&font_caches_mutex);
  v0 = (uint64_t *)font_caches;
  if (font_caches)
  {
    do
    {
      CGFontCacheReset(*v0);
      v0 = (uint64_t *)v0[1];
    }
    while (v0);
  }
  return pthread_mutex_unlock(&font_caches_mutex);
}

uint64_t CGFontCacheSetMaxSize(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 8) = a2;
  return result;
}

uint64_t CGFontCacheGetMaxSize(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void CGFontCachePrint(uint64_t a1, FILE *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t i;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t j;
  uint64_t v11;
  uint64_t k;
  _QWORD *m;
  os_unfair_lock_s *lock;

  if (a1 && a2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 4);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 4));
    v5 = *(_QWORD *)(a1 + 40);
    lock = v4;
    for (i = 0; v5; v5 = *(_QWORD *)(v5 + 8))
      i += (uint64_t)CGFontStrikeGetSize(*(os_unfair_lock_s **)v5);
    fprintf(a2, "cache %p: size = %zu (max %zu)\n", (const void *)a1, i, *(_QWORD *)(a1 + 8));
    v7 = *(uint64_t **)(a1 + 40);
    if (v7)
    {
      do
      {
        v8 = *v7;
        fwrite("  ", 2uLL, 1uLL, a2);
        if (v8)
          v9 = v8 + 8;
        else
          v9 = 0;
        fprintf(a2, "strike %p <font %d; style 0x%04x >; ", (const void *)v8, *(_DWORD *)v9, *(_DWORD *)(v9 + 4));
        fprintf(a2, "[ %g %g %g %g ; %g %g ]; ",
          *(double *)(v9 + 8),
          *(double *)(v9 + 16),
          *(double *)(v9 + 24),
          *(double *)(v9 + 32),
          *(double *)(v9 + 40),
          *(double *)(v9 + 48));
        fprintf(a2, "[ %g %g ]; ", *(double *)(v9 + 56), *(double *)(v9 + 64));
        fprintf(a2, "%zu bytes; %d", *(_QWORD *)(v8 + 88), *(_DWORD *)(v8 + 4));
        fwrite(":\n", 2uLL, 1uLL, a2);
        if (*(_QWORD *)(v8 + 88))
        {
          fwrite("    entries:\n", 0xDuLL, 1uLL, a2);
          for (j = 0; j != 256; ++j)
          {
            v11 = *(_QWORD *)(v8 + 8 * j + 112);
            if (v11)
            {
              for (k = 0; k != 256; ++k)
              {
                for (m = *(_QWORD **)(v11 + 8 * k); m; m = (_QWORD *)m[1])
                  fprintf(a2, "    glyph %hu (%hhu/%hhu)\n", *(unsigned __int16 *)(*m + 4), *(unsigned __int8 *)(*m + 6), *(unsigned __int8 *)(*m + 7));
              }
            }
          }
        }
        else
        {
          fwrite("    no entries.\n", 0x10uLL, 1uLL, a2);
        }
        v7 = (uint64_t *)v7[1];
      }
      while (v7);
    }
    else
    {
      fwrite("  no strikes.\n", 0xEuLL, 1uLL, a2);
    }
    os_unfair_lock_unlock(lock);
  }
}

uint64_t CGFontCacheGetLocalCache()
{
  if (CGFontCacheGetLocalCache_predicate != -1)
    dispatch_once(&CGFontCacheGetLocalCache_predicate, &__block_literal_global_5899);
  return CGFontCacheGetLocalCache_local_font_cache;
}

float *resample_float_v_3cpp_ap(float *result, uint64_t a2, unsigned __int8 a3, int a4, float **a5, uint64_t *a6)
{
  unint64_t v6;
  unint64_t v7;
  int v8;
  float *v9;
  float *v10;
  float *v11;
  float v12;
  float v13;
  float v14;
  float v15;
  uint64_t *v16;
  int v17;
  float v18;
  float v19;
  uint64_t v20;
  float v21;

  v6 = (a3 * a4) & 0xFFFFFFFC;
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = *((_DWORD *)result + 1);
    v9 = result + 2;
    v11 = *a5;
    v10 = a5[1];
    do
    {
      v12 = 0.0;
      v13 = 0.0;
      v14 = 0.0;
      v15 = 0.0;
      if (v8)
      {
        v16 = a6;
        result = v9;
        v17 = v8;
        do
        {
          v18 = *result++;
          v19 = v18;
          v20 = *v16++;
          v12 = v12 + (float)(*(float *)(v20 + 4 * v7) * v19);
          v13 = v13 + (float)(*(float *)(v20 + 4 * (v7 | 1)) * v19);
          v14 = v14 + (float)(*(float *)(v20 + 4 * (v7 | 2)) * v19);
          v15 = v15 + (float)(*(float *)(v20 + 4 * (v7 | 3)) * v19);
          --v17;
        }
        while (v17);
      }
      if (v12 > v15)
        v15 = v12;
      if (v13 > v15)
        v15 = v13;
      if (v14 > v15)
        v15 = v14;
      *v11 = v12;
      v11[1] = v13;
      v11[2] = v14;
      v11 += 3;
      if (v15 >= 0.0)
        v21 = v15;
      else
        v21 = 0.0;
      if (v15 > 1.0)
        v21 = 1.0;
      *v10++ = v21;
      v7 += 4;
    }
    while (v7 < v6);
  }
  return result;
}

uint64_t resample_float_v_Ncpp_ap(uint64_t result, uint64_t a2, unsigned __int8 a3, int a4, _QWORD *a5, uint64_t *a6)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  float *v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  float v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float v20;
  uint64_t *v21;
  float *v22;
  int v23;
  float v24;
  float v25;
  uint64_t v26;
  float v27;
  float v28;
  uint64_t v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  uint64_t *v37;
  float *v38;
  float v39;
  float v40;
  uint64_t v41;
  float v42;
  float v43;

  v6 = *a5 - 4;
  v7 = a5[1] - 4;
  v8 = *(_DWORD *)(result + 4);
  v9 = (float *)(result + 8);
  v10 = a3;
  v11 = a3 * a4;
  v12 = v11 & 0xFFFFFFFC;
  if ((int)v12 < 1)
  {
    LODWORD(v13) = 0;
    v14 = 0.0;
    v15 = a3;
  }
  else
  {
    v13 = 0;
    v14 = 0.0;
    v15 = a3;
    do
    {
      v16 = v13 | 1;
      v17 = 0.0;
      v18 = 0.0;
      v19 = 0.0;
      v20 = 0.0;
      if (v8)
      {
        v21 = a6;
        v22 = v9;
        v23 = v8;
        do
        {
          v24 = *v22++;
          v25 = v24;
          v26 = *v21++;
          v17 = v17 + (float)(*(float *)(v26 + 4 * v13) * v25);
          v18 = v18 + (float)(*(float *)(v26 + 4 * v16) * v25);
          v19 = v19 + (float)(*(float *)(v26 + 4 * (v13 | 2)) * v25);
          v20 = v20 + (float)(*(float *)(v26 + 4 * (v13 | 3)) * v25);
          --v23;
        }
        while (v23);
      }
      if (v14 < v17)
        v14 = v17;
      if (v16 == v15)
      {
        v27 = 0.0;
        if (v14 >= 0.0)
          v27 = v14;
        if (v14 <= 1.0)
          v28 = v27;
        else
          v28 = 1.0;
        *(float *)(v7 + 4) = v28;
        v7 += 4;
        v29 = v15 + v10;
        v15 += v10;
        v14 = 0.0;
      }
      else
      {
        v29 = v15;
        *(float *)(v6 + 4) = v17;
        v6 += 4;
      }
      if (v14 < v18)
        v14 = v18;
      if ((v13 | 2) == v29)
      {
        v30 = 0.0;
        if (v14 >= 0.0)
          v30 = v14;
        if (v14 <= 1.0)
          v31 = v30;
        else
          v31 = 1.0;
        *(float *)(v7 + 4) = v31;
        v7 += 4;
        v29 = v15 + v10;
        v15 += v10;
        v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v18;
        v6 += 4;
      }
      if (v14 < v19)
        v14 = v19;
      result = v13 | 3;
      if ((v13 | 3) == v29)
      {
        v32 = 0.0;
        if (v14 >= 0.0)
          v32 = v14;
        if (v14 <= 1.0)
          v33 = v32;
        else
          v33 = 1.0;
        *(float *)(v7 + 4) = v33;
        v7 += 4;
        v29 = v15 + v10;
        v15 += v10;
        v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v19;
        v6 += 4;
      }
      if (v14 < v20)
        v14 = v20;
      v13 += 4;
      if (v13 == v29)
      {
        v34 = 0.0;
        if (v14 >= 0.0)
          v34 = v14;
        if (v14 <= 1.0)
          v35 = v34;
        else
          v35 = 1.0;
        *(float *)(v7 + 4) = v35;
        v7 += 4;
        v15 += v10;
        v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v20;
        v6 += 4;
      }
    }
    while (v13 < v12);
  }
  if ((int)v13 < (int)v11)
  {
    v13 = v13;
    do
    {
      v36 = 0.0;
      if (v8)
      {
        v37 = a6;
        v38 = v9;
        LODWORD(result) = v8;
        do
        {
          v39 = *v38++;
          v40 = v39;
          v41 = *v37++;
          v36 = v36 + (float)(*(float *)(v41 + 4 * v13) * v40);
          result = (result - 1);
        }
        while ((_DWORD)result);
      }
      if (v14 < v36)
        v14 = v36;
      if (++v13 == v15)
      {
        v42 = 0.0;
        if (v14 >= 0.0)
          v42 = v14;
        if (v14 <= 1.0)
          v43 = v42;
        else
          v43 = 1.0;
        *(float *)(v7 + 4) = v43;
        v7 += 4;
        v15 += v10;
        v14 = 0.0;
      }
      else
      {
        *(float *)(v6 + 4) = v36;
        v6 += 4;
      }
    }
    while (v13 != v11);
  }
  return result;
}

